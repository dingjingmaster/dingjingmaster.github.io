[{"categories":["linux"],"content":"wireshark 是什么 Wireshark(前称Ethereal)是一个网络封包分析软件。网络封包软件的功能主要是截取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用 WinPCAP 作为接口，直接与网卡进行数据报文交换。 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:1:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 使用 首先进入 wireshark，启动时候需要使用命令行以 root 启动 非root用户无法抓取网卡上所有的包 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"1. 选择网卡 选择菜单栏上 Capture -\u003e Option，选中使用的网卡，点击 start 开始抓包 选择网卡 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"2. 添加过滤条件 比如仅需要查看 www.baidu.com 的数据包，通过 ping 命令获取对应的 ip，在 wireshark 中设置 ip 过滤条件就可以看到。 ip.addr == 119.75.217.26 and icmp 表示只显示ICPM协议且源主机IP或者目的主机IP为119.75.217.26的数据包 添加过滤条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 界面说明 wireshark界面说明 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:3:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"数据详细区说明 Frame: 物理层的数据帧概况 Ethernet II: 数据链路层以太网帧头部信息 Internet Protocol Version 4: 互联网层IP包头部信息 Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP 之后的都属于应用层 wireshark界面说明 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:3:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 设置过滤条件 需要注意的是，wireshark 既可以设置抓包过滤条件，也可以设置显示过滤条件，前者限制大，用于减少捕获数据包的数量；后者用于在报文中隐藏某些报文。 抓包过滤器只能在抓包前设置，无法动态修改，显示过滤器则没有此限制 设置抓包过滤条件，(如果已经开始抓包，需要先停止…)菜单栏 Capture -\u003e Options -\u003e Input -\u003e Capture filter for selected interfaces 设置配置条件，同时选中要抓取的网卡，点击此页面右下角的 Start 即可开始抓包 设置显示过滤条件，在菜单栏下边有个文本输入框(Apply a display filter ... \u003cCtrl-/\u003e) 在这里配置显示过滤条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"抓取过滤类型(抓包过滤) 类型 说明 host 让wireshark只抓取源于或发往由标识符host所指定的主机名或IP地址的流量 net 让wireshark只抓取源于或发往由标识符net所标识的IPv4/IPv6网络号的流量 port 让wireshark只抓取源于或发往由标识符port指定端口号的流量包 portrange 让wireshark只抓取源于或发往由标识符portrange指定端口范围的流量包 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"过滤方向(显示/抓包过滤) 方向 说明 src 发送端条件 dst 目标端条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"过滤协议(显示过滤) 协议 说明 ether fddi tr wlan ip ip6 arp rarp decnet sctp tcp udp http … ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:3","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"逻辑运算符(显示过滤) 运算符 说明 \u0026\u0026 或 and 两者等价与逻辑 || 或 or 两者等价或逻辑 ! 或 not 两者等价非逻辑 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:4","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"比较操作符(显示过滤) 运算符 说明 == 等于 != 不等于 \u003e 大于 \u003c 小于 \u003e= 大于等于 \u003c= 小于等于 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:5","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"例子 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"抓包过滤条件 抓取百度的包 host www.baidu.com 或者使用 ping www.baidu.com 得到百度网站的ip (220.181.38.150)再使用命令 net 220.181.38.150 抓取指定ip范围内的包 net 192.168.0.0/24 或 net 192.168.0.0 mask 255.255.255.0 抓取从指定 IP 范围发出的包 src net 192.168.0.0/24 或 src net 192.168.0.0 mask 255.255.255.0 抓取发往目标 IP 范围的包 dst net 192.168.0.0/24 或 dst net 192.168.0.0 mask 255.255.255.0 抓取指定端口53的包(DNS服务) port 53 抓取指定服务器上非 HTTP 和非 SMTP 的包 host www.example.com and not (port 80 or port 25) host www.example.com and not port 80 and not port 25 抓取除了 ARP 和 DNS 的包 port not 53 and not arp 抓取指定端口范围的包 (tcp[0:2] \u003e 1500 and tcp[0:2] \u003c 1550) or (tcp[2:2] \u003e 1500 and tcp[2:2] \u003c 1550) 或 tcp portrange 1501-1549 值抓取EAPOL类型以太网的包 ether proto 0x888e 拒绝向链路层发现协议发送的以太网帧 not ether dst 01:80:c2:00:00:0e 仅捕获IPv4流量-最短的过滤器，但有时非常有用，以摆脱较低的层协议，如ARP和STP ip 仅捕获单播流量-如果你只想看到与你的机器之间的流量，而不捕获广播和多播 not broadcast and not multicast 捕获IPv6“所有节点”(路由器和邻居通告)流量。可以用来找到流氓RAs dst host ff02::1 捕获HTTP GET请求。这将查找TCP头后面的字节’G’、‘E’、‘T’和’ ‘(十六进制值47、45、54和20)。“tcp[12:1] \u0026 0xf0) » 2\"计算出tcp报头长度 port 80 and tcp[((tcp[12:1] \u0026 0xf0) \u003e\u003e 2):4] = 0x47455420 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"显示过滤器 仅显示 SMTP(25端口)和 ICMP 数据包 tcp.port eq 25 or icmp 只显示局域网(192.168.x.x)的流量，工作站和服务器之间-没有Internet: ip.src==192.168.0.0/16 and ip.dst==192.168.0.0/16 TCP buffer full - Source指示Destination停止发送数据 tcp.window_size == 0 \u0026\u0026 tcp.flags.reset != 1 参考：https://wiki.wireshark.org/DisplayFilters 参考: https://wiki.wireshark.org/Home ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"samba 挂载 目前有一个需求，系统重启时候需要自动挂载远程 samba 文件系统，起初使用 fstab 发现并不能成功挂载，考虑应该是和启动顺序有关系，当没有网络的时候是无法执行挂载操作的，或者说挂载会出错，后来发现 systemd 也提供自动挂载的功能，于是尝试了一下，发现是可以的。 ","date":"2022-03-18","objectID":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/:1:0","tags":["linux","samba","systemd"],"title":"systemd 自动挂载samba","uri":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/"},{"categories":["linux"],"content":"具体步骤 在 /etc/samba/ 下创建 credentials 文件夹 mkdir /etc/samba/crendentials 在/etc/samba/crendentials下创建比如名为share0的文件并加入如下配置 # vim /etc/samba/crendentials/share0 username=\u003csamba登录用户名\u003e password=\u003csamba对应的密码\u003e 创建systemd unit文件，内容如下 # vim /etc/systemd/system/mnt-share.mount Description= mount a samba share Requires=network-online.target After=network-online.target systemd-resolved.service Wants=network-online.target systemd-resolved.service [Mount] Name=mnt-share What=//\u003c远程samba-ip\u003e/\u003c远程samba路径\u003e Where=/mnt/share # \u003c本机挂载路径\u003e Type=cifs Options=x-systemd.automount,_netdev,credentials=/etc/samba/credentials/share,sec=ntlmssp,vers=1.0,rw,uid=1000,gid=1000,dir_mode=0777,file_mode=0777,iocharset=utf8 TimeoutSec=30 [Install] WantedBy=multi-user.target 测试是否可以挂载 systemctl start mnt-share.mount 如果有报错就需要尝试修改 5. 开机自动挂载 systemctl enable mnt-share.mount 注意：挂载路径(Where)必须和文件名(mnt-share0)对应，比如挂载到 /mnt/share，那么文件名必须是mnt-share0.mount 参考：arch linux samba https://wiki.archlinux.org/index.php/samba#As_systemd_unit ","date":"2022-03-18","objectID":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/:2:0","tags":["linux","samba","systemd"],"title":"systemd 自动挂载samba","uri":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/"},{"categories":["linux"],"content":"说明 dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:1:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"块大小可以使用的计量表 单元大小 表示 字节(1B) c 字节(2B) w 块(512B) b 千字节(1024B) k 兆字节(1024KB) M 吉字节(1024MB) G ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:2:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"参数解释 参数 说明 if=\u003c文件名\u003e 输入文件名，默认为stdin标准输入，用来指定读取的源文件 of=\u003c文件名\u003e 输出文件名，默认为stdout标准输出，用来指定输出的目的文件 ibs=\u003c字节\u003e 一次读入bytes个字节，即指定一个块大小为bytes个字节 obs=\u003c字节\u003e 一次输出bytes个字节，即指定一个块大小为bytes个字节 bs=\u003c字节\u003e 同事设置读入/读出的块大小为 bytes 个字节 cbs=\u003c字节\u003e 一次转换bytes个字节，即指定转换缓存区大小 skip=\u003c字节\u003e 从输入文件开头跳过blocks个块后再开始复制 seek=\u003c字节\u003e 从输出文件开头跳过blocks个块后再开始复制 count=\u003c字节\u003e 仅拷贝blocks个块，块大小等于ibs指定的字节数 conv=\u003c转换参数\u003e 用指定的参数转换文件。ascii:转换ebcdic为asciiebcdic:转换ascii为ebcdicibm:转换ascii为alternate ebcdicblock:把每一行转换为长度为cbs，不足部分用空格填充unblock:使没一行的长度都为cbs，不足部分用空格填充lcase:把大写字符转换为小写字符ucase:把小写字符转换为大写字符swab:交换输入的每对字节noerror:出错时不停止notrunc:不截断输出文件sync:将每个输入块填充到ibs个字节，不足部分也能够(NUL)字符补齐 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:3:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"dd应用实例 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"将本地 /dev/hdb 盘备份到 /dev/hdd dd if=/dev/hdb of=/dev/hdd ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:1","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"备份/dev/hdb全盘数据，并利用gzip工具进行压缩，保存到指定路径 dd if=/dev/hdb | gzip \u003e /root/image.gz ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:2","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"将压缩的备份文件恢复到指定盘 gzip -dc /root/image.gz | dd of=/dev/hdb ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:3","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"备份与恢复MBR 备份磁盘开始的512个字节大小的MBR信息到指定文件： dd if=/dev/hda of=/root/image count=1 bs=512 count=1指仅拷贝一个块；bs=512指块大小为512个字节 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:4","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"增加swap分区文件大小 第一步：创建一个大小为256M的文件： dd if=/dev/zero of=/swapfile bs=1024 count=262144 第二步：把这个文件变成swap文件： mkswap /swapfile 第三步：启用这个swap文件： swapon /swapfile 第四步：编辑/etc/fstab文件，使在每次开机时自动加载swap文件： /swapfile swap swap default 0 0 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:5","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"销毁磁盘数据 dd if=/dev/urandom of=/dev/hda1 注意：利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:6","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"测试硬盘的读写速度 dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file dd if=/root/1Gb.file bs=64k | dd of=/dev/null 通过以上两个命令输出的命令执行时间，可以计算出硬盘的读、写速度 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:7","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"确定硬盘的最佳块大小 dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file 通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:8","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"修复硬盘 dd if=/dev/sda of=/dev/sda # 或 dd if=/dev/hda of=/dev/hda 当硬盘较长时间(一年以上)放置不使用后，磁盘上会产生magnetic flux point，当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数 据起死回生。并且这个过程是安全、高效的 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:9","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"利用netcat远程备份 dd if=/dev/hda bs=16065b | netcat \u003c targethost-IP \u003e 1234 在源主机上执行此命令备份/dev/hda netcat -l -p 1234 | dd of=/dev/hdc bs=16065b 在目的主机上执行此命令来接收数据并写入/dev/hdc netcat -l -p 1234 | bzip2 \u003e partition.img netcat -l -p 1234 | gzip \u003e partition.img 以上两条指令是目的主机指令的变化分别采用bzip2、gzip对数据进行压缩，并将备份文件保存在当前目录 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:10","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"另附 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"/dev/null 和/dev/zero的区别 /dev/null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着。它是空设备，也称为位桶（bit bucket）。任何写入它的输出都会被抛弃。如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶 /dev/zero，是一个输入设备，你可你用它来初始化文件。该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:1","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"使用/dev/null 把/dev/null看作\"黑洞\"， 它等价于一个只写文件，所有写入它的内容都会永远丢失.，而尝试从它那儿读取内容则什么也读不到。然而， /dev/null对命令行和脚本都非常的有用 禁止标准输出 cat $filename \u003e/dev/null 禁止标准错误 #rm $badname 2\u003e/dev/null 禁止标准输出和标准错误的输出 cat $filename 2\u003e/dev/null \u003e/dev/null cat $filename \u0026\u003e/dev/null 自动清空日志文件的内容 cat /dev/null \u003e /var/log/messages # : \u003e /var/log/messages 有同样的效果， 但不会产生新的进程.（因为:是内建的） 隐藏cookie而不再使用 if [ -f ~/.netscape/cookies ] # 如果存在则删除. then rm -f ~/.netscape/cookies fi ln -s /dev/null ~/.netscape/cookies 现在所有的cookies都会丢入黑洞而不会保存在磁盘上了 使用/dev/zero 像/dev/null一样， /dev/zero也是一个伪文件， 但它实际上产生连续不断的null的流（二进制的零流，而不是ASCII型的）。 写入它的输出会丢失不见， 而从/dev/zero读出一连串的null也比较困难， 虽然这也能通过od或一个十六进制编辑器来做到。 /dev/zero主要的用处是用来创建一个指定长度用于初始化的空文件，就像临时交换文件。 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:2","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["system"],"content":"前言 致力于传统操作系统基本概念、基本技术、基本方法的阐述 把操作系统成熟的基本原理与当代具有代表性的具体实例紧密地结合起来 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:1:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"涉及内容 操作系统概论 介绍操作系统的基本概念、多道程序设计技术、操作系统的形成和发展，操作系统的分类；操作系统的服务、操作系统的功能、操作系统的接口；操作系统的结构 处理机管理 从处理器和中断技术开始，介绍了中断的概念、分类、处理、优先级和多重中断。接着，引入进程和线程的概念，介绍进程管理的实现模型、线程不同级别的实现方法，介绍处理机调度的三个层次，着重讨论了各种单处理机调度算法，也涉及到多处理机调度算法和实时调度算法 并发进程 介绍进程的顺序性和并发性，进程的协作和竞争，以进程交互、进程控制、进程通信和进程死锁问题为重点，讨论并发程序设计有关技术和各种进程互斥、同步、通信机制和工具 存储管理 讨论存储管理的基本功能、各种传统存储管理技术、虚拟存储管理技术和最新的存储管理技术，如多级页表、反置页表等 设备管理 讨论 I/O 硬件原理、I/O 控制方式、I/O 软件原理、I/O 缓冲技术，着重介绍磁盘驱动调度技术、RAID 技术以及设备分配/去配和虚拟设备技术。也介绍了具有通道的I/O系统管理 文件管理 讨论文件概念、文件目录、文件逻辑结构、文件物理结构、文件的保护和保密、文件存储空间管理以及文件的操作和使用原理。也讨论了文件系统的新概念：内存映射文件和虚拟文件系统。 操作系统安全性 讨论操作系统安全威胁和类型；操作系统保护的层次及保护的基本机制、策略和模型，其中着重讨论了身份认证机制、授权机制、加密机制和审计机制 网络和分布式操作系统 简要介绍网络和分布式操作系统的基本概念和技术，包括网络和数据通信基础、网络体系结构、网络操作系统；分布式进程通信、分布式资源管理、分布式进程同步、分布式文件系统和进程迁移等 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:1:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统概论 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统定义 操作系统是管理系统资源、控制程序执行、改善人机界面、提供各种服务，合理组织计算机工作流程和为用户有效使用计算机提供良好运行环境的一种系统软件。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"配置操作系统的主要目标 方便用户使用 OS 通过提供用户与计算机之间的友善接口来方便用户使用 扩大机器功能 OS 通过扩充改造硬件设施和提供新的服务来扩大机器功能 管理系统资源 OS 有效管理好系统中所有硬件软件资源，使之得到充分利用 提高系统效率 OS 合理组织好计算机的工作流程，以改进系统性能和提高系统效率 构筑开放环境 OS 遵循有关国际标准来设计和构造，以构筑出一个开放环境。含义主要是指：遵循有关国际标准（如开放的通信标准、开放的用户接口标准、开放的线程库标准等）；支持体系结构的可伸缩性和可扩展性；支持应用程序在不同平台上的可移植性和可互操作性 计算机系统包括硬件和软件两个组成部分。硬件是所有软件运行的物质基础，软件能充分发挥硬件潜能和扩充硬件功能，完成各种系统及应用任务，两者互相促进、相辅相成、缺一不可。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统的作用和功能 操作系统是用户与计算机硬件之间的接口 操作系统是计算机系统的资源管理者 处理器管理 处理器管理的第一项工作是处理中断事件。硬件只能发现中断事件，捕捉它并产生中断信号，但不能进行处理，配置了操作系统，就能对中断事件进行处理 处理器管理的第二项工作是处理器调度。处理器是计算机系统中一种稀有和宝贵的资源，应该最大限度地提高处理器的利用率。为了提高处理器的利用率，操作系统采用了多道程序设计技术。在多道程序或多用户的情况下，组织多个作业或任务执行时，就要解决处理器的调度、分配和回收等问题。为了实现处理器管理的功能，描述多道程序的并发执行，操作系统引入了进程的概念，处理器的分配和执行都是以进程为基本单位；随着并行处理技术的发展，为了进一步提高系统并行性，使并发执行单位的粒度变细，并发执行的代价降低，操作系统又引入了线程的概念。对处理器的管理和调度最终归结为对进程和线程的管理和调度，包括：（1）进程控制和管理；（2）进程同步和互斥；（3）进程通信；（4）进程死锁；（5）线程控制和管理；（6）处理器调度，又分高级调度，中级调度和低级调度。 正是由于操作系统对处理器的管理策略不同，其提供的作业处理方式也就不同，例如，批处理方式、分时处理方式、实时处理方式等等。从而，呈现在用户面前，成为具有不同处理方式和不同特点的操作系统。 存储管理 存储管理的主要任务是管理存储器资源，为多道程序运行提供有力的支撑，便于用户使用存储资源，提高存储空间的利用率。存储管理的主要功能包括： 存储分配。存储管理将根据用户程序的需要分配给它存储器资源，这是多道程序能并发执行的首要条件，当然程序运行结束时，还需回收存储资源。 存储共享。存储管理能让内存储器（又叫主存储器）中的多个用户程序实现存储资源的共享，以提高存储器的利用率。 地址转换与存储保护。存储管理负责把用户的逻辑地址转换成物理地址，同时要保证各个用户程序相互隔离起来互不干扰，更不允许用户程序访问操作系统的程序和数据，从而，保护系统和用户程序存放在存储器中的信息不被破坏。 存储扩充。由于受到处理器寻址能力的限制，一台计算机的物理内存容量总是有限的，难以满足用户大型程序的需求，而外存储器容量大且价格便宜。存储管理还应该能从逻辑上来扩充内存储器，把内存和外存混合起来使用，为用户提供一个比内存实际容量大得多的逻辑编程空间，方便用户的编程和使用。 设备管理 设备管理的主要任务是管理各类外围设备，完成用户提出的I/O请求，加快I/O信息的传送速度，发挥I/O设备的并行性，提高I/O设备的利用率，以及提供每种设备的设备驱动程序和中断处理程序，为用户隐蔽硬件细节，提供方便简单的设备使用方法。为实现这些任务，设备管理应该具有以下功能： 提供外围设备的控制与处理 提供缓冲区的管理 提供设备独立性 外围设备的分配和去配 实现共享型外围设备的驱动调度 实现虚拟设备 文件管理 文件管理则是针对系统中的信息资源的。在现代计算机中，通常把程序和数据以文件形式存储在外存储器（又叫辅存储器）上，供用户使用，这样，外存储器上保存了大量文件。 文件管理，它的主要任务是对用户文件和系统文件进行有效管理，实现按名存取；实现文件的共享、保护和保密，保证文件的安全性；并提供给用户一整套能方便使用文件的操作和命令。 具体来说，文件管理要完成以下任务： 提供文件的逻辑组织方法 提供文件的物理组织方法 提供文件的存取方法 提供文件的使用方法 实现文件的目录管理 实现文件的共享和存取控制 实现文件的存储空间管理 网络与通信管理 计算机网络源于计算机与通信技术的结合，联网操作系统至少应具有以下管理功能： 网上资源管理功能。计算机网络的主要目的之一是共享资源，网络操作系统应实现网上资源的共享，管理用户应用程序对资源的访问，保证信息资源的安全性和完整性。 数据通信管理功能。计算机联网后，结点之间可以互相传送数据，进行通信，通过通信软件，按照通信协议的规定，完成网络上计算机之间的信息传送。 网络管理功能。包括故障管理、安全管理、性能管理、记帐管理和配置管理等。 用户接口 为了使用户能灵活、方便地使用计算机和系统功能，操作系统还提供了一组友好的使用其功能的手段称用户接口，它包括两大类：程序接口和操作接口。用户通过这些接口能方便地调用操作系统功能，有效地组织作业及其工作和处理流程，并使整个系统能高效地运行。 操作系统的主要特性 并发性 并发性是指两个或两个以上的事件或活动在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在若干个运行着的程序，因此，它应该具有处理和调度多个程序同时执行的能力。 发挥并发性能够消除计算机系统中部件和部件之间的相互等待，有效地改善系统资源的利用率，改进系统的吞吐率，提高系统效率。 并发性虽然能有效改善系统资源的利用率，但却会引发一系列的问题，使操作系统的设计和实现变得复杂化。如：进程切换、进程调度、进程隔离保护、进程协作 在多处理器系统中，程序的并发性不仅体现在宏观上，而且体现在微观上，这称为并行的。并行性是指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同 CPU 上同时执行。而在分布式系统中，多台计算机的并存使程序的并发性得到了更充分的发挥，因为，同一时刻每台计算机上都可以有程序在执行。可见并行的事件或活动一定是并发的，但反之并发的事件或活动未必是并行的，并行性是并发性的特例，而并发性是并行性的扩展。由于并发技术的本质思想是：当一个程序发生事件（如等待 I/O）时出让其占用的 CPU 而由另一个程序运行，据此不难看出，实现并发技术的关键之一是如何对系统内的多个运行程序（进程）进行切换的技术。 共享性 共享指计算机系统中的资源（包括硬件资源和信息资源）可被多个并发执行的用户程序和系统程序共同使用，而不是被其中某一个程序所独占。 资源共享的方式可以分成两种： 互斥访问 系统中的某些资源如打印机、磁带机、卡片机，虽然它们可提供给多个程序使用，但在同一时间段内却只允许一个程序访问这些资源，即要求互相排斥地使用这些资源 同时访问 允许同一时间内多个程序对它们进行访问，这里“同时”是宏观上的说法，从微观上看多个程序访问资源仍然是交错的，只是这种交错访问的顺序对访问的结果没有影响罢了。典型的可供多个程序同时访问的资源是磁盘，各种可重入程序也可被同时访问 与共享性有关的问题是资源分配、信息保护、存取控制等，必须要妥善解决好这些问题。 共享性和并发性是操作系统两个最基本的特性，它们互为依存。一方面，资源的共享是因为程序的并发执行而引起的，若系统不允许程序并发执行，自然也就不存在资源共享问题。另一方面，若系统不能对资源共享实施有效管理，必然会影响到程序的并发执行，甚至程序无法并发执行，操作系统也就失去了并发性，导致整个系统效率低下。 异步性 在多道程序环境中，允许多个进程并发执行，由于资源有限而进程众多，多数情况下，进程的执行不是一贯到底，而是“走走停停”。 虚拟性 虚拟性是指操作系统中的一种管理技术，它是把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。显然，前者是实际存在的而后者是虚构假想的，采用虚拟技术的目的是为用户提供易于使用、方便高效的操作环境。比如：1个 CPU 被虚拟成两个、1台机器可以虚拟出多台的硬件 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统的形成和发展 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"人工操作阶段 初始操作系统尚未出现，由程序员采用手工方式直接控制和使用计算机硬件，程序员使用机器语言编程，并将事先准备好的程序和数据穿孔在纸带或卡片上，从纸带或卡片输入机将程序和数据输入计算机。然后，启动计算机运行程序，程序员可以通过控制台上的按钮、开关和氖灯来操纵和控制程序，运行完毕，取走计算输出的结果，才轮到下一个用户上机。 后来，汇编语言产生了，在汇编系统中，数字操作码被记忆码代替，程序按固定格式的汇编语言书写。系统程序员预先编制一个汇编程序，它把用汇编语言书写的“源程序”解释成计算机能直接执行的机器语言格式的目标程序。随后，一些高级程序设计语言相继出现进一步方便了编程。 执行时需要把汇编程序或编译系统以及源程序和数据，都穿在卡片或纸带上，然后，再装入和执行。 其大致过程为： 人工把源程序用穿孔机穿在卡片或纸带上 将准备好的汇编程序或编译系统装入计算机 汇编程序或编译系统读入人工装在输入机上的穿孔卡片或穿孔带上的源程序 执行汇编过程或编译过程，产生目标程序，并输出到目标卡片迭或纸带 通过引导程序把装在输入机上的目标程序读入计算机 执行目标程序，从输入机上读入人工装好的数据卡片或数据带上的数据 产生计算结果，把执行结果从打印机上或卡片机上输出 上述方式比直接用机器语言前进了一步，程序易于编制和读取，汇编程序或编译系统可执行存储、分配等辅助工作，从而，在一定程度上减轻了用户的负担。 人工操作方式存在严重缺点： 用户独占资源 人工干预较多 计算时间拉长 这种人工操作方式在慢速的计算机上还能容忍，但是随着计算机速度的提高，其缺点就更加暴露出来了。 此外，随着 CPU 速度迅速提高而 I/O 设备速度却提高不多，导致 CPU 与 I/O 设备之间的速度不匹配，矛盾越来越突出，需要妥善解决这些问题 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"管理程序阶段 早期批处理系统借助于作业控制语言变革了计算机的手工操作方式。用户不再通过开关和按钮来控制计算机的执行，而是通过脱机方式使用计算机，通过作业控制卡来描述对作业的加工和控制步骤，并把作业控制卡连同程序、数据一起提交给计算机的操作员，操作员收集到一批作业后一起把它们放到卡片机上输入计算机。计算机上则运行一个驻留在内存中的执行程序，以对作业进行自动控制和成批处理，自动进行作业转换以减少系统空闲和手工操作时间。其工作流程如下：执行程序将一批作业从纸带或卡片机输入到磁带上，每当一批作业输入完成后，执行程序自动把磁带上的第一个作业装入内存，并把控制权交给作业。当该作业执行完成后，执行程序收回控制权并再调入磁带上的第二个作业到内存执行。计算机在执行程序的控制下就这样连续地一个作业一个作业地执行，直至磁带上的作业全部做完。这种系统能实现作业到作业的自动转换，缩短作业的准备和建立时间，减少人工操作和干预，让计算机尽可能地连续运转。 早期的批处理系统中，一开始作业的输入和输出均是联机的，联机 I/O 的缺点是速度慢， I/O 设备和 CPU 仍然串行工作，CPU 时间浪费很大，为此，在批处理中引进了脱机 I/O 技术。除主机外，另设一台辅机，该机仅与 I/O 设备打交道，不与主机连接。输入设备上的作业通过辅机输到磁带上，这叫脱机输入；主机负责从磁带上把作业读入内存执行，作业完成后，主机负责把结果输出到磁带上，这叫脱机输出；然后，由辅机把磁带上的结果信息在打印机上打印输出。这称作脱机 I/O 技术。 为了发挥批处理系统的性能，缩短作业的准备和建立时间，驻留在内存工作的执行程序的功能得到了很大的扩充，进化到管理程序。FMS 和 IBSYS ）是这类系统的典型实例。 管理程序的内存组织如图所示，它的主要功能小结如下： 管理程序的内存组织 - 自动控制和处理作业流。管理程序把控制权传送给一个作业，当作业运行结束时，它又收回控制权，继续调度下一个作业执行，自动控制和处理作业流，减少了作业的准备和建立时间。作业流的自动控制和处理依靠作业控制语言，因而，促进了作业控制语言的发展。作业控制语言是由一些描述作业控制过程的语句组成的，每个语句附有一行作业或作业步信息编码，并以穿孔卡的形式提供。例如，$\\$JOB$ 卡表示启动一个新作业; $\\$FIN$ 卡表示调用 FORTRAN 编译系统; $\\$ASM$ 卡表示调用汇编程序；$\\$LOAD$ 卡表示调用装配程序；$\\$DATA$ 卡指定数据；$\\$RUN$ 卡执行用户程序；$\\$END$ 卡表示一个作业结束。管理程序通过输入、解释并执行嵌入用户作业的作业控制卡规定的功能，就能自动地处理用户作业流。每个作业完成后，管理程序又自动地从输入机上读取下一个作业运行，直到整批作业处理结束。 - 提供一套操作命令。操作员通过打字机输入命令，管理程序识别并执行命令，这样不仅速度快，操作员还可进行一些复杂的控制。输出信息也可由打字机输出，代替了早期的氖灯显示，易于理解。这种交互方式不仅提高了效率，也便于使用 - 提供设备驱动和 I/O 控制功能。系统提供标准 I/O 程序，用户通过管理程序获得和使用 I/O 设备，减轻了用户驱动物理设备的负担。管理程序还能处理某些特殊设备和设备故障，改进了设备的可靠性和可用性。 - 提供库程序和程序装配功能。库程序包括：汇编程序、FORTRAN 语言编译程序、标准 I/O 程序、标准子程序等。通常，用户程序必须调用库程序才能执行下去，装配工作由管理程序完成。所有程序都按相对地址编址，管理程序把相应库程序和用户程序进行装配，并转换成绝对地址形式的目标程序，以便执行。 - 提供简单的文件管理功能。用户通过输入设备输入程序和数据，为了反复使用，用户希望能把这些信息保存起来，以便随时使用，这就产生了文件系统。从此，用户可按文件名字，而不是信息的物理地址进行存取，方便灵活，安全可靠。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"多道程序设计与操作系统的形成 多道程序设计 在早期的单道批处理系统中，内存中仅有单个作业在运行，致使系统中仍有许多资源空闲，设备利用率低，系统性能较差。 单道算题运行时处理器的使用效率 当 CPU 工作时，外部设备不能工作；而外部设备工作时，CPU 必须等待。 20 世纪 60 年代初，有两项技术取得了突破：中断和通道，这两种技术结合起来为实现 CPU 和 I/O 设备的并行工作提供了基础，这时，多道程序的概念才变成了现实。 多道程序设计是指允许多个程序(作业)同时进入一个计算机系统的内存储器并启动进行交替计算的方法。也就是说，计算机内存中同时存放了多道（二个以上相互独立的）程序，它们均处于开始和结束点之间。从宏观上看是并行的，多道程序都处于运行过程中，但都未运行结束；从微观上看是串行的，各道程序轮流占用 CPU，交替地执行。引入多道程序设计技术的根本目的是提高 CPU 的利用率，充分发挥计算机系统部件的并行性，现代计算机系统都采用了多道程序设计技术。 操作系统的形成 第三代计算机的性能有了更大提高，机器速度更快，内外存容量增大，I/O 设备数量和种类增多，为软件的发展提供了有力支持。如何更好地发挥硬件功效，如何更好地满足各种应用的需要，这些都迫切要求扩充管理程序的功能。 中断技术 和 通道技术 的出现使得硬部件具有了较强的并行工作能力，从理论上来说，实现多道程序系统已无问题。但是，从半自动的管理程序方式过渡到能够自动控制程序执行的操作系统方式，对辅助存储器性能的要求增高。这个阶段虽然有个别的磁带操作系统出现，但操作系统的真正形成还期待着大容量高速辅助存储器的出现。 大约到 60 年代中期以后，随着磁盘的问世，相继出现了多道批处理操作系统和分时操作系统、实时操作系统，到这个时候标志着操作系统正式形成。 计算机配置操作系统后，其资源管理水平和操作自动化程度有了进一步提高，具体表现在： 操作系统实现了计算机操作过程的自动化。批处理方式更为完善和方便，作业控制语言有了进一步发展，为优化调度和管理控制提供了新手段 资源管理水平有了提高，实现了外围设备的联机同时操作, 进一步提高了计算机资源的利用率 提供虚存管理功能，由于多个用户作业同时在内存中运行，在硬件设施的支持下，操作系统为多个用户作业提供了存储分配、共享、保护和扩充的功能，导致操作系统步入实用化 支持分时操作，多个用户通过终端可以同时联机地与一个计算机系统交互 文件管理功能有改进，数据库系统开始出现 多道程序设计趋于完善，采用复杂的调度算法，充分利用各类资源，最大限度地提高计算机系统效率 操作系统的发展和分类 促使操作系统不断发展的主要动力有以下五个方面： 器件快速更新换代：CPU 性能快速提升 计算机体系结构不断发展：硬件的改进促使计算机技术的进步 提高计算机系统资源利用率的需要 让用户使用计算机越来越方便的需要 满足用户的新要求，提供给用户新服务 从操作系统形成以来，按照功能、特点和使用方式的不同，可把操作系统区分为三种基本类型： 批处理操作系统，特征如下： 用户脱机工作 成批处理作业 单/多个程序运行 分时操作系统，特征如下： 同时性。若干个终端用户同时联机使用计算机，分时就是指多个用户分享使用同一台计算机的 CPU 时间 独立性。终端用户彼此独立，互不干扰，每个终端用户感觉上好像他独占了这台计算机 及时性。终端用户的立即型请求（即不要求大量 CPU 时间处理的请求）能在足够快的时间之内得到响应（通常应该为 2 ~ 3 秒钟）。这一特性与计算机 CPU 的处理速度、分时系统中联机终端用户数目和时间片的长短密切相关 交互性。人机交互，联机工作，用户直接控制其程序的运行，便于程序的调试和排错。 分时操作系统和批处理操作系统虽然有共性，它们都基于多道程序设计技术，但存在下列不同点： 追求的目标不同。批处理系统以提高系统资源利用率和作业吞吐率为目标；分时系统则要满足多个联机用户立即型命令的快速响应。 适应的作业不同。批处理适应已经调试好的大型作业；而分时系统适应正在调试的小作业。 资源的利用率不同。批处理操作系统可合理安排不同负载的作业，使各种资源利用率较佳；分时操作系统中，多个终端作业使用相同类型编译系统、运行系统和公共子程序时，系统调用它们的开销较小。 作业控制的方式不同。批处理由用户通过 JCL 的语句书写作业控制流，预先提交，脱机工作；交互型作业，由用户从键盘输入操作命令控制，交互方式，联机工作。 实时操作系统；目前有三种典型的实时系统，过程控制系统、信息查询系统和事务处理系统。 微机操作系统；供个人使用 并行操作系统；计算机的应用经历了从数据处理到信息处理，从信息处理到知识处理，每前进一步都要求增加计算机的处理能力。 网络操作系统；计算机网络是通过通信设施将地理上分散的并具有自治功能的多个计算机系统互连起来的系统 分布式操作系统 操作系统提供的服务和用户接口 操作系统提供的基本服务 操作系统要为用户程序的执行提供一个良好的运行环境，它要为程序及其用户提供各种服务，当然不同的操作系统提供的服务不完全相同，但有许多共同点。 提供操作系统共性服务为程序员带来了方便，使编程任务变得更加容易，操作系统提供给程序和用户的共性服务大致有： 创建程序。提供各种工具和服务，程序的编辑工具和调试工具，帮助用户编程并生成高质量的源程序等服务 执行程序。将用户程序和数据装入主存，为其运行做好一切准备工作并启动和执行程序。当程序编译或运行出现异常时，应能报告发生的情况，终止程序执行或进行适当处理 数据I/O 信息存取。文件系统让用户按文件名来建立、读写、修改以及删除文件，使用方便，安全可靠。当涉及多用户访问或共享文件时，操作系统将提供信息保护机制 通信服务。在许多情况下，一个进程要与另外的进程交换信息，这种通信一般分为两种情况，一是在同一台计算机上执行的进程之间通信；二是在被网络连接在一起的不同计算机上执行的进程之间通信 错误检测和处理。操作系统能捕捉和处理各种硬件或软件造成的差错或异常，并让这些差错或异常造成的影响缩小在最小范围内，必要时及时报告给操作员或用户。 此外，操作系统除上述提供给用户的服务外，还具有另外一些功能，以保证它自身高效率、高质量地工作，从而，使得多个用户程序能够有效地共享系统资源，提高系统效率，这些功能有： 资源分配 统计 保护 操作系统提供的用户接口 操作系统可以通过程序接口和操作接口两种方式把它的服务和功能提供给用户，反过来也可以这样说，用户可以通过两个接口来调用操作系统提供的服务和功能 用户和操作系统间的两种接口 程序接口与系统调用 系统调用 系统调用的实现要点 系统调用与过程（函数）调用的区别 程序中执行系统调用或过程（函数）调用，虽然都是对某种功能或服务的需求，但两者从调用形式到具体实现都有很大区别。 调用形式不同。过程（函数）使用一般调用指令，其转向地址是固定不变的，包含在跳转语句中，但系统调用中不包含处理程序入口，而仅仅提供功能号，按功能号调用 被调用代码的位置不同。过程（函数）调用是一种静态调用，调用程序和被调用代码在同一程序内，经过连接编辑后作为目标代码的一部份。当过程（函数）升级或修改时，必须重新编译连接。而系统调用是一种动态调用，系统调用的处理代码在调用程序之外（在操作系统中），这样一来，系统调用处理代码升级或修改时，与调用程序无关。而且，调用程序的长度也大大缩短，减少了调用程序占用的存储空间。 提供方式不同。过程（函数）往往由编译系统提供，不同编译系统提供的过程（函数）可以不同；系统调用由操作系统提供，一旦操作系统设计好，系统调用的功能、种类与数量便固定不变了。 调用的实现不同。程序使用一般机器指令（跳转指令）来调用过程（函数），是在用户态运行的；程序执行系统调用，是通过中断机构来实现，需要从用户态转变到核心态，在管理状态执行。因此程序执行系统调用安全性好 Linux 的系统调用 每个系统调用由两部分组成： 核心函数：是实现系统调用功能的（内核）代码，它运行在核心态，数据也存放在内核空间，通常它不能再使用系统调用，也不能使用应用程序可用的库函数。 接口函数：是提供给应用程序的 API，以库函数形式存在，该库中存放了所有系统调用的接口函数的目标代码，用汇编语言书写。其主要功能是把系统调用号、入口参数地址传送给相应的核心函数，并使用户态下运行的应用程序陷入核心态（Linux内核陷入由 0X80 中断实现，调用流程：1. 取系统调用号，检验合法性；2. 建立调用堆栈，保护现场信息；3. 根据系统调用号定位核心函数地址；4. 根据通用寄存器内容，从用户栈中取入口参数；5. 核心函数执行，把结果返回应用程序； 6. 执行退栈操作，判别调度程序 scheduler 是否要被执行）。 操作接口与系统程序 作业控制方式 命令解释程序 系统程序 操作系统的结构设计 操作系统的构件 内核 进程 线程 管程 类程 整体式结构的操作系统 层次式结构的操作系统 虚拟机结构的操作系统 客户/服务器与微内核结构的操作系统 客户/服务器与微内核结构 微内核的设计 操作系统的运行模型 非进程内核模型 OS 功能（函数）在用户进程内执行的模型 OS 功能（函数）作为独立进程执行的模型 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"总结 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:4","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"处理器管理 处理器管理是操作系统的重要组成部分，它负责管理、调度和分派计算机系统的重要资源———处理器，并控制程序的执行。由于处理器管理是操作系统中最核心的组成部分，任何程序的执行都必须真正占有处理器，因此，处理器管理直接影响系统的性能。 操作系统的基本任务是对“进程”实施管理，操作系统必须有效控制进程的执行、给进程分配资源、允许进程之间共享和交换信息、保护每个进程在运行期间免受其他进程干扰、控制进程的互斥、同步和通信。为达到这些要求，操作系统的处理器管理必须为每一个进程维护一个数据结构，用以描述该进程的状态和分配到的资源，并允许操作系统行使对进程的控制权。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:4:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中央处理器 计算机系统的核心是中央处理器。如果一个计算机系统只包括一个运算处理器，称之为单处理器系统。如果有多个运算处理器，则称之为多处理器系统。 早期的计算机系统是基于单个处理器的顺序处理机器，每一条指令的执行也是串行的，为提高计算机处理的速度，首先发展起来的是联想存储器系统和流水线系统，前者提出了数据驱动的思想，后者解决了指令并行执行的问题，这两者都是最初计算机并行化发展的例子。 随着硬件技术的进步，并行处理技术得到了迅猛的发展，计算机系统不再局限于单处理器和单数据流，各种各样的并行结构得到了应用。 目前计算机系统可以分作以下四类： 单指令流单数据流（SISD）。一个处理器在一个存储器中的数据上执行单条指令流。 单指令流多数据流（SIMD）。单条指令流控制多个处理单元同时执行，每个处理单元包括处理器和相关的数据存储，一条指令事实上控制了不同的处理器对不同的数据进行了操作。向量机和阵列机是这类计算机系统的代表。 多指令流单数据流（MISD）。一个数据流被传送给一组处理器，通过这一组处理器上的不同指令操作最终得到处理结果 多指令流多数据流（MIMD）。多个处理器对各自不同的数据集同时执行不同的指令流。可以把 MIMD 系统划分为共享内存的紧密耦合 MIMD 系统和内存分布的松散耦合 MIMD 系统两大类。 根据处理器分配策略，紧密耦合 MIMD 系统可以分为主从式系统 MSP 和对称式系统 SMP 两类。 主从式系统的基本思想是：在一个特别的处理器上运行操作系统内核，其他处理器上则运行用户程序和操作系统例行程序，内核负责分配和调度各个处理器，并向其他程序提供各种服务（如输入输出）。这种方式实现简单，但是主处理器的崩溃会导致整个系统的崩溃，并且极可能在主处理器形成性能瓶颈。 在对称式多处理器系统中有两个或两个以上的处理器，操作系统内核可以运行在任意一个处理器上。每个处理器都可以自我调度运行的进程和线程，单个进程的多个线程可在不同处理器上同时运行，服务器进程可以使用多个线程去处理同时来自多个客户的请求，并且操作系统内核也被设计成多进程或多线程，内核的各个部分可以并行执行。 对称多处理器是迄今为止开发出的最为成功的两种并行机之一，有一种 SMP 机最多可支持 64 个处理器，多个处理器之间采用共享主存储器。SMP 机有对称性、单一地址空间、低通信延迟和一致的高速缓存等特点，具有高可靠性、可扩充性、易伸缩性。这一系统中任何处理器都可以访问任何存储单元及 I/O 设备；处理器之间通信代价很低，而并行度较高。 由于共享存储器中只要保存一个操作系统和数据库副本，既有利于动态负载平衡，又有利于保证数据的完整性和一致性。 在松散耦合 MIMD 系统中，每个处理单元都有一个独立的内存储器，各个处理单元之间通过设定的线路或网络通信，多计算机系统和集群系统都是松散耦合 MIMD 系统的例子。 集群系统是迄今为止开发出的另一种最为成功的并行机，它是一组互联的计算机系统。因此也是分布式系统的一种，集群操作系统也是分布式操作系统的一个品种。集群系统运行时构成统一的计算资源，给人以一台机器的感觉。集群系统的配置一般有两种方法，一是各个节点计算机自带磁盘，二是多个节点计算机共享 RAID 磁盘。 在集群系统中，每一台计算机都是一个完整的节点，离开集群后自己可以独立地工作，所以一个节点的失效并不意味着服务的失败，从而使集群系统具备很好的容错性。集群系统还具有很好的可伸缩性，可以用低成本的微机和以太网设备等产品构成。 寄存器 计算机系统的处理器包括一组寄存器，其个数根据机型（处理器型号）的不同而不同，它们构成了一级存储，虽然比主存储器容量要小的多，但是访问速度要快的多。这组寄存器所存储的信息与程序的执行有很大的关系，构成了处理器现场。 不同类型的处理器具有不同的寄存器组成。一般来说，这些寄存器可以分为以下几类： 通用寄存器。可由程序设计者指定许多功能，如存放操作数或用作寻址寄存器。 数据寄存器。用以存放操作数。它们作为内存数据的高速缓存，可以被系统程序和用户程序直接使用并进行计算。 地址寄存器。用于指明内存地址，如索引寄存器、段寄存器（基址/限长）、堆栈指针寄存器等。 I/O 地址寄存器。用于指定 I/O 设备 I/O 缓冲寄存器。用于处理器和 I/O 设备交换数据 控制寄存器。用于存放处理器的控制和状态信息，它至少应该包括程序计数器 PC 和指令寄存器 IR，中断寄存器以及用于存储器和 I/O 模块控制的寄存器。此外还有存放将被访问的存储单元地址的存储器地址寄存器，以及存放从存储器读出或欲写入的数据的存储器数据寄存器。 特权指令与非特权指令 计算机的基本功能是执行程序，而最终被执行的程序是存储在内存中的机器指令。处理器根据程序计数器（PC）内存中取一条指令到指令寄存器（IR）并执行它，PC 将自动地增长或改变为转移地址以指明下一条要执行的指令的入口地址。 每台计算机的机器指令的集合称指令系统，它反映了一台机器的功能和处理能力，可以分为以下五类： 数据处理类指令：用于执行算术和逻辑运算 转移类指令：如无条件转移、条件转移、计数转移等用于改变指令执行序列 数据传送类指令：用于在处理器的寄存器和寄存器、寄存器和存储器单元、存储器单元和存储器之间交换数据 移位与字符串指令，移位分算术、逻辑和循环移位。字符串处理有字符串的传送、比较、查询和转换。 I/O类指令：用于启动外围设备，让主存和外围设备之间交换数据 引入操作系统后，操作系统核心程序可以使用全部机器指令，但用户程序只能使用机器指令系统的一个子集。这是因为，用户程序执行一些有关资源管理的机器指令时很容易导致系统混乱，造成系统或用户信息的破坏。 因此，在多道程序设计环境中，从资源管理和控制程序执行的角度出发，必须把指令系统中的指令分作两类：特权指令和非特权指令。 所谓特权指令是指那些只能提供给操作系统的核心程序使用的指令，如启动输入 % 输出设备、设置时钟、控制中断屏蔽位、清内存、建立存储键，加载 PSW 等。只有操作系统才能执行全部指令（特权指令和非特权指令），如果一般用户执行特权指令，会导致非法执行而产生保护中断，转交给操作系统的“用户非法执行特权指令”的特殊处理程序处理。 处理器状态 那么，中央处理器怎么知道当前是操作系统还是一般用户在其上运行呢？这将依赖于处理器状态的标志。在执行不同程序时，根据执行程序对资源和机器指令的使用权限把处理器设置成不同状态。 处理器状态又称为处理器的运行模式，有些系统把处理器状态划分为核心状态、管理状态和用户状态，而大多数系统把处理器状态简单划分为管理状态（又称特权状态、系统模式、特态或管态）和用户状态（又称目标状态、用户模式、常态或目态）。 当处理器处于管理状态时，程序可以执行全部指令，访问所有资源，并具有改变处理器状态的能力；当处理器处于用户状态时，程序只能执行非特权指令。 Intel 奔腾处理器由四种状态，支持 4 个特权级别，0 级权限最高，3 级权限最低。 0 级为操作系统内核级。处理 I/O 、存储管理和其他关键操作。 1 级为系统调用处理程序级。用户程序可以通过调用这里的过程执行系统调用，但是只有一些特定的和受保护的过程可以被调用。 2 级为共享库过程级。它可以被很多正在运行的程序共享，用户程序可以调用这些过程，读取它们的数据，但是不能修改它们。 3 级为用户程序级。它受到的保护最少。 当然，各个操作系统在实现过程中可以根据具体策略有选择地使用硬件提供的保护级别，如运行在 奔腾 上的 windows 操作系统只使用了 0 级 和 3 级。 下面两类情况会导致从用户态向管理状态转换 程序请求操作系统服务，执行一条系统调用 程序运行时，产生了一个中断事件，运行程序被中断，让中断处理程序工作 这两类情况都是通过中断机构才发生的，可以说中断是目态到管态转换的惟一途径。当系统中断响应交换程序状态字时，这个处理中断事件的处理程序的程序状态字的处理器状态位标志一定为“管态”。怎样实现管态到目态的转换呢？每台计算机通常会提供一条特权指令称作加载程序状态字 LPSW (Load PSW)，用来实现操作系统向用户程序的转换。 程序状态字寄存器 操作系统通过引入程序状态字 PSW (Program Status Word) 来区别不同的处理器工作状态。 ，程序状态字用来指示处理器状态、控制指令的执行顺序并且保留和指示与运行程序有关的各种信息，其主要作用是方便地实现程序状态的保护和恢复。每个正在执行的程序都有一个与其执行相关的 PSW ，而每个处理器都设置一个程序状态字寄存器。 一个程序占有处理器执行，它的 PSW 将占有程序状态字寄存器。 一般来说，程序状态字寄存器包括以下几类内容： 程序基本状态。包括： 程序计数器：指明下一条执行的指令地址； 条件码：表示指令执行的结果状态； 处理器状态位：指明当前的处理器状态，如目态或管态、运行或等待。 中断码。保存程序执行时当前发生的中断事件。 中断屏蔽位。指明程序执行中发生中断事件时，是否响应出现的中断事件。 由于不同处理器中的控制寄存器组织方式不同，所以在大多数计算机的处理器现场中可能找不到一个称为程序状态字寄存器的具体寄存器，但总是有一组控制与状态寄存器实际上起到这一作用。 在 Intel 奔腾中，程序状态字由标志寄存器 EFLAGS 和指令指针寄存器 EIP 组成，均为 32 位。EFLAGS 的低 16 位称 FLAGS，可当作一个单元来处理。标志可划分为三组：状态标志、控制标志、系统标志。 状态标志：它使得一条指令的执行结果影响后面的指令。算术运算指令使用 OF","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:4:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断技术 现代计算机中都配置了硬件中断装置，中断机制是操作系统的重要组成部分之一。 每当用户程序执行系统调用以求获得系统的服务和帮助、或操作系统管理 I/O 设备和处理形形色色的内部和外部事件时，都需要通过中断机制进行处理。所以，也有人说操作系统是由 “中断驱动” 的。 中断是指程序执行过程中，当发生某个事件时，中止 CPU 上现行程序的运行，引出处理该事件的服务程序执行的过程。 在提供中断装置的计算机系统中，在每两条指令或某些特殊指令执行期间都检查是否有中断事件发生，若无则立即执行下一条或继续执行，否则响应该事件并转去处理中断事件。 中断这种处理突发事件的能力是由硬件和软件协作完成的。首先，由硬件的中断装置发现产生的中断事件，然后，中断装置中止现行程序的执行，引出处理该事件的程序来处理。 计算机系统不仅可以处理由于硬件或软件错误而产生的事件，而且可以处理某种预见要发生的事件。例如，外围设备工作结束时，也发出中断请求，向系统报告它已完成任务，系统根据具体情况做出相应处理。 引起中断的事件称为中断源。发现中断源并产生中断的硬件称中断装置。在不同的硬件结构中，通常有不同的中断源和不同的中断装置，但它们有一个共性，即当中断事件发生后，中断装置能改变处理器内操作执行的顺序，可见中断是现代操作系统实现并发性的基础之一。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:5:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断源分类 从中断事件的性质和激活的手段来说，可以分成强迫性中断事件和自愿性中断事件两大类。 强迫性中断事件不是正在运行的程序所期待的，而是由于随机发生的某种事故或外部请求信息所引起的。这类中断事件大致有以下几种： 机器故障中断事件。例如电源故障、主存储器出错等 程序性中断事件。例如定点溢出、除数为0、地址越界等。由于这类中断反映程序执行中发现的例外情况，所以又称异常 外部中断事件。例如时钟的定时中断、控制台发控制信息等 输入输出中断事件。例如设备出错、传输结束等 自愿性中断事件是正在运行的程序所期待的事件。这种事件是由于执行了一条访管指令而引起的，它表示正在运行的程序对操作系统有某种需求，一旦机器执行到一条访管指令时，便自愿停止现行程序的执行而转入访管中断处理程序处理。例如，要求操作系统协助启动外围设备工作。 两类中断事件的响应过程略有不同，详见图： 两类中断事件 还可以按照中断信号的来源，把中断分为外中断和内中断两类： 外中断。一般又称中断，是指来自处理器和主存储器之外的中断，包括电源故障中断、时钟中断、控制台中断、它机中断和 I/O 中断等。每个不同的中断具有不同的中断优先级，在处理高一级中断时，往往会屏蔽部分或全部低级中断。 内中断。是指来自处理器和主存内部的中断，一般又称异常，包括通路校验错、主存奇偶错、非法操作码、地址越界、页面失效、调试指令、访管中断、算术操作溢出等各种程序性中断。其中访管中断是由机器指令提供的特殊指令，该指令执行时将会引起内中断。异常是不能被屏蔽的，一旦出现应立即响应并加以处理。 中断和异常的区别如下： 中断：中断是由与现行指令无关的中断信号触发的，所以它是异步的，而且中断的发生与 CPU 处在用户模式或内核模式无关，通常在两条机器指令之间才可以响应中断，一般来说，中断处理程序提供的服务不是为当前进程所需要的，如时钟中断、硬盘读写服务请求中断 异常：异常则是由处理器正在执行现行指令而引起的。因而一条指令执行期间允许响应陷入。通常，异常处理程序提供的服务是为当前进程所用的。异常包括很多方面，有出错，也有陷入。出错和陷入的主要一点区别是：它们发生时保存的返回指令地址不同，出错保存指向触发异常的那条指令，而陷入保存指向触发异常的那条指令的下一条指令。因此，当从异常返回时，出错会重新执行那条指令，而陷入就不会重新执行那条指令。 上述的内中断与外中断（中断和异常）要通过硬件设施来产生中断请求，可以看作硬中断。与其相对应的不必由硬件发信号而能引发的一种中断称为软中断，软中断是利用硬件中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。它通常是由内核或进程对某个进程发出的中断信号，可以看作内核与进程或进程与进程之间用来模拟硬中断的一种信号通信方式。 软中断和硬中断两者的共同点是：当中断源产生中断请求或发出软中断信号后，CPU 或者接收进程在适当的时机自动进行中断处理或完成软中断信号所对应的功能。这里所说适当时机表示接收的硬中断会及时获得中断处理程序的处理，但接收软中断信号的进程不一定正好在接到此信号时占有处理器，而相应的软中断信号处理必需等到该接收进程获得处理器后才能进行，通常会有一定时间的延迟。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断装置 发现中断源并产生中断的硬件称中断装置，这些硬件包括中断逻辑线路和中断寄存器。 迄今为止，所有的计算机系统都采用硬件和软件（硬件中断装置和软件中断处理程序）结合的方法实现中断处理。 一般来说，硬件中断装置主要做以下三件事： 发现中断源，响应中断请求。当发现多个中断源时，它将根据规定的优先级，先后发出中断请求。 保护现场。将运行程序中断点在处理器中某些寄存器内的现场信息（又称运行程序的执行上下文）存放于内存储器。使得中断处理程序运行时，不会破坏被中断程序的有用信息，以便在中断处理结束后能够返回被中断程序继续运行。 启动处理中断事件的中断处理程序，处理器状态已从目态被切换到管态。 中断来源于正在执行的程序以及计算机系统的各个部件，甚至计算机的外部环境。当一个具体的中断事件发生时，计算机的硬件中断装置必须把它记录下来。中断寄存器是用来记录中断事件的寄存器，中断寄存器的内容称中断字，中断字的每一位对应一个中断事件。每当一条机器指令执行结束的时刻，中断控制部件扫描中断字，查看是否有中断事件发生，若是则处理器便响应这个中断请求。 当中断发生后，中断字的相应位会被置位。由于同一时刻可能有多个中断事件发生，中断装置将根据中断屏蔽要求和中断优先级选取一个，然后把中断寄存器的内容送入程序状态字寄存器的中断码字段，且把中断寄存器的相应位清“0”当处理中断事件的程序执行时就可以读出中断信息进行分析，从而知道发生了什么中断事件。 紧接着中断装置进行必要的保护现场工作。此时并不一定要将处理器中所有寄存器中的信息全部存于（写回）存储器中，但是，对程序状态字寄存器中的那些信息一定要保护起来。最后，将中断处理程序的程序状态字送入现行程序状态字寄存器，这就引出了相应的中断事件处理程序。 IBM中大型机中断响应过程 如果把被中断的程序的程序状态字称为旧程序状态字，而把中断处理程序的程序状态字称为新程序状态字的话，如何来实现新旧程序状态字的交换呢？通常，系统为每一种中断都开辟了主存的固定单元存放新的和旧的程序状态字。 下图是 IBM 中大型机中断响应过程，主存中开辟了专用的双字单元（用16进制标出），用于存放各类中断的旧的和新的 PSW（分别为旧的和新的外中断、访管中断、程序中断、机器故障中断和 I/O 中断），CPU 中还有硬件程序状态字寄存器保存运行程序的现行 PSW。 IBM PC 中断的响应过程 当响应中断时，由硬件执行 1 把中断码装配到现行 PSW 中，然后，执行 2 把现行 PSW 保存到中断类相应的旧 PSW 单元；同时，执行 3 把中断类相应的新 PSW 加载到现行 PSW ，这就引出了相应中断类的中断处理程序。中断事件处理结束后，如果执行 4 便可从断点返回继续执行被中断的程序。 在 IBM PC 机上，为了方便地找到中断处理程序，通常在计算机内存的低地址处开辟了一个称为中断向量表的区域。表中每一项称为一个中断向量，其中存放了一个中断处理程序的入口地址及相关信息，不同中断源需要用不同的中断处理程序处理，也就对应了不同的中断向量。 另外，采用堆栈方式保存被中断程序的状态信息，当发现中断源并响应中断时，中断装置将把现行 PSW 内容压进堆栈，接着再把指令指针 IP 和代码段基地址内容也压进堆栈，这就保存了原运行程序的状态。处理器根据硬件中断装置提供的中断向量号，获得被接受的中断请求的中断向量地址，再按照中断向量地址把中断处理程序的 PSW 送入现行程序状态字寄存器，加载新的程序状态字。从而，就引出了处理特定中断事件的中断处理程序。返回原程序时，只要把栈顶内容弹出送入现行 IP、CS和PSW中。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断处理程序 处理中断事件的程序称为中断处理程序。它的主要任务是处理中断事件和恢复正常操作。由于不同中断源对应不同中断处理程序，故快速找到中断处理程序的入口地址是一个关键问题。寻找入口地址可用如下办法：在主存储器(常在低地址区)设置一张向量地址表，存储单元的地址对应向量地址，存储单元的内容为入口地址。CPU 响应中断后，根据预先规定的次序找到相应向量地址，便可获得该中断事件处理程序的入口地址。 一个操作系统设计者将根据中断的不同类型和不同的应用环境，来确定不同的处理原则。 具体地讲，一个中断处理程序主要做以下四项工作： 保护未被硬件保护的一些必需的处理状态。例如，将通用寄存器的内容保存到主存储器，从而使中断处理程序在运行中可以使用通用寄存器 识别各个中断源，分析产生中断的原因。 处理发生的中断事件。中断处理程序将根据不同的中断源，进行各种处理操作。有简单的操作，如置一个特征标志；也有相当复杂的操作，如重新启动磁带机倒带并执行重读操作。 恢复正常操作。恢复正常操作一般有几种情况：恢复中断前的程序按断点执行；重新启动一个新的程序或者甚至重新启动操作系统。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断事件的具体处理方案 机器故障中断事件的处理 一般来说，这种事件是由硬件的故障产生的，排除这种故障必须进行人工干预。中断处理能做的工作一般是保护现场，防止故障蔓延，报告给操作员并提供故障信息以便维修和校正，以及对程序中所造成的破坏进行估价和恢复。下面列举一些硬件失效中断事件的处理办法。 电源故障的处理 当电源发生故障，例如断电时，硬设备能保证继续正常工作一段时间。操作系统利用这段时间可以做以下三项工作： 将处理器中有关寄存器内的信息经主存储器送到磁盘保存起来，以便在故障排除后恢复现场，继续工作。 停止外围设备工作。有些外围设备（例如磁带机）不能立即停止，中断处理程序将把这些正在交换信息又不能立即停止的设备记录下来。 停止处理器工作。一般可以让主机处于停机状态，此时，整个系统既不执行指令又不响应中断。 当故障排除后，操作员可以从一个约定点启动操作系统以恢复工作。恢复程序做的主要工作是： 恢复中断前的有关现场 启动被停止的外围设备继续工作 如果发生故障时有不能立即停止的外围设备正在工作，那么，涉及这些外围设备的程序将被停止执行而等待操作员的干预命令 完成上述各项工作后，系统将选择可以运行的程序继续运行 主存储器故障的处理 主存储器的奇偶校验或海明校验装置发现主存储器读写错误时，就产生这种中断事件。中断处理程序首先停止与出现的中断事件有关的程序的运行。然后向操作员报告出错单元的地址和错误的性质。 程序性中断事件的处理 处理程序性中断事件大体上有两种办法。 对于那些纯属程序错误而又难以克服的事件，例如非法使用特权指令，企图访问一个不允许其使用的主存储器单元等，操作系统只能将出错程序的名字、出错地点和错误性质报告给操作员并请求干预。 对于其他一些程序性中断，例如定点溢出、阶码下溢等，不同的用户往往有不同的处理要求。所以，操作系统可以将这种程序性中断事件转交给用户程序自行处理。 如果用户程序对发生的中断事件没有提出处理办法，那么操作系统将进行标准处理。 用户怎样来编制处理中断事件的程序呢？有些语言提供了称之为 on 语句的调试语句，它的形式如下： on \u003c条件\u003e \u003c中断续元入口\u003e 比如： // 每当发生定点溢出时，转向以 LA 为标号的语句 on fixed overflow go to LA; // 对于发生在不同地方的同一种程序性中断事件允许用户采用不同的处理方法。 // 例如，在执行了上述调试语句后又执行调试语句： on fixed overflow go to LB; // 就表示今后再发生溢出时将转向 LB 而不是转向 LA 去处理了 有了调试语句后，用户用程序设计语言编制程序时，也就可以编写处理程序性中断事件的程序了。编译程序为每个用户设置一张中断续元入口表，且在编译源程序产生目标程序时，把调试语句翻译成一段程序。其功能是：将中断续元入口地址送入中断续元入口表中对应该语句的中断条件的那一栏。中断续元入口表的形式如图: 中断续元入口 对应每一个用户处理的中断事件，表格中有一栏用以填写处理该中断事件的中断续元入口地址。如果用户没有给出处理其中断事件的中断续元时，相应栏的内容为0。当程序运行执行到调试语句时，就将中断续元的入口地址送入相应栏内。 显然，对于同一中断事件，当执行第二次对应该事件的调试语句时，就将第二次规定的中断续元入口地址填入表内相应栏中而冲去了第一次填写的内容。这就是上面所说的，利用对同一条件多次使用调试语句时，可以做到对发生于不同地点的同一种中断事件采用不同的处理方法。 当发生程序中断事件后，操作系统是怎样转交给用户程序去处理的呢？操作系统只要根据中断事件查看表中对应栏，如果对应栏为“0”它表示用户未定义该类中断续元，此时系统将按规定的标准办法进行处理。例如，将程序停止下来，向操作员报告出错位置和性质，或者置之不顾，就好像什么事也没有发生一样。如果对应栏不为“0”，则强迫用户程序转向中断续元去处理。 如果在中断续元的执行中又发生中断事件时，就不能这样简单地处理了。首先，中断续元的嵌套一般应规定重数，在上面的表格中规定嵌套重数为2。表格第一栏的第 0 字节记录了第一次进入中断续元的事件号；第 1 个字节记录了第二次（嵌套）进入中断续元的事件号。其次，中断续元的嵌套不能递归，例如，处理定点溢出的中断续元，在执行时不允许又发生定点溢出程序性中断事件。 下面按步骤小结一下中断续元的处理过程和原则： 编译程序编译到 on 语句时，生成填写相应中断续元入口表的目标代码段； 程序运行执行到 on 语句时，根据中断条件号，将中断续元入口填入相应栏，这是通过执行上述代码段来实现的； 执行同一中断条件号的 on 语句时，中断续元入口被填入同一栏，从而，用户可在他的程序的不同部分对同一中断条件采用不同的处理方法； 每当一个中断条件发生时，检查中断续元入口表相应栏，或转入中断续元处理，或进行操作系统标准处理； 程序性中断处理允许嵌套，应预先规定嵌套重数，但不允许递归。 外部中断事件的处理 时钟定时中断以及来自控制台的信息都属外部中断事件，它们的处理原则如下： 时钟中断事件的处理 时钟是操作系统进行调度工作的重要工具，如让分时进程作时间片轮转、让实时进程定时发出或接收控制信号、系统定时唤醒或阻塞一个进程、对用户进程进行记账。 时钟可以分成绝对时钟和间隔时钟（即闹钟）两种。利用计时器能确保操作系统必要时获得控制权，例如，陷入死循环的进程最终因时间片耗尽会被迫出让处理器。 系统设置一个绝对时钟寄存器，计算机的绝对时钟定时地（例如每 10 ms）把该寄存器的内容加 1。如果开始时这个寄存器的内容为 0，那么，只要操作员告诉系统开机时的年、月、日、时、分、秒，以后就可推算出当前的年、月、日、时、分、秒了。当绝对时钟寄存器记满溢出时，就产生一次绝对时钟中断，操作系统处理这个中断时，只要在主存的固定单元上加 1 就行了。这个固定单元记录了绝对时钟中断的次数，这样就可保证有足够的计时量。计算当前时间时，只要按绝对时钟中断的次数和绝对时钟寄存器的内容推算就可得到。 间隔时钟是定时将一个间隔时钟寄存器的内容减 1，当间隔时钟寄存器的内容为 0 时，就产生一个间隔时钟中断。所以，只要在间隔时钟寄存器中放一个预定的值，那么就可起到闹钟的作用，每当产生一个间隔时钟中断，就意味着预定的时间到了。操作系统经常利用间隔时钟作控制调度。 时钟硬件做的工作仅仅是按已知时间间隔产生中断，其余与时间有关的任务必须由软件来做，不同的操作系统有关时钟的任务不同，但一般包括以下内容： 维护绝对日期和时间 防止进程的运行时间超出其允许值，发现陷入死循环的进程 对使用 CPU 的用户进程记账 处理进程的间隔时钟（闹钟) 对系统的功能或部件提供监视定时器 在 Intel x86/奔腾 微机中，Linux利用 CMOS 中记录的时间作为系统启动时的基准时间，在系统运行时，利用时钟滴答来维护系统的时间。Linux 使用一个全局变量称 jiffies(瞬时)作为所有系统时间的测量基准，系统启动时，CMOS 中记录的时间转化为从 1970年1月1日0时0分0秒(UNIX纪元)算起的 jiffies 值(累积秒数)。操作系统中需要有定时服务的机制，以实现准时调度任务或处理与时间相关的工作，这些都是通过定时器机制来实现的。 Linux定时器机制 Linux 中存在两种类型的系统定时器，这两种定时器都具有对应的处理例程，必须在到达给定的系统时间时被进程调用，但实现方法有些不同。第一类是老的定时器机制，有一个 CA 个指针的数组定义的定时器。每个指针可指向一个 timer-struct 结构，而 timer-active 是活动定时器的掩码，数组元素是静态定义的，在系统初始化时入口被加到该数组中。第二类是新的定时器机制，突破了 32 个定时器的限制，使用一个 timer-list 数据结构的链表，按定时器到期时间的升序排列。两类定时器中 expires 给出该定时器被激活的时间，而 *fn() 指出定时器激活后的处理函数。 两类定时器都使用 jiffies 值作为到期比较时间。例如，某个定时器要在 2s 之后到期，则必须将 2s 转换成对应的 jiffies 值，加上当前的系统时间(也是以 jiffies 为单位)后，得到的便是该定时器到期的系统时间 expires。每次系统时钟滴答到来时，定时器 bottom half 处理过程被标记为活动状态，这样当调度程序下次运行时，定时器队列能获得处理。定时器 buttom half 处理过程要处理两种类型的系统定时器。对于老的系统定时器，检查 timer-active 中被置位的位掩码，以便确定活动的定时器。如果一个活动的定时器到期，便调用对应的定时器例程，timer-active 对应位被清除。对于新的系统定时器，检查链表中的 timer-list 数据结构。每个到期的定时器将被从链表中移出，对应的定时器例程被调用。新的定时器机制的优点是能传递参数 data 到定时器例程中。 有了上述定时器，Linux 就可以统计用户的记账信息，它记录进程的创建时间及进程在生命周期占用的 CPU 时间。每个时钟滴答到来时，核心都修改当前进程在内核态和用户态占用的时间，这些时间称为记账信息。对于不同的时间，Linux 运行了不同的间隔定时器，这些间隔定时器的类型有三种： real 这种间隔定时器按实际时间计时，不管进程处在何种模式下运行（包括进程被挂起时），计时总在进行，当定时到达时发送给进程一个 SIGALRM 信号 virtual 这种间隔定时器仅当进程在用户态下执行时才计时，当定时到达时发送","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["linux"],"content":"imx6ull emmc镜像制作 ","date":"2022-03-16","objectID":"/2022/03/0004-imx6ull%E7%83%A7%E5%86%99%E9%95%9C%E5%83%8F/:1:0","tags":["linux","imx6ull"],"title":"Imx6ull烧写镜像","uri":"/2022/03/0004-imx6ull%E7%83%A7%E5%86%99%E9%95%9C%E5%83%8F/"},{"categories":["linux"],"content":"什么是buildroot buildroot 是一个简单、高效、易用的工具，能够利用交叉编译生成嵌入式linux系统 ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:1:0","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"buildroot 项目 ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:2:0","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"拉取buildroot源码 https://github.com/imx6ull-pro/buildroot.git buildroot 配置编译选项 查询可用目标系统 make list-defconfigs 选定目标系统 make imx6ullevk_defconfig 打开配置菜单 make menuconfig # 或 make nconfig 查看帮助 make help ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:2:1","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"gvfs 介绍 gvfs 是 GNOME 用户空间虚拟文件系统的缩写，从 GLib 2.15.1 开始加入系统，主要是对 I/O 的一层抽象。gvfs 提供了一些模块，这些模块由使用 libgio 的 API 应用程序自动使用。也通过 fuse，允许不适用 gio 的应用程序可以访问 gvfs 文件系统。 访问虚拟文件系统的前提是挂载文件系统，gvfs 提供了一个守护进程——gvfsd来协调处理模块，每个模块都与 gvfsd 通过 gio 进行通信信。gvfs带有一些后端，这些后端实现了回收站、sftp、ftp、webdav、以及本地数据相关支持，都是作为 gvfs 功能实现的一部分。 gvfs 还包括用于 gio 实现卷监视器。 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:1:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfs守护进程说明 守护进程 功能 gvfsd 是gvfs主要守护程序。它通过org.gtk.vfs.Daemon名连接到dbus会话总线上，当gvfsd没有启动时候，可以通过gio客户端自动拉起gvfsd守护进程。gvfsd主要任务是充当模块的安装器和跟踪器。在需要的时候，它会产生新的后端，并跟踪它们的生命周期，维护已挂载的列表并创建与它们的直接连接。gvfsd还将启动gvfsd-fuse 并向其提供应在其中安装 fuse 文件系统的安装点 gvfsd-fuse gvfsd-fuse维护FUSE(用户空间的文件系统)挂载，以使gvfs后端可用于 POSIX 应用程序。fuse文件系统的挂载点由 [PATH] 参数提供。其主要由 gvfsd 启动 gvfsd-metadata gvfsd-metadata是一个守护进程，充当内部 gvfs 元数据存储的写入序列化程序。它是在 gio 客户端更改元数据时候自动启动。读取操作直接由客户端 gio 完成，并不需要运行守护程序 gvfs-goa-volume-monitor 支持 GNOME 在线账户 gvfs-gphoto2-volume-monitor 支持图片传输协议，如:gPhoto gvfs-mtp-volume-monitor 支持媒体传输协议 gvfs-udisks2-volume-monitor gvfs-udisks2-volume-monitor负责磁盘、介质、挂载和fstab桌面用户界面中显示的项目。特别的是gnome-shell以及使用 GLib API 的任何其它应用程序都在使用此过程中的信息。 请注意：不要把它与udisks软件包中的udisksd和udisksctl混淆 gvfs-afc-volume-monitor 苹果文件系统 gvfsd-afc 挂载IPhone/Ipod touch音量 gvfsd-afp 苹果文件协议卷 gvfsd-afp-browse 浏览apple归档协议卷 gvfsd-archive 挂载各种格式的归档文件 gvfsd-burn 提供刻录 CD 的位置 gvfsd-cdda 挂载音频 CD gvfsd-computer 提供计算机 computer:/// 支持 gvfsd-dav 挂载 DAV 文件系统 gvfsd-dnssd 浏览域名解析 gvfsd-ftp 挂载 FTP 文件系统 gvfsd-gphoto2 通过PTP挂载，这意味着gvfs通过libgphoto2通过 VFS 将相机上的照片显示给GNOME程序 gvfsd-http 通过 HTTP 挂载 gvfsd-localtest 测试后端 gvfsd-mtp 通过 mtp 挂载 gvfsd-network 提供 network:///支持 gvfsd-nfs 提供 nfs 协议支持 gvfsd-recent 提供最近访问支持 gvfsd-sftp 提供sftp支持 gvfsd-smb 提供samba支持 gvfsd-smb-browse 浏览windows共享文件系统的卷 gvfsd-trash 提供回收站支持 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:1:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd 代码模块功能梳理 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd 依赖文件及库分析 # 源码 daemon/main.c daemon/mount.c # 依赖库 gvfsddaemon gvfsd 代码梳理 解析命令行，是否使用 fuse、是否debug、是否仅仅打印版本信息 … 创建gvfs daemon g_vfs_daemon_new (TRUE, \u003creplace\u003e) gvfs_get_socket_dir()创建文件夹 监听 daemon 的 shutdown 信号 session dbus总线上注册，名字为：org.gtk.vfs.Daemon 如果需要 fuse 支持则启动 gvfsd-fuse 进程 session 上 dbus 注册成功就会调用 gboolean mount_init() gvfsd 结束执行 mount_finalize() g_vfs_daemon_new (TRUE, \u003creplace\u003e) g_vfs_daemon_new () 声明与定义位于daemon/gvfsdaemon.[hc]文件里 创建线程: g_thread_pool_new() 初始化互斥锁: g_mutex_init() 挂载数量初始化0、jobs初始化NULL、registered_paths(hash)、client_connections(hash)、session dbus的conn g_dbus_auth_observer_new() allow-mechanism authorize-authenticated-peer gvfs_dbus_daemon_skeleton_new() handle-get-connection handle-cancel handle-list-monitor-implementations gvfs_dbus_mountable_skeleton_new() handle-mount gboolean mount_init () gboolean mount_init ()声明与定义在daemon/mount.[hc]文件里 read_mountable_config () 获取环境变量 GVFS_MOUNTABLE_EXTENSION(默认是.mount文件)、GVFS_MOUNTABLE_DIR 读取 GVFS_MOUNTABLE_DIR 文件名需要有 .mount 后缀，文件夹是：/usr/share/gvfs/mounts/ /sys/fs/cgroup/ 解析 xxx.mount并保存到链表 mountables 全局变量 创建管道 pipe(reload_pipes) (其中 reload_pipes 是全局的static int reload_pipes[2];) 监控管道，当管道有数据读入就会重新执行第一步流程read_mountable_config () 获取SESSION bus 的实例 conn = g_bus_get_sync(SESSION, NULL, NULL) mount_tracker = gvfs_dbus_mount_tracker_skeleton_new () 并分别监听信号(这些信号分别对应相应dbus功能) handle-register-fuse handle-register-mount handle-mount-location handle-lookup-mount handle-lookup-mount-by-fuse-path handle-list-mounts handle-list-mounts2 handle-list-mountable-info handle-list-mount-types handle-unregister-mount g_dbus_interface_skeleton_export(mount_tracker,conn,G_VFS_DBUS_MOUNTTRACKER_PATH,NULL) G_VFS_DBUS_MOUNTTRACKER_PATH 是 /org/gtk/vfs/mounttracker 通过d-feet查看，此dbus提供了一系列接口，主要功能包括：支持的挂载类型、挂载信息、挂载点、通过 fuse 挂载的位置；同时也提供了挂载和卸载信号 gvfs_dbus_mount_tracker_skeleton_new() 一系列dbus对应的操作及一些接口声明 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:2","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"udisks2 gvfs-udisks2-monitor 进程负责磁盘、media、挂载点和fstab在桌面环境挂载、访问。尤其是 gnome-shell 和文件管理器程序 (nautilus)以及其它使用 GLib 的 API 程序。 通常，只会显示可挂载文件系统的测盘或媒体，这些媒体在下边统称为 “设备”。 如果设备挂载点在 /media/、$HOME、/run/media/$USER 之外的文件夹，那么设备可能不会显示在用户界面。或者如果设备挂载点在 /media/、$HOME、/run/media/$USER 这些目录之下，但是挂载点是以 . 开头的，那么也不会显示。这需要使用使用挂载选项 x-gvfs-show 来强制显示，当然 x-gvfs-hide 也可以使挂载点隐藏。 设备的名称、图标、符号图标是根据某些特征选择的，比如：设备的文件系统标签、x-gvfs-name=\u003cvalue\u003e、x-gvfs-icon=\u003cvalue\u003e 和 x-gvfs-symbolic-icon=\u003cvalue\u003e 在 /etc/fstab 添加自动挂载点时候，建议用户使用 /dev/disk 层次结构中稳定的符号连接，而不是内核名称 sda、sdb 等 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"热插拔 通过 eSATA 或 USB 连接的设备在物理机器上是可热插拔的。当物理设备连接到机器上或从机器上移除时候 linux内核 会把通知事件发送到用户空间，系统接受到此类事件并根据其配置对它们进行响应 设备驱动加载后会在 devfs (/dev) 下生成对应的设备节点，如果设备连接后 systemd-udevd 会根据配置对 /dev/ 下的设备节点进行增加 如果是块设备，systemd-udevd 通知 udisksd 和 gvfsd 以及 gvfs-udisks2-volume-monitor ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"一些 fstab 例子 强制在用户界面隐藏设备 /dev/disk/by-id/ata-HITACHI_HTS723232A7A364_E3834563KRG2HN-part1 /home/davidz/Data auto defaults,x-gvfs-hide 0 0 强制在用户界面显示设备(显示名字为 ‘My Movies’) /dev/disk/by-uuid/4CAE8E5B5AF47502 /Movies auto defaults,x-gvfs-show,x-gvfs-name=My%20Movies 0 0 自定义设备图标 /dev/disk/by-uuid/4CAE8E5B5AF47502 /Movies auto defaults,x-gvfs-show,x-gvfs-name=My%20Movies,x-gvfs-icon=folder-videos,x-gvfs-symbolic-icon=folder-videos-symbolic 0 0 强制在用户空间显示 NFS 挂载点 10.200.0.210:/tank/media /mnt/Filer nfs4 default,users,noauto,x-gvfs-show 0 0 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:2","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"一些udev例子 不自动挂载金士顿U盘 SUBSYSTEMS==\"usb\", ENV{ID_VENDOR}==\"*Kingston*\", ENV{ID_MODEL}==\"*DataTraveler*\", ENV{UDISKS_AUTO}=\"0\" 自动挂载某设备但是不要求admin权限 ENV{ID_SERIAL}==\"WDC_WD1002FAEX-00Y9A0_WD-WCAW30039835\", ENV{UDISKS_AUTO}=\"1\", ENV{UDISKS_SYSTEM}=\"0\" 给特殊设备特殊名字和图标 ENV{ID_MEDIA_PLAYER}==\"apple-ipod\", ENV{UDISKS_NAME}=\"David's iPod\", ENV{UDISKS_ICON_NAME}=\"multimedia-player-ipod\", ENV{UDISKS_SYMBOLIC_ICON_NAME}=\"multimedia-player-ipod-symbolic\" 确保此特殊设备不出现在用户界面 ENV{ID_SERIAL}==\"HITACHI_HTS723232A7A364_E3834563KRG2HN\", ENV{UDISKS_IGNORE}=\"1\" ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:3","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux","qemu"],"content":"在Linux宿主机上挂载 qemu 虚拟盘 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:0","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"下载 qemu-nbd 工具 pacman -S qemu 或 apt-get install qemu-utils 或 yum install qemu-img ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:1","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"加载nbd模块并挂载 modprobe nbd max_part=8 qemu-nbd --connect=/dev/nbd0 \u003cxxx.qcow2\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:2","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"开始挂载nbd磁盘到文件系统 mount /dev/nbd0xx \u003c挂载点\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:3","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"卸载nbd qemu-nbd --disconnect /dev/nbd0 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:4","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"将vmware的vmdk虚拟盘转为qemu支持的qcow2虚拟盘 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:0","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"合并vmware虚拟磁盘 如果vmware下虚拟机的磁盘是分块的，比如:xxx-s001.vmdk、xxx-s002.vmdk… 需要先合并为一个vmdk文件 vmware-vdiskmanager.exe -r \u003c虚拟盘的路径\u003e -t 0 \u003c合并后盘的名字\u003e vmware-vdiskmanager.exe 在vmware安装路径下 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:1","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"vmdk转qcow2 在linux下执行(确保执行前安装有qemu环境和工具包) qemu-img convert -f vmdk -O qcow2 \u003cxxx.vmdk\u003e \u003cxxx.qcow2\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:2","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux"],"content":"ARM 简史 ARM公司既不生产芯片也不销售芯片，它只出售芯片技术授权。却做到了在手持设备市场上占有90%以上的份额。 软银在2016年耗资320亿美元拿下ARM，使得本来就大红大紫的ARM公司，再一次窜到了业界人士的面前。ARM这家不生产芯片却也能数钱数到手抽筋的公司到底有着怎样的发展史？ 1978 年诞生 ARM公司既不生产芯片也不销售芯片，它只出售芯片技术授权。却做到了在手持设备市场上占有90%以上的份额。 软银在2016年耗资320亿美元拿下ARM，使得本来就大红大紫的ARM公司，再一次窜到了业界人士的面前。ARM这家不生产芯片却也能数钱数到手抽筋的公司到底有着怎样的发展史？ CPU公司的全称：Cambridge Processor Unit，字面意思是“剑桥处理器单元”。 CPU公司的创始人：奥地利籍物理学博士Hermann Hauser和他的朋友，英国工程师Chris Curry。 不过，CPU公司成立之后，主要从事电子设备设计和制造的业务。他们接到的第一份订单，是制造赌博机的微控制器系统。这个微控制器系统被开发出来后，称之为Acorn System 1。 1979 年公司改名 1979年，这家公司给自己换了个名字——Acorn Computer Ltd。 Acorn是什么意思？橡子。 Acorn Computer Ltd公司的商标里面就有一个橡子。 关于Acorn，还有一个有趣的说法，就是因为他们想在电话黄页里排在Apple（苹果）公司的前面… 在Acorn System 1之后，他们又陆续开发了System 2、3、4，还有面向消费者的盒式计算机 —— Acorn Atom。 1981 年迎来BBC订单 到了1981年，公司迎来了一个难得的机遇 —— 英国广播公司BBC打算在整个英国播放一套提高电脑普及水平的节目，他们希望Acorn能生产一款与之配套的电脑。 这个计划非常宏大，英国政府也参与其中（购机费的一半将由政府资助），电脑一旦采购，将进入英国的每一间教室。 接下这个任务之后，Acorn就开始干了起来。 结果，很快他们就发现，自己产品的硬件设计并不能满足需求。当时，中央处理器的发展潮流，正在从8位变成16位。Acorn并没有合适的芯片可以用。 起初，他们打算使用美国国家半导体和摩托罗拉公司的16位芯片。但是，经过评估后，他们发现了两个缺陷： 芯片的执行速度有点慢，中断的响应时间太长。 售价太贵，一台500英镑的电脑，处理器芯片就占到100英镑。 他们打算去找当时如日中天的英特尔（Intel），希望对方提供一些80286处理器的设计资料和样品。但是，却遭到了拒绝。 备受打击的Acorn公司，一气之下决定自己干，自己造芯片。 当时，Acorn公司的研发人员从美国加州大学伯克利分校找到了一个关于新型处理器的研究——简化指令集，恰好可以满足他们的设计要求。 在此基础上，经过多年的艰苦奋斗，来自剑桥大学的计算机科学家Sophie Wilson和Steve Furber最终完成了微处理器的设计。 对于这块芯片，Acorn给它命名为Acorn RISC Machine。 嗯，这就是大名鼎鼎的“ARM”三个字母的由来。 Acorn是公司名称，Machine是机器，那RISC是什么意思呢？ RISC的全称是\"精简指令集计算机\"（reduced instruction set computer），它支持的指令比较简单，所以功耗小、价格便宜，特别适合移动设备。早期使用ARM芯片的典型设备，就是苹果公司的牛顿PDA。 这里解释一下，到底“简化指令集”有什么意义。 它是相对于“复杂指令集（CISC，complex instruction set computer）”的一个概念。 早期的处理器都是CISC架构（包括英特尔的处理器），随著时间推移，有越来越多的指令集加入。由于当时编译器的技术并不纯熟，程序都会直接以机器码或是组合语言写成，为了减少程序的设计时间，逐渐开发出单一指令，复杂操作的程序代码。设计师只需写下简单的指令，再交给CPU去执行。 但是后来有人发现，整个指令集中，只有约20％的指令常常会被使用到，大约占了整个程序的80％；剩余80％的指令，只占了整个程序的20％。（典型的二八原则） 于是，1979年美国加州大学伯克利分校的David Patterson教授提出了RISC的想法，主张硬件应该专心加速常用的指令，较为复杂的指令则利用常用的指令去组合。 1985年10月，英特尔发布了80386。在80386面前，ARM1就只有被吊打的份了。 intel 80386 32位，27.5万个晶体管，频率为12.5MHz，后提高到33MHz 让ARM直接在性能上和x86系列硬杠，显然是不现实的。ARM有意无意地选择了与Intel不同的设计路线——Intel持续迈向x86高效能设计，ARM则专注于低成本、低功耗的研发方向。 BBC在1981年就提出需求，如果等到1985年ARM1出来，那岂不是黄花菜都凉了？ 所以，在ARM1问世之前，Acorn其实已经提供了解决方案给BBC。 当时，Acorn的电脑，临时采用了MOS 6502处理器（由MOS科技研发的8位微处理器）。 MOS 6502处理器 1982 年推出 BBC Micro计算机 1982 年Acorn计算机公司推出了BBC Micro计算机，这是欧洲第一台畅销的个人计算机。 BBC Micro 1984 BBC Micro 被大量使用 到了 1984 年，大约80%的英国学校都配有这款电脑。Acorn公司彻底在大英帝国老百姓面前刷了一把存在感。 后来，ARM处理器被研发出来之后，用在了BBC Micro的后续型号中。 BBC Micro电脑里面的ARM芯片 1985 年推出 ARM1 芯片 1985 年Acorn与合作伙伴推出了ARM1芯片，以此作为其未来个人计算机的中枢。 在ARM1之后，Acorn陆续推出了好几个系列，例如ARM2，ARM3。 1990 年得到苹果公司投资 1990 年11月27日，Acorn公司正式改组为ARM计算机公司。苹果公司出资150万英镑，芯片厂商VLSI出资25万英镑，Acorn本身则以150万英镑的知识产权和12名工程师入股。 在成立后的那几年，ARM业绩平平，工程师们人心惶惶，害怕随时失业。 在这个情况下，ARM决定改变他们的产品策略——他们不再生产芯片，转而以授权的方式，将芯片设计方案转让给其他公司，即“Partnership”开放模式。 没想到正是这种模式，开创了属于ARM的全新时代。 ARM 32位嵌入式RISC(Reduced lnstruction Set Computer)处理器扩展到世界范围，占据了低功耗、低成本和高性能的嵌入式系统应用领域的领先地位。 ARM所采取的是IP（Intellectual Property，知识产权）授权的商业模式，收取一次性技术授权费用和版税提成。 具体来说，ARM有三种授权方式：处理器、POP以及架构授权。 处理器授权是指授权合作厂商使用ARM设计好的处理器，对方不能改变原有设计，但可以根据自己的需要调整产品的频率、功耗等。 POP（processor optimization pack，处理器优化包）授权是处理器授权的高级形式， ARM出售优化后的处理器给授权合作厂商，方便其在特定工艺下设计、生产出性能有保证的处理器。 架构授权是ARM会授权合作厂商使用自己的架构，方便其根据自己的需要来设计处理器（例如后来高通的Krait架构和苹果的Swift架构，就是在取得ARM的授权后设计完成的）。 所以，授权费和版税就成了ARM的主要收入来源。除此之外，就是软件工具和技术支持服务的收入。 对于半导体公司来说，授权费和版税到底有多少呢？一次性技术授权费用在100万-1000万美元之间，版税提成比例一般在1%-2%之间。 正是ARM的这种授权模式，极大地降低了自身的研发成本和研发风险。它以风险共担、利益共享的模式，形成了一个以ARM为核心的生态圈，使得低成本创新成为可能。 苹果公司投资ARM，是为了保证其Newton手持计算机的芯片供应，这个不切实际的设备以失败而告终。 注意：这里的ARM是公司名称，不是芯片名称。这个ARM的完全拼写也不一样，是Advanced RISC Machines。 前面的芯片名称：Acorn RISC Machine 现在的公司名称：Advanced RISC Machines 1998 年诺基亚基于ARM设计并畅销 1998 年诺基亚基于ARM设计的畅销帮助它成了全世界最大的手机生产商。 1991 年ARM将产品授权给英国GEC Plessey半导体公司 1993 年ARM将产品授权给Cirrus Logic和德州仪器（Texas Instruments，TI） 与德州仪器的合作，给ARM公司带来了重要的突破。而且，也给ARM公司树立了声誉，证实了授权模式的可行性。 此后，越来越多的公司参与到这种授权模式中，与ARM建立了合作关系。其中就包括三星、夏普等公司。 在此基础上，ARM坚定了授权模式的决心，并着手设计更多性价比高的产品。 1993年，苹果公司推出了一款新型掌上电脑产品——Newton。ARM公司开发的ARM6芯片被用于该产品之中。 Apple Newton Message Pad 现在被认为是PDA和智能手机的鼻祖 但是很遗憾，因为Newton技术过于超前，加上一些用户体验上的缺陷，所以未能被市场接受，后来以失败告终。 但ARM积累了经验，继续改良技术。没过多久，ARM迎来了自己的黄金机遇——","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:1:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"硬件相关概念 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"电平 在数字电路中，分为高电平和低电平，分别用1和0表示。一个数字电路的管脚，总是存在一个电平的，要么高要么低，或者说要么1要到0(其实还有一种，高阻) ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:1","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"总线 在嵌入式系统中一定会有一块处理器芯片，此外，还有其它的芯片作为外部设备（后面简称外设），这些芯片与处理器协作实现产品的功能。复杂的产品往往是由大量的芯片组成的。那么不可避免的是我们需要将所有的外设与处理器进行相连，最为简单的是将所有的外设都采用独立（注意是独立）的信号线连接至处理器，这样的好处是容易理解，但问题是：不可行。 因为处理器芯片需要引出太多的线了，从芯片的生产和产品的生产角度来看都不实际。加之，处理器（在此我们假设处理器是单核的，而不是多核的）处理事务在微观上是串行的，也就是说在某一时刻如果要对外设进行读写操作，那只可能是对大量外设中的一个进行，即多个外设不可能在微观上被处理器同时访问。需要注意的是，这里提出了微观这一概念，这是为了区别于宏观。 从宏观上来讲，一个处理器中可以有多个任务同时运行，但这些任务在微观上却是一个一个运行的（后面会用串行来描述这里所说的“一个一个”），多任务的串行运行实现是由操作系统扮演着重要的角色来实现的。回到我们的话题，即然将每个外设采用独立的信号线连到处理器不可行，且处理器在单一时间内只会对一个外设进行访问，那我们能不能采用共享的信号线将所有的芯片连在一起呢？这就是总线概念的由来。 通俗的说，如果我们周围有十个家庭，为了让这十个家庭每两个之间都能往来，我们并不需要为每两个家庭修一条单独（注意是单独）的路（如果这样，要修45条路），而是可以修一条大路，然后，每个家都与大路相连。 对于总线，我们往往说总线是处理器的，而其它的外设是挂在总线上的。那有一个问题，我们每一时间只能访问挂在总线上的一个外设，那如何区分这些外设呢？和我们的路一样，我们需要用地址来区分每一个家庭，在总线上，也是采用地址来进行区分的。这样，总线就根据其功能分为两类了。一类是地址总线，这一总线上的数据只会是从处理器向外设“流”，是单向的。 另一类则是数据总线，用来将数据从处理器传送到外设（从处理器的角度来说是写操作）或者是将数据从外设传送到处理器（从处理器的角度来说是读操作），显然，数据总线是双向的。也就是说，在我们的嵌入式系统中同时存在地址总线和数据总线将所有需要与处理器进行通讯的芯片连在一起的。 总线是有宽度的，正如我们的路分为“三车道”或是“四车道”，我们说32位处理器，是指其数据总线宽度是32位，也就是“有32辆车能同时跑”，显然，宽度越是宽我们的处理器速度就越是快，因为我们从外设芯片存取数据的速度会更快，这就是为什么我们的计算机向64位发展的原因。同样的，地址总线也是有宽度的，对于32位处理器其最大宽度也就是32位。 总线的概念有了，那接下来的一个问题是，即使是每一个外设都有一个地址，那这一地址记在哪里呢？是放在外设芯片上吗？如果这样的话，那就有一个问题，每一类外设的地址必须是不能重叠的，而当一个产品中需要两块一样的芯片的话，两块芯片的地址就无法区分了，看来这样操作存在问题。还有，如果这样的话每一个外设也得与（比如，32根）数据总线完全相连，并监听数据线以了解处理器是不是在“叫”自己，这样很是复杂。 此外，地址也有可能因为外设种类的增多而用光。总的来说地址不能存放在外设芯片，那如何让外设知道，此时它是被处理器招换从而需要进行读写访问的呢？答案就是芯片的片选（CS， chip select）信号，或者又叫使能（ENable）信号。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:2","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"片选(CS或EN) 片选信号对于外设芯片来讲，就是一个（也是一根）通知信号，告诉芯片“嘿，请开门，我要放些东西进来，或是拿些东西走”，这里的东西只能是数据，不可能是玉米棒什么的。那有个问题，这个信号源从哪里来呢？显然，只能从处理器来。那是不是也是像总线那样，每一个芯片都共用一根线连在一起呢？如果这样，可能处理器“一叫开门”所有的芯片都将“门”打开了。如果是处理器写数据，那可能所有的芯片都被写入同样的数据。 而取数据时，每个外设芯片都向外“扔”数据，这一定会造成数据总线冲突，因为有的芯片向总线上“扔”1，有的则“扔”0，这种情况下处理器一定会“发疯”的，因为它不知道应当得到1还是0。 既然这样，显然不能将所有的片选信号连在一起了，只能是各芯片的片选信号独立。前面提到了地址总线，我们是采用一根地址线连一个外设芯片呢？还是采用其它的方法。如果采用一根地址线连一个外设芯片，那可能最多只能挂接32个芯片了，这显然不行。其实，在现实中，是采用32位的数字来表示一个外设芯片的地址的，比如1可以表示芯片A，而6534可以表示另外一个芯片B， 等等。由此看来，理论上我们可以表示2的32次方（4294967296）个设备，之所以说理论上，是因为有的设备要占用大量的地址。即然这样，那还有一个问题，如果将32位的地址总线转换成芯片的一根片选信号呢？这需要引入译码（器）的概念。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:3","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"译码器 译码器将一个数据转换成一根信号线上的信号，比如3/8译码器，可以将一个位宽是3位的数据转换成8根（2的3次方）完全独立的信号线，当向数据侧写入二进制的011时，对应的是8根线的第3根，当输入二进制的111时，对应的是8根线中的最后一根。有了译码器，处理器的地址线就简化了，只要32根地址线加上外面的译码器，就可以访问大量的外设芯片了。外部设备的选择问题，我们已经解决了，现在还得回头看一看数据总线。 3/8译码器 在嵌入式系统中，所有芯片的数据总线可以理解成是直接相连的。之所以用了“可以理解”一词，是因为为了提高总线的负载能力，其中会加入总线驱动器。为了理解，我们看一看我们生活中的自来水，比如，在北京理论上可能所有的水管是连在一起的，但中间可能为了提高水压，存在很多小的水站用来增加供水压力，而不可能全北京所有的自来水自接来自一个水厂。 既然所有的数据总线是连在一起的，那就可能会有问题。当向外部设备写数据时，处理器先向地址总线输送目标外设的地址，地址译码器将其转换成一根信号的片选信号送到了目标外设，目标外设收到这一信号后，将“门”打开。接下来处理器将要传送到外设的数据往数据总线上一放，由于只有目标外设芯片打开了“门”，所以数据只会进入到目标外设，而其它的外设什么也不会收到。 很好！处理器向外写数据应当没有问题，我们接下来看一看读。读的话，由于数据是从外设输送到处理器的，尽管我们采用和写一样的方法打开目标外设的“门”，但此时，其它的外设也在数据总线上，它们有可能处于1也可能处于0，是不是会影响处理器读取目标外设的数据呢？结果当然不会，但我们得引入另一个概念：高阻态。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:4","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"高阻态 很显然，当处理器从目标外设读数据时，我们希望其它没有被选上的芯片的数据总线不会对目标外设所要传送的数据有影响，那怎么办呢？实际上，当芯片没有被选中时，其数据总线都处于高阻态。所谓的高阻态，我们可以理解成这一管脚在外设芯片内部是断开的，如此一来，显然不会对处理器从目标外设读取数据造成任何的影响了。 我们说当一个芯片没有被选中或是没有被使能时，其数据总线一定是处于高阻态的。前面用了“门”的开和关来打比方，那“门”是指什么呢？是指外设的数据总线，片选信号的作用就是控制将外设的数据总线与处理器的数据总线相连或是断开。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:5","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"驱动 总线上的数据是谁放上去的我们就说谁是那一时刻的驱动者。也就是说，当处理器向外设写数据时，它是在驱动数据总线的，而当处理器从目标外设读取数据时，目标外设是在驱动数据总线的。对于地址总线，因为只可能从处理器向目标外设写，所以地址总线永远是由处理器驱动的。当一个芯片没有被选中时，我们说它并不驱动数据总线。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:6","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"三态门 前面我们说到外设芯片的数据总线在没有被选中时其处于高阻态，当被选中时，其电平可能是高（1）或是低（0）。如此一来，我们说外设的数据总线其芯片管脚是属于三态门的，即存在高电平、低电平和高阻态，三个状态。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:7","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"电平特效 前面我们了解了什么是片选信号，也讲到了三态门，需要指出的是片选信号通常不是三态门，其只存在两个状态，即高电平或是低电平。前面我们也说了，片选信号是用来“开门”的，而片选信号又有高和低电平，那到底是高电平表示“开门”呢？还是低电平？对于这一问题，我们称如果一个电平对于一个片选信号表示“开门”那么它就是这一信号的有效电平。 比如，对于一个片选信号，如果低电平表示“开门”，那么我们说这个片选信号是低电平有效的。虽然，在这里我们用片选信号来解释电平的有效性，但是很多信号都存在有效性的问题，比如，后面我们将要谈的读信号和写信号都存在有效性问题。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:8","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"时序 在前面我们说到当处理器要向外设芯片写数据时，需要先将所需访问的外设的地址放在地址总线上，然后，由译码器将地址总线上的数据转换成片选信号，片选信号则使能目标外设芯片，接下来处理器写数据到数据总线上，从而完成一个写操作。显然，在处理器将数据写到数据总线之前地址线上的数据必须一直保留一段时间，否则的话译码器不能长时间的使片选信号有效。 当完成了数据的写操作后，处理器就不需要保证地址总线上的地址有效了。我们可以看出，这一系列的操作都有一定严格的时间顺序的，这称之为时序。时序描述了处理器与外部设备的交互信号 “规程”，大家只有按照这一“规程”来操作，才能保证处理器与外部设备之间能正常的通讯。 这好比，我们的道路上的红绿灯，如果我们行人和车辆不按照其指示来通行的话，就会出现事故。通常，采用时序图来描述芯片之间通讯的信号“规程”。 读时序图 读时序图 从图中我们可以看出ADDRESS是表示地址总线的，DQ是表示数据总线的,CE是片选信号，且是低电平有效，其宽度要保证在进行读操作时总是有效的。学会看时序图对于做嵌入式系统开发非常有帮助，因为我们不可避免的要与芯片打交道。在时序图中，通常会标识很多的时间需求信息。 在写启动代码时需要初始化各地址空间的片选地址寄存器和读写时序，时序的配置依据就是来自于外设芯片的时间需求，这是芯片手册很重要的一部分内容。当一个地址空间中存在多个外设芯片时，我们需要考虑到其中最慢的外设芯片的时间需求，否则的话有的芯片就不能正常工作。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:9","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"读信号 当处理器需要从外设芯片读取信号时，除了需要产生片选信号外，还需要告诉外设芯片这是一个读操作，而不是一个写操作，这是通过读信号来实现的。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:10","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"写信号 前面讲了读信号，我想对于写信号也就不难理解了，这个信号用于告诉外设芯片，这是一个向外设芯片写数据的操作。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:11","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"I/O端口 前面提到了外设（芯片）)，现在是对外设进行分类的时候了。大体上外设分为两类，一类是存储器外设，而另一类是非存储器外设，后者常被称之为I/O设备，这里的I/O是Input/Output的简写，即输入、输出。可见，I/O外设是一个非常宽泛的概念。对于存储器外设，其特点是，它所占用的空间是连续的一片。比如，SDRAM内存就是属于存储器外设，如果其容量是8M字节，那么其占用的地址空间也会是8M的。 与存储器外设所不同的是，I/O外设所点用的地址一般都很少。比如一个I/O外设可能存在多个控制寄存器，这些控制寄存器从处理器来看就是多个I/O端口（地址），向这个地址写数据就是向外设所对应的寄存器写数据，反之，也可以是读。 比如，一个串口芯片可能存在多个寄存器，一个用来查询芯片的状态，一个用来设置芯片的功能，另一个用来读取芯片从串口线所收到的数据，最后，还有一个用来向芯片写数据以向串口线上发送数据。对于这一串口芯片的寄存器，从处理器的角度来看，都是独立的I/O端口。 I/O端口存在读、写性问题，有的端口是只读的，有的端口是只写的，还有的端口是即可读也可写，其读写性是由外设芯片的寄存器所决定的，在芯片的数据手册中能找到。需要指出的是，有些存储器外设也存在I/O端口，以对其进行一定的控制。从I/O端口这一名字来看，对于处理器来说，就是对从外面读入数据或是向外面输出数据的一个接口总称。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:12","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"中断 中断从硬件的角度来看就是一个能产生高、低电平的一根信号线，但理解它需要从处理器的角度出发。我们说过了，处理器从微观上看，所做的工作是按顺序进行的，其对程序的处理只能是一条指令一条指令的执行。如果存在需要对外设芯片进行访问，而有可能从处理器发出读、写命令后，由于外设通常比处理器慢很多，所以外设芯片需要一些时间来准备好所需的数据。 在这种情况下，如果处理器一直等外设芯片的返回数据再执行后续的指令的话，将耗费宝贵的时间，这些时间完全可以用来做其它的工作。别忘了，从宏观上看来处理器常常是多任务的，任务是指操作系统所提供的调度单位。当一个任务因为等待外设芯片的数据而阻塞时，我们可以切换到另外的任务，从而提高处理效率。 这就有一个问题，当处理器去处理另一个任务时，如果外设芯片的数据好了的话，如果告诉处理器呢？对了！就是通过中断信号。中断信号的高、低电平可以用来表示是否有中断需要处理器注意以处理特定的事件（比如，外设数据准备好了的事件）。 由此看来，中断的引入能大大的提高处理器的运用效率。为了使用处理器上的中断，一开始我们需要初始化好处理器的中断控制器，比如安装好所需的中断服务程序或称之为ISR（Interrupt Service Routine），然后，打开中断屏蔽位。中断服务程序中需要做如下的操作： 从外设读入或向外设写数据。读还是写通常需要读取外设的中断状态寄存器来决定。 清除外设的中断信号。我们知道，中断信号是由外设芯片驱动的，为了告诉外设芯片，处理器已经处理完了所需做的工作，那么处理器需要通过一定的方式通知外设芯片。这种方式就是向外设芯片的寄存器中的某一位写入一个数据，比如，可能是写入1表示清中断，也可能是写入0表示清中断，这通常在外设的数据手册中能查到。 当外设收到了处理器的清中断请求后，其就会驱动中断线使其无效。比如，一个外设的中断线是当其为低电平表示有中断，将其从低电平变为高电平就是驱动为无效。 清除处理器的中断信号标识。处理器中往往也会保存外部中断信号是否发生过，当我们处理完了外设芯片的中断时，我们也需要清除处理器上的标识，从而为下一次中断做准备。需要注意的是，清外设的中断必须发生在请处理器中断标识之前！ 中断还存在一个触发方式问题。有两种触发方式 ，一种是电平触发，另一种是沿触发。电平触发是指电平的高低表示外设是否有中断，而沿触发则是能过中断线上的电平的升或降来表示的，显然，存在两种沿触发方式。 一种是中断线从低电平变为高电平，我们称之为上升沿触发，另一处是中断线从高电平转换为低电平，我们称之为下降沿触发。总的来说中断的触发方式有电平触发、上升沿触发和下降沿触发。电平触发方式中处理中中断设置很重要的一个步骤。 ROM ROM(Read Only Memory)和RAM(Random Access Memory)指的都是半导体存储器，ROM在系统停止供电的时候仍然可以保持数据，而RAM通常是在掉电之后就丢失数据，典型的RAM就是计算机的内存。 ROM有很多种，PROM是可编程的ROM，它和EPROM(可擦除可编程ROM)的区别是，PROM是一次性的，也就是软件灌入后，就无法修改了，这是早期的产品，现在已经不再使用，而EPROM是通过紫外光的照射擦出原先的程序的一种通用存储器。另外一种EEPROM是通过电子擦除，价格很高，写入时间很长，写入慢。 举个例子，手机软件一般放在EEPROM中，我们打电话，有些最后拨打的号码，暂时存在SRAM中，不是马上写入通话记录(通话记录保存在EEPROM中)，因为当时有很重要工作(通话)要做，如果写入，漫长的等待用户无法忍受。 RAM RAM有两大类，一种称为静态RAM(Static RAM/SRAM)，SRAM速度非常快，是目前读写最快的存储设备了，它也非常昂贵，所以只在要求很苛刻的地方使用，譬如CPU的一级缓冲，二级缓冲。 另一种称为动态RAM(Dynamic RAM/DRAM)，DRAM保留数据的时间很短，速度也比SRAM慢，不过它还是比任何的ROM都要快，但从价格上来说DRAM相比SRAM要便宜很多，计算机内存就是DRAM的。 DRAM DRAM分为很多种，常见的主要有FPRAM/FastPage、EDORAM、SDRAM、DDR RAM、RDRAM、SGRAM以及WRAM等，这里介绍其中的一种DDR RAM。 DDR RAM DDR RAM(Date-Rate RAM)也称作DDR SDRAM，这种改进型的RAM和SDRAM是基本一样的，不同之处在于它可以在一个时钟读写两次数据，这样就使得数据传输速度加倍了。 这是目前电脑中用得最多的内存，而且它有着成本优势，击败了Intel的另外一种内存标准-Rambus DRAM。在很多高端的显卡上，也配备了高速DDR RAM来提高带宽，这可以大幅度提高3D加速卡的像素渲染能力。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:13","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"内存原理解析 内存是用来存放当前正在使用的(即执行中)的数据和程序，我们平常所提到的计算机的内存指的是动态内存(即DRAM)，动态内存中所谓的“动态”，指的是当我们将数据写入DRAM后，经过一段时间，数据会丢失，因此需要一个额外设电路进行内存刷新操作。 具体的工作过程是这样的：一个DRAM的存储单元存储的是0还是1取决于电容是否有电荷，有电荷代表1，无电荷代表0。但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，这就是数据丢失的原因; 刷新操作定期对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电; 若电量小于1/2，则认为其代表0，并把电容放电，藉此来保持数据的连续性。 NAND Flash和NOR Flash的比较 常用的Flash类型有：NOR Flash和NAND Flash两种。NOR Flash由Intel公司在1988年发明，以替代当时在市场上占据主要地位的EPROM和EEPROM。NANDFlash由Toshiba公司在1989年发明。两者的主要差别如下表所示。 NOR Flash支持XIP，即代码可以直接在NOR Flash上执行，无需拷贝到内存中。这是由于NOR Flash的接口与RAM完全相同，可以随机访问任意地址的数据。在NOR Flash上进行读操作的效率非常高，但是擦除和写操作的效率很低；另外，NOR Flash的容量一般比较小。 NAND Flash进行擦除和写操作的效率更高，并且容量更大。一般而言，NOR Flash用于存储程序，NAND Flash用于存储数据。基于NAND Flash的设备通常也要搭配NOR Flash以存储程序。 Flash存储器件由擦除单元(也称为块)组成，当要写某个块时，需要确保这个块已经被擦除。NOR Flash的块大小范围为64KB～128KB；NAND Flash的块大小范围为8KB～64KB，擦/写一个NOR Flash块需4S，而擦/写一个NAND Flash块仅需2ms。 NOR Flash的块太大，不仅增加了擦写时间，对于给定的写操作，NOR Flash也需要更多的擦除操作——特别是小文件，比如一个文件只有1KB，但是为了保存它却需要擦除大小为64KB～128KB的NOR Flash块。 NOR Flash的接口与RAM完全相同，可以随意访问任意地址的数据。而NAND Flash的接口仅仅包含几个I/O引脚，需要串行地访问。NAND Flash一般以512字节为单位进行读写。这使得NOR Flash适合于运行程序，而NAND Flash更适合于存储数据。 容量相同的情况下，NAND Flash的体积更小，对于空间有严格要求的系统，NAND Flash可以节省更多空间。市场上NOR Flash的容量通常为1~4MB(也有32MB的NOR Flash)，NANDFlash的容量为8~512MB。容量的差别也使得NOR Flash多用于存储程序，NAND Flash多用于存储数据。 对于Flash存储器件的可靠性需要考虑3点：位反转、坏块和可擦除次数。所有Flash器件都遭遇位反转的问题：由于FLASH固有的电器特性，在读写数据过程中，偶然会产生一位或几位数据错误——这种概率很低，而NAND Flash出现的概率远大于NOR Flash。当位反转发生在关键的代码、数据上时，有可能导致系统崩溃。 当仅仅是报告位反转，重新读取即可；如果确实发生了位反转，则必须有相应的错误检测/恢复措施。在NAND Flash上发生位反转的概率更高，推荐使用EDC/ECC进行错误检测和恢复。 NAND Flash上面会有坏块随机分布，在使用前需要将坏块扫描出来，确保不再使用它们，否则会使产品含有严重的故障。NAND Flash每块的可擦除次数通常在100000次左右，是NOR Flash的10倍。另外，因为NAND Flash的块大小通常是NOR Flash的1/8，所以NAND Flash的寿命远远超过NOR Flash。 linux对NOR、NAND Flash的软件支持都很成熟。在NOR Flash上常用jffs2文件系统，而在NAND Flash上常用yaffs文件系统。在更底层，有MTD驱动程序实现对它们的读、写、擦除操作，它也实现了EDC/ECC校验。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:14","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"工具 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"万用表 万用表通常是用来查看电平的高低、电阻的大小等的，是常用且必不可少的工具之一。在嵌入式系统开发中，我们常用的是数字万用表。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:1","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"示波器 在嵌入式系统开发中，我们不可避免的要与外设芯片打交道。调试驱动程序时，除了需要完全看明白芯片的数据手册，且在软件高度的过程中，还需要看我们所期望的信号电平是否发生在芯片上。比如，我们在写驱动程序时，需要通过写I/O端口来对外设芯片进行操作，当写相应的I/O端口时，我们知道所对应芯片的片选信号应当有效，有时，我们需要验证是否按预期发生了，这就需要用到示波器。 一般的示波器是能同时观测两个信号线的信号状态的。示波器都提供一定的功能，比如设置信号扑捉的方式等等。示波器很重要的一个参数据是其采集频率，根据Nyquist采集定理，如果我们想用示波器查看频率是100M赫兹的信号，那么其采样频率必须至少是其两倍，即200M赫兹。有人可能会问：为什么不用万用表来看呢？因为万用表的采集频率很底，无法采集到很快的信号变化。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:2","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"逻辑分析仪 简单的说逻辑分析器就是具有很多信号通道的示波器。通过逻辑分析仪，我们可以看到地址总线和数据总线上的数据。逻辑分析仪都提供一定的编程能力，用于编程什么时候开始对总线上的数据进行采集。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:3","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"环境搭建目标 pc 可以通过 串口 连接到 开发板，并能查看输出日志 pc 可以通过 ssh 连接到 开发板。开发板默认登录用户名: root，无密码 在 pc 上配置好 arm 交叉编译工具链 准备好常用的源码: uboot源码、linux源码、buildroot源码 我使用 manjaro 作为开发环境；使用 imx6ull pro 作为运行/学习环境，开发板下载的工具里没有linux平台的，因此需要从下载资料的 ubuntu 虚拟机里提取。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发板展示 各标号硬件含义 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发板启动方式（上图表号16对应状态） boot sw1(lcd_data5) sw2(lcd_data11) sw3(boot_mode0) sw4(boot_mode1) emmc OFF OFF ON OFF sd ON ON ON OFF usb X X OFF ON 注意：当设为 USB 启动时候，不能插上SD卡、TF卡；上电之后才可以插卡。刚出厂的板子在 emmc 上烧写了系统，开发板启动方式需要设置为 emmc 启动。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"第一次启动开发板 设置开发板的打开方式为 emmc，打开电源开关 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"接串口 下载 linux 串口驱动程序 https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers 并编译之后在源码目录执行insmod ./xxx.ko，插入编译生成的内核模块(xxx.ko文件) 连接开发板电源线并打开开关，插拔 usb 线观察 /dev/ 下设备变化，发现插入 usb 后会多出 ttyUSB0 这一设备 执行 pacman -S minicom 下载 minicom 打开串口 minicom -D /dev/ttyUSB0 然后重启开发板(直接断点和上电)，后续就可以通过 minicom 看到串口日志了（需要开发板默认打开串口输出） ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"ssh 连接到开发板 给开发板联网并重启，在系统选项里设置网络(ip、子网掩码、网关)并用 PC ssh 连接上去 接上串口，用 minicom 来观察日志输出 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:4","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"搭建环境 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"下载开相关源码及工具 百度网盘下载,提取码:root ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"配置 arm gcc 交叉编译环境(使用imx6ull资料配置) 解压缩 ubuntu 的虚拟机文件（如果压缩文件是多个，需要都选中然后解压） 查看解压后的文件有几个 *.vmdk 文件，如果是多个则需要使用 vdiskmanager 合并为一个 使用 qemu-img 把 xxx.vmdk 文件转为 qemu 支持的 qcow2 文件 我的 linux 工作机用 qemu 而不是 vmware 挂载转换后的文件系统 使用mount挂载虚拟硬盘的家目录，大概是 /dev/nb0p4 挂载后可以通过 ls 命令看到book文件夹，这就是家目录，然后把文件 100ask_imx6ull-sdk 复制出来，在这个文件夹的ToolChain目录下有需要的arm编译链，具体目录是 100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot 配置环境变量，修改 ~/.bashrc 添加如下配置: export ARCH=arm export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- PATH=\u003carm交叉编译根目录\u003e/bin:${PATH} export PATH=$(echo ${PATH} | sed 's/:/\\n/g' | sort | uniq | tr -s '\\n' ':' | sed 's/:$//g') 配置好后重新打开终端或执行source ~/.bashrc 之后打开终端，运行 arm-buildroot-linux-gnueabihf-gcc -v，查看是否有如下信息输出(如果没有，重新执行这一步): Using built-in specs. COLLECT_GCC=/data/environment/gcc-arm/bin/arm-buildroot-linux-gnueabihf-gcc.br_real COLLECT_LTO_WRAPPER=/data/environment/gcc-arm/bin/../libexec/gcc/arm-buildroot-linux-gnueabihf/7.5.0/lto-wrapper Target: arm-buildroot-linux-gnueabihf Configured with: ./configure --prefix=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --sysconfdir=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/etc --enable-static --target=arm-buildroot-linux-gnueabihf --with-sysroot=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/arm-buildroot-linux-gnueabihf/sysroot --enable-__cxa_atexit --with-gnu-ld --disable-libssp --disable-multilib --disable-decimal-float --with-gmp=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-mpc=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-mpfr=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-pkgversion='Buildroot 2020.02-gee85cab' --with-bugurl=http://bugs.buildroot.net/ --disable-libquadmath --enable-tls --enable-plugins --enable-lto --enable-threads --with-isl=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-abi=aapcs-linux --with-cpu=cortex-a7 --with-fpu=neon-vfpv4 --with-float=hard --with-mode=arm --enable-languages=c,c++,fortran --with-build-time-tools=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/arm-buildroot-linux-gnueabihf/bin --enable-shared --enable-libgomp Thread model: posix gcc version 7.5.0 (Buildroot 2020.02-gee85cab) 上述2、3、4步相关教程可以查看qcow2虚拟分区挂载 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"配置arm gcc交叉编译环境(这个留备后续使用，不需要配置) arm 交叉编译工具下载地址: arm 交叉编译工具下载地址，或者复制到浏览器下载(这个包宿主机是x86，目标代码编译成arm的): https://armkeil.blob.core.windows.net/developer/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-arm-none-linux-gnueabihf.tar.xz 下载并解压之后放置指定目录并改名为 gcc-arm，比如: /data/envrionment/gcc-arm/ 配置环境变量，编辑 ~/.bashrc，在末尾加入如下代码: export ARCH=arm export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- PATH=\u003carm交叉编译根目录\u003e/bin:${PATH} export PATH=$(echo ${PATH} | sed 's/:/\\n/g' | sort | uniq | tr -s '\\n' ':' | sed 's/:$//g') 配置好后重新打开终端或执行source ~/.bashrc 之后打开终端，运行 arm-none-linux-gnueabihf-gcc -v，查看是否有如下信息输出(如果没有，重新执行这一步): Using built-in specs. COLLECT_GCC=arm-none-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER=/data/environment/gcc-arm/bin/../libexec/gcc/arm-none-linux-gnueabihf/11.2.1/lto-wrapper Target: arm-none-linux-gnueabihf Configured with: /data/jenkins/workspace/GNU-toolchain/arm-11/src/gcc/configure --target=arm-none-linux-gnueabihf --prefix= --with-sysroot=/arm-none-linux-gnueabihf/libc --with-build-sysroot=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/install//arm-none-linux-gnueabihf/libc --with-bugurl=https://bugs.linaro.org/ --enable-gnu-indirect-function --enable-shared --disable-libssp --disable-libmudflap --enable-checking=release --enable-languages=c,c++,fortran --with-gmp=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-mpfr=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-mpc=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-isl=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-arch=armv7-a --with-fpu=neon --with-float=hard --with-mode=thumb --with-arch=armv7-a --with-pkgversion='GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)' Thread model: posix Supported LTO compression algorithms: zlib gcc version 11.2.1 20220111 (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 这里需要注意的是，如果下载的 arm 编译工具链与开发板文件系统的编译工具链 gcc 不一致，则会导致在 pc 上用跨平台编译工具链编译出来的程序无法在 arm 开发板上运行。解决办法：1. 重新编译开发板根文件系统、内核并烧写；2. 使用官方提供的交叉编译工具链 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"安装 make 项目管理命令 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:4","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"cortexA7 烧写工具 imx6ull 官方烧写工具是 mfgtools 操作简单，一键烧写整个镜像\u003c用这个就可以\u003e nxp 提供的 uuu (Universal Update Utility) 又名 mfgtools 3.0 这块具体使用后续会有介绍 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:5","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"4. mkimage 工具 这一工具来源于 u-boot，用来给一个 bin 文件添加头部信息，芯片固件需要根据头部信息把 bin 文件放到内存中去执行 执行 pacman -S u-boot 命令后，再次执行 mkimage -h 查看是否正确安装: mkimage: invalid option -- 'h' Error: Invalid option Usage: mkimage -l image -l ==\u003e list image header information mkimage [-x] -A arch -O os -T type -C comp -a addr -e ep -n name -d data_file[:data_file...] image -A ==\u003e set architecture to 'arch' -O ==\u003e set operating system to 'os' -T ==\u003e set image type to 'type' -C ==\u003e set compression type 'comp' -a ==\u003e set load address to 'addr' (hex) -e ==\u003e set entry point to 'ep' (hex) -n ==\u003e set image name to 'name' -d ==\u003e use image data from 'datafile' -x ==\u003e set XIP (execute in place) mkimage [-D dtc_options] [-f fit-image.its|-f auto|-F] [-b \u003cdtb\u003e [-b \u003cdtb\u003e]] [-E] [-B size] [-i \u003cramdisk.cpio.gz\u003e] fit-image \u003cdtb\u003e file is used with -f auto, it may occur multiple times. -D =\u003e set all options for device tree compiler -f =\u003e input filename for FIT source -i =\u003e input filename for ramdisk file -E =\u003e place data outside of the FIT structure -B =\u003e align size in hex for FIT structure and header Signing / verified boot options: [-k keydir] [-K dtb] [ -c \u003ccomment\u003e] [-p addr] [-r] [-N engine] -k =\u003e set directory containing private keys -K =\u003e write public keys to this .dtb file -G =\u003e use this signing key (in lieu of -k) -c =\u003e add comment in signature node -F =\u003e re-sign existing FIT image -p =\u003e place external data at a static position -r =\u003e mark keys used as 'required' in dtb -N =\u003e openssl engine to use for signing mkimage -V ==\u003e print version information and exit Use '-T list' to see a list of available image types ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:6","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"最后来一个例子 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"在开发机上编写一个例子 #include \u003cstdio.h\u003e int main (int argc, char* argv[]) { printf (\"Hello World!\\n\"); return 0; } ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发机上的Makefile CC = arm-buildroot-linux-gnueabihf-gcc CUR_DIR = $(shell pwd) SRC = $(strip $(subst $(CUR_DIR), ., $(wildcard $(CUR_DIR)/*.c))) TARGET = $(strip $(patsubst %.c, %.run, $(SRC))) all:${TARGET} %.run:%.c ${CC} -o $@ $\u003c clean: rm -f *.run rm -f *.o ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"编译 分别保存上述代码为 hello-world.c、makefile脚本为 Makefile，两个文件放在同级目录，执行 make 会在当前目录下生成 hello-world.run，使用 scp ./hello-world.run root@\u003c开发机ip\u003e:~ 把编译好的二进制文件传输到开发机，最后使用 ssh 登录到开发机上家目录执行 ./hello-world.run 即可看到输出结果。 至此，开发环境和开发板打通。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]