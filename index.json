[{"categories":["qemu"],"content":"虚拟化简介 ","date":"2023-04-13","objectID":"/2023/04/0002-qemu%E4%B8%8Ekvm/:1:0","tags":["qemu","kvm","linux"],"title":"Qemu与KVM","uri":"/2023/04/0002-qemu%E4%B8%8Ekvm/"},{"categories":["qemu"],"content":"虚拟化思想 虚拟化的主要思想是，通过分层将底层的复杂、难用的资源虚拟抽象成简单、易用的资源，提供给上层使用。 底层资源或者通过空间的分割、或者通过时间的分割，将下层资源通过一种简单易用的方式转换成另一种资源，提供给上层使用。 ","date":"2023-04-13","objectID":"/2023/04/0002-qemu%E4%B8%8Ekvm/:1:1","tags":["qemu","kvm","linux"],"title":"Qemu与KVM","uri":"/2023/04/0002-qemu%E4%B8%8Ekvm/"},{"categories":["qemu"],"content":"虚拟机简介 虚拟机就是提供一个完成用户指定任务的环境。 模拟器是另一种形式的虚拟机，典型的模拟器有 QEMU、Bochs。 模拟器实现两种方式： 对源程序指令一条条分析、然后执行指令对应的操作 通过二进制翻译实现，即先将程序中所有的源ISA指令翻译成目标ISA上具有同样功能的指令，然后在目标ISA上执行 ","date":"2023-04-13","objectID":"/2023/04/0002-qemu%E4%B8%8Ekvm/:1:2","tags":["qemu","kvm","linux"],"title":"Qemu与KVM","uri":"/2023/04/0002-qemu%E4%B8%8Ekvm/"},{"categories":["qemu"],"content":"系统虚拟化的历史 早期计算机不支持硬件层面的虚拟机，整个虚拟过程在应用层实现 后来CPU硬件层面开始支持虚拟化(x86在2005年开始支持)，2006年以色列Qumranet利用硬件虚拟化技术在Linux内核上开发了KVM。 目前，QEMU已经不仅仅作为一个模拟器了，而是作为以 QEMU-KVM 为基础的为云计算服务的系统虚拟化软件。 ","date":"2023-04-13","objectID":"/2023/04/0002-qemu%E4%B8%8Ekvm/:1:3","tags":["qemu","kvm","linux"],"title":"Qemu与KVM","uri":"/2023/04/0002-qemu%E4%B8%8Ekvm/"},{"categories":["qemu"],"content":"例子 ","date":"2023-04-13","objectID":"/2023/04/0002-qemu%E4%B8%8Ekvm/:2:0","tags":["qemu","kvm","linux"],"title":"Qemu与KVM","uri":"/2023/04/0002-qemu%E4%B8%8Ekvm/"},{"categories":["qemu"],"content":"程序 start: mov $0x48,%al outb %al,$0xf1 mov $0x65,%al outb %al,$0xf1 mov $0x6c,%al outb %al,$0xf1 mov $0x6f,%al outb %al,$0xf1 mov $0x0a,%al outb %al,$0xf1 hlt ","date":"2023-04-13","objectID":"/2023/04/0002-qemu%E4%B8%8Ekvm/:2:1","tags":["qemu","kvm","linux"],"title":"Qemu与KVM","uri":"/2023/04/0002-qemu%E4%B8%8Ekvm/"},{"categories":["qemu"],"content":"qemu /************************************************************************* \u003e FileName: qemu.c \u003e Author : DingJing \u003e Mail : dingjing@live.cn \u003e Created Time: Thu 13 Apr 2023 04:02:07 PM CST ************************************************************************/ #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003csys/mman.h\u003e #include \u003csys/ioctl.h\u003e #include \u003clinux/kvm.h\u003e int main (int argc, char* argv[]) { int ret = 0; struct kvm_sregs sregs; // 获取子文件系统的文件描述符 int kvmFd = open (\"/dev/kvm\", O_RDWR); // 应用层检查版本是否支持 ioctl(kvmFd, KVM_GET_API_VERSION, NULL); // 创建一个虚拟机，返回新建虚拟机的文件描述符 int vmFd = ioctl(kvmFd, KVM_CREATE_VM, 0); // void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset); unsigned char* ram = (unsigned char*) mmap (NULL, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS | MAP_EXECUTABLE, -1, 0); int kfd = open (\"./test.bin\", O_RDONLY); read (kfd, ram, 4096); struct kvm_userspace_memory_region mem = { .slot = 0, .flags = 0, .guest_phys_addr = 0, .memory_size = 0x1000, .userspace_addr = (unsigned long) ram, }; // 为虚拟机指定内存 ret = ioctl (vmFd, KVM_SET_USER_MEMORY_REGION, \u0026mem); // 为虚拟机创建vcpu int vcpufd = ioctl (vmFd, KVM_CREATE_VCPU, 0); int mmap_size = ioctl(kvmFd, KVM_GET_VCPU_MMAP_SIZE, NULL); struct kvm_run* run = (struct kvm_run*) mmap (NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0); // 获取虚拟机 CPU 寄存器 ret = ioctl (vcpufd, KVM_GET_SREGS, \u0026sregs); sregs.cs.base = 0; sregs.cs.selector = 0; // 设置虚拟机 CPU 寄存器 ret = ioctl(vcpufd, KVM_SET_SREGS, \u0026sregs); struct kvm_regs regs = { .rip = 0, }; ret = ioctl (vcpufd, KVM_SET_REGS, \u0026regs); while (1) { ret = ioctl (vcpufd, KVM_RUN, NULL); if (-1 == ret) { printf (\"exit unknow\\n\"); return -1; } switch (run-\u003eexit_reason) { case KVM_EXIT_HLT: { puts(\"KVM_EXIT_HLT\"); return 0; } case KVM_EXIT_IO: { putchar(*(((char*) run) + run-\u003eio.data_offset)); break; } case KVM_EXIT_FAIL_ENTRY:{ puts(\"entry error\"); return -1; } default: { puts (\"other error\"); printf (\"exit reason: %d\\n\", run-\u003eexit_reason); return -1; } } } return 0; } ","date":"2023-04-13","objectID":"/2023/04/0002-qemu%E4%B8%8Ekvm/:2:2","tags":["qemu","kvm","linux"],"title":"Qemu与KVM","uri":"/2023/04/0002-qemu%E4%B8%8Ekvm/"},{"categories":["qt"],"content":"qrandom.cpp:455:62: error: no matching function for call to ‘std::mersenne_twister_engine 解决方法: 打开 qrandom.cpp 文件，文件编辑器打开后，在220行添加类型声明：typedef quint32 result_type; ","date":"2023-03-13","objectID":"/2023/03/0001-qt-5.11.3%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%94%99%E8%AF%AF/:1:0","tags":["qt","linux"],"title":"Qt 5.11.3编译过程中错误","uri":"/2023/03/0001-qt-5.11.3%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%94%99%E8%AF%AF/"},{"categories":["qt"],"content":"qbytearraymatcher.h:103:38: error: ‘numeric_limits’ is not a member of ‘std’ 解决方法： 因为qbytearraymatcher.h 文件缺少 limits 头文件，所以打开此文件添加 #include \u003climits\u003e ","date":"2023-03-13","objectID":"/2023/03/0001-qt-5.11.3%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%94%99%E8%AF%AF/:2:0","tags":["qt","linux"],"title":"Qt 5.11.3编译过程中错误","uri":"/2023/03/0001-qt-5.11.3%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%94%99%E8%AF%AF/"},{"categories":["qt"],"content":"socketcanbackend.cpp:697:41: error: ‘SIOCGSTAMP’ was not declared in this scope 解决方法： 在qt源码中搜索socketcanbackend.cpp，在头文件中添加#include \u003clinux/sockios.h\u003e ","date":"2023-03-13","objectID":"/2023/03/0001-qt-5.11.3%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%94%99%E8%AF%AF/:3:0","tags":["qt","linux"],"title":"Qt 5.11.3编译过程中错误","uri":"/2023/03/0001-qt-5.11.3%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%94%99%E8%AF%AF/"},{"categories":["qt"],"content":"qjp2handler.cpp:853:41: error: ‘pow’ was not declared in this scope 解决方法： 在Qt源码中查找qjp2handler.cpp，在头文件中添加#include \u003cmath.h\u003e ","date":"2023-03-13","objectID":"/2023/03/0001-qt-5.11.3%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%94%99%E8%AF%AF/:4:0","tags":["qt","linux"],"title":"Qt 5.11.3编译过程中错误","uri":"/2023/03/0001-qt-5.11.3%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%94%99%E8%AF%AF/"},{"categories":["ncurses","linux"],"content":"add_wch 在窗口中添加复杂字符串，然后移动光标 #include \u003ccurses.h\u003e int add_wch( const cchar_t *wch ); int wadd_wch( WINDOW *win, const cchar_t *wch ); int mvadd_wch( int y, int x, const cchar_t *wch ); int mvwadd_wch( WINDOW *win, int y, int x, const cchar_t *wch ); int echo_wchar( const cchar_t *wch ); int wecho_wchar( WINDOW *win, const cchar_t *wch ); add_wch、wadd_wch、mvadd_wch和mvwadd_wch函数将复杂字符wch放在给定窗口的当前位置。 这些函数执行换行和特殊字符处理，如下所示: 如果指向一个空格字符，则该位置之前的任何字符都将被删除。由wch指定的新字符被放置在该位置，并由wch指定再现。然后光标移动到屏幕上的下一个空格字符。 如果引用非空格字符，则该位置之前的所有字符都将保留。其中的非空格字符被添加到空格复合字符中，并且忽略wch指定的再现。 如果其中的字符部分是制表符、换行符、退格符或其他控制字符，则窗口将被更新，光标将像调用addch一样移动。 echo_wchar 等价于 add_wch + refresh ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:1:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"add_wchstr 在窗口中添加复杂字符串 #include \u003ccurses.h\u003e int add_wchstr(const cchar_t *wchstr); int add_wchnstr(const cchar_t *wchstr, int n); int wadd_wchstr(WINDOW * win, const cchar_t *wchstr); int wadd_wchnstr(WINDOW * win, const cchar_t *wchstr, int n); int mvadd_wchstr(int y, int x, const cchar_t *wchstr); int mvadd_wchnstr(int y, int x, const cchar_t *wchstr, int n); int mvwadd_wchstr(WINDOW *win, int y, int x, const cchar_t *wchstr); int mvwadd_wchnstr(WINDOW *win, int y, int x, const cchar_t *wchstr, int n); 这些函数从当前光标位置开始将(以null结尾的)复杂字符数组wchstr复制到窗口图像结构中。以n为最后一个参数的四个函数最多复制n个元素，但不会超过一行的容量。如果n=-1，则复制整个数组，直到该行能容纳的最大字符数。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:2:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"addch 将字符显示到指定位置 #include \u003ccurses.h\u003e int addch(const chtype ch); int waddch(WINDOW *win, const chtype ch); int mvaddch(int y, int x, const chtype ch); int mvwaddch(WINDOW *win, int y, int x, const chtype ch); int echochar(const chtype ch); int wechochar(WINDOW *win, const chtype ch); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:3:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"addchstr 将字符串显示到指定位置 #include \u003ccurses.h\u003e int addchstr(const chtype *chstr); int addchnstr(const chtype *chstr, int n); int waddchstr(WINDOW *win, const chtype *chstr); int waddchnstr(WINDOW *win, const chtype *chstr, int n); int mvaddchstr(int y, int x, const chtype *chstr); int mvaddchnstr(int y, int x, const chtype *chstr, int n); int mvwaddchstr(WINDOW *win, int y, int x, const chtype *chstr); int mvwaddchnstr(WINDOW *win, int y, int x, const chtype *chstr, int n); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:4:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"addstr #include \u003ccurses.h\u003e int addstr(const char *str); int addnstr(const char *str, int n); int waddstr(WINDOW *win, const char *str); int waddnstr(WINDOW *win, const char *str, int n); int mvaddstr(int y, int x, const char *str); int mvaddnstr(int y, int x, const char *str, int n); int mvwaddstr(WINDOW *win, int y, int x, const char *str); int mvwaddnstr(WINDOW *win, int y, int x, const char *str, int n); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:5:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"addwstr #include \u003ccurses.h\u003e int addwstr(const wchar_t *wstr); int addnwstr(const wchar_t *wstr, int n); int waddwstr(WINDOW *win, const wchar_t *wstr); int waddnwstr(WINDOW *win, const wchar_t *wstr, int n); int mvaddwstr(int y, int x, const wchar_t *wstr); int mvaddnwstr(int y, int x, const wchar_t *wstr, int n); int mvwaddwstr(WINDOW *win, int y, int x, const wchar_t *wstr); int mvwaddnwstr(WINDOW *win, int y, int x, const wchar_t *wstr, int n); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:6:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"attr 字体和窗口属性 #include \u003ccurses.h\u003e int attr_get(attr_t *attrs, short *pair, void *opts); int wattr_get(WINDOW *win, attr_t *attrs, short *pair, void *opts); int attr_set(attr_t attrs, short pair, void *opts); int wattr_set(WINDOW *win, attr_t attrs, short pair, void *opts); int attr_off(attr_t attrs, void *opts); int wattr_off(WINDOW *win, attr_t attrs, void *opts); int attr_on(attr_t attrs, void *opts); int wattr_on(WINDOW *win, attr_t attrs, void *opts); int attroff(int attrs); int wattroff(WINDOW *win, int attrs); int attron(int attrs); int wattron(WINDOW *win, int attrs); int attrset(int attrs); int wattrset(WINDOW *win, int attrs); int chgat(int n, attr_t attr, short pair, const void *opts); int wchgat(WINDOW *win, int n, attr_t attr, short pair, const void *opts); int mvchgat(int y, int x, int n, attr_t attr, short pair, const void *opts); int mvwchgat(WINDOW *win, int y, int x, int n, attr_t attr, short pair, const void *opts); int color_set(short pair, void* opts); int wcolor_set(WINDOW *win, short pair, void* opts); int standend(void); int wstandend(WINDOW *win); int standout(void); int wstandout(WINDOW *win); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:7:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"beep 响铃 #include \u003ccurses.h\u003e int beep(void); int flash(void); beep和flash例程用于提醒终端用户。如果可能的话，例行的哔哔声在终端上发出声音警报;否则它会闪烁屏幕(可见的铃铛)。常规闪光闪烁屏幕，如果这是不可能的，声音警报。如果两个警报都不可能，什么都不会发生。几乎所有的终端机都有声音警报(铃声或嘟嘟声)，但只有一些终端机可以在屏幕上闪烁。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:8:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"bkgd 窗口背景操作 #include \u003ccurses.h\u003e void bkgdset(chtype ch); void wbkgdset(WINDOW *win, chtype ch); int bkgd(chtype ch); int wbkgd(WINDOW *win, chtype ch); chtype getbkgd(WINDOW *win); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:9:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"bkgdset bkgdset和wbkgdset例程设置窗口的背景。窗口的背景是一个chtype，由任意属性(即再现)和字符的组合组成: 背景的属性部分与使用waddch写入窗口的所有非空白字符合并 背景的字符和属性部分都与写入窗口的空白字符相结合 背景成为每个字符的属性，并随着字符的滚动和插入/删除行/字符操作而移动。 在特定终端上，背景的属性部分尽可能显示为屏幕上字符的图形再现。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:9:1","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"bkgd bkgd和wbkgd函数设置当前或指定窗口的背景属性，然后将此设置应用于该窗口中的每个字符位置。根据《X/Open Curses》，它应该这样做: 屏幕上的每个字符的呈现都变成了新的背景呈现。 只要前一个背景字符出现，它就被更改为新的背景字符。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:9:2","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"bkgrnd 窗口复杂的后台操作例程 #include \u003ccurses.h\u003e int bkgrnd( const cchar_t *wch); int wbkgrnd( WINDOW *win, const cchar_t *wch); void bkgrndset(const cchar_t *wch ); void wbkgrndset(WINDOW *win, const cchar_t *wch); int getbkgrnd(cchar_t *wch); int wgetbkgrnd(WINDOW *win, cchar_t *wch); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:10:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"border_set 使用复杂字符和再现的边框或线条 #include \u003ccurses.h\u003e int border_set(const cchar_t *ls, const cchar_t *rs, const cchar_t *ts, const cchar_t *bs, const cchar_t *tl, const cchar_t *tr, const cchar_t *bl, const cchar_t *br ); int wborder_set(WINDOW *win, const cchar_t *ls, const cchar_t *rs, const cchar_t *ts, const cchar_t *bs, const cchar_t *tl, const cchar_t *tr, const cchar_t *bl, const cchar_t *br); int box_set(WINDOW *win, const cchar_t *verch, const cchar_t *horch); int hline_set(const cchar_t *wch, int n); int whline_set(WINDOW *win, const cchar_t *wch, int n); int mvhline_set(int y, int x, const cchar_t *wch, int n); int mvwhline_set(WINDOW *win, int y, int x, const cchar_t *wch, int n); int vline_set(const cchar_t *wch, int n); int wvline_set(WINDOW *win, const cchar_t *wch, int n); int mvvline_set(int y, int x, const cchar_t *wch, int n); int mvwvline_set(WINDOW *win, int y, int x, const cchar_t *wch, int n); border_set和wborder_set函数围绕当前或指定窗口的边缘绘制边框。这些函数不会改变光标位置，也不会自动换行。 除了窗口，每个参数都是一个带有attributes的复杂字符: ls - left side, rs - right side, ts - top side, bs - bottom side, tl - top left-hand corner, tr - top right-hand corner, bl - bottom left-hand corner, and br - bottom right-hand corner. 如果这些参数中的任何一个为零，则使用相应的默认值(在curses.h中定义): WACS_VLINE, WACS_VLINE, WACS_HLINE, WACS_HLINE, WACS_ULCORNER, WACS_URCORNER, WACS_LLCORNER, and WACS_LRCORNER. ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:11:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"border 创建 border —— 水平线或垂直线 #include \u003ccurses.h\u003e int border(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl, chtype tr, chtype bl, chtype br); int wborder(WINDOW *win, chtype ls, chtype rs, chtype ts, chtype bs, chtype tl, chtype tr, chtype bl, chtype br); int box(WINDOW *win, chtype verch, chtype horch); int hline(chtype ch, int n); int whline(WINDOW *win, chtype ch, int n); int vline(chtype ch, int n); int wvline(WINDOW *win, chtype ch, int n); int mvhline(int y, int x, chtype ch, int n); int mvwhline(WINDOW *win, int y, int x, chtype ch, int n); int mvvline(int y, int x, chtype ch, int n); int mvwvline(WINDOW *win, int y, int x, chtype ch, int n); border, wborder和box例程围绕窗口的边缘绘制一个方框。除了窗口，每个参数都是一个带有at的字符: ls - left side, rs - right side, ts - top side, bs - bottom side, tl - top left-hand corner, tr - top right-hand corner, bl - bottom left-hand corner, and br - bottom right-hand corner. 如果这些参数中的任何一个为零，则使用相应的默认值(在curses.h中定义): ACS_VLINE, ACS_VLINE, ACS_HLINE, ACS_HLINE, ACS_ULCORNER, ACS_URCORNER, ACS_LLCORNER, ACS_LRCORNER. ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:12:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"clear #include \u003ccurses.h\u003e int erase(void); int werase(WINDOW *win); int clear(void); int wclear(WINDOW *win); int clrtobot(void); int wclrtobot(WINDOW *win); int clrtoeol(void); int wclrtoeol(WINDOW *win); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:13:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"erase/werase erase和werase例程将空格复制到window的每个位置，清除屏幕。 由擦除创建的空白将当前的背景再现(由wbkgdset(3x)设置)合并到其中。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:13:1","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"clear/wclear clear和wclear例程类似于erase和werase，但它们也调用clearok(3x)，以便在下次调用该窗口的wrefresh时完全清除屏幕并从头重新绘制。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:13:2","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"clrtobot/wclrtobot clrtobot和wclrtobot例程从光标擦除到屏幕末端。也就是说，它们会擦除窗口中光标下方的所有行。此外，光标右侧的当前行(包括在内)将被擦除。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:13:3","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"clrtoeol/wclrtoeol clrtool和wclrtool例程擦除光标右侧的当前行(包括当前行末尾)。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:13:4","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"color #include \u003ccurses.h\u003e int start_color(void); bool has_colors(void); bool can_change_color(void); int init_pair(short pair, short f, short b); int init_color(short color, short r, short g, short b); /* extensions */ int init_extended_pair(int pair, int f, int b); int init_extended_color(int color, int r, int g, int b); int color_content(short color, short *r, short *g, short *b); int pair_content(short pair, short *f, short *b); /* extensions */ int extended_color_content(int color, int *r, int *g, int *b); int extended_pair_content(int pair, int *f, int *b); /* extensions */ void reset_color_pairs(void); int COLOR_PAIR(int n); PAIR_NUMBER(attrs); Curses支持具有该功能的终端上的颜色属性。要使用这些例程，必须调用start_color，通常在initscr之后。颜色总是成对使用(称为颜色对)。 颜色对由前景色(用于字符)和背景色(用于显示字符的空白字段)组成。 程序员使用init_pair例程初始化颜色对。在初始化后，COLOR_PAIR(n)可用于将pair转换为显示属性。 如果终端能够重新定义颜色，程序员可以使用init_color例程来更改颜色的定义。 例程has_colors和can_change_color返回TRUE或FALSE，这取决于终端是否具有颜色功能以及程序员是否可以更改颜色。 例程color_content允许程序员以初始化的颜色提取红色、绿色和蓝色组件的数量。 例程pair_content允许程序员找出给定颜色对当前是如何定义的。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:14:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"delch 在窗口中删除光标下的字符 #include \u003ccurses.h\u003e int delch(void); int wdelch(WINDOW *win); int mvdelch(int y, int x); int mvwdelch(WINDOW *win, int y, int x); 这些例程删除光标下的字符;同一行中光标右边的所有字符都向左移动一个位置，最后一个字符为空。光标位置不会改变(移动到y, x(如果指定)之后)。(这并不意味着使用硬件删除字符特性。) ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:15:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"deleteln 删除并插入多行到windows #include \u003ccurses.h\u003e int deleteln(void); int wdeleteln(WINDOW *win); int insdelln(int n); int winsdelln(WINDOW *win, int n); int insertln(void); int winsertln(WINDOW *win); deleteln和wdeleteln例程删除窗口中光标下的行;当前行以下的所有行都向上移动一行。窗口的底部边框被清除。光标位置不变。 insdelln和winsdelln例程，对于正n，将n行插入到当前行上方的指定窗口中。底线不见了。对于负n，删除n行(从光标下的行开始)，并将剩余的行向上移动。清除底部的n行。当前光标位置保持不变。 insertln和winsertln例程在当前行的上方插入一个空行，而底部的行将丢失。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:16:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"extend #include \u003ccurses.h\u003e const char* curses_version(void); int use_extended_names(bool enable); 这些函数是curses库的扩展，不容易归入其他类别。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:17:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"get_wch 从终端键盘获取宽字符 #include \u003ccurses.h\u003e int get_wch(wint_t *wch); int wget_wch(WINDOW *win, wint_t *wch); int mvget_wch(int y, int x, wint_t *wch); int mvwget_wch(WINDOW *win, int y, int x, wint_t *wch); int unget_wch(const wchar_t wch); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:18:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"get_wstr 从curses终端键盘获取宽字符数组 #include \u003ccurses.h\u003e int get_wstr(wint_t *wstr); int getn_wstr(wint_t *wstr, int n); int wget_wstr(WINDOW *win, wint_t *wstr); int wgetn_wstr(WINDOW *win, wint_t *wstr, int n); int mvget_wstr(int y, int x, wint_t *wstr); int mvgetn_wstr(int y, int x, wint_t *wstr, int n); int mvwget_wstr(WINDOW *win, int y, int x, wint_t *wstr); int mvwgetn_wstr(WINDOW *win, int y, int x, wint_t *wstr, int n); get_wstr的效果就像对get_wch(3x)进行了一系列调用，直到处理换行符、其他行结束符或文件结束符条件。文件结束条件由WEOF表示，如\u003cwchar.h\u003e中所定义。换行符和行尾条件由\\n wchar_t值表示。在所有实例中，字符串的结尾都以空wchar_t结束。该例程将结果值放在wstr所指向的区域中。 用户的擦除和终止字符将被解释。如果窗口的键盘模式是打开的，KEY_LEFT和KEY_BACKSPACE都被认为等同于用户的终止字符。 只有当前打开echo时，输入的字符才会被返回。在这种情况下，退格回显为删除前一个字符(通常是向左移动)。 wget_wstr的效果就像对wget_wch进行了一系列调用。 mvget_wstr的效果就像调用了一个move，然后调用了一系列get_wch。 mvwget_wstr的效果就像调用wmove，然后调用一系列wget_wch。 getn_wstr, mvgettn_wstr, mvwget_wstr和wget_wstr函数分别与get_wstr, mvget_wstr, mvwget_wstr函数相同，除了*n_*版本最多读取n个字符，让应用程序防止输入缓冲区溢出。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:19:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"getcchar 从cchar_t对象获取宽字符串并进行再现，或者从宽字符串对象设置cchar_t对象 #include \u003ccurses.h\u003e int getcchar(const cchar_t *wcval, wchar_t *wch, attr_t *attrs, short *color_pair, void *opts ); int setcchar(cchar_t *wcval, const wchar_t *wch, const attr_t attrs, short color_pair, const void *opts ); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:20:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"getch 从终端键盘获取字符 #include \u003ccurses.h\u003e int getch(void); int wgetch(WINDOW *win); int mvgetch(int y, int x); int mvwgetch(WINDOW *win, int y, int x); int ungetch(int ch); /* extension */ int has_key(int ch); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:21:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"getstr #include \u003ccurses.h\u003e int getstr(char *str); int getnstr(char *str, int n); int wgetstr(WINDOW *win, char *str); int wgetnstr(WINDOW *win, char *str, int n); int mvgetstr(int y, int x, char *str); int mvwgetstr(WINDOW *win, int y, int x, char *str); int mvgetnstr(int y, int x, char *str, int n); int mvwgetnstr(WINDOW *win, int y, int x, char *str, int n); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:22:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"in_wch 这些函数从命名窗口的当前位置提取复杂字符到wcval引用的cchar_t对象中。 #include \u003ccurses.h\u003e int in_wch(cchar_t *wcval); int win_wch(WINDOW *win, cchar_t *wcval); int mvin_wch(int y, int x, cchar_t *wcval); int mvwin_wch(WINDOW *win, int y, int x, cchar_t *wcval); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:23:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"in_wchstr #include \u003ccurses.h\u003e int in_wchstr(cchar_t *wchstr); int in_wchnstr(cchar_t *wchstr, int n); int win_wchstr(WINDOW *win, cchar_t *wchstr); int win_wchnstr(WINDOW *win, cchar_t *wchstr, int n); int mvin_wchstr(int y, int x, cchar_t *wchstr); int mvin_wchnstr(int y, int x, cchar_t *wchstr, int n); int mvwin_wchstr(WINDOW *win, int y, int x, cchar_t *wchstr); int mvwin_wchnstr(WINDOW *win, int y, int x, cchar_t *wchstr, int n); 这些函数在wchstr中返回一个复杂字符数组，从指定窗口中的当前光标位置开始。属性(再现)与字符一起存储。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:24:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"inch 从窗口获取一个字符和属性 #include \u003ccurses.h\u003e chtype inch(void); chtype winch(WINDOW *win); chtype mvinch(int y, int x); chtype mvwinch(WINDOW *win, int y, int x); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:25:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"inchstr 从curses窗口获取字符串(和属性) #include \u003ccurses.h\u003e int inchstr(chtype *chstr); int inchnstr(chtype *chstr, int n); int winchstr(WINDOW *win, chtype *chstr); int winchnstr(WINDOW *win, chtype *chstr, int n); int mvinchstr(int y, int x, chtype *chstr); int mvinchnstr(int y, int x, chtype *chstr, int n); int mvwinchstr(WINDOW *win, int y, int x, chtype *chstr); int mvwinchnstr(WINDOW *win, int y, int x, chtype *chstr, int n); 这些例程返回一个以null结束的chtype数量数组，从指定窗口中的当前光标位置开始，到窗口的右边缘结束。以n作为最后一个参数的四个函数，返回一个最多n个字符的前导子字符串(不包括结尾(chtype)0)。\u003ccurhes.h\u003e中定义的常量可以与\u0026(逻辑与)操作符一起使用，从chstr中的任何位置单独提取字符或属性[参见curs_inch(3x)]。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:26:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"initscr 屏幕初始化和操作函数 #include \u003ccurses.h\u003e WINDOW *initscr(void); int endwin(void); bool isendwin(void); SCREEN *newterm(const char *type, FILE *outfd, FILE *infd); SCREEN *set_term(SCREEN *new); void delscreen(SCREEN* sp); initscr通常是初始化程序时调用的第一个curses例程。有时需要在它之前调用一些特殊的例程;它们是slk_init(3x)， filter, ripoffline, use_env。对于多终端应用，可能会在initscr之前调用newterm。 initscr代码确定终端类型并初始化所有curses数据结构。Initscr还会导致第一次调用刷新(3x)以清除屏幕。如果发生错误，initscr将适当的错误消息写入标准错误并退出;否则，返回指向stdscr的指针。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:27:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"inopts 输入选项 #include \u003ccurses.h\u003e int cbreak(void); int nocbreak(void); int echo(void); int noecho(void); int intrflush(WINDOW *win, bool bf); int keypad(WINDOW *win, bool bf); int meta(WINDOW *win, bool bf); int nodelay(WINDOW *win, bool bf); int notimeout(WINDOW *win, bool bf); int nl(void); int nonl(void); int raw(void); int noraw(void); void qiflush(void); void noqiflush(void); int halfdelay(int tenths); void timeout(int delay); void wtimeout(WINDOW *win, int delay); int typeahead(int fd); ncurses库提供了几个函数，可以让应用程序改变终端输入的处理方式。有些是全局的，适用于所有窗口。其他的只应用于特定的窗口。特定于窗口的设置不会自动应用于新窗口或派生窗口。如果需要相同的行为，应用程序必须将这些应用到每个窗口。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"cbreak/nocbreak 通常，tty驱动程序会缓冲键入的字符，直到键入换行符或回车符。cbreak例程禁用行缓冲和删除/终止字符处理(中断和流控制字符不受影响)，使用户键入的字符立即对程序可用。nocbreak例程将终端返回到正常模式。 最初终端可能处于cbreak模式，也可能不处于cbreak模式，因为该模式是继承的;因此，程序应该显式地调用cbreak或nocbreak。大多数使用curses的交互程序都设置了cbreak模式。 注意，cbreak会覆盖raw。[参见curs_getch(3x)了解这些例程如何与echo和noecho交互。] ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:1","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"echo/noecho echo和noecho例程控制用户输入的字符是否在输入时由getch(3x)回显。tty驱动程序的回显总是被禁用的，但是最初getch处于回显模式，因此输入的字符被回显。大多数交互程序的作者更喜欢在屏幕的一个受控区域中进行自己的回显，或者根本不回显，所以他们通过调用noecho来禁用回显。[参见curs_getch(3x)了解这些例程如何与cbreak和nocbreak交互。] ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:2","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"halfdelay half-delay例程用于半延迟模式，它类似于cbreak模式，用户输入的字符可以立即被程序使用。但是，在阻塞了十分之一秒之后，如果没有输入任何东西，则返回ERR。十分位数必须为1到255之间的数字。使用nocbreak离开半延迟模式。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:3","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"intrflush 如果启用了intrflush选项(bf为TRUE)，并且按下了键盘上的中断键(interrupt, break, quit)， tty驱动队列中的所有输出都将被刷新，从而对中断做出更快的响应，但会导致curses对屏幕上的内容有错误。禁用该选项(bf为FALSE)可防止刷新。该选项的默认值继承自tty驱动程序设置。窗口参数被忽略。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:4","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"keypad 小键盘选项启用用户终端的小键盘。如果启用(bf为TRUE)，用户可以按下一个功能键(如方向键)，wgetch(3x)返回一个代表功能键的值，如KEY_LEFT。如果禁用(bf为FALSE)， curses不会特别处理功能键，程序必须自己解释转义序列。如果终端中的小键盘可以打开(用于传输)和关闭(用于本地工作)，则打开此选项将导致在调用wgetch(3x)时打开终端小键盘。“键盘”的默认值为“FALSE”。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:5","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"meta 最初，终端在输入时返回7位还是8位有效位取决于tty驱动程序的控制模式[参见termios(3)]。强制返回8位，调用meta(win, TRUE);在POSIX下，这相当于在终端上设置CS8标志。强制返回7位，调用meta(win, FALSE);在POSIX下，这相当于在终端上设置CS7标志。窗口参数win总是被忽略。如果为终端定义了terminfo能力smm (meta_on)和rmm (meta_off)，则在调用meta(win, TRUE)时向终端发送smm，在调用meta(win, FALSE)时向终端发送rmm。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:6","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"nl/nonl nl和nonl例程控制底层显示设备是否在输入时将返回键转换为换行符。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:7","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"nodelay nodelay选项使getch成为一个非阻塞调用。如果没有准备好的输入，getch返回ERR。如果被禁用(bf为FALSE)， getch将等待按键被按下。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:8","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"notimeout 当解释转义序列时，wgetch(3x)在等待下一个字符时设置一个计时器。如果调用notimeout(win, TRUE)，则wgetch不设置定时器。该超时的目的是区分从功能键接收到的序列和用户键入的序列。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:9","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"raw/noraw raw和noraw例程将终端设置为raw模式或退出raw模式。Raw模式类似于cbreak模式，输入的字符会立即传递给用户程序。不同之处在于，在原始模式中，中断、退出、挂起和流控制字符都是未经解释传递的，而不是生成信号。BREAK键的行为取决于tty驱动程序中不是由curses设置的其他位。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:10","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"qiflush/noqiflush 当使用noqiflush例程时，与INTR、QUIT和SUSP字符相关的输入和输出队列的正常刷新将不会进行[参见termios(3)]。当调用qiflush时，当读取这些控制字符时，队列将被刷新。如果希望在信号处理程序退出后继续输出，就像中断没有发生一样，那么可能需要在信号处理程序中调用noqiflush。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:11","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"timeout/wtimeout timeout和wtimeout例程为给定窗口设置阻塞或非阻塞读取。如果delay为负，则使用阻塞读取(即无限期地等待输入)。如果延迟为零，则使用非阻塞读取(即，如果没有输入等待，则read返回ERR)。如果delay为正，则读取延迟毫秒的块，如果仍然没有输入则返回ERR。因此，这些例程提供了与nodelay相同的功能，加上能够仅阻塞延迟毫秒(其中delay为正)的额外功能。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:12","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"typeahead curses库通过在更新屏幕时定期查找提前输入来进行“换行优化”。如果找到了来自tty的输入，则当前更新将被推迟，直到再次调用refresh(3x)或doupdate。这样可以更快地响应预先键入的命令。通常，传递给newterm的输入FILE指针(在使用initscr的情况下是stdin)将被用于执行输入前检查。typeahead例程指定使用文件描述符fd来检查typeahead。如果fd为-1，则不执行输入前检查。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:28:13","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"ins_wch 在屏幕上插入复杂字符串 #include \u003ccurses.h\u003e int ins_wch(const cchar_t *wch); int wins_wch(WINDOW *win, const cchar_t *wch); int mvins_wch(int y, int x, const cchar_t *wch); int mvwins_wch(WINDOW *win, int y, int x, const cchar_t *wch); 这些例程，在光标下的字符之前插入带有再现的复杂字符。光标右边的所有字符都向右移动一个空格，有可能丢失行中最右边的字符。插入操作不会改变游标位置。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:29:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"ins_wstr 在屏幕上插入宽字符 #include \u003ccurses.h\u003e int ins_wstr(const wchar_t *wstr); int ins_nwstr(const wchar_t *wstr, int n); int wins_wstr(WINDOW *win, const wchar_t *wstr); int wins_nwstr(WINDOW *win, const wchar_t *wstr, int n); int mvins_wstr(int y, int x, const wchar_t *wstr); int mvins_nwstr(int y, int x, const wchar_t *wstr, int n); int mvwins_wstr(WINDOW *win, int y, int x, const wchar_t *wstr); int mvwins_nwstr(WINDOW *win, int y, int x, const wchar_t *wstr, int n); 这些例程在光标下的字符之前插入一个wchar_t字符串(一行中可以容纳多少字符)。光标右边的所有字符都向右移动，有可能丢失行中最右边的字符。不执行包装。光标位置不会改变(移动到y, x(如果指定)之后)。以n作为最后一个参数的四个例程插入一个最多n个wchar_t字符的前导子字符串。如果n小于1，则插入整个字符串。 如果wstr中的字符是制表符、换行符、回车符或退格符，则光标将在窗口内适当移动。换行符在移动之前也会执行一个clrtool。制表符被认为是每八列。如果wstr中的字符是另一个控制字符，则以^X表示法绘制。在添加一个控制字符之后调用win_wch(如果需要的话，移动到它)不会返回控制字符，而是返回控制字符的^-表示中的一个字符。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:30:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"insch 游标前插入一个字符串 #include \u003ccurses.h\u003e int insch(chtype ch); int winsch(WINDOW *win, chtype ch); int mvinsch(int y, int x, chtype ch); int mvwinsch(WINDOW *win, int y, int x, chtype ch); 这些例程在光标下的字符之前插入字符ch。光标右边的所有字符都向右移动一个空格，有可能丢失行中最右边的字符。插入操作不会改变游标位置。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:31:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"insstr 游标前插入字符串 #include \u003ccurses.h\u003e int insstr(const char *str); int insnstr(const char *str, int n); int winsstr(WINDOW *win, const char *str); int winsnstr(WINDOW *win, const char *str, int n); int mvinsstr(int y, int x, const char *str); int mvinsnstr(int y, int x, const char *str, int n); int mvwinsstr(WINDOW *win, int y, int x, const char *str); int mvwinsnstr(WINDOW *win, int y, int x, const char *str, int n); 这些例程在光标下的字符之前插入一个字符串(一行可以容纳多少字符)。光标右边的所有字符都向右移动，可能会丢失行中最右边的字符。光标位置不会改变(移动到y, x(如果指定)之后)。以n作为最后一个参数的函数插入最多n个字符的前导子字符串。如果n\u003c=0，则插入整个字符串。 特殊字符在addch中被处理。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:32:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"instr 获取游标处的字符 #include \u003ccurses.h\u003e int instr(char *str); int innstr(char *str, int n); int winstr(WINDOW *win, char *str); int winnstr(WINDOW *win, char *str, int n); int mvinstr(int y, int x, char *str); int mvinnstr(int y, int x, char *str, int n); int mvwinstr(WINDOW *win, int y, int x, char *str); int mvwinnstr(WINDOW *win, int y, int x, char *str, int n); 这些例程返回str中的字符串，从指定窗口中的当前光标位置开始提取。从字符中剥离属性。以n作为最后一个参数的四个函数返回一个最多n个字符的前导子字符串(不包括尾随的NUL)。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:33:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"inwstr 获取游标处字符串 #include \u003ccurses.h\u003e int inwstr(wchar_t *wstr); int innwstr(wchar_t *wstr, int n); int winwstr(WINDOW *win, wchar_t *wstr); int winnwstr(WINDOW *win, wchar_t *wstr, int n); int mvinwstr(int y, int x, wchar_t *wstr); int mvinnwstr(int y, int x, wchar_t *wstr, int n); int mvwinwstr(WINDOW *win, int y, int x, wchar_t *wstr); int mvwinnwstr(WINDOW *win, int y, int x, wchar_t *wstr, int n); 这些例程在wstr中返回一个wchar_t宽字符的字符串，从指定窗口中的当前光标位置开始提取。 以n为最后一个参数的四个函数返回前导子字符串最多n个字符长(不包括尾随的NUL)。当前行的末尾，或者当有n个字符存储在wstr引用的位置时停止获取。 如果n的大小不足以存储一个完整的复杂字符，则会生成一个错误。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:34:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"kernel #include \u003ccurses.h\u003e int def_prog_mode(void); int def_shell_mode(void); int reset_prog_mode(void); int reset_shell_mode(void); int resetty(void); int savetty(void); void getsyx(int y, int x); void setsyx(int y, int x); int ripoffline(int line, int (*init)(WINDOW *, int)); int curs_set(int visibility); int napms(int ms); 下面的例程提供了对各种curses功能的低级访问。这些例程通常在库例程中使用。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:35:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"def_prog_mode, def_shell_mode def_prog_mode和def_shell_mode例程将当前终端模式保存为“程序”(curses)或“shell”(非curses)状态，供reset_prog_mode和reset_shell_mode例程使用。这是由initscr自动完成的。每个由newterm分配的屏幕上下文都有一个这样的保存区域。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:35:1","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"reset_prog_mode, reset_shell_mode reset_prog_mode和reset_shell_mode例程将终端恢复为“程序”(处于诅咒状态)或“shell”(处于诅咒状态)状态。这些是由endwin(3x)自动完成的，在endwin之后，由doupdate自动完成，所以通常不调用它们。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:35:2","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"resetty, savetty 复位和安全例程保存和恢复终端模式的状态。Savetty将当前状态保存在缓冲区中，重置将状态恢复到最后一次调用Savetty时的状态。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:35:3","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"getsyx getsyx例程返回虚拟屏幕光标在y和x中的当前坐标。如果leaveok当前为TRUE，则返回-1，-1。如果线条已经从屏幕顶部移除，使用ripoffline, y和x包括这些线条;因此，y和x只能作为setsyx的参数。 很少有应用程序会使用这个特性，大多数应用程序会使用getyx。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:35:4","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"setsyx setsyx例程将虚拟屏幕光标设置为y, x。如果y和x都是-1，则设置leaveok。getsyx和setsyx这两个例程被设计为库例程使用，库例程操作curses窗口，但不想改变程序光标的当前位置。库例程将在开始时调用getsyx，对其自己的窗口进行操作，对其窗口执行wnoutrefresh，调用setsyx，然后调用doupdate。 很少有应用程序会使用这个特性，大多数应用程序会使用wmove。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:35:5","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"ripoffline ripoffline例程提供了对slk_init[参见curs_slk(3x)]用于减小屏幕大小的相同工具的访问。Ripoffline必须在initscr或newterm调用之前调用，以准备这些初始操作: 如果line为正数，则从stdscr顶部删除一行 如果line为负数，则从底部删除一行 当最终的初始化在initscr内部完成时，例程init(由用户提供)将被调用，并带有两个参数: 一个窗口指针，指向已分配和的单行窗口 窗口中列数的整数 在这个初始化例程中，不能保证整型变量LINES和COLS(在\u003ccurses.h\u003e中定义)是准确的，也不能调用wrefresh或doupdate。允许在初始化例程期间调用wnoutrefresh。 在调用initscr或newterm之前，ripoffline最多可以被调用五次。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:35:6","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"curs_set curs_set例程将游标状态分别设置为不可见、正常或非常可见(可见性分别为0、1或2)。如果终端支持所请求的可见性，则返回先前的游标状态;否则返回ERR。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:35:7","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"napms napms例程用于毫秒级的睡眠 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:35:8","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"legacy 获取curses光标和窗口坐标，属性 #include \u003ccurses.h\u003e int getattrs(const WINDOW *win); int getbegx(const WINDOW *win); int getbegy(const WINDOW *win); int getcurx(const WINDOW *win); int getcury(const WINDOW *win); int getmaxx(const WINDOW *win); int getmaxy(const WINDOW *win); int getparx(const WINDOW *win); int getpary(const WINDOW *win); 这些遗留函数比X/Open Curses函数使用起来更简单: getattrs函数返回与wattr_get相同的属性数据。然而，getattrs返回一个整数(实际上是一个chtype)，而wattr_get在一个单独的参数中返回当前颜色对。在宽字符库配置中，颜色对可能不适合chtype，因此wattr_get是获取颜色信息的唯一方法。因为getattrs在单个参数中返回属性，所以应用程序不可能将其与ERR (a -1)区分开来。如果窗口参数为空，getattrs将返回A_NORMAL(零)。 getbegy和getbegx函数返回与getbegyx相同的数据。 getcury和getcurx函数返回与getyx相同的数据。 getmaxx和getmaxx函数返回与getmaxyx相同的数据。 getpary和getparx函数返回与getparyx相同的数据。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:36:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"memleaks 内存检测 #include \u003ccurses.h\u003e void exit_curses(int code); #include \u003cterm.h\u003e void exit_terminfo(int code); /* deprecated (intentionally not declared in curses.h or term.h) */ void _nc_freeall(void); void _nc_free_and_exit(int code); void _nc_free_tinfo(int code); 这些函数用于简化ncurses库中的内存泄漏分析。 任何curses的实现都不能释放与屏幕相关的内存，因为(即使在调用endwin(3x)之后)，它必须在下一次调用refresh(3x)时可用。还有一些内存块是出于性能原因而保留的。这使得很难分析curses应用程序的内存泄漏。当使用ncurses库的特殊配置的调试版本时，应用程序可以调用释放这些内存块的函数，从而简化内存泄漏检查过程。 一些函数以“_nc_”前缀命名，因为它们不打算在非调试库中使用: ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:37:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"_nc_freeall 这将释放(几乎)ncurses分配的所有内存。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:37:1","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"_nc_free_and_exit 这将释放由ncurses分配的内存(如_nc_freeall)，并退出程序。它优先于_nc_freeall，因为可能需要一些内存来保持应用程序运行。简单地退出(使用给定的退出代码)更安全。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:37:2","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"_nc_free_tinfo 如果只使用低级的terminfo函数(以及相应的库)，则使用此函数。像_nc_free_and_exit一样，它在释放内存后退出程序。 前缀为“_nc”的函数通常不可用;它们必须在构建时使用——disable-leaks选项配置到库中。编译代码释放通常不会被释放的内存。 如果库配置为支持内存泄漏检查，exit_curses和exit_terminfo函数将调用_nc_free_and_exit和_nc_free_tinfo。如果库没有配置为支持内存泄漏检查，则会简单地调用exit。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:37:3","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"mouse #include \u003ccurses.h\u003e typedef unsigned long mmask_t; typedef struct { short id; /* ID to distinguish multiple devices */ int x, y, z; /* event coordinates */ mmask_t bstate; /* button state bits */ } MEVENT; bool has_mouse(void); int getmouse(MEVENT *event); int ungetmouse(MEVENT *event); mmask_t mousemask(mmask_t newmask, mmask_t *oldmask); bool wenclose(const WINDOW *win, int y, int x); bool mouse_trafo(int* pY, int* pX, bool to_screen); bool wmouse_trafo(const WINDOW* win, int* pY, int* pX, bool to_screen); int mouseinterval(int erval); 这些函数为来自ncurses(3x)的鼠标事件提供了接口。鼠标事件由wgetch(3x)输入流中的KEY_MOUSE伪键值表示。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:38:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"move 移动游标的位置 #include \u003ccurses.h\u003e int move(int y, int x); int wmove(WINDOW *win, int y, int x); 这些例程将与窗口相关联的光标移动到y行和x列。在调用refresh(3x)之前，此例程不会移动终端的物理光标。指定的位置相对于窗口的左上角，即(0,0)。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:39:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"opaque #include \u003ccurses.h\u003e bool is_cleared(const WINDOW *win); bool is_idcok(const WINDOW *win); bool is_idlok(const WINDOW *win); bool is_immedok(const WINDOW *win); bool is_keypad(const WINDOW *win); bool is_leaveok(const WINDOW *win); bool is_nodelay(const WINDOW *win); bool is_notimeout(const WINDOW *win); bool is_pad(const WINDOW *win); bool is_scrollok(const WINDOW *win); bool is_subwin(const WINDOW *win); bool is_syncok(const WINDOW *win); WINDOW * wgetparent(const WINDOW *win); int wgetdelay(const WINDOW *win); int wgetscrreg(const WINDOW *win, int *top, int *bottom); 该实现提供了返回WINDOW结构中设置的属性的函数，如果定义了符号NCURSES_OPAQUE，则允许其为“opaque”: is_cleared: returns the value set in clearok is_idcok: returns the value set in idcok is_idlok: returns the value set in idlok is_immedok: returns the value set in immedok is_keypad: returns the value set in keypad is_leaveok: returns the value set in leaveok is_nodelay: returns the value set in nodelay is_notimeout: returns the value set in notimeout is_pad: returns TRUE if the window is a pad i.e., created by newpad is_scrollok: returns the value set in scrollok is_subwin: returns TRUE if the window is a subwindow, i.e., created by subwin or derwin is_syncok: returns the value set in syncok wgetdelay: returns the delay timeout as set in wtimeout. wgetparent: returns the parent WINDOW pointer for subwindows, or NULL for windows having no parent. wgetscrreg: returns the top and bottom rows for the scrolling margin as set in wsetscrreg. ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:40:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"output 输出选项 #include \u003ccurses.h\u003e int clearok(WINDOW *win, bool bf); int idlok(WINDOW *win, bool bf); void idcok(WINDOW *win, bool bf); void immedok(WINDOW *win, bool bf); int leaveok(WINDOW *win, bool bf); int scrollok(WINDOW *win, bool bf); int setscrreg(int top, int bot); int wsetscrreg(WINDOW *win, int top, int bot); 这些例程设置选项，更改curses中的输出样式。所有选项的初始值都是FALSE，除非另有说明。在调用endwin(3x)之前，没有必要关闭这些选项。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:41:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"clearok 如果clearok以TRUE为参数调用，那么下一次调用该窗口的wrefresh将完全清除屏幕并从头重新绘制整个屏幕。这在屏幕内容不确定时很有用，或者在某些情况下为了获得更令人愉悦的视觉效果。如果clearok的win参数是全局变量curscr，那么对任意窗口的下一个wrefresh调用将导致屏幕被清除并从头重新绘制。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:41:1","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"idlok 如果idlok以TRUE作为第二个参数调用，curses会考虑使用这样配置的终端的硬件插入/删除行特性。以FALSE作为第二个参数调用idlok将禁止使用行插入和删除。只有当应用程序需要插入/删除行(例如，用于屏幕编辑器)时，才应该启用此选项。它在默认情况下是禁用的，因为在应用程序中使用插入/删除行时，它在视觉上很讨厌。如果插入/删除行不能使用，curses将重新绘制所有行中已更改的部分。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:41:2","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"idcok 如果idcok以FALSE作为第二个参数调用，curses将不再考虑使用这样配置的终端的硬件插入/删除字符特性。默认情况下启用字符插入/删除功能。以TRUE作为第二个参数调用idcok可以重新使用字符插入和删除。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:41:3","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"immedok 如果以TRUE作为参数调用immedok，那么窗口图像中的任何变化，例如由waddch、wclrtobot、wscrl等引起的变化，都会自动引起对wrefresh的调用。但是，由于反复调用wrefresh，它可能会大大降低性能。默认是禁用的。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:41:4","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"leaveok 通常情况下，硬件游标会停留在刷新窗口游标的位置。leaveok选项允许光标停留在更新恰好停留的地方。它对于不使用游标的应用程序非常有用，因为它减少了游标移动的需要。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:41:5","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"scrollok scrollok选项控制将窗口的光标移出窗口边缘或滚动区域时发生的情况，无论是由于在底线上执行换行操作，还是由于键入最后一行的最后一个字符。如果禁用，(bf为FALSE)，游标将留在底线上。如果启用(bf为TRUE)，窗口将向上滚动一行(注意，为了在终端上获得物理滚动效果，还需要调用idlok)。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:41:6","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"setscrreg/wsetscrreg setscrreg和wsetscrreg例程允许应用程序程序员在窗口中设置软件滚动区域。top和bot参数是滚动区域的顶部和底部边缘的行号。(第0行是窗口的顶行。)如果启用了此选项和scrollok，则尝试离开底边距会导致滚动区域中的所有行沿第一行的方向滚动一行。只滚动窗口的文本。(请注意，这与在终端中使用物理滚动区域功能无关，就像在VT100中那样。如果启用了idlok，并且终端具有滚动区域或插入/删除行功能，那么它们可能会被输出例程使用。) ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:41:7","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"overlay #include \u003ccurses.h\u003e int overlay(const WINDOW *srcwin, WINDOW *dstwin); int overwrite(const WINDOW *srcwin, WINDOW *dstwin); int copywin(const WINDOW *srcwin, WINDOW *dstwin, int sminrow, int smincol, int dminrow, int dmincol, int dmaxrow, int dmaxcol, int overlay); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:42:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"overlay, overwrite overlay和overwrite例程将srcwin覆盖在dstwin之上。scrwin和dstwin的大小不需要相同;只复制两个Windows重叠的文本。区别在于overlay覆盖是非破坏性的(空白不会被复制)，而overwrite覆盖是破坏性的。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:42:1","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"copywin copywin例程提供了对覆盖例程和覆盖例程更细粒度的控制。与预刷新例程一样，在目标窗口(dminrow, dmincol)和(dmaxrow, dmaxcol)中指定矩形，在源窗口的左上角坐标(sminrow, smincol)中指定矩形。如果参数overlay为真，则复制是非破坏性的，就像overlay一样。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:42:2","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"pad #include \u003ccurses.h\u003e WINDOW *newpad(int nlines, int ncols); WINDOW *subpad(WINDOW *orig, int nlines, int ncols, int begin_y, int begin_x); int prefresh(WINDOW *pad, int pminrow, int pmincol, int sminrow, int smincol, int smaxrow, int smaxcol); int pnoutrefresh(WINDOW *pad, int pminrow, int pmincol, int sminrow, int smincol, int smaxrow, int smaxcol); int pechochar(WINDOW *pad, chtype ch); int pecho_wchar(WINDOW *pad, const cchar_t *wch); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:43:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"newpad newpad例程创建并返回一个指针，指向具有给定行数(nlines)和列数(ncols)的新pad数据结构。一个垫子就像一个窗口，除了它不受屏幕大小的限制，并且不一定与屏幕的特定部分相关联。当需要一个大的窗口时，可以使用衬垫，并且一次只会在屏幕上显示窗口的一部分。不会发生pad的自动刷新(例如，从滚动或输入的回显)。 使用pad作为实参调用wrefresh是不合法的;应该调用prefresh或pnoutrefresh例程。注意，这些例程需要额外的参数来指定要显示的pad部分以及用于显示的屏幕上的位置。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:43:1","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"subpad subpad例程创建并返回一个指针，该指针指向pad内的子窗口，具有给定的行数(nlines)和列数(ncols)。与使用屏幕坐标的subwin不同，窗口位于pad上的位置(begin_x, begin_y)。该窗口位于窗口源的中间，因此对一个窗口所做的更改会影响两个窗口。在使用这个例程的过程中，通常需要在调用prefresh之前调用origo上的touchwin或touchline。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:43:2","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"prefresh, pnouterfresh prefresh和pnoutrefresh例程类似于wrefresh和wnoutrefresh，只不过它们与pad而不是窗口相关。需要附加的参数来指示涉及到衬垫和屏幕的哪个部分。 pminrow和pmincol参数指定要显示在pad上的矩形的左上角。 sminrow、smincol、smaxrow和smaxcol参数指定要在屏幕上显示的矩形的边。 要在pad中显示的矩形的右下角是根据屏幕坐标计算的，因为矩形必须是相同的大小。两个矩形必须完全包含在各自的结构中。pminrow、pmincol、sminrow或smincol的负值被视为零。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:43:3","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"pechochar pechochar例程在功能上等价于调用addch后调用refresh(3x)，调用waddch后调用wrefresh，或者调用waddch后调用prefresh。考虑到只输出单个字符的知识，对于非控制字符，使用这些例程而不是它们的等量例程可能会看到相当大的性能增益。在pechochar的情况下，屏幕上垫的最后一个位置被重用，用于预刷新参数。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:43:4","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"pecho_wchar pecho_wchar函数是pechochar的类似宽字符形式。它输出一个字符到一个垫子，并立即刷新垫子。它通过调用wadd_wch，然后调用prefresh来实现这一点。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:43:5","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"print #include \u003ccurses.h\u003e int mcprint(char *data, int len); 该函数使用mc5p或mc4和mc5功能(如果它们存在)将给定的数据传送到连接到终端的打印机。 请注意，mcprint代码无法对打印机进行流控制，也无法知道它有多少缓冲。您的应用程序负责将对打印机的写入速率保持在其连续吞吐率以下(通常约为其标称cps等级的一半)。点阵打印机和每分钟6页的激光通常可以处理80cps，所以一个好的保守的经验法则是在输出每80个字符的行之后睡一秒钟。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:44:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"printw #include \u003ccurses.h\u003e int printw(const char *fmt, ...); int wprintw(WINDOW *win, const char *fmt, ...); int mvprintw(int y, int x, const char *fmt, ...); int mvwprintw(WINDOW *win, int y, int x, const char *fmt, ...); int vw_printw(WINDOW *win, const char *fmt, va_list varglist); /* obsolete */ int vwprintw(WINDOW *win, const char *fmt, va_list varglist); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:45:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"refresh #include \u003ccurses.h\u003e int refresh(void); int wrefresh(WINDOW *win); int wnoutrefresh(WINDOW *win); int doupdate(void); int redrawwin(WINDOW *win); int wredrawln(WINDOW *win, int beg_line, int num_lines); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:46:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"scanw #include \u003ccurses.h\u003e int scanw(const char *fmt, ...); int wscanw(WINDOW *win, const char *fmt, ...); int mvscanw(int y, int x, const char *fmt, ...); int mvwscanw(WINDOW *win, int y, int x, const char *fmt, ...); int vw_scanw(WINDOW *win, const char *fmt, va_list varglist); /* obsolete */ int vwscanw(WINDOW *win, const char *fmt, va_list varglist); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:47:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"scr_dump #include \u003ccurses.h\u003e int scr_dump(const char *filename); int scr_restore(const char *filename); int scr_init(const char *filename); int scr_set(const char *filename); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:48:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"scroll #include \u003ccurses.h\u003e int scroll(WINDOW *win); int scrl(int n); int wscrl(WINDOW *win, int n); scroll例程将窗口向上滚动一行。这涉及到移动窗口数据结构中的行。作为一种优化，如果窗口的滚动区域是整个屏幕，则可以同时滚动物理屏幕。 对于正n, scrl和wscrl例程将窗口向上滚动n行(第i+n行变成第i行);否则将窗口向下滚动n行。这涉及到移动窗口字符图像结构中的行。当前光标位置不变。 为了使这些功能工作，滚动必须通过scrollok启用。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:49:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"slk #include \u003ccurses.h\u003e int slk_init(int fmt); int slk_set(int labnum, const char *label, int fmt); int slk_wset(int labnum, const wchar_t *label, int fmt); char *slk_label(int labnum); int slk_refresh(void); int slk_noutrefresh(void); int slk_clear(void); int slk_restore(void); int slk_touch(void); int slk_attron(const chtype attrs); int slk_attroff(const chtype attrs); int slk_attrset(const chtype attrs); int slk_attr_on(attr_t attrs, void* opts); int slk_attr_off(const attr_t attrs, void * opts); int slk_attr_set(const attr_t attrs, short pair, void* opts); /* extension */ attr_t slk_attr(void); int slk_color(short pair); /* extension */ int extended_slk_color(int pair); slk*函数操作存在于许多终端上的软功能键标签集。对于那些没有软标签的终端，curses接管了stdscr的底部边框线，减小了stdscr的大小和变量LINES。cruses有八个标签，每个标签最多八个字符。除此之外，ncurses实现还支持一种模式，它模拟12个标签，每个标签最多5个字符。这对于类pc的终端用户设备很有用。Ncurses通过接管屏幕底部的两行来模拟这种模式。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:50:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"sp_funcs #include \u003ccurses.h\u003e int alloc_pair_sp(SCREEN* sp, int fg, int bg); int assume_default_colors_sp(SCREEN* sp, int fg, int bg); int baudrate_sp(SCREEN* sp); int beep_sp(SCREEN* sp); bool can_change_color_sp(SCREEN* sp); int cbreak_sp(SCREEN* sp); int color_content_sp(SCREEN* sp, short color, short* r, short* g, short* b); int curs_set_sp(SCREEN* sp, int visibility); int def_prog_mode_sp(SCREEN* sp); int def_shell_mode_sp(SCREEN* sp); int define_key_sp(SCREEN* sp, const char * definition, int keycode); int delay_output_sp(SCREEN* sp, int ms); int doupdate_sp(SCREEN* sp); int echo_sp(SCREEN* sp); int endwin_sp(SCREEN* sp); char erasechar_sp(SCREEN* sp); int erasewchar_sp(SCREEN* sp, wchar_t *ch); int extended_color_content_sp(SCREEN * sp, int color, int * r, int * g, int * b); int extended_pair_content_sp(SCREEN* sp, int pair, int * fg, int * bg); int extended_slk_color_sp(SCREEN* sp, int pair); void filter_sp(SCREEN* sp); int find_pair_sp(SCREEN* sp, int fg, int bg); int flash_sp(SCREEN* sp); int flushinp_sp(SCREEN* sp); int free_pair_sp(SCREEN* sp, int pair); int get_escdelay_sp(SCREEN* sp); int getmouse_sp(SCREEN* sp, MEVENT* event); WINDOW* getwin_sp(SCREEN* sp, FILE* filep); int halfdelay_sp(SCREEN* sp, int tenths); bool has_colors_sp(SCREEN* sp); bool has_ic_sp(SCREEN* sp); bool has_il_sp(SCREEN* sp); int has_key_sp(SCREEN* sp, int ch); bool has_mouse_sp(SCREEN* sp); int init_color_sp(SCREEN* sp, short color, short r, short g, short b); int init_extended_color_sp(SCREEN* sp, int color, int r, int g, int b); int init_extended_pair_sp(SCREEN* sp, int pair, int fg, int bg); int init_pair_sp(SCREEN* sp, short pair, short fg, short bg); int intrflush_sp(SCREEN* sp, WINDOW* win, bool bf); bool is_term_resized_sp(SCREEN* sp, int lines, int columns); bool isendwin_sp(SCREEN* sp); int key_defined_sp(SCREEN* sp, const char *definition); char* keybound_sp(SCREEN* sp, int keycode, int count); NCURSES_CONST char * keyname_sp(SCREEN* sp, int c); int keyok_sp(SCREEN* sp, int keycode, bool enable); char killchar_sp(SCREEN* sp); int killwchar_sp(SCREEN* sp, wchar_t *ch); char* longname_sp(SCREEN* sp); int mcprint_sp(SCREEN* sp, char *data, int len); int mouseinterval_sp(SCREEN* sp, int erval); mmask_t mousemask_sp(SCREEN* sp, mmask_t newmask, mmask_t *oldmask); int mvcur_sp(SCREEN* sp, int oldrow, int oldcol, int newrow, int newcol); int napms_sp(SCREEN* sp, int ms); WINDOW* newpad_sp(SCREEN* sp, int nrows, int ncols); SCREEN* new_prescr(void); SCREEN* newterm_sp(SCREEN* sp, const char *type, FILE *outfd, FILE *infd); WINDOW* newwin_sp(SCREEN* sp, int nlines, int ncols, int begin_y, int begin_x); int nl_sp(SCREEN* sp); int nocbreak_sp(SCREEN* sp); int noecho_sp(SCREEN* sp); void nofilter_sp(SCREEN* sp); int nonl_sp(SCREEN* sp); void noqiflush_sp(SCREEN* sp); int noraw_sp(SCREEN* sp); int pair_content_sp(SCREEN* sp, short pair, short* fg, short* bg); void qiflush_sp(SCREEN* sp); int raw_sp(SCREEN* sp); int reset_prog_mode_sp(SCREEN* sp); void reset_color_pairs_sp(SCREEN* sp); int reset_shell_mode_sp(SCREEN* sp); int resetty_sp(SCREEN* sp); int resize_term_sp(SCREEN* sp, int lines, int columns); int resizeterm_sp(SCREEN* sp, int lines, int columns); int ripoffline_sp(SCREEN* sp, int line, int (*init)(WINDOW* win, int fmt)); int savetty_sp(SCREEN* sp); int scr_init_sp(SCREEN* sp, const char *filename); int scr_restore_sp(SCREEN* sp, const char *filename); int scr_set_sp(SCREEN* sp, const char *filename); int set_escdelay_sp(SCREEN* sp, int ms); int set_tabsize_sp(SCREEN* sp, int cols); int slk_attr_set_sp(SCREEN* sp, const attr_t attrs, short pair, void*opts); int slk_attrset_sp(SCREEN* sp, const chtype a); int slk_attroff_sp(SCREEN* sp, const chtype a); int slk_attron_sp(SCREEN* sp, const chtype a); attr_t slk_attr_sp(SCREEN* sp); int slk_clear_sp(SCREEN* sp); int slk_color_sp(SCREEN* sp, short pair); int slk_init_sp(SCREEN* sp, int fmt); char* slk_label_sp(SCREEN* sp, int labnum); int slk_noutrefresh_sp(SCREEN* sp); int slk_refresh_sp","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:51:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"termattrs #include \u003ccurses.h\u003e int baudrate(void); char erasechar(void); int erasewchar(wchar_t *ch); bool has_ic(void); bool has_il(void); char killchar(void); int killwchar(wchar_t *ch); char *longname(void); attr_t term_attrs(void); chtype termattrs(void); char *termname(void); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:52:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"termcap #include \u003ccurses.h\u003e #include \u003cterm.h\u003e extern char PC; extern char * UP; extern char * BC; extern short ospeed; int tgetent(char *bp, const char *name); int tgetflag(const char *id); int tgetnum(const char *id); char *tgetstr(const char *id, char **area); char *tgoto(const char *cap, int col, int row); int tputs(const char *str, int affcnt, int (*putc)(int)); 这些例程是作为使用termcap库的程序的转换辅助而包含的。它们的参数是相同的，但是这些例程是使用terminfo数据库模拟的。因此，它们只能用于查询已经编译了terminfo条目的条目的功能。 ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:53:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"terminfo #include \u003ccurses.h\u003e #include \u003cterm.h\u003e TERMINAL *cur_term; const char * const boolnames[]; const char * const boolcodes[]; const char * const boolfnames[]; const char * const numnames[]; const char * const numcodes[]; const char * const numfnames[]; const char * const strnames[]; const char * const strcodes[]; const char * const strfnames[]; int setupterm(const char *term, int filedes, int *errret); TERMINAL *set_curterm(TERMINAL *nterm); int del_curterm(TERMINAL *oterm); int restartterm(const char *term, int filedes, int *errret); char *tparm(const char *str, ...); int tputs(const char *str, int affcnt, int (*putc)(int)); int putp(const char *str); int vidputs(chtype attrs, int (*putc)(int)); int vidattr(chtype attrs); int vid_puts(attr_t attrs, short pair, void *opts, int (*putc)(int)); int vid_attr(attr_t attrs, short pair, void *opts); int mvcur(int oldrow, int oldcol, int newrow, int newcol); int tigetflag(const char *capname); int tigetnum(const char *capname); char *tigetstr(const char *capname); char *tiparm(const char *str, ...); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:54:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"threads #include \u003ccurses.h\u003e typedef int (*NCURSES_WINDOW_CB)(WINDOW *, void *); typedef int (*NCURSES_SCREEN_CB)(SCREEN *, void *); int get_escdelay(void); int set_escdelay(int ms); int set_tabsize(int cols); int use_screen(SCREEN *scr, NCURSES_SCREEN_CB func, void *data); int use_window(WINDOW *win, NCURSES_WINDOW_CB func, void *data); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:55:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"touch #include \u003ccurses.h\u003e int touchline(WINDOW *win, int start, int count); int touchwin(WINDOW *win); int wtouchln(WINDOW *win, int y, int n, int changed); int untouchwin(WINDOW *win); bool is_linetouched(WINDOW *win, int line); bool is_wintouched(WINDOW *win); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:56:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"trace #include \u003ccurses.h\u003e unsigned curses_trace(const unsigned param); void _tracef(const char *format, ...); char *_traceattr(attr_t attr); char *_traceattr2(int buffer, chtype ch); char *_tracecchar_t(const cchar_t *string); char *_tracecchar_t2(int buffer, const cchar_t *string); char *_tracechar(int ch); char *_tracechtype(chtype ch); char *_tracechtype2(int buffer, chtype ch); void _tracedump(const char *label, WINDOW *win); char *_nc_tracebits(void); char *_tracemouse(const MEVENT *event); /* deprecated */ void trace(const unsigned int param); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:57:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"util #include \u003ccurses.h\u003e const char *unctrl(chtype c); wchar_t *wunctrl(cchar_t *c); const char *keyname(int c); const char *key_name(wchar_t w); void filter(void); void nofilter(void); void use_env(bool f); void use_tioctl(bool f); int putwin(WINDOW *win, FILE *filep); WINDOW *getwin(FILE *filep); int delay_output(int ms); int flushinp(void); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:58:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"variables #include \u003ccurses.h\u003e int COLOR_PAIRS; int COLORS; int COLS; int ESCDELAY; int LINES; int TABSIZE; WINDOW* curscr; WINDOW* newscr; WINDOW* stdscr; ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:59:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"window #include \u003ccurses.h\u003e WINDOW *newwin(int nlines, int ncols, int begin_y, int begin_x); int delwin(WINDOW *win); int mvwin(WINDOW *win, int y, int x); WINDOW *subwin(WINDOW *orig, int nlines, int ncols, int begin_y, int begin_x); WINDOW *derwin(WINDOW *orig, int nlines, int ncols, int begin_y, int begin_x); int mvderwin(WINDOW *win, int par_y, int par_x); WINDOW *dupwin(WINDOW *win); void wsyncup(WINDOW *win); int syncok(WINDOW *win, bool bf); void wcursyncup(WINDOW *win); void wsyncdown(WINDOW *win); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:60:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"default_color #include \u003ccurses.h\u003e int use_default_colors(void); int assume_default_colors(int fg, int bg); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:61:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"define_key #include \u003ccurses.h\u003e int define_key(const char *definition, int keycode); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:62:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_cursor #include \u003cform.h\u003e int pos_form_cursor(FORM *form); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:63:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_data #include \u003cform.h\u003e bool data_ahead(const FORM *form); bool data_behind(const FORM *form); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:64:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_driver #include \u003cform.h\u003e int form_driver(FORM *form, int c); int form_driver_w(FORM *form, int c, wchar_t wch); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:65:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_field_attributes #include \u003cform.h\u003e int set_field_fore(FIELD *field, chtype attr); chtype field_fore(const FIELD *field); int set_field_back(FIELD *field, chtype attr); chtype field_back(const FIELD *field); int set_field_pad(FIELD *field, int pad); int field_pad(const FIELD *field); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:66:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_field_buffer #include \u003cform.h\u003e int set_field_buffer(FIELD *field, int buf, const char *value); char *field_buffer(const FIELD *field, int buffer); int set_field_status(FIELD *field, bool status); bool field_status(const FIELD *field); int set_max_field(FIELD *field, int max); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:67:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_field_info #include \u003cform.h\u003e int field_info(const FIELD *field, int *rows, int *cols, int *frow, int *fcol, int *nrow, int *nbuf); int dynamic_field_info(const FIELD *field, int *rows, int *cols, int *max); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:68:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_field_just #include \u003cform.h\u003e int set_field_just(FIELD *field, int justification); int field_just(const FIELD *field); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:69:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_field_new #include \u003cform.h\u003e FIELD *new_field(int height, int width, int toprow, int leftcol, int offscreen, int nbuffers); FIELD *dup_field(FIELD *field, int toprow, int leftcol); FIELD *link_field(FIELD *field, int toprow, int leftcol); int free_field(FIELD *field); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:70:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_field_opts #include \u003cform.h\u003e int set_field_opts(FIELD *field, Field_Options opts); Field_Options field_opts(const FIELD *field); int field_opts_on(FIELD *field, Field_Options opts); int field_opts_off(FIELD *field, Field_Options opts); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:71:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_field_userptr #include \u003cform.h\u003e int set_field_userptr(FIELD *field, void *userptr); void *field_userptr(const FIELD *field); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:72:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_field_validation #include \u003cform.h\u003e void *field_arg(const FIELD *field); FIELDTYPE *field_type(const FIELD *field); int set_field_type(FIELD *field, FIELDTYPE *type, ...); /* predefined field types */ FIELDTYPE *TYPE_ALNUM; FIELDTYPE *TYPE_ALPHA; FIELDTYPE *TYPE_ENUM; FIELDTYPE *TYPE_INTEGER; FIELDTYPE *TYPE_NUMERIC; FIELDTYPE *TYPE_REGEXP; FIELDTYPE *TYPE_IPV4; ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:73:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_field #include \u003cform.h\u003e int set_form_fields(FORM *form, FIELD **fields); FIELD **form_fields(const FORM *form); int field_count(const FORM *form); int move_field(FIELD *field, int frow, int fcol); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:74:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_fieldtype #include \u003cform.h\u003e FIELDTYPE *new_fieldtype(bool (* const field_check)(FIELD *, const void *), bool (* const char_check)(int, const void *)); int free_fieldtype(FIELDTYPE *fieldtype); int set_fieldtype_arg(FIELDTYPE *fieldtype, void *(* const make_arg)(va_list *), void *(* const copy_arg)(const void *), void (* const free_arg)(void *)); int set_fieldtype_choice(FIELDTYPE *fieldtype, bool (* const next_choice)(FIELD *, const void *), bool (* const prev_choice)(FIELD *, const void *)); FIELDTYPE *link_fieldtype(FIELDTYPE *type1, FIELDTYPE *type2); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:75:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_hook #include \u003cform.h\u003e int set_field_init(FORM *form, Form_Hook func); Form_Hook field_init(const FORM *form); int set_field_term(FORM *form, Form_Hook func); Form_Hook field_term(const FORM *form); int set_form_init(FORM *form, Form_Hook func); Form_Hook form_init(const FORM *form); int set_form_term(FORM *form, Form_Hook func); Form_Hook form_term(const FORM *form); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:76:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_new_page #include \u003cform.h\u003e int set_new_page(FIELD *field, bool new_page_flag); bool new_page(const FIELD *field); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:77:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_new #include \u003cform.h\u003e FORM *new_form(FIELD **fields); int free_form(FORM *form); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:78:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_opts #include \u003cform.h\u003e int set_form_opts(FORM *form, Field_Options opts); Field_Options form_opts(const FORM *form); int form_opts_on(FORM *form, Field_Options opts); int form_opts_off(FORM *form, Field_Options opts); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:79:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_page #include \u003cform.h\u003e int set_current_field(FORM *form, FIELD *field); FIELD *current_field(const FORM *form); int unfocus_current_field(FORM *form); int set_form_page(FORM *form, int n); int form_page(const FORM *form); int field_index(const FIELD *field); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:80:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_post #include \u003cform.h\u003e int post_form(FORM *form); int unpost_form(FORM *form); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:81:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_requestname #include \u003cform.h\u003e const char *form_request_name(int request); int form_request_by_name(const char *name); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:82:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_userptr #include \u003cform.h\u003e int set_form_userptr(FORM *form, void *userptr); void* form_userptr(const FORM *form); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:83:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_variables #include \u003cform.h\u003e FIELDTYPE* TYPE_ALNUM; FIELDTYPE* TYPE_ALPHA; FIELDTYPE* TYPE_ENUM; FIELDTYPE* TYPE_INTEGER; FIELDTYPE* TYPE_IPV4; FIELDTYPE* TYPE_NUMERIC; FIELDTYPE* TYPE_REGEXP; ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:84:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"form_win #include \u003cform.h\u003e int set_form_win(FORM *form, WINDOW *win); WINDOW *form_win(const FORM *form); int set_form_sub(FORM *form, WINDOW *sub); WINDOW *form_sub(const FORM *form); int scale_form(const FORM *form, int *rows, int *columns); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:85:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"key_Defined #include \u003ccurses.h\u003e int key_defined(const char *definition); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:86:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"keybound #include \u003ccurses.h\u003e char* keybound(int keycode, int count); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:87:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"keyok #include \u003ccurses.h\u003e int keyok(int keycode, bool enable); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:88:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"legacy_coding #include \u003ccurses.h\u003e int use_legacy_coding(int level); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:89:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_attributes #include \u003cmenu.h\u003e int set_menu_fore(MENU *menu, chtype attr); chtype menu_fore(const MENU *menu); int set_menu_back(MENU *menu, chtype attr); chtype menu_back(const MENU *menu); int set_menu_grey(MENU *menu, chtype attr); chtype menu_grey(const MENU *menu); int set_menu_pad(MENU *menu, int pad); int menu_pad(const MENU *menu); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:90:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_cursor #include \u003cmenu.h\u003e int pos_menu_cursor(const MENU *menu); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:91:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_driver #include \u003cmenu.h\u003e int menu_driver(MENU *menu, int c); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:92:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_format #include \u003cmenu.h\u003e int set_menu_format(MENU *menu, int rows, int cols); void menu_format(const MENU *menu, int *rows, int *cols); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:93:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_hook #include \u003cmenu.h\u003e int set_item_init(MENU *menu, Menu_Hook func); Menu_Hook item_init(const MENU *menu); int set_item_term(MENU *menu, Menu_Hook func); Menu_Hook item_term(const MENU *menu); int set_menu_init(MENU *menu, Menu_Hook func); Menu_Hook menu_init(const MENU *menu); int set_menu_term(MENU *menu, Menu_Hook func); Menu_Hook menu_term(const MENU *menu); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:94:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_items #include \u003cmenu.h\u003e int set_menu_items(MENU *menu, ITEM **items); ITEM **menu_items(const MENU *menu); int item_count(const MENU *menu); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:95:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_mark #include \u003cmenu.h\u003e int set_menu_mark(MENU *menu, const char *mark); const char *menu_mark(const MENU *menu); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:96:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_new #include \u003cmenu.h\u003e MENU *new_menu(ITEM **items); int free_menu(MENU *menu); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:97:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_opts #include \u003cmenu.h\u003e int set_menu_opts(MENU *menu, Menu_Options opts); Menu_Options menu_opts(const MENU *menu); int menu_opts_on(MENU *menu, Menu_Options opts); int menu_opts_off(MENU *menu, Menu_Options opts); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:98:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_pattern #include \u003cmenu.h\u003e int set_menu_pattern(MENU *menu, const char *pattern); char *menu_pattern(const MENU *menu); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:99:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_post #include \u003cmenu.h\u003e int post_menu(MENU *menu); int unpost_menu(MENU *menu); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:100:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_requestname #include \u003cmenu.h\u003e const char *menu_request_name(int request); int menu_request_by_name(const char *name); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:101:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_spacing #include \u003cmenu.h\u003e int set_menu_spacing(MENU *menu, int spc_description, int spc_rows, int spc_columns); int menu_spacing(const MENU *menu, int* spc_description, int* spc_rows, int* spc_columns); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:102:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_userptr #include \u003cmenu.h\u003e int set_menu_userptr(MENU *menu, void *userptr); void *menu_userptr(const MENU *menu); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:103:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"menu_win #include \u003cmenu.h\u003e int set_menu_win(MENU *menu, WINDOW *win); WINDOW *menu_win(const MENU *menu); int set_menu_sub(MENU *menu, WINDOW *sub); WINDOW *menu_sub(const MENU *menu); int scale_menu(const MENU *menu, int *rows, int *columns); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:104:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"mitem_current #include \u003cmenu.h\u003e int set_current_item(MENU *menu, ITEM *item); ITEM *current_item(const MENU *menu); int set_top_row(MENU *menu, int row); int top_row(const MENU *menu); int item_index(const ITEM *item); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:105:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"mitem_name #include \u003cmenu.h\u003e const char *item_name(const ITEM *item); const char *item_description(const ITEM *item); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:106:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"mitem_new #include \u003cmenu.h\u003e ITEM *new_item(const char *name, const char *description); int free_item(ITEM *item); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:107:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"mitem_opts #include \u003cmenu.h\u003e int set_item_opts(ITEM *item, Item_Options opts); Item_Options item_opts(const ITEM *item); int item_opts_on(ITEM *item, Item_Options opts); int item_opts_off(ITEM *item, Item_Options opts); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:108:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"mitem_userptr #include \u003cmenu.h\u003e int set_item_userptr(ITEM *item, void *userptr); void *item_userptr(const ITEM *item); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:109:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"mitem_value #include \u003cmenu.h\u003e int set_item_value(ITEM *item, bool value); bool item_value(const ITEM *item); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:110:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"mitem_visible #include \u003cmenu.h\u003e bool item_visible(const ITEM *item); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:111:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"new_pair #include \u003ccurses.h\u003e int alloc_pair(int fg, int bg); int find_pair(int fg, int bg); int free_pair(int pair); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:112:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"panel #include \u003cpanel.h\u003e cc [flags] sourcefiles -lpanel -lncurses PANEL *new_panel(WINDOW *win); int bottom_panel(PANEL *pan); int top_panel(PANEL *pan); int show_panel(PANEL *pan); void update_panels(void); int hide_panel(PANEL *pan); WINDOW *panel_window(const PANEL *pan); int replace_panel(PANEL *pan, WINDOW *window); int move_panel(PANEL *pan, int starty, int startx); int panel_hidden(const PANEL *pan); PANEL *panel_above(const PANEL *pan); PANEL *panel_below(const PANEL *pan); int set_panel_userptr(PANEL *pan, const void *ptr); const void *panel_userptr(const PANEL *pan); int del_panel(PANEL *pan); /* ncurses-extensions */ PANEL *ground_panel(SCREEN *sp); PANEL *ceiling_panel(SCREEN *sp); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:113:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"resizeterm #include \u003ccurses.h\u003e bool is_term_resized(int lines, int columns); int resize_term(int lines, int columns); int resizeterm(int lines, int columns); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:114:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"term_variables #include \u003ccurses.h\u003e #include \u003cterm.h\u003e chtype acs_map[]; SCREEN * SP; TERMINAL * cur_term; char ttytype[]; NCURSES_CONST char * const boolcodes[]; NCURSES_CONST char * const boolfnames[]; NCURSES_CONST char * const boolnames[]; NCURSES_CONST char * const numcodes[]; NCURSES_CONST char * const numfnames[]; NCURSES_CONST char * const numnames[]; NCURSES_CONST char * const strcodes[]; NCURSES_CONST char * const strfnames[]; NCURSES_CONST char * const strnames[]; ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:115:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"wresize #include \u003ccurses.h\u003e int wresize(WINDOW *win, int lines, int columns); ","date":"2023-02-06","objectID":"/2023/02/0003-ncurses-api/:116:0","tags":["ncurses"],"title":"ncurses API","uri":"/2023/02/0003-ncurses-api/"},{"categories":["ncurses","linux"],"content":"ncurses 与 curses ncurses 完全兼容旧的 curses，它们表示同一个函数库 ","date":"2023-02-05","objectID":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/:0:1","tags":["ncurses"],"title":"ncurses使用中需要明确的点","uri":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/"},{"categories":["ncurses","linux"],"content":"initscr() 初始化终端，清空屏幕，为 当前窗口(stdscr) 和其它数据结构分配内存。 ","date":"2023-02-05","objectID":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/:0:2","tags":["ncurses"],"title":"ncurses使用中需要明确的点","uri":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/"},{"categories":["ncurses","linux"],"content":"refresh() 对stdscr任何操作都是对屏幕缓存的操作，只有执行 refresh() 之后才把绘制结果显示到屏幕。 ","date":"2023-02-05","objectID":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/:0:3","tags":["ncurses"],"title":"ncurses使用中需要明确的点","uri":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/"},{"categories":["ncurses","linux"],"content":"endwin() 释放 curses 子系统及其数据结构占用的内存，并将终端置于正常模式。不调用并结束进程会导致终端显示异常。 ","date":"2023-02-05","objectID":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/:0:4","tags":["ncurses"],"title":"ncurses使用中需要明确的点","uri":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/"},{"categories":["ncurses","linux"],"content":"raw()和cbreak() 执行后，用户的每个输入都会被传递给程序，否则直到用户输入回车才传递给程序。 ","date":"2023-02-05","objectID":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/:0:5","tags":["ncurses"],"title":"ncurses使用中需要明确的点","uri":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/"},{"categories":["ncurses","linux"],"content":"echo()和noecho() noecho() 用于控制回显，不执行则用户每次输入会立刻显示到当前(x，y)座标 ","date":"2023-02-05","objectID":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/:0:6","tags":["ncurses"],"title":"ncurses使用中需要明确的点","uri":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/"},{"categories":["ncurses","linux"],"content":"keypad() 用于初始化读取功能键 ","date":"2023-02-05","objectID":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/:0:7","tags":["ncurses"],"title":"ncurses使用中需要明确的点","uri":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/"},{"categories":["ncurses","linux"],"content":"halfdelay() 等待用户输入过程时可以超时返回。 ","date":"2023-02-05","objectID":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/:0:8","tags":["ncurses"],"title":"ncurses使用中需要明确的点","uri":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/"},{"categories":["ncurses","linux"],"content":"getch() 用于获取用户输入的一个字符 ","date":"2023-02-05","objectID":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/:0:9","tags":["ncurses"],"title":"ncurses使用中需要明确的点","uri":"/2023/02/0002-ncurses%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E7%82%B9/"},{"categories":["linux","uos"],"content":"需求背景 近来我做的项目需要在 UOS 文件管理器右键菜单添加几个菜单项，后来通过公司找到 UOS 同事，他们提供了两种解决方案给我且都可满足需求。本文接下来将描述这两种实现方案 ","date":"2023-02-04","objectID":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/:1:0","tags":["linux","uos","menu","菜单"],"title":"UOS添加菜单项","uri":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/"},{"categories":["linux","uos"],"content":"通过配置文件方式添加菜单项 详细文档可参看：https://developer.chinauos.com/#/pages/document/info?id=ae53aada-100b-498c-ba02-b905fa3cf9ed\u0026admin= 在此我提供一个简单的例子，配置文件的方式相对比较简单 创建文件 ‘menu.desktop’ 并写入如下内容： [Desktop Entry] Type=Application Name=Test Name[zh_CN]=测试 Exec=/bin/xdg-open %F 把 ‘menu.desktop’ 复制到 ‘/usr/share/deepin/dde-file-manager/oem-menuextensions/’ 安装 xautomation 软件包 重启机器，启动后在桌面上选中文件并右键菜单即可看到菜单中添加了 测试 这一选项。 这种方式扩展可满足绝大部分需求，我考虑过有一种使用场景是无法满足的：当需要根据选中文件的内容判断菜单项中是否需要显示指定菜单项目这一需求时候，通过这一方式无法实现。 但是显然这种使用场景很少，大多数场景都是根据文件扩展名来做判断 当然这种方式优势也很明显，哪怕插件接口改变也不会影响功能正常使用 ","date":"2023-02-04","objectID":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/:2:0","tags":["linux","uos","menu","菜单"],"title":"UOS添加菜单项","uri":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/"},{"categories":["linux","uos"],"content":"通过插件的方式扩展 UOS 文件管理器的插件机制是由文件管理器提供一个扩展库 libdfm-extension.so 来提供接口，这是一个纯 C/C++ 接口的库。第三方开发者通过加载该扩展库，按照文管提供的标准来调用和实现相应接口，共同完成定制需求的功能扩展。 ","date":"2023-02-04","objectID":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/:3:0","tags":["linux","uos","menu","菜单"],"title":"UOS添加菜单项","uri":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/"},{"categories":["linux","uos"],"content":"dde-file-manager第三方插件加载流程 在文件管理器启动时，会去检测目录 /usr/lib/[arch]/dde-file-manager/plugins/extensions 下的所有文件（其中 [arch] 代表平台架构，如 ARM64 下为 aarch64-linux-gnu，AMD 64下为 x86_64-linux-gnu）， 并检测是否是一个正常的动态库文件，如果是则尝试加载，因此第三方开发者应该将扩展插件安装到此目录下。如果加载成功，文管将会检查扩展插件是否实现了相应的元接口，如果通过了检查，文管将与第三方扩展插件开始正常业务交互。 ","date":"2023-02-04","objectID":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/:3:1","tags":["linux","uos","menu","菜单"],"title":"UOS添加菜单项","uri":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/"},{"categories":["linux","uos"],"content":"接口列表 这里列出文管提供的所有接口，其中元接口是 C ⻛格的接口，右键菜单和⻆标展示是通过 C++ 类接口进行实现的。 元接口 接口定义在头文件 dfm-extension.h 中，第三方开发者需要自行创建 C++ 源码文件实现接口，当前元接口定义如下： extern \"C\" void dfm_extension_initialize(); extern \"C\" void dfm_extension_shutdown(); extern \"C\" DFMExtMenuPlugin *dfm_extension_menu(); extern \"C\" DFMExtEmblemIconPlugin *dfm_extension_emblem(); 名称 简介 dfm_extension_initialize 插件初始化入口函数，插件被加载后将首先调用它 dfm_extension_shutdown 插件释放的函数，当插件被卸载前将会调用它 dfm_extension_menu 返回右键菜单扩展对象的函数，该对象的类由第三方开发者实现 dfm_extension_emblem 返回⻆标对象的函数，该对象的类由第三方开发者实现 类接口 由于此扩展方式提供了共享库 libdfm-extension.so，因此为了避免 ABI 兼容性的问题，以下 C++ 类接口采用了pimpl 技法隐藏类属性，采用 std::function ＋ std::bind 来替代虚函数（伪虚函数）。 【伪虚函数】 与普通的 C++ 接口类不同的是，普通的 C++ 接口类通常在基类使用虚函数定义可重写的接口，派生类继承进行实现。而在 dfm-extension 中的，使用了宏来“标记“接口是一个可重写的接口（伪虚函数），定义在一个全局的头文件头文件 dfm-extension-global.h 中： // 仅用于标记，没有具体意义 #define DFM_FAKE_VIRTUAL #define DFM_FAKE_OVERRIDE 宏 DFM_FAKE_VIRTUAL （伪虚函数）用来标记它是第三方开发者应该去注册的接口函数，开发者也可以在派生类用 DFM_FAKE_OVERRIDE 来标记将要 bind 的方法。 角标 DFMExtEmblemIconPlugin DFMExtEmblemIconPlugin 类是第三方开发者应该继承并实现的接口类，并且在元接口 dfm_extension_emblem 中返回派生的类对象，接口定义在头文件 dfmextemblemiconplugin.h 中。需要特别注意的是，需要提前将⻆标资源图片文件安装到系统主题中，规则遵循 freedesktop 规范。 class DFMExtEmblemIconPluginPrivate; class DFMExtEmblemIconPlugin { DFM_DISABLE_COPY(DFMExtEmblemIconPlugin) public: using IconsType = std::vector\u003cstd::string\u003e; using EmblemIcons = std::function\u003cIconsType(const std::string \u0026)\u003e; using LocationEmblemIcons = std::function\u003cDFMExtEmblem(const std::string \u0026, int)\u003e; public: DFMExtEmblemIconPlugin(); ~DFMExtEmblemIconPlugin(); // Note: If the corner mark set by emblemIcons conflicts with the corner mark position // set by locationEmblemIcons, the conflict position will only display the corner mark set by locationEmblemIcons DFM_FAKE_VIRTUAL IconsType emblemIcons(const std::string \u0026fileUrl) const; void registerEmblemIcons(const EmblemIcons \u0026func); DFM_FAKE_VIRTUAL DFMExtEmblem locationEmblemIcons(const std::string \u0026fileUrl, int systemIconCount) const; void registerLocationEmblemIcons(const LocationEmblemIcons \u0026func); private: DFMExtEmblemIconPluginPrivate *d { nullptr }; }; 接口说明： emblemIcons 和 registerEmblemIcons 是旧接口，locationEmblemIcons 和 registerLocationEmblemIcons 可以代替 名称 简介 emblemIcons 文管主动调用，传入文件路径，返回被安装的⻆标图片名称列表 registerEmblemIcons emblemIcons␁接口的注册函数，第三方开发者主动注册 locationEmblemIcons 文管主动调用，传入文件路径和这个文件的现有系统⻆标数量，如果这个值达到了4，那么就位置绘制扩展⻆标了 registerLocationEmblemIcons locationEmblemIcons␁接口的注册函数，第三方开发者主动注册 DFMExtEmblemIconLayout 扩展角标布局信息，描述一个角标位置和角标图片路径 class DFMExtEmblemIconLayoutPrivate; class DFMExtEmblemIconLayout { friend class DFMExtEmblemIconLayoutPrivate; public: enum class LocationType : uint8_t { BottomRight = 0, BottomLeft, TopLeft, TopRight, Custom = 0xff }; explicit DFMExtEmblemIconLayout(LocationType type, const std::string \u0026path, int x = 0, int y = 0); ~DFMExtEmblemIconLayout(); DFMExtEmblemIconLayout(const DFMExtEmblemIconLayout \u0026emblem); DFMExtEmblemIconLayout \u0026operator=(const DFMExtEmblemIconLayout \u0026emblem); LocationType locationType() const; std::string iconPath() const; int x() const; int y() const; private: DFMExtEmblemIconLayoutPrivate *d { nullptr }; }; 接口说明： 名称 简介 locationType 需要第三方开发者返回⻆标的位置信息，目前有␁LocationType␁的␁4␁个位置，custom 暂时未使用 iconPath 需要第三方开发者返回返回⻆标图片路径的字符串 x 预留接口，暂时未实现 y 预留接口，暂时未实现 DFMExtEmblem ⻆标操作对象类，管理一个文件扩展⻆标的所有布局信息。 class DFMExtEmblemPrivate; class DFMExtEmblem { friend class DFMExtEmblemPrivate; public: explicit DFMExtEmblem(); ~DFMExtEmblem(); DFMExtEmblem(const DFMExtEmblem \u0026emblem); DFMExtEmblem \u0026operator=(const DFMExtEmblem \u0026emblem); void setEmblem(const std::vector\u003cDFMExtEmblemIconLayout\u003e \u0026iconPaths); std::vector\u003cDFMExtEmblemIconLayout\u003e emblems() const; private: DFMExtEmblemPrivate *d { nullptr }; }; 接口说明 名称 简介 setEmblem 需要第三方开发者自行设置一个⻆标␁Layout␁信息，最多支持␁4␁个 emblems 返回␁setEmblem␁设置的␁Layout␁信息 右键菜单 DFMExtMenuPlugin DFMExtMenuPlugin 是第三方开发者应该继承并实现的接口类，并且在元接口 dfm_extension_menu 中返回派生的类对象，接口定义在头文件 dfmextmenuplugin.h 中： class DFMExtMenuPlugin { DFM_DISABLE_COPY(DFMExtMenuPlugin) public: using InitializeFunc = std::function\u003cvo","date":"2023-02-04","objectID":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/:3:2","tags":["linux","uos","menu","菜单"],"title":"UOS添加菜单项","uri":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/"},{"categories":["linux","uos"],"content":"dde-file-manager插件扩展示例 1. 安装依赖 libdde-file-manager-dev cmake pkg-config libfm-extension 2. cmake配置 cmake_minimum_required(VERSION 2.8) #设置项目名称 project(dfmextension-demo) #启用 pkg-config 标准 find_package(PkgConfig REQUIRED) #只需要依赖 dfm-extension pkg_search_module(dfm-extension REQUIRED dfm-extension IMPORTED_TARGET ) #扩展插件源码 set(SRCS demomenuplugin.h demomenuplugin.cpp) #生成共享库 add_library(${PROJECT_NAME} SHARED ${SRCS}) target_link_libraries(${PROJECT_NAME} PkgConfig::dfm-extension) #安裝配置 include(GNUInstallDirs) set(LIB_INSTALL_DIR /usr/lib/${CMAKE_LIBRARY_ARCHITECTURE}/dde-file-manager/plugins/extensions) #安裝插件 install(TARGETS ${PROJECT_NAME} LIBRARY DESTINATION ${LIB_INSTALL_DIR}) 3. 实现元接口 在这里新建.cpp文件 dfm-extension.cpp 实现元接口： static DFMExtMenuPlugin *kMenuPlugin = nullptr; extern \"C\" void dfm_extension_initiliaze() { if (!kMenuPlugin) kMenuPlugin = new ICBCMenuPlugin; } extern \"C\" DFMExtMenuPlugin *dfm_extension_menu() { return kMenuPlugin; } extern \"C\" void dfm_extension_shutdown() { if (kMenuPlugin) { delete kMenuPlugin; kMenuPlugin = nullptr; } } 需要特别注意的是，需要在接口前添加 extern “C” ，否则文管将无法解析出接口。 3. 实现相关类接口 继承右键菜单插件的基类 DFMExtMenuPlugin 进行实现： icbcmenuplugin.h class ICBCMenuPlugin: public DFMEXT::DFMExtMenuPlugin { public: ICBCMenuPlugin(); void initilaize(DFMEXT::DFMExtMenuProxy *proxy) DFM_FAKE_OVERRIDE; bool buildNormalMenu(DFMEXT::DFMExtMenu *main, const std::list\u003cstd::string\u003e \u0026urlList, const std::string \u0026currentUrl, const std::string \u0026focusUrl, bool onDesktop) DFM_FAKE_OVERRIDE; bool buildEmptyAreaMenu(DFMEXT::DFMExtMenu *main, const std::string \u0026currentUrl, bool onDesktop) DFM_FAKE_OVERRIDE; void hoverd(DFMEXT::DFMExtAction *action); private: DFMEXT::DFMExtMenuProxy *menuProxy = nullptr; }; icbcmenuplugin.cpp #include \"icbcmenuplugin.h\" #include \u003cmenu/dfmextmenu.h\u003e #include \u003cmenu/dfmextmenuproxy.h\u003e #include \u003cmenu/dfmextaction.h\u003e #include \u003ciostream\u003e #include \u003cfunctional\u003e #include \u003cunistd.h\u003e void ICBCMenuPlugin::hoverd(DFMEXT::DFMExtAction *action) { std::cout \u003c\u003c \"hover!!!!!!!!!!\" \u003c\u003c std::endl; auto top = action-\u003emenu(); if (top-\u003eactions().empty()) { sleep(1); auto a1 = menuProxy-\u003ecreateAction(); a1-\u003esetText(\"nihao\"); top-\u003eaddAction(a1); auto a2 = menuProxy-\u003ecreateAction(); a2-\u003esetText(\"no hao\"); top-\u003eaddAction(a2); } } ICBCMenuPlugin::ICBCMenuPlugin() : DFMEXT::DFMExtMenuPlugin() { registerInitialize(std::bind(\u0026ICBCMenuPlugin::initilaize, this, std::placeholders::_1)); registerBuildNormalMenu(std::bind(\u0026ICBCMenuPlugin::buildNormalMenu, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4)); registerBuildEmptyAreaMenu(std::bind(\u0026ICBCMenuPlugin::buildEmptyAreaMenu, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)); } void ICBCMenuPlugin::initilaize(DFMEXT::DFMExtMenuProxy *proxy) { std::cout \u003c\u003c \"ICBCMenuPlugin::initilaize\" \u003c\u003c std::endl; menuProxy = proxy; } bool ICBCMenuPlugin::buildNormalMenu(DFMEXT::DFMExtMenu *main, const std::list\u003cstd::string\u003e \u0026urlList, const std::string \u0026currentUrl, const std::string \u0026focusUrl, bool onDesktop) { std::cout \u003c\u003c \"ICBCMenuPlugin::buildNormalMenu\" \u003c\u003c std::endl; if (main == nullptr) return false; auto top = menuProxy-\u003ecreateMenu(); //top-\u003eregisterHovered(std::bind(\u0026hoverd,std::placeholders::_1)); auto ac = menuProxy-\u003ecreateAction(); ac-\u003esetMenu(top); ac-\u003esetText(\"wps\"); ac-\u003eregisterHovered(std::bind(\u0026ICBCMenuPlugin::hoverd,this,std::placeholders::_1)); main-\u003eaddAction(ac); for (auto ac : main-\u003eactions()) { std::cout \u003c\u003c \"ssss :\" \u003c\u003c ac-\u003etext() \u003c\u003c std::endl; } //todo 释放 return true; } bool ICBCMenuPlugin::buildEmptyAreaMenu(DFMEXT::DFMExtMenu *main, const std::string \u0026currentUrl, bool onDesktop) { std::cout \u003c\u003c \"ICBCMenuPlugin::buildEmptyAreaMenu\" \u003c\u003c std::endl; return false; } https://wikidev.uniontech.com/index.php?title=文管扩展开发\u0026oldid=52343 ","date":"2023-02-04","objectID":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/:3:3","tags":["linux","uos","menu","菜单"],"title":"UOS添加菜单项","uri":"/2023/02/0013-uos%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9/"},{"categories":["linux"],"content":"ALSA是什么 ALSA(Advanced Linux Sound Architecture)是linux上主流的音频结构，提供了对音频和MIDI的支持，在没有出现ALSA架构之前，一直使用OSS(Open Sound System)音频架构。 Linux 2.6 内核之前使用 OSS 音频架构，之后使用 ALSA 音频架构 ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:1:0","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"ALSA 主要特点 支持多种声卡设备 模块化的内核驱动程序 支持SMP(对称多处理)和多线程 提供应用程序开发函数库 兼容 OSS 有用程序 ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:1:1","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"ALSA 与 OSS 对比 以下是关于OSS和ALSA的对比： OSS和ALSA对比 主要的区别就是在OSS架构下，App访问底层是直接通过Sound设备节点访问的。而在ALSA音频架构下，App是通过ALSA提供的alsa-lib库访问底层硬件的操作，不再访问Sound设备节点了。这样做的好处可以简化App实现的难度。 ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:1:2","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"ALSA 兼容 OSS ALSA为了兼容OSS，ALSA提供了内核模块来模拟OSS声音驱动，所以在OSS架构下编写的App无需修改就可以在ALSA下运行。另外libaoos库也可以模拟OSS，无需OSS相关的内核模块。 ALSA兼容OSS ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:1:3","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"ALSA 系统架构 ALSA系统架构 User空间：主要由Alsa Libray API对应用程序提供统一的API接口，各个APP应用程序只要调用 alsa-lib 提供的 API接口来实现放音、录音、控制。现在提供了两套基本的库，tinyalsa是一个简化的alsa-lib库，现在Android的系统中主要使用它。 ALSA CORE：alsa 核心层，向上提供逻辑设备（PCM/CTL/MIDI/TIMER/…）系统调用，向下驱动硬件设备（Machine/I2S/DMA/CODEC） ASOC Core：是 ALSA 的标准框架，是 ALSA-driver 的核心部分，提供了各种音频设备驱动的通用方法和数据结构，为 Audio driver提供 ALSA Driver API Hardware Driver：音频硬件设备驱动，由三大部分组成，分别是 Machine、Platform、Codec，提供的 ALSA Driver API 和相应音频设备的初始化及工作流程，实现具体的功能组件，这也是驱动开发人员需要具体实现的部分。 https://alsa.opensrc.org/ ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:1:4","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"ALSA 相关工具 alsa utils 是一组小型且强大的有用程序，旨在允许用户控制 ALSA 系统的各个部分。 alsactl 用来保存设备设置的方法 amixer 允许调整设备的音量和声音控制的命令行工具 alsamixer 是 amixer 的命令行版本 acconnect 和 aseqview 应用程序用于进行 MIDI 连接和查看连接端口列表 aply 和 arecord 用于命令行回放和记录许多文件类型，包括 raw、wave、aiff采样率、位深等 ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:2:0","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"如何使用 ALSA Audio 接口 翻译自 http://equalarea.com/paul/alsa-audio.html 本文档试图提供ALSA音频API的介绍。 它不是一个完整的API参考手册，它没有涵盖许多更复杂的软件需要解决的具体问题，它仅仅试图为一个相当熟练的程序员提供足够的背景和信息， ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:3:0","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"理解音频接口 让我们首先回顾一下音频接口的基本设计。作为应用程序开发人员，您不需要担心这种级别的操作——它全部由设备驱动程序处理(这是ALSA提供的组件之一)。但是如果您想要编写高效且灵活的软件，您确实需要了解概念层面上的情况。 音频接口是一种允许计算机从外部世界接收和发送音频数据的设备。在计算机内部，音频数据表示为比特流。然而，音频接口可以以模拟信号(时变电压)或数字信号(一些比特流)的形式发送和接收音频。在任何一种情况下，计算机用来表示特定声音的一组位在被传送到外部世界之前都需要转换，同样，接口接收到的外部信号在对计算机有用之前也需要转换。这两种转换是音频接口存在的原因。 在音频接口中有一个称为“硬件缓冲区”的区域。当外部世界的音频信号到达时，接口将其转换为计算机可用的比特流，并将其存储在用于向计算机发送数据的部件硬件缓冲区中。当它在硬件缓冲区中收集了足够的数据时，接口中断计算机，告诉它已经为它准备好了数据。当数据从计算机发送到外部世界时，同样的过程反过来也会发生。接口中断计算机，告诉它硬件缓冲区中有空间，计算机继续在那里存储数据。接口稍后将这些位转换成所需的任何形式，以便将其传递给外部世界，并将其传递。理解接口使用这个缓冲区作为“循环缓冲区”是非常重要的。当它到达缓冲区的末尾时，它继续绕到开头。 为了使这个过程正确工作，需要配置许多变量。它们包括: 在计算机使用的比特流和外界使用的信号之间进行转换时，接口应该使用什么格式? 音频数据在接口和计算机之间传输的速率是多少? 当计算机设备发生中断前，应该有多少数据(或存储空间)? 硬件缓冲区应该有多大? 前两个问题是控制音频数据质量的基础。后两个问题会影响音频信号的“延迟”。 来自外部世界的数据到达音频接口，并且它对计算机可用(“输入延迟”) 前两个问题是控制音频数据质量的基础据由计算机传送，并被传送到外部世界(“输出延迟”) 这两点对于许多类型的音频软件都是非常重要的，尽管有些程序不需要涉及这些问题。 ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:3:1","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"典型的音频应用程序是做什么的 一个典型的音频应用程序有这样的粗略结构: open_the_device(); set_the_parameters_of_the_device(); while (!done) { /* one or both of these */ receive_audio_data_from_the_device(); deliver_audio_data_to_the_device(); } close the device ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:3:2","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"一个最小的后台播放程序 该程序打开一个音频接口播放，配置为立体声，16位，44.1kHz，交错常规读/写访问。然后它向它发送一组随机数据，然后退出。它代表了ALSA Audio API最简单的可能用法，并不是一个真正的程序。 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003calsa/asoundlib.h\u003e int main (int argc, char *argv[]) { int i; int err; short buf[128]; snd_pcm_t *playback_handle; snd_pcm_hw_params_t *hw_params; //if ((err = snd_pcm_open (\u0026playback_handle, argv[1], SND_PCM_STREAM_PLAYBACK, 0)) \u003c 0) { if ((err = snd_pcm_open (\u0026playback_handle, \"default\", SND_PCM_STREAM_PLAYBACK, 0)) \u003c 0) { fprintf (stderr, \"cannot open audio device 'default' (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params_malloc (\u0026hw_params)) \u003c 0) { fprintf (stderr, \"cannot allocate hardware parameter structure (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params_any (playback_handle, hw_params)) \u003c 0) { fprintf (stderr, \"cannot initialize hardware parameter structure (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params_set_access (playback_handle, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED)) \u003c 0) { fprintf (stderr, \"cannot set access type (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params_set_format (playback_handle, hw_params, SND_PCM_FORMAT_S16_LE)) \u003c 0) { fprintf (stderr, \"cannot set sample format (%s)\\n\", snd_strerror (err)); exit (1); } unsigned int rate = 44100; if ((err = snd_pcm_hw_params_set_rate_near (playback_handle, hw_params, \u0026rate, 0)) \u003c 0) { fprintf (stderr, \"cannot set sample rate (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params_set_channels (playback_handle, hw_params, 2)) \u003c 0) { fprintf (stderr, \"cannot set channel count (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params (playback_handle, hw_params)) \u003c 0) { fprintf (stderr, \"cannot set parameters (%s)\\n\", snd_strerror (err)); exit (1); } snd_pcm_hw_params_free (hw_params); if ((err = snd_pcm_prepare (playback_handle)) \u003c 0) { fprintf (stderr, \"cannot prepare audio interface for use (%s)\\n\", snd_strerror (err)); exit (1); } for (i = 0; i \u003c 10; ++i) { if ((err = snd_pcm_writei (playback_handle, buf, 128)) != 128) { fprintf (stderr, \"write to audio interface failed (%s)\\n\", snd_strerror (err)); exit (1); } } snd_pcm_close (playback_handle); exit (0); } 下面这个程序打开一个音频接口进行捕获，配置为立体声，16位，44.1kHz，交错常规读/写访问。然后它从中读取一组随机数据，然后退出。这并不是一个真正的程序。 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003calsa/asoundlib.h\u003e int main (int argc, char *argv[]) { int i; int err; short buf[128]; snd_pcm_t *capture_handle; snd_pcm_hw_params_t *hw_params; if ((err = snd_pcm_open (\u0026capture_handle, \"default\", SND_PCM_STREAM_CAPTURE, 0)) \u003c 0) { fprintf (stderr, \"cannot open audio device 'default' (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params_malloc (\u0026hw_params)) \u003c 0) { fprintf (stderr, \"cannot allocate hardware parameter structure (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params_any (capture_handle, hw_params)) \u003c 0) { fprintf (stderr, \"cannot initialize hardware parameter structure (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params_set_access (capture_handle, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED)) \u003c 0) { fprintf (stderr, \"cannot set access type (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params_set_format (capture_handle, hw_params, SND_PCM_FORMAT_S16_LE)) \u003c 0) { fprintf (stderr, \"cannot set sample format (%s)\\n\", snd_strerror (err)); exit (1); } unsigned int rate = 44100; if ((err = snd_pcm_hw_params_set_rate_near (capture_handle, hw_params, \u0026rate, 0)) \u003c 0) { fprintf (stderr, \"cannot set sample rate (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params_set_channels (capture_handle, hw_params, 2)) \u003c 0) { fprintf (stderr, \"cannot set channel count (%s)\\n\", snd_strerror (err)); exit (1); } if ((err = snd_pcm_hw_params (capture_handle, hw_params)) \u003c 0) { fprintf (stderr, \"cannot set parameters (%s)\\n\", snd_strerror (err)); exit (1); } snd_pcm_hw_params_free (hw_params); if ((err = snd_pcm_prepare (capture_handle)) \u003c 0) {","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:3:3","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"一些术语 术语 解释 capture 从外部世界接收数据(与“记录”不同，“记录”意味着将数据存储在某个地方，并且不是ALSA API的一部分) playback 向外部世界传递数据(尽管不一定)，以便能够被听到。 duplex 捕获和回放同时发生在同一界面上的一种情况。 xrun 一旦音频接口开始运行，它就会继续运行，直到被告知停止。它将生成数据供计算机使用和/或将数据从计算机发送到外部世界。由于各种原因，您的程序可能跟不上它。对于回放，这可能导致接口需要来自计算机的新数据，但它不存在，迫使它使用遗留在硬件缓冲区中的旧数据。这就是所谓的“欠压”。为了捕获，接口可能有数据要传递给计算机，但没有地方存储这些数据，因此它必须覆盖硬件缓冲区中包含计算机尚未接收到的数据的部分。这就是所谓的“泛滥”。为简单起见，我们使用通用术语“xrun”来指代这两种情况 PCM 脉冲编码调制。这个短语(和首字母缩写词)描述了用数字形式表示模拟信号的一种方法。它是几乎被计算机音频接口使用的方法，在ALSA API中用作“音频”的缩写。 channel frame 采样是描述音频信号在单个声道上的单个时间点的振幅的单个值。当我们谈论使用数字音频时，我们经常想要谈论在单个时间点上表示所有频道的数据。这是一个样本的集合，每个通道一个，通常称为“帧”。当我们以框架的形式讨论时间的流逝时，它大致相当于人们以样本的形式测量的时间，但更准确;更重要的是，当我们讨论在一个时间点上表示所有通道所需的数据量时，它是唯一有意义的单位。几乎每个ALSA Audio API函数都使用帧作为数据量的度量单位。 interleaved 一种数据布局安排，其中将在同一时间播放的每个通道的样本按顺序相互跟随。参见“non-interleaved” non-interleaved 一种数据布局，其中单个通道的样本按顺序相互跟随;另一个通道的样本要么在另一个缓冲区中，要么在该缓冲区的另一部分中。与\"interleaves\"形成对比 sample clock 一种计时源，用于标记样品应该发送/接收到外部世界的时间。有些音频接口允许你使用外部采样时钟，要么是“文字时钟”信号(通常用于许多工作室)，要么是“自动同步”(使用传入数字数据中的时钟信号)。所有音频接口都至少有一个样本时钟源，该时钟源存在于接口本身，通常是一个小晶体时钟。有些接口不允许改变时钟的速率，有些接口的时钟实际上并不能精确地以您期望的速率运行(44.1kHz等)。没有两个样本时钟可以被期望以完全相同的速率运行——如果你需要两个样本流保持彼此同步，它们必须从同一个样本时钟运行。 ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:3:4","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"API使用流程 打开设备 设置参数 硬件参数 采样率：如果接口有模拟I/O，则控制A/D/D/A转换的速率。对于全数字接口，它控制用于将数字音频数据移动到/从外部世界的时钟的速度。在某些接口上，其他特定于设备的配置可能意味着您的程序不能控制这个值(例如，当接口被告知使用外部字时钟源来确定采样率时)。 格式：它控制用于向接口传输数据和从接口传输数据的格式。它可能与硬件直接支持的格式对应，也可能不对应。 通道数： 数据访问与布局：这控制程序从接口传递/接收数据的方式。有两个参数由4个可能的设置控制。其中一个参数是是否使用“读/写”模型，即使用显式函数调用来传输数据。这里的另一个选项是使用“mmap模式”，在这种模式下，数据是通过在内存区域之间复制来传输的，API调用只需要注意它开始和结束的时间。另一个参数是数据布局是交错的还是非交错的。 中断时间间隔：这决定了接口每次对其硬件缓冲区的完整遍历将产生多少中断。它可以通过指定周期大小的一些周期来设置。因为这决定了在接口中断计算机之前必须积累的空间/数据帧数。它是控制延迟的核心。 缓冲区大小：这决定了硬件缓冲区的大小。它可以以时间或帧为单位指定。 软件参数(这些参数控制设备驱动程序的操作，而不是硬件本身。大多数使用ALSA音频API的程序不需要设置这些;少数将需要设置它们的子集。) 何时启动设备：当您打开音频接口时，ALSA确保它不是活动的-没有数据被移动到或从它的外部连接器。可以推测，在某个时刻，您希望数据传输开始。有几种方法可以实现这一目标。这里的控制点是开始阈值，它定义了自动启动设备所需的空间/数据帧数。如果设置为播放的某个值而不是0，则有必要在设备启动之前预填充播放缓冲区。如果设置为0，第一次写入设备的数据(或第一次尝试从捕获流读取数据)将启动设备。您还可以显式地使用snd_pcm_start启动设备，但是在播放流的情况下，这需要缓冲区预填充。如果尝试不这样做就启动流，则会得到-EPIPE作为返回代码，表示没有数据等待传递到回放硬件缓冲区。 如何处理 xruns：如果发生了xrun，设备驱动程序可能会根据请求采取某些步骤来处理它。选项包括停止设备，或静音用于回放的全部或部分硬件缓冲区。 停止阈值：如果可用的数据/空间帧数达到或超过这个值，驱动程序将停止接口。 沉默阈值：如果一个回放流的可用空间帧数达到或超过这个值，驱动程序将用静默填充部分回放硬件缓冲区。 沉默值大小：当满足静默阈值水平时，这将决定有多少静默帧被写入回放硬件缓冲区 可用于唤醒的最小空间/数据帧数：使用poll(2)或select(2)来确定音频数据何时可以传输到接口或从接口传输的程序可以将此设置为控制相对于硬件缓冲区的状态，它们希望在哪个点被唤醒。 传输块大小：这决定了从设备硬件缓冲区传输数据时使用的帧数。 还有一些其他的软件参数，但在这里不需要考虑。 ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:3:5","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"ALSA API ALSA 提供了 Kernel API 和 库API，本文当描述了库 API 以及它如何与内核 API 交互。 应用程序程序员应该使用库API而不是内核API。该库提供了内核API的100%功能，但在可用性方面进行了重大改进，使应用程序代码更简单、更美观。此外，将来的修复程序或兼容性代码可能会放在库代码中，而不是放在内核驱动程序中。 ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:4:0","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"API 链接 页面控件接口解释了基本控件API 基本控件插件解释了基本控件插件的设计 高级控件接口解释了高级原语控件API 页面混合器接口解释了混合器控件API PCM(数字音频)接口页面解释了PCM(数字音频)API的设计 PCM(数字音频)插件页面解释了PCM(数字音频)插件的设计 Page PCM External Plugin SDK介绍了外部PCM插件SDK Page ctl_external_plugins解释了外部控制插件SDK 页面RawMidi接口说明了RawMidi API的设计 Page Timer接口解释了Timer API的设计 Page Sequencer界面解释了Sequencer API的设计 页面用例接口解释用例API Page ALSA Topology Interface解释了DSP拓扑API ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:4:1","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["linux"],"content":"配置 Page Configuration文件解释了库配置的语法 配置文件中的Page运行时参数解释运行时参数语法 配置文件中的运行时函数页解释了运行时函数的定义及其用法 配置文件中的Page hook解释了运行时钩子的定义及其用法 页面用例配置解释了UCM配置和它们的用法 ","date":"2023-01-28","objectID":"/2023/01/0012-alsa/:4:2","tags":["linux","alsa","music","sound"],"title":"Linux音频体系结构——ALSA","uri":"/2023/01/0012-alsa/"},{"categories":["ncurses"],"content":"简介 在电传终端的旧时代，终端远离计算机，通过串行电缆与计算机连接。终端可以通过发送一系列字节来配置。终端的所有功能(如移动光标到一个新的位置，擦除屏幕的一部分，滚动屏幕，改变模式等)都可以通过这一系列字节访问。这些控制序列通常被称为转义序列，因为它们以一个转义(0x1B)字符开始。即使在今天，通过适当的模拟，我们也可以向模拟器发送转义序列，并在终端窗口上实现相同的效果。 假设你想用彩色打印一行。试着在控制台上输入如下代码： echo \"^[[0;31;40mIn Color\" 第一个字符是转义字符，看起来像两个字符^和[。要打印它，你必须按CTRL+V，然后按ESC键。所有其他字符都是正常的可打印字符。你应该可以看到字符串“In Color”是红色的。它保持这种方式，并恢复到原始模式键入这个。 echo \"^[[0;37;40m\" 现在，这些神奇的字符是什么意思?难以理解?对于不同的终端，它们甚至可能是不同的。 因此UNIX的设计者发明了一种名为termcap的机制。它是一个列出特定终端的所有功能的文件，以及实现特定效果所需的转义序列。 在后来的几年里，这被terminfo所取代。这种机制允许应用程序查询terminfo数据库并获得要发送到终端或终端模拟器的控制字符，而无需深入研究太多细节。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:1:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"ncurses 是什么? 在上面的场景中，每个应用程序都应该查询terminfo并执行必要的操作(发送控制字符等)。 很快就很难管理这种复杂性，这就产生了“CURSES”。 Curses是“游标优化”名称的双关语。 Curses库在使用原始终端代码时形成了一个包装器，并提供了高度灵活和高效的API(应用程序编程接口)。 它提供了移动光标，创建窗口，产生颜色，玩鼠标等功能。应用程序不需要担心底层终端功能。 什么是NCURSES? NCURSES是原System V Release 4.0 (SVr4) curses的克隆。 它是一个可自由分发的库，完全兼容旧版本的curses。 简而言之，它是一个函数库，用于管理应用程序在字符单元终端上的显示。在该文件的其余部分，术语curses和ncurses互换使用。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:1:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"使用ncurses可以做什么? NCURSES不仅在终端功能上创建了一个包装器，而且还提供了一个健壮的框架，以文本模式创建漂亮的UI(用户界面)。 它提供了创建窗口等功能。它的姐妹库 panel，menu 和forms提供了一个扩展库。可以创建包含多个窗口、菜单、面板和表单的应用程序。窗口可以独立管理，可以提供“可滚动性”，甚至可以隐藏。 菜单为用户提供了一个简单的命令选择选项。表单允许创建易于使用的数据输入和显示窗口。面板扩展了ncurses处理重叠和堆叠窗口的能力。 这些只是我们可以用ncurses做的一些基本事情。随着我们的前进，我们将看到这些库的所有功能。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:1:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"项目结构 ncurses | |----\u003e JustForFun -- just for fun programs |----\u003e basics -- basic programs |----\u003e demo -- output files go into this directory after make | | | |----\u003e exe -- exe files of all example programs |----\u003e forms -- programs related to form library |----\u003e menus -- programs related to menus library |----\u003e panels -- programs related to panels library |----\u003e perl -- perl equivalents of the examples (contributed | by Anuradha Ratnaweera) |----\u003e Makefile -- the top level Makefile |----\u003e README -- the top level README file. contains instructions |----\u003e COPYING -- copyright notice 文件详细信息 Description of files in each directory -------------------------------------- JustForFun | |----\u003e hanoi.c -- The Towers of Hanoi Solver |----\u003e life.c -- The Game of Life demo |----\u003e magic.c -- An Odd Order Magic Square builder |----\u003e queens.c -- The famous N-Queens Solver |----\u003e shuffle.c -- A fun game, if you have time to kill |----\u003e tt.c -- A very trivial typing tutor basics | |----\u003e acs_vars.c -- ACS_ variables example |----\u003e hello_world.c -- Simple \"Hello World\" Program |----\u003e init_func_example.c -- Initialization functions example |----\u003e key_code.c -- Shows the scan code of the key pressed |----\u003e mouse_menu.c -- A menu accessible by mouse |----\u003e other_border.c -- Shows usage of other border functions apa | -- rt from box() |----\u003e printw_example.c -- A very simple printw() example |----\u003e scanw_example.c -- A very simple getstr() example |----\u003e simple_attr.c -- A program that can print a c file with | -- comments in attribute |----\u003e simple_color.c -- A simple example demonstrating colors |----\u003e simple_key.c -- A menu accessible with keyboard UP, DOWN | -- arrows |----\u003e temp_leave.c -- Demonstrates temporarily leaving curses mode |----\u003e win_border.c -- Shows Creation of windows and borders |----\u003e with_chgat.c -- chgat() usage example forms | |----\u003e form_attrib.c -- Usage of field attributes |----\u003e form_options.c -- Usage of field options |----\u003e form_simple.c -- A simple form example |----\u003e form_win.c -- Demo of windows associated with forms menus | |----\u003e menu_attrib.c -- Usage of menu attributes |----\u003e menu_item_data.c -- Usage of item_name() etc.. functions |----\u003e menu_multi_column.c -- Creates multi columnar menus |----\u003e menu_scroll.c -- Demonstrates scrolling capability of menus |----\u003e menu_simple.c -- A simple menu accessed by arrow keys |----\u003e menu_toggle.c -- Creates multi valued menus and explains | -- REQ_TOGGLE_ITEM |----\u003e menu_userptr.c -- Usage of user pointer |----\u003e menu_win.c -- Demo of windows associated with menus panels | |----\u003e panel_browse.c -- Panel browsing through tab. Usage of user | -- pointer |----\u003e panel_hide.c -- Hiding and Un hiding of panels |----\u003e panel_resize.c -- Moving and resizing of panels |----\u003e panel_simple.c -- A simple panel example perl |----\u003e 01-10.pl -- Perl equivalents of first ten example programs ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:1:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"Hello World #include \u003cncurses.h\u003e int main() { initscr(); /* Start curses mode */ printw(\"Hello World !!!\"); /* Print Hello World */ refresh(); /* Print it on to the real screen */ getch(); /* Wait for user input */ endwin(); /* End curses mode */ return 0; } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:2:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"代码分析 initscr() 函数initscr()以curses模式初始化终端。 在某些实现中，它会清除屏幕并显示空白屏幕。 要做任何屏幕操作使用ncurses这必须首先被调用。 这个函数初始化curses系统，并为当前窗口(称为stdscr)和其他一些数据结构分配内存。 在极端情况下，由于没有足够的内存为curses库的数据结构分配内存，该函数可能会失败。 完成此操作后，我们可以进行各种初始化以自定义curses设置。这些细节将在后面解释。 refresh() 下一行printw将字符串“Hello World !!”打印到屏幕上。 这个函数在各个方面都类似于普通的printf，除了它在一个名为stdscr的窗口上打印当前(y,x)坐标上的数据。 由于我们当前的坐标是0,0，字符串被打印在窗口的左上角。 这就引出了神秘的refresh()。 当我们调用printw时，数据实际上被写入了一个假想的窗口，这个窗口还没有在屏幕上更新。 printw的任务是更新一些标志和数据结构，并将数据写入与stdscr对应的缓冲区。 为了在屏幕上显示它，我们需要调用refresh()并告诉curses系统将内容转储到屏幕上。 这一切背后的理念是允许程序员在想象的屏幕或窗口上进行多次更新，并在所有屏幕更新完成后进行刷新。 refresh()检查窗口并仅更新已更改的部分。这提高了性能并提供了更大的灵活性。 但是，初学者有时会感到沮丧。初学者常犯的一个错误是在通过printw()类函数进行更新后忘记调用refresh()。我有时还是会忘记加上它:-) endwin() 最后别忘了结束ncurses模式。否则，在程序退出后，您的终端可能会表现异常。 endwin()释放curses子系统及其数据结构占用的内存，并将终端置于正常模式。此函数必须在使用curses模式后调用。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:2:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"ncurses 初始化 现在我们知道，要初始化curses系统，必须调用函数initscr()。在初始化之后，可以调用一些函数来定制curses会话。我们可以要求curses系统将终端设置为原始模式或初始化颜色或初始化鼠标等。让我们讨论一些通常在initscr()之后立即调用的函数; ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:3:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"raw() 和 cbreak() 通常，终端驱动程序会缓冲用户输入的字符，直到遇到新的行或回车。但是大多数程序都要求用户在输入字符时就可以使用这些字符。以上两个功能用于禁用行缓冲。 这两个函数之间的区别在于传递给程序的控制字符，如暂停(CTRL-Z)、中断和退出(CTRL-C)。 在raw()模式下，这些字符直接传递给程序而不生成信号。 在cbreak()模式下，终端驱动程序将这些控制字符解释为任何其他字符。 我个人更喜欢使用raw()，因为我可以更好地控制用户的操作。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:3:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"echo() 和 noecho() 这些函数控制用户输入的字符到终端的回显。 noecho()关闭回声，这样做的原因可能是为了获得对回显的更多控制，或者在通过getch()等函数从用户获取输入时抑制不必要的回显。 大多数交互式程序在初始化时调用noecho()，并以受控的方式进行字符回显。它使程序员能够灵活地在窗口的任何位置回显字符，而无需更新当前(y,x)坐标。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:3:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"keypad() 这是我最喜欢的初始化函数。它可以读取功能键，如F1, F2，方向键等。 几乎每个交互程序都支持这一点，因为方向键是任何用户界面的主要部分。 执行 keypad(stdscr, TRUE) 在常规屏幕(stdscr)上启用此功能。在本文档后面的部分中，您将了解有关按键管理的更多信息。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:3:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"halfdelay() 这个函数虽然不常用，但有时很有用。调用halfdelay()来启用半延迟模式，它类似于cbreak()模式，输入的字符立即可用于程序。 但是，如果没有可用的输入，它会等待’X’十分之一秒来输入，然后返回ERR。‘X’是传递给函数halfdelay()的超时值。 当你想让用户输入，如果他在一定时间内没有回应，这个函数是有用的，我们可以做一些其他的事情。一个可能的例子是密码提示处的超时。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:3:4","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"getch() 函数getch()用于从user获取一个字符。它相当于普通的getchar()。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:3:5","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"Windows 简介 在我们深入研究无数ncurses函数之前，让我先澄清一些关于窗口的事情。下面几节将详细解释Windows。 窗口是由curses系统定义的假想屏幕。窗口并不意味着通常在Win9X平台上看到的有边框的窗口。 当curses初始化时，它会创建一个名为stdscr的默认窗口，该窗口表示您的80x25(或您正在运行的窗口的大小)屏幕。 如果你正在做一些简单的任务，比如打印一些字符串，读取输入等，你可以安全地使用这个窗口来完成所有的任务。您还可以创建窗口并调用显式工作在指定窗口上的函数。 printw(\"Hi There !!!\"); refresh(); 它打印stdscr上当前光标位置的字符串。类似地，对refresh()的调用仅适用于stdscr。 假设你已经创建了窗口，那么你必须调用一个函数，在通常的函数中添加一个’w’。 wprintw(win, \"Hi There !!!\"); wrefresh(win); 正如您将在文档的其余部分看到的，函数的命名遵循相同的约定。每个函数通常有三个以上的函数。 printw(string); /* Print on stdscr at present cursor position */ mvprintw(y, x, string);/* Move to (y, x) then print string */ wprintw(win, string); /* Print on window win at present cursor position */ /* in the window */ mvwprintw(win, y, x, string); /* Move to (y, x) relative to window */ /* co-ordinates and then print */ 通常w-less函数是宏，它以stdscr作为窗口参数展开为相应的w-function。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:4:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"输出函数 至此ncurses初始化完成，接下来让我们完成一些交互工作。 你可以使用三类函数在屏幕上进行输出。 addch()：打印带有属性的单个字符 printw()：类似printf()一样的格式化输出 addstr()：打印字符串 这些函数可以互换使用，使用哪个类只是风格问题。让我们详细看看每一个。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:5:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"addch() 这些函数将单个字符放入当前光标位置，并向前移动光标的位置。您可以指定要打印的字符，但它们通常用于打印具有某些属性的字符。属性将在文档后面的部分中详细解释。如果一个字符与一个属性相关联(粗体，反向视频等)，当curses打印该字符时，它将被打印在该属性中。 为了将一个字符与某些属性结合起来，你有两个选择: 通过将单个字符与所需的属性宏进行OR运算。这些属性宏可以在头文件ncurses.h中找到。例如，你想打印一个字符ch(char类型)加粗加下划线，你可以调用addch()，如下所示。 addch(ch | A_BOLD | A_UNDERLINE); 通过使用attrset()、attron()、attrff()等函数。属性部分解释了这些函数。简单地说，它们操作给定窗口的当前属性。设置完成后，打印在窗口中的字符将与属性相关联，直到将其关闭。 此外，curses为基于字符的图形提供了一些特殊字符。你可以画表格、水平线或垂直线等。您可以在头文件ncurses.h中找到所有可用的字符。尝试在这个文件中寻找以ACS_开头的宏。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:5:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"mvaddch(), waddch()和mvwaddch() mvaddch()用于将光标移动到给定点，然后打印。例子: move(row,col); /* moves the cursor to rowth row and colth column */ addch(ch); 可以被替换为： mvaddch(row, col, ch); Waddch()与addch()类似，只是它将一个字符添加到给定的窗口中。(注意addch()将一个字符添加到窗口stdscr中。) 以类似的方式使用mvwaddch()函数将字符添加到给定坐标的给定窗口中。 现在，我们已经熟悉了基本的输出函数addch()。但是，如果我们想打印一个字符串，一个字符一个字符地打印是很烦人的。幸运的是，ncurses提供了类似printf或类似put的函数。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:5:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"printw() 这些函数类似于printf()，只不过增加了在屏幕上任何位置打印的功能。 printw()和mvprintw() 这两个函数的工作原理很像printf()。Mvprintw()可以用来移动光标到一个位置，然后打印。如果你想先移动光标，然后使用printw()函数打印，先使用move()，然后使用printw()，尽管我不明白为什么应该避免使用mvprintw()，你可以灵活操作。 wprintw()和mvwprintw() 这两个函数与上面两个函数相似，除了它们打印在作为参数给定的相应窗口中。 vwprintw() 这个函数类似于vprintf()。当要打印可变数量的参数时，可以使用此方法。 例子 #include \u003cncurses.h\u003e /* ncurses.h includes stdio.h */ #include \u003cstring.h\u003e int main() { char mesg[]=\"Just a string\"; /* message to be appeared on the screen */ int row, col; /* to store the number of rows and * * the number of colums of the screen */ initscr(); /* start the curses mode */ getmaxyx(stdscr, row, col); /* get the number of rows and columns */ mvprintw(row / 2, (col-strlen(mesg)) / 2, \"%s\", mesg); /* print the message at the center of the screen */ mvprintw(row-2, 0, \"This screen has %d rows and %d columns\\n\", row, col); printw(\"Try resizing your window(if possible) and then run this program again\"); refresh(); getch(); endwin(); return 0; } 上面的程序演示了使用printw是多么容易。您只需输入坐标和要显示在屏幕上的消息，然后它就会执行您想要的操作。 上面的程序向我们介绍了一个新函数getmaxyx()，它是在ncurses.h中定义的宏。它给出了给定窗口中的列数和行数。 getmaxyx()通过更新给定的变量来实现这一点。因为getmaxyx()不是一个函数，我们不向它传递指针，我们只给出两个整数变量。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:5:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"addstr() addstr()用于将字符串放入给定的窗口中。这个函数类似于为给定字符串中的每个字符调用一次addch()。对于所有输出函数都是如此。这个家族中还有其他函数，如mvaddstr()，mvwaddstr()和waddstr()，它们遵循curses的命名约定。mvaddstr()类似于分别调用move()和addstr()。这个家族的另一个函数是addnstr()，它额外接受一个整数形参(比如n)。这个函数最多在屏幕上放置n个字符。如果n为负，则整个字符串将被添加。 注意： 所有这些函数的参数都先取y坐标，然后取x坐标。 初学者常犯的一个错误是按这个顺序传递x和y。如果你对(y,x)坐标做了太多的操作，考虑把屏幕分成几个窗口，然后分别操作每个窗口。窗口将在窗口一节中进行解释。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:5:4","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"输入函数 没有输入的打印是很无聊的。让我们看看允许我们从用户那里获取输入的函数。这些功能也可以分为三类。 getch()：输入一个字符 scanw()：格式化输入 getstr()：输入一个字符串 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:6:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"getch() 这些函数从终端读取单个字符。 但有几个微妙的事实需要考虑。例如，如果不使用函数cbreak()，curses将不会连续读取输入字符，而是在遇到新行或EOF后才开始读取它们。为了避免这种情况，必须使用cbreak()函数，以便程序可以立即使用字符。 另一个广泛使用的函数是noecho()。顾名思义，当这个函数被设置(使用)时，用户输入的字符将不会显示在屏幕上。两个函数cbreak()和noecho()是密钥管理的典型示例。密钥管理部分解释了这种类型的功能。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:6:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"scanw() 这些函数类似于scanf()，只不过增加了从屏幕上任何位置获取输入的功能。 scanw() 和 mvscanw() 这些函数的用法类似于sscanf()，其中要扫描的行是由wgetstr()函数提供的。也就是说，这些函数调用wgetstr()函数(下面解释)并使用结果行进行扫描。 wscanw() 和 mvwscanw() 这些函数类似于上面两个函数，除了它们从窗口读取，而窗口是作为这些函数的参数之一提供的。 vwscanw() 这个函数类似于vscanf()。当要扫描的参数数量可变时，可以使用这种方法。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:6:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"getstr() 这些函数用于从终端获取字符串。本质上，这个函数执行的任务与一系列调用getch()所实现的任务相同，直到接收到换行符、回车符或文件结束符。生成的字符字符串由str指向，str是用户提供的字符指针。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:6:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"例子 #include \u003cncurses.h\u003e /* ncurses.h includes stdio.h */ #include \u003cstring.h\u003e int main() { char mesg[]=\"Just a string\"; /* message to be appeared on the screen */ int row, col; /* to store the number of rows and * * the number of colums of the screen */ initscr(); /* start the curses mode */ getmaxyx(stdscr, row, col); /* get the number of rows and columns */ mvprintw(row / 2, (col-strlen(mesg)) / 2, \"%s\", mesg); /* print the message at the center of the screen */ mvprintw(row-2, 0, \"This screen has %d rows and %d columns\\n\", row, col); printw(\"Try resizing your window(if possible) and then run this program again\"); refresh(); getch(); endwin(); return 0; } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:6:4","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"属性 我们已经看到了如何使用属性打印具有某些特殊效果的字符的示例。如果谨慎地设置属性，可以以简单、可理解的方式显示信息。下面的程序以一个C文件作为输入，并打印带有粗体注释的文件。扫描代码。 例子 #include \u003cncurses.h\u003e #include \u003cstdlib.h\u003e int main(int argc, char *argv[]) { int ch, prev, row, col; prev = EOF; FILE *fp; int y, x; if(argc != 2) { printf(\"Usage: %s \u003ca c file name\u003e\\n\", argv[0]); exit(1); } fp = fopen(argv[1], \"r\"); if(fp == NULL) { perror(\"Cannot open input file\"); exit(1); } initscr(); /* Start curses mode */ getmaxyx(stdscr, row, col); /* find the boundaries of the screeen */ while ((ch = fgetc(fp)) != EOF) { /* read the file till we reach the end */ getyx(stdscr, y, x); /* get the current curser position */ if(y == (row - 1)) { /* are we are at the end of the screen */ printw(\"\u003c-Press Any Key-\u003e\"); /* tell the user to press a key */ getch(); clear(); /* clear the screen */ move(0, 0); /* start at the beginning of the screen */ } if(prev == '/' \u0026\u0026 ch == '*') { /* If it is / and * then only switch bold on */ attron(A_BOLD); /* cut bold on */ getyx(stdscr, y, x); /* get the current curser position */ move(y, x - 1); /* back up one space */ printw(\"%c%c\", '/', ch); /* The actual printing is done here */ } else { printw(\"%c\", ch); } refresh(); if(prev == '*' \u0026\u0026 ch == '/') { attroff(A_BOLD); /* Switch it off once we got and then */ } prev = ch; } endwin(); /* End curses mode */ fclose(fp); return 0; } 不要担心所有那些初始化和其他废话。专注于while循环。它读取文件中的每个字符并搜索模式/*。一旦它发现了模式，就会使用attron()打开BOLD属性。当我们得到模式*/时，它被attroff()关闭。 上面的程序还介绍了两个有用的函数getyx()和move()。第一个函数将当前光标的坐标转换为变量y, x。由于getyx()是一个宏，我们不必将指针传递给变量。函数move()将光标移动到给定的坐标。 上面的程序实际上是一个简单的程序，它没有做很多事情。在这些行中，我们可以编写一个更有用的程序，它可以读取C文件，解析它，并以不同的颜色打印它。人们甚至可以将其扩展到其他语言。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:7:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"属性细节 让我们更详细地了解属性。函数attron()、attroff()、attrset()以及它们的姐妹函数attr_get()等。可用于打开/关闭属性，获取属性并产生彩色显示。 函数attron和attroff接受属性的位掩码，并分别打开或关闭它们。下面定义在\u003ccurses.h\u003e中的视频属性可以传递给这些函数。 A_NORMAL Normal display (no highlight) A_STANDOUT Best highlighting mode of the terminal. A_UNDERLINE Underlining A_REVERSE Reverse video A_BLINK Blinking A_DIM Half bright A_BOLD Extra bright or bold A_PROTECT Protected mode A_INVIS Invisible or blank mode A_ALTCHARSET Alternate character set A_CHARTEXT Bit-mask to extract a character COLOR_PAIR(n) Color-pair number n 最后一个是最丰富多彩的一个:-)颜色将在下一节中解释。 我们可以OR(|)以上任意数量的属性来获得组合效果。如果你想用闪烁字符反向视频，你可以使用： attron(A_REVERSE | A_BLINK); ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:7:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"attron()和attrset() 那么attron()和attrset()有什么区别呢? attrset设置窗口的属性，而attron只是打开给定的属性。因此attrset()完全覆盖窗口之前拥有的任何属性，并将其设置为新的属性。 类似地，attroff()只是关闭了作为参数赋予它的属性。这为我们提供了轻松管理属性的灵活性。但是如果你不小心使用它们，你可能会丢失窗口的属性并混淆显示。在管理带有颜色和高亮显示的菜单时尤其如此。所以，制定一个一致的政策，并坚持下去。您总是可以使用standend()，它相当于attrset(A_NORMAL)，它会关闭所有属性并将您带到正常模式。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:7:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"attr_get() 函数attr_get()获取窗口的当前属性和颜色对。虽然我们可能不像上面的函数那样经常使用它，但它在扫描屏幕区域时很有用。假设我们想要在屏幕上进行一些复杂的更新，并且我们不确定每个字符与什么属性相关联。然后，该函数可以与attrset或attron一起使用，以产生所需的效果。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:7:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"attr_functions 有一系列函数，如attr_set()， attr_on()等。这些函数与上面的函数类似，只是它们接受attr_t类型的参数。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:7:4","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"wattr_functions 对于上面的每个函数，我们都有一个对应的带有“w”的函数，它对特定的窗口进行操作。上述函数对stdscr进行操作。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:7:5","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"chgat() 函数chgat()列在手册curs_attr的末尾。这实际上是一个有用的方法。此函数可用于设置一组字符的属性而不移动。我是认真的!-)它从当前光标位置开始改变给定数量的字符的属性。 我们可以给-1作为字符数来更新直到行结束。如果你想改变字符的属性从当前位置到行尾，只需使用这个。 chgat(-1, A_REVERSE, 0, NULL); 当更改屏幕上已经存在的字符的属性时，此函数非常有用。移动到要更改的字符并更改属性。 其他函数wchgat()， mvchgat()， wchgat()的行为类似，除了w函数操作在特定的窗口上。mv函数首先移动光标，然后执行给定的工作。实际上，chgat是一个宏，它被一个带有stdscr作为窗口的wchgat()所取代。大多数“无w”函数都是宏。 #include \u003cncurses.h\u003e int main(int argc, char *argv[]) { initscr(); /* Start curses mode */ start_color(); /* Start color functionality */ init_pair(1, COLOR_CYAN, COLOR_BLACK); printw(\"A Big string which i didn't care to type fully \"); mvchgat(0, 0, -1, A_BLINK, 1, NULL); /* * First two parameters specify the position at which to start * Third parameter number of characters to update. -1 means till * end of line * Forth parameter is the normal attribute you wanted to give * to the charcter * Fifth is the color index. It is the index given during init_pair() * use 0 if you didn't want color * Sixth one is always NULL */ refresh(); getch(); endwin(); /* End curses mode */ return 0; } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:7:6","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"Windows 窗口是ncurses中最重要的概念。您已经看到了上面的标准窗口stdscr，其中所有函数都隐式地操作该窗口。 现在，为了使设计成为最简单的GUI，您需要求助于窗口。使用窗口的主要原因可能是为了单独操作屏幕的各个部分，从而提高效率，只更新需要更改的窗口，从而获得更好的设计。 我想说最后一个原因是选择窗户最重要的。在程序中，您应该始终努力实现更好且易于管理的设计。如果您正在编写大型、复杂的gui，那么在您开始做任何事情之前，这是至关重要的。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:8:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"基础 窗口可以通过调用newwin()函数来创建。它不会在屏幕上创建任何东西。它为一个结构分配内存来操作窗口，并更新结构与窗口的数据，如它的大小，开始，开始等。 因此，在curses中，窗口只是一个虚构窗口的抽象，可以独立于屏幕的其他部分进行操作。函数newwin()返回一个指向WINDOW结构的指针，这个指针可以传递给窗口相关的函数，比如wprintw()等。最后，可以使用delwin()销毁窗口。它将释放与窗口结构相关联的内存。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:8:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"创建一个窗口 如果一个窗口被创造出来，而我们却看不到它，这是多么有趣。有趣的部分从显示窗口开始。函数box()可用于在窗口周围绘制边框。让我们在本例中更详细地研究这些函数。 #include \u003cncurses.h\u003e WINDOW *create_newwin(int height, int width, int starty, int startx); void destroy_win(WINDOW *local_win); int main(int argc, char *argv[]) { WINDOW *my_win; int startx, starty, width, height; int ch; initscr(); /* Start curses mode */ cbreak(); /* Line buffering disabled, Pass on everty thing to me */ keypad(stdscr, TRUE); /* I need that nifty F1 */ height = 3; width = 10; starty = (LINES - height) / 2; /* Calculating for a center placement */ startx = (COLS - width) / 2; /* of the window */ printw(\"Press F1 to exit\"); refresh(); my_win = create_newwin(height, width, starty, startx); while((ch = getch()) != KEY_F(1)) { switch(ch) { case KEY_LEFT: destroy_win(my_win); my_win = create_newwin(height, width, starty, --startx); break; case KEY_RIGHT: destroy_win(my_win); my_win = create_newwin(height, width, starty, ++startx); break; case KEY_UP: destroy_win(my_win); my_win = create_newwin(height, width, --starty, startx); break; case KEY_DOWN: destroy_win(my_win); my_win = create_newwin(height, width, ++starty, startx); break; } } endwin(); /* End curses mode */ return 0; } WINDOW *create_newwin(int height, int width, int starty, int startx) { WINDOW *local_win; local_win = newwin(height, width, starty, startx); box(local_win, 0 , 0); /* 0, 0 gives default characters * for the vertical and horizontal * lines */ wrefresh(local_win); /* Show that box */ return local_win; } void destroy_win(WINDOW *local_win) { /* box(local_win, ' ', ' '); : This won't produce the desired * result of erasing the window. It will leave it's four corners * and so an ugly remnant of window. */ wborder(local_win, ' ', ' ', ' ',' ',' ',' ',' ',' '); /* The parameters taken are * 1. win: the window on which to operate * 2. ls: character to be used for the left side of the window * 3. rs: character to be used for the right side of the window * 4. ts: character to be used for the top side of the window * 5. bs: character to be used for the bottom side of the window * 6. tl: character to be used for the top left corner of the window * 7. tr: character to be used for the top right corner of the window * 8. bl: character to be used for the bottom left corner of the window * 9. br: character to be used for the bottom right corner of the window */ wrefresh(local_win); delwin(local_win); } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:8:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"上述代码说明 我知道这是个很好的例子。但我必须在这里解释一些重要的事情:-)。这个程序创建一个矩形窗口，可以用左、右、上、下方向键移动。只要用户按下一个按键，它就会反复创建和破坏窗口。 create_newwin()函数的作用是:使用newwin()创建一个窗口，并在窗口周围用方框显示边框。函数destroy_win()首先用’ ‘字符绘制边框，然后调用delwin()来释放与之相关的内存，从而从屏幕上删除窗口。根据用户所按的键，starty或startx将被更改，并创建一个新窗口。 在destroy_win中，如你所见，我使用了wborder而不是box。原因写在评论里(你错过了。我知道。阅读代码:-))。wborder用4个角点和4条线在窗口周围画一个边框。清楚地说，如果你调用wborder，如下所示: wborder(win, '|', '|', '-', '-', '+', '+', '+', '+'); 显示如下： +------------+ | | | | | | | | | | | | +------------+ ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:8:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"例子中其它相关内容 您还可以在上面的示例中看到，我使用了变量COLS, LINES，它们在initscr()之后初始化为屏幕大小。它们可以用于查找屏幕尺寸和查找屏幕的中心坐标。函数getch()像往常一样从键盘获取键，并根据键执行相应的工作。这种类型的开关情况在任何基于GUI的程序中都很常见。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:8:4","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"其它boder函数 上面的程序是非常低效的，因为每按一个键，一个窗口被破坏，另一个窗口被创建。因此，让我们编写一个更有效的程序，使用其他与边界相关的函数。 下面的程序使用mvhline()和mvvline()来实现类似的效果。这两个函数很简单。它们在指定位置创建指定长度的水平线或垂直线。 #include \u003cncurses.h\u003e typedef struct _win_border_struct { chtype ls, rs, ts, bs, tl, tr, bl, br; } WIN_BORDER; typedef struct _WIN_struct { int startx, starty; int height, width; WIN_BORDER border; } WIN; void init_win_params(WIN *p_win); void print_win_params(WIN *p_win); void create_box(WIN *win, bool flag); int main(int argc, char *argv[]) { WIN win; int ch; initscr(); /* Start curses mode */ start_color(); /* Start the color functionality */ cbreak(); /* Line buffering disabled, Pass on everty thing to me */ keypad(stdscr, TRUE); /* I need that nifty F1 */ noecho(); init_pair(1, COLOR_CYAN, COLOR_BLACK); /* Initialize the window parameters */ init_win_params(\u0026win); print_win_params(\u0026win); attron(COLOR_PAIR(1)); printw(\"Press F1 to exit\"); refresh(); attroff(COLOR_PAIR(1)); create_box(\u0026win, TRUE); while((ch = getch()) != KEY_F(1)) { switch(ch) { case KEY_LEFT: create_box(\u0026win, FALSE); --win.startx; create_box(\u0026win, TRUE); break; case KEY_RIGHT: create_box(\u0026win, FALSE); ++win.startx; create_box(\u0026win, TRUE); break; case KEY_UP: create_box(\u0026win, FALSE); --win.starty; create_box(\u0026win, TRUE); break; case KEY_DOWN: create_box(\u0026win, FALSE); ++win.starty; create_box(\u0026win, TRUE); break; } } endwin(); /* End curses mode */ return 0; } void init_win_params(WIN *p_win) { p_win-\u003eheight = 3; p_win-\u003ewidth = 10; p_win-\u003estarty = (LINES - p_win-\u003eheight)/2; p_win-\u003estartx = (COLS - p_win-\u003ewidth)/2; p_win-\u003eborder.ls = '|'; p_win-\u003eborder.rs = '|'; p_win-\u003eborder.ts = '-'; p_win-\u003eborder.bs = '-'; p_win-\u003eborder.tl = '+'; p_win-\u003eborder.tr = '+'; p_win-\u003eborder.bl = '+'; p_win-\u003eborder.br = '+'; } void print_win_params(WIN *p_win) { #ifdef _DEBUG mvprintw(25, 0, \"%d %d %d %d\", p_win-\u003estartx, p_win-\u003estarty, p_win-\u003ewidth, p_win-\u003eheight); refresh(); #endif } void create_box(WIN *p_win, bool flag) { int i, j; int x, y, w, h; x = p_win-\u003estartx; y = p_win-\u003estarty; w = p_win-\u003ewidth; h = p_win-\u003eheight; if (flag == TRUE) { mvaddch(y, x, p_win-\u003eborder.tl); mvaddch(y, x + w, p_win-\u003eborder.tr); mvaddch(y + h, x, p_win-\u003eborder.bl); mvaddch(y + h, x + w, p_win-\u003eborder.br); mvhline(y, x + 1, p_win-\u003eborder.ts, w - 1); mvhline(y + h, x + 1, p_win-\u003eborder.bs, w - 1); mvvline(y + 1, x, p_win-\u003eborder.ls, h - 1); mvvline(y + 1, x + w, p_win-\u003eborder.rs, h - 1); } else { for(j = y; j \u003c= y + h; ++j) { for(i = x; i \u003c= x + w; ++i) { mvaddch(j, i, ' '); } } } refresh(); } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:8:5","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"颜色 如您所见，要开始使用颜色，首先应该调用函数start_color()。在此之后，您可以使用各种功能来使用终端的颜色功能。要确定终端是否具有颜色功能，可以使用has_colors()函数，如果终端不支持颜色，则返回FALSE。 Curses在调用start_color()时初始化终端支持的所有颜色。这些可以通过定义常量访问，如COLOR_BLACK等。现在要真正开始使用颜色，你必须定义颜色对。颜色总是成对使用。这意味着您必须使用init_pair()函数为您给出的pair编号定义前台和背景。之后，可以使用COLOR_PAIR()函数将对号作为普通属性使用。这可能一开始看起来很麻烦。但是这种优雅的解决方案使我们能够非常容易地管理颜色对。要理解它，你必须研究一下“dialog”的源代码，这是一个用于从shell脚本显示对话框的实用程序。开发人员已经为他们可能需要的所有颜色定义了前景和背景组合，并在开始时进行了初始化。这使得通过访问我们已经定义为常量的一对来设置属性变得非常容易。 下面的颜色在curse.h中定义。您可以使用这些作为各种颜色函数的参数。 COLOR_BLACK 0 COLOR_RED 1 COLOR_GREEN 2 COLOR_YELLOW 3 COLOR_BLUE 4 COLOR_MAGENTA 5 COLOR_CYAN 6 COLOR_WHITE 7 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:9:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"修改颜色定义 函数init_color()可以用来改变最初由curses定义的颜色的rgb值。假设你想把红色的强度调淡一点。然后你可以用这个函数 init_color(COLOR_RED, 700, 0, 0); /* param 1 : color name * param 2, 3, 4 : rgb content min = 0, max = 1000 */ 如果您的终端不能更改颜色定义，则该函数返回ERR。函数can_change_color()可用于判断终端是否具有更改颜色内容的能力。rgb内容从0扩展到1000。最初定义红色的内容为1000(r)， 0(g)， 0(b)。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:9:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"颜色上下文 函数color_content()和pair_content()可用于查找颜色内容和前景色、背景组合。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:9:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"与键盘的接口 没有强大的用户界面，GUI是不完整的，为了与用户交互，curses程序应该对用户的按键或鼠标操作敏感。让我们先处理按键事件。 正如您在上面几乎所有示例中所看到的，从用户那里获得键输入非常容易。获取按键的一个简单方法是使用getch()函数。当您感兴趣的是单个按键而不是整行文本(通常以回车符结束)时，应该启用cbreak模式来读取键。键盘应该启用功能键，方向键等。有关详细信息，请参阅初始化部分。 getch()返回一个与所按键对应的整数。如果是普通字符，则整数值等效于该字符。否则，它返回一个可以与curses.h中定义的常量匹配的数字。例如，如果用户按F1，返回的整数是265。可以使用curses.h中定义的宏KEY_F()进行检查。这使得读取键易于携带和管理。 int ch; ch = getch(); getch()将等待用户按下一个键(除非您指定了超时)，当用户按下一个键时，将返回相应的整数。然后，您可以检查返回值与curses.h中定义的常量，以匹配所需的键。 if(ch == KEY_LEFT) printw(\"Left arrow is pressed\\n\"); #include \u003cstdio.h\u003e #include \u003cncurses.h\u003e #define WIDTH 30 #define HEIGHT 10 int startx = 0; int starty = 0; char *choices[] = { \"Choice 1\", \"Choice 2\", \"Choice 3\", \"Choice 4\", \"Exit\", }; int n_choices = sizeof(choices) / sizeof(char *); void print_menu(WINDOW *menu_win, int highlight); int main() { WINDOW *menu_win; int highlight = 1; int choice = 0; int c; initscr(); clear(); noecho(); cbreak(); /* Line buffering disabled. pass on everything */ startx = (80 - WIDTH) / 2; starty = (24 - HEIGHT) / 2; menu_win = newwin(HEIGHT, WIDTH, starty, startx); keypad(menu_win, TRUE); mvprintw(0, 0, \"Use arrow keys to go up and down, Press enter to select a choice\"); refresh(); print_menu(menu_win, highlight); while(1) { c = wgetch(menu_win); switch(c) { case KEY_UP: if(highlight == 1) highlight = n_choices; else --highlight; break; case KEY_DOWN: if(highlight == n_choices) highlight = 1; else ++highlight; break; case 10: choice = highlight; break; default: mvprintw(24, 0, \"Charcter pressed is = %3d Hopefully it can be printed as '%c'\", c, c); refresh(); break; } print_menu(menu_win, highlight); if(choice != 0) /* User did a choice come out of the infinite loop */ break; } mvprintw(23, 0, \"You chose choice %d with choice string %s\\n\", choice, choices[choice - 1]); clrtoeol(); refresh(); endwin(); return 0; } void print_menu(WINDOW *menu_win, int highlight) { int x, y, i; x = 2; y = 2; box(menu_win, 0, 0); for(i = 0; i \u003c n_choices; ++i) { if(highlight == i + 1) /* High light the present choice */ { wattron(menu_win, A_REVERSE); mvwprintw(menu_win, y, x, \"%s\", choices[i]); wattroff(menu_win, A_REVERSE); } else mvwprintw(menu_win, y, x, \"%s\", choices[i]); ++y; } wrefresh(menu_win); } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:10:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"鼠标 现在您已经看到了如何获取键，让我们从鼠标执行相同的操作。通常每个UI都允许用户使用键盘和鼠标进行交互。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:11:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"开始 在你做任何其他事情之前，你想要接收的事件必须通过mousemask()启用。 mousemask(mmask_t newmask, /* The events you want to listen to */ mmask_t *oldmask) /* The old events mask */ 上述函数的第一个参数是您想要侦听的事件的位掩码。默认情况下，所有事件都是关闭的。位掩码ALL_MOUSE_EVENTS可用于获取所有事件。 以下是所有的事件掩码: Name Description --------------------------------------------------------------------- BUTTON1_PRESSED mouse button 1 down BUTTON1_RELEASED mouse button 1 up BUTTON1_CLICKED mouse button 1 clicked BUTTON1_DOUBLE_CLICKED mouse button 1 double clicked BUTTON1_TRIPLE_CLICKED mouse button 1 triple clicked BUTTON2_PRESSED mouse button 2 down BUTTON2_RELEASED mouse button 2 up BUTTON2_CLICKED mouse button 2 clicked BUTTON2_DOUBLE_CLICKED mouse button 2 double clicked BUTTON2_TRIPLE_CLICKED mouse button 2 triple clicked BUTTON3_PRESSED mouse button 3 down BUTTON3_RELEASED mouse button 3 up BUTTON3_CLICKED mouse button 3 clicked BUTTON3_DOUBLE_CLICKED mouse button 3 double clicked BUTTON3_TRIPLE_CLICKED mouse button 3 triple clicked BUTTON4_PRESSED mouse button 4 down BUTTON4_RELEASED mouse button 4 up BUTTON4_CLICKED mouse button 4 clicked BUTTON4_DOUBLE_CLICKED mouse button 4 double clicked BUTTON4_TRIPLE_CLICKED mouse button 4 triple clicked BUTTON_SHIFT shift was down during button state change BUTTON_CTRL control was down during button state change BUTTON_ALT alt was down during button state change ALL_MOUSE_EVENTS report all button state changes REPORT_MOUSE_POSITION report mouse movement ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:11:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"获取事件 一旦启用了一类鼠标事件，getch()类函数就会在每次发生某个鼠标事件时返回KEY_MOUSE。然后可以使用getmouse()检索鼠标事件。 MEVENT event; ch = getch(); if(ch == KEY_MOUSE) if(getmouse(\u0026event) == OK) /* Do some thing with the event */ . . getmouse()将事件返回给它的指针。它是一个包含 typedef struct { short id; /* ID to distinguish multiple devices */ int x, y, z; /* event coordinates */ mmask_t bstate; /* button state bits */ } bstate是我们感兴趣的主要变量。它告诉鼠标的按钮状态。 然后，使用如下所示的代码片段，我们可以了解发生了什么。 if(event.bstate \u0026 BUTTON1_PRESSED) printw(\"Left Button Pressed\"); ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:11:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"例子 这就是鼠标界面。让我们创建相同的菜单并启用鼠标交互。为了简化操作，删除了键处理。 #include \u003cncurses.h\u003e #define WIDTH 30 #define HEIGHT 10 int startx = 0; int starty = 0; char *choices[] = { \"Choice 1\", \"Choice 2\", \"Choice 3\", \"Choice 4\", \"Exit\", }; int n_choices = sizeof(choices) / sizeof(char *); void print_menu(WINDOW *menu_win, int highlight); void report_choice(int mouse_x, int mouse_y, int *p_choice); int main() { int c, choice = 0; WINDOW *menu_win; MEVENT event; /* Initialize curses */ initscr(); clear(); noecho(); cbreak(); //Line buffering disabled. pass on everything /* Try to put the window in the middle of screen */ startx = (80 - WIDTH) / 2; starty = (24 - HEIGHT) / 2; attron(A_REVERSE); mvprintw(23, 1, \"Click on Exit to quit (Works best in a virtual console)\"); refresh(); attroff(A_REVERSE); /* Print the menu for the first time */ menu_win = newwin(HEIGHT, WIDTH, starty, startx); print_menu(menu_win, 1); /* Get all the mouse events */ mousemask(ALL_MOUSE_EVENTS, NULL); while(1) { c = wgetch(menu_win); switch(c) { case KEY_MOUSE: if(getmouse(\u0026event) == OK) { /* When the user clicks left mouse button */ if(event.bstate \u0026 BUTTON1_PRESSED) { report_choice(event.x + 1, event.y + 1, \u0026choice); if(choice == -1) //Exit chosen goto end; mvprintw(22, 1, \"Choice made is : %d String Chosen is \\\"%10s\\\"\", choice, choices[choice - 1]); refresh(); } } print_menu(menu_win, choice); break; } } end: endwin(); return 0; } void print_menu(WINDOW *menu_win, int highlight) { int x, y, i; x = 2; y = 2; box(menu_win, 0, 0); for(i = 0; i \u003c n_choices; ++i) { if(highlight == i + 1) { wattron(menu_win, A_REVERSE); mvwprintw(menu_win, y, x, \"%s\", choices[i]); wattroff(menu_win, A_REVERSE); } else mvwprintw(menu_win, y, x, \"%s\", choices[i]); ++y; } wrefresh(menu_win); } /* Report the choice according to mouse position */ void report_choice(int mouse_x, int mouse_y, int *p_choice) { int i,j, choice; i = startx + 2; j = starty + 3; for(choice = 0; choice \u003c n_choices; ++choice) if(mouse_y == j + choice \u0026\u0026 mouse_x \u003e= i \u0026\u0026 mouse_x \u003c= i + strlen(choices[choice])) { if(choice == n_choices - 1) *p_choice = -1; else *p_choice = choice + 1; break; } } 函数mouse_trafo()和wmouse_trafo()可用于将鼠标坐标转换为屏幕相对坐标。详情请参见curs_mouse(3X)手册页。 mouseinterval函数设置按下和释放事件之间的最大时间(以千分之秒为单位)，以便将它们识别为单击。这个函数返回之前的间隔值。默认值是1 / 5秒。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:11:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"屏幕 在本节中，我们将研究一些函数，这些函数使我们能够有效地管理屏幕并编写一些奇特的程序。这在编写游戏时尤其重要。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:12:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"getyx() 函数getyx()可用于查找当前游标坐标。它将在参数中填充x和y坐标的值。由于getyx()是一个宏，您不必传递变量的地址。它可以被称为 getyx(win, y, x); /* win: window pointer * y, x: y, x co-ordinates will be put into this variables */ 函数getparyx()获取子窗口相对于主窗口的起始坐标。这对于更新子窗口有时很有用。当设计一些花哨的东西，如编写多个菜单时，很难存储菜单位置，它们的第一个选项坐标等。这个问题的一个简单解决方案是在子窗口中创建菜单，然后使用getparyx()找到菜单的起始坐标。 函数getbegyx()和getmaxyx()存储当前窗口的起始坐标和最大坐标。这些函数在有效地管理窗口和子窗口方面与上面的方法相同。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:12:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"screen 复制 在编写游戏时，有时需要存储屏幕状态并将其恢复到相同的状态。函数scr_dump()可用于将屏幕内容转储到作为参数给定的文件中。之后可以通过scr_restore函数恢复。这两个简单的功能可以有效地用于保持快速移动的游戏与不断变化的场景。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:12:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"window 复制 为了存储和恢复窗口，可以使用putwin()和getwin()函数。putwin()将当前窗口状态放入一个文件，稍后可以通过getwin()恢复该文件。 函数copywin()可用于将一个窗口完全复制到另一个窗口。它将源窗口和目标窗口作为参数，并根据指定的矩形将矩形区域从源窗口复制到目标窗口。它的最后一个参数指定是将内容覆盖还是覆盖到目标窗口。如果这个论点成立，那么复制是非破坏性的。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:12:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"其它功能点 现在您已经了解了足够多的功能，可以编写一个好的curses程序。有一些杂函数在各种情况下都很有用。让我们来看看其中的一些。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:13:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"curs_set() 此函数可用于使游标不可见。这个函数的参数应该是: 0 : invisible or 1 : normal or 2 : very visible. ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:13:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"暂时离开curses模式 有时您可能想暂时回到正常模式(正常线路缓冲模式)。在这种情况下，首先需要通过调用def_prog_mode()来保存tty模式，然后调用endwin()来结束curses模式。这将使您处于原来的tty模式。要在完成之后返回curses，请调用reset_prog_mode()。该函数将tty返回到def_prog_mode()存储的状态。然后执行refresh()，您将回到curses模式。下面的例子显示了要做的事情的顺序。 #include \u003cncurses.h\u003e int main() { initscr(); /* Start curses mode */ printw(\"Hello World !!!\\n\"); /* Print Hello World */ refresh(); /* Print it on to the real screen */ def_prog_mode(); /* Save the tty modes */ endwin(); /* End curses mode temporarily */ system(\"/bin/sh\"); /* Do whatever you like in cooked mode */ reset_prog_mode(); /* Return to the previous tty mode*/ /* stored by def_prog_mode() */ refresh(); /* Do refresh() to restore the */ /* Screen contents */ printw(\"Another String\\n\"); /* Back to curses use the full */ refresh(); /* capabilities of curses */ endwin(); /* End curses mode */ return 0; } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:13:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"ACS_ 变量 如果您曾经在DOS中编程，您就知道扩展字符集中的那些漂亮字符。它们只能在某些终端上打印。像box()这样的NCURSES函数使用这些字符。所有这些变量都以ACS开头，即替代字符集。您可能已经注意到我在上面的一些程序中使用了这些字符。下面是一个显示所有字符的示例。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:13:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"其它一些库 除了curses库，还有一些文本模式库，它们提供了更多的功能和许多特性。下面几节将解释通常随curses一起分发的三个标准库。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:14:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"Panel 库 既然你精通ncurses，你就想干点大事。您创建了许多重叠的窗口，以提供专业的窗口类型的外观。不幸的是，很快就很难管理这些。多次刷新、更新会让你陷入噩梦。当您忘记按正确的顺序刷新窗口时，重叠的窗口会产生斑点。 不要绝望。在panels库中提供了一个优雅的解决方案。用ncurses开发者的话来说 当您的界面设计使得窗口可能深入可见性堆栈或在运行时弹出到顶部时，所产生的记账可能是乏味的，并且难以正确处理。因此有了面板库。 如果你有很多重叠的窗口，那么面板库是要去的方式。它避免了执行一系列wnoutrefresh()，doupdate()的需要，并减轻了正确执行(自底向上)的负担。库维护有关窗口顺序、重叠和正确更新屏幕的信息。那为什么还要等待呢?让我们仔细看看面板。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:15:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"基础 Panel 对象是一个窗口，它被隐式地视为包括所有其他Panel对象在内的一部分。deck被视为一个堆栈，顶部Panel是完全可见的，其他Panel可能被遮挡，也可能不被遮挡，根据他们的位置。因此，基本思想是创建一个重叠Panel的堆栈，并使用Panel库来正确显示它们。有一个类似于refresh()的函数，当调用它时，将以正确的顺序显示Panel。函数提供隐藏或显示Panel，移动Panel，改变其大小等。在所有对这些函数的调用期间，重叠问题由Panel库管理。 Panel程序的一般流程是这样的: 创建附加到 panel 上的窗口(使用newwin())。 用所选的可见性顺序创建Panel。根据所需的可见性将它们堆叠起来。函数new_panel()用于创建面板。 调用update_panels()以正确的可见性顺序将面板写入虚拟屏幕。执行doupdate()将其显示在屏幕上。 使用show_panel()，hide_panel()，move_panel()等操作面板。使用帮助函数，如panel_hidden()和panel_window()。使用用户指针存储面板的自定义数据。使用函数set_panel_userptr()和panel_userptr()来设置和获取面板的用户指针。 当你不再使用panel时，使用del_panel()删除。 让我们用一些程序把概念弄清楚。下面是一个简单的程序，它创建了3个重叠的面板，并在屏幕上显示它们。 #include \u003cpanel.h\u003e int main() { WINDOW *my_wins[3]; PANEL *my_panels[3]; int lines = 10, cols = 40, y = 2, x = 4, i; initscr(); cbreak(); noecho(); /* Create windows for the panels */ my_wins[0] = newwin(lines, cols, y, x); my_wins[1] = newwin(lines, cols, y + 1, x + 5); my_wins[2] = newwin(lines, cols, y + 2, x + 10); /* * Create borders around the windows so that you can see the effect * of panels */ for(i = 0; i \u003c 3; ++i) box(my_wins[i], 0, 0); /* Attach a panel to each window */ /* Order is bottom up */ my_panels[0] = new_panel(my_wins[0]); /* Push 0, order: stdscr-0 */ my_panels[1] = new_panel(my_wins[1]); /* Push 1, order: stdscr-0-1 */ my_panels[2] = new_panel(my_wins[2]); /* Push 2, order: stdscr-0-1-2 */ /* Update the stacking order. 2nd panel will be on top */ update_panels(); /* Show it on the screen */ doupdate(); getch(); endwin(); } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:15:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"panel 切换 下面给出了一个稍微复杂的例子。这个程序创建了3个窗口，可以通过使用标签循环。看一下代码。 #include \u003cpanel.h\u003e #define NLINES 10 #define NCOLS 40 void init_wins(WINDOW **wins, int n); void win_show(WINDOW *win, char *label, int label_color); void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color); int main() { WINDOW *my_wins[3]; PANEL *my_panels[3]; PANEL *top; int ch; /* Initialize curses */ initscr(); start_color(); cbreak(); noecho(); keypad(stdscr, TRUE); /* Initialize all the colors */ init_pair(1, COLOR_RED, COLOR_BLACK); init_pair(2, COLOR_GREEN, COLOR_BLACK); init_pair(3, COLOR_BLUE, COLOR_BLACK); init_pair(4, COLOR_CYAN, COLOR_BLACK); init_wins(my_wins, 3); /* Attach a panel to each window */ /* Order is bottom up */ my_panels[0] = new_panel(my_wins[0]); /* Push 0, order: stdscr-0 */ my_panels[1] = new_panel(my_wins[1]); /* Push 1, order: stdscr-0-1 */ my_panels[2] = new_panel(my_wins[2]); /* Push 2, order: stdscr-0-1-2 */ /* Set up the user pointers to the next panel */ set_panel_userptr(my_panels[0], my_panels[1]); set_panel_userptr(my_panels[1], my_panels[2]); set_panel_userptr(my_panels[2], my_panels[0]); /* Update the stacking order. 2nd panel will be on top */ update_panels(); /* Show it on the screen */ attron(COLOR_PAIR(4)); mvprintw(LINES - 2, 0, \"Use tab to browse through the windows (F1 to Exit)\"); attroff(COLOR_PAIR(4)); doupdate(); top = my_panels[2]; while((ch = getch()) != KEY_F(1)) { switch(ch) { case 9: top = (PANEL *)panel_userptr(top); top_panel(top); break; } update_panels(); doupdate(); } endwin(); return 0; } /* Put all the windows */ void init_wins(WINDOW **wins, int n) { int x, y, i; char label[80]; y = 2; x = 10; for(i = 0; i \u003c n; ++i) { wins[i] = newwin(NLINES, NCOLS, y, x); sprintf(label, \"Window Number %d\", i + 1); win_show(wins[i], label, i + 1); y += 3; x += 7; } } /* Show the window with a border and a label */ void win_show(WINDOW *win, char *label, int label_color) { int startx, starty, height, width; getbegyx(win, starty, startx); getmaxyx(win, height, width); box(win, 0, 0); mvwaddch(win, 2, 0, ACS_LTEE); mvwhline(win, 2, 1, ACS_HLINE, width - 2); mvwaddch(win, 2, width - 1, ACS_RTEE); print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color)); } void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color) { int length, x, y; float temp; if(win == NULL) win = stdscr; getyx(win, y, x); if(startx != 0) x = startx; if(starty != 0) y = starty; if(width == 0) width = 80; length = strlen(string); temp = (width - length)/ 2; x = startx + (int)temp; wattron(win, color); mvwprintw(win, y, x, \"%s\", string); wattroff(win, color); refresh(); } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:15:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"panel 的移动和大小改变 函数move_panel()可用于将面板移动到所需的位置。它不会改变面板在堆栈中的位置。确保在与面板关联的窗口上使用move_panel()而不是mvwin()。 调整面板的大小有点复杂。没有直接的函数来调整与面板相关联的窗口的大小。调整面板大小的一个解决方案是创建一个具有所需大小的新窗口，使用replace_panel()更改与面板相关的窗口。不要忘记删除旧窗口。可以使用函数panel_window()找到与面板关联的窗口。 下面的程序在一个简单的程序中展示了这些概念。您可以像往常一样使用\u003cTAB\u003e在窗口中循环。要调整或移动活动面板按'r'调整'm'移动。然后使用方向键调整大小或将其移动到所需的方式，并按enter键结束调整大小或移动。本例使用用户数据获取执行操作所需的数据。 #include \u003cpanel.h\u003e typedef struct _PANEL_DATA { int x, y, w, h; char label[80]; int label_color; PANEL *next; } PANEL_DATA; #define NLINES 10 #define NCOLS 40 void init_wins(WINDOW **wins, int n); void win_show(WINDOW *win, char *label, int label_color); void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color); void set_user_ptrs(PANEL **panels, int n); int main() { WINDOW *my_wins[3]; PANEL *my_panels[3]; PANEL_DATA *top; PANEL *stack_top; WINDOW *temp_win, *old_win; int ch; int newx, newy, neww, newh; int size = FALSE, move = FALSE; /* Initialize curses */ initscr(); start_color(); cbreak(); noecho(); keypad(stdscr, TRUE); /* Initialize all the colors */ init_pair(1, COLOR_RED, COLOR_BLACK); init_pair(2, COLOR_GREEN, COLOR_BLACK); init_pair(3, COLOR_BLUE, COLOR_BLACK); init_pair(4, COLOR_CYAN, COLOR_BLACK); init_wins(my_wins, 3); /* Attach a panel to each window */ /* Order is bottom up */ my_panels[0] = new_panel(my_wins[0]); /* Push 0, order: stdscr-0 */ my_panels[1] = new_panel(my_wins[1]); /* Push 1, order: stdscr-0-1 */ my_panels[2] = new_panel(my_wins[2]); /* Push 2, order: stdscr-0-1-2 */ set_user_ptrs(my_panels, 3); /* Update the stacking order. 2nd panel will be on top */ update_panels(); /* Show it on the screen */ attron(COLOR_PAIR(4)); mvprintw(LINES - 3, 0, \"Use 'm' for moving, 'r' for resizing\"); mvprintw(LINES - 2, 0, \"Use tab to browse through the windows (F1 to Exit)\"); attroff(COLOR_PAIR(4)); doupdate(); stack_top = my_panels[2]; top = (PANEL_DATA *)panel_userptr(stack_top); newx = top-\u003ex; newy = top-\u003ey; neww = top-\u003ew; newh = top-\u003eh; while((ch = getch()) != KEY_F(1)) { switch(ch) { case 9: /* Tab */ top = (PANEL_DATA *)panel_userptr(stack_top); top_panel(top-\u003enext); stack_top = top-\u003enext; top = (PANEL_DATA *)panel_userptr(stack_top); newx = top-\u003ex; newy = top-\u003ey; neww = top-\u003ew; newh = top-\u003eh; break; case 'r': /* Re-Size*/ size = TRUE; attron(COLOR_PAIR(4)); mvprintw(LINES - 4, 0, \"Entered Resizing :Use Arrow Keys to resize and press \u003cENTER\u003e to end resizing\"); refresh(); attroff(COLOR_PAIR(4)); break; case 'm': /* Move */ attron(COLOR_PAIR(4)); mvprintw(LINES - 4, 0, \"Entered Moving: Use Arrow Keys to Move and press \u003cENTER\u003e to end moving\"); refresh(); attroff(COLOR_PAIR(4)); move = TRUE; break; case KEY_LEFT: if(size == TRUE) { --newx; ++neww; } if(move == TRUE) --newx; break; case KEY_RIGHT: if(size == TRUE) { ++newx; --neww; } if(move == TRUE) ++newx; break; case KEY_UP: if(size == TRUE) { --newy; ++newh; } if(move == TRUE) --newy; break; case KEY_DOWN: if(size == TRUE) { ++newy; --newh; } if(move == TRUE) ++newy; break; case 10: /* Enter */ move(LINES - 4, 0); clrtoeol(); refresh(); if(size == TRUE) { old_win = panel_window(stack_top); temp_win = newwin(newh, neww, newy, newx); replace_panel(stack_top, temp_win); win_show(temp_win, top-\u003elabel, top-\u003elabel_color); delwin(old_win); size = FALSE; } if(move == TRUE) { move_panel(stack_top, newy, newx); move = FALSE; } break; } attron(COLOR_PAIR(4)); mvprintw(LINES - 3, 0, \"Use 'm' for moving, 'r' for resizing\"); mvprintw(LINES - 2, 0, \"Use tab to browse through the windows (F1 to Exit)\"); attroff(COLOR_PAIR(4)); refresh(); update_panels(); doupdate(); } endwin(); return 0; } /* Put all the windows */ void init_wins(WINDOW **wins, int n) { int x, y, i; char label[80]; y = 2; x = 10; for(i = 0; i \u003c n; ++i) { wins[i] = newwin(NLINES, NCOLS, y, x); sprintf(label, \"Window Number %d\", i + 1); win_show(wins[i], label, i + 1); y += 3; x += 7; } } /* Set the PANEL_DATA structures for individual panels */ void set_user_ptrs(PANEL **panels, int n) { PANEL_DATA *ptrs; WINDOW *win;","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:15:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"面板的隐藏和显示 可以使用函数hide_panel()隐藏面板。该函数只是将其从面板堆栈中移除，从而在执行update_panels()和doupdate()时将其隐藏在屏幕上。它不会破坏与隐藏面板相关联的PANEL结构。它可以通过使用show_panel()函数再次显示。 下面的程序显示了面板的隐藏。按“a”或“b”或“c”分别显示或隐藏第一个、第二个和第三个窗口。它使用带有一个小变量hide的用户数据，该变量跟踪窗口是否被隐藏。由于某种原因，函数panel_hidden()没有工作，它告诉你一个面板是否被隐藏。Michael Andres在这里还提供了一份错误报告 #include \u003cpanel.h\u003e typedef struct _PANEL_DATA { int hide; /* TRUE if panel is hidden */ } PANEL_DATA; #define NLINES 10 #define NCOLS 40 void init_wins(WINDOW **wins, int n); void win_show(WINDOW *win, char *label, int label_color); void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color); int main() { WINDOW *my_wins[3]; PANEL *my_panels[3]; PANEL_DATA panel_datas[3]; PANEL_DATA *temp; int ch; /* Initialize curses */ initscr(); start_color(); cbreak(); noecho(); keypad(stdscr, TRUE); /* Initialize all the colors */ init_pair(1, COLOR_RED, COLOR_BLACK); init_pair(2, COLOR_GREEN, COLOR_BLACK); init_pair(3, COLOR_BLUE, COLOR_BLACK); init_pair(4, COLOR_CYAN, COLOR_BLACK); init_wins(my_wins, 3); /* Attach a panel to each window */ /* Order is bottom up */ my_panels[0] = new_panel(my_wins[0]); /* Push 0, order: stdscr-0 */ my_panels[1] = new_panel(my_wins[1]); /* Push 1, order: stdscr-0-1 */ my_panels[2] = new_panel(my_wins[2]); /* Push 2, order: stdscr-0-1-2 */ /* Initialize panel datas saying that nothing is hidden */ panel_datas[0].hide = FALSE; panel_datas[1].hide = FALSE; panel_datas[2].hide = FALSE; set_panel_userptr(my_panels[0], \u0026panel_datas[0]); set_panel_userptr(my_panels[1], \u0026panel_datas[1]); set_panel_userptr(my_panels[2], \u0026panel_datas[2]); /* Update the stacking order. 2nd panel will be on top */ update_panels(); /* Show it on the screen */ attron(COLOR_PAIR(4)); mvprintw(LINES - 3, 0, \"Show or Hide a window with 'a'(first window) 'b'(Second Window) 'c'(Third Window)\"); mvprintw(LINES - 2, 0, \"F1 to Exit\"); attroff(COLOR_PAIR(4)); doupdate(); while((ch = getch()) != KEY_F(1)) { switch(ch) { case 'a': temp = (PANEL_DATA *)panel_userptr(my_panels[0]); if(temp-\u003ehide == FALSE) { hide_panel(my_panels[0]); temp-\u003ehide = TRUE; } else { show_panel(my_panels[0]); temp-\u003ehide = FALSE; } break; case 'b': temp = (PANEL_DATA *)panel_userptr(my_panels[1]); if(temp-\u003ehide == FALSE) { hide_panel(my_panels[1]); temp-\u003ehide = TRUE; } else { show_panel(my_panels[1]); temp-\u003ehide = FALSE; } break; case 'c': temp = (PANEL_DATA *)panel_userptr(my_panels[2]); if(temp-\u003ehide == FALSE) { hide_panel(my_panels[2]); temp-\u003ehide = TRUE; } else { show_panel(my_panels[2]); temp-\u003ehide = FALSE; } break; } update_panels(); doupdate(); } endwin(); return 0; } /* Put all the windows */ void init_wins(WINDOW **wins, int n) { int x, y, i; char label[80]; y = 2; x = 10; for(i = 0; i \u003c n; ++i) { wins[i] = newwin(NLINES, NCOLS, y, x); sprintf(label, \"Window Number %d\", i + 1); win_show(wins[i], label, i + 1); y += 3; x += 7; } } /* Show the window with a border and a label */ void win_show(WINDOW *win, char *label, int label_color) { int startx, starty, height, width; getbegyx(win, starty, startx); getmaxyx(win, height, width); box(win, 0, 0); mvwaddch(win, 2, 0, ACS_LTEE); mvwhline(win, 2, 1, ACS_HLINE, width - 2); mvwaddch(win, 2, width - 1, ACS_RTEE); print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color)); } void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color) { int length, x, y; float temp; if(win == NULL) win = stdscr; getyx(win, y, x); if(startx != 0) x = startx; if(starty != 0) y = starty; if(width == 0) width = 80; length = strlen(string); temp = (width - length)/ 2; x = startx + (int)temp; wattron(win, color); mvwprintw(win, y, x, \"%s\", string); wattroff(win, color); refresh(); } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:15:4","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"panel_above() 和 panel_below() 函数panel_above()和panel_below()可用于查找面板上面和下面的面板。如果这些函数的参数为NULL，则它们分别返回一个指向底部面板和顶部面板的指针。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:15:5","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"Menu Menu库为基本的ncurses提供了一个很好的扩展，通过它你可以创建Menu。它提供了一组创建Mneu的函数。但他们必须定制，以提供一个更好的外观，与颜色等。让我们进入细节。 Menu是一种屏幕显示，帮助用户选择给定项目集的某个子集。简单地说，菜单是一个项目的集合，可以从中选择一个或多个项目。有些读者可能不知道多项目选择功能。Menu库提供了编写菜单的功能，用户可以从中选择多个项目作为首选选项。这将在后面的部分中处理。现在是学习一些基本知识的时候了。 要创建Menu，首先要创建item，然后将Menu发布到显示器。在此之后，所有用户响应的处理都在一个优雅的menu_driver()函数中完成，它是任何菜单程序的主力。 菜单程序的一般控制流程是这样的: 初始化诅咒 使用new_item()创建项目。您可以为项目指定名称和描述。 通过指定要附加的项，使用new_menu()创建菜单。 使用menu_post()发布菜单并刷新屏幕。 使用循环处理用户请求，并使用menu_driver对菜单进行必要的更新。 使用menu_unpost()取消菜单 释放free_menu()分配给菜单的内存 使用free_item()释放分配给项目的内存 结束ncurses 让我们看一个程序，它打印一个简单的菜单，并用上下箭头更新当前选择。 #include \u003ccurses.h\u003e #include \u003cmenu.h\u003e #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0])) #define CTRLD 4 char *choices[] = { \"Choice 1\", \"Choice 2\", \"Choice 3\", \"Choice 4\", \"Exit\", }; int main() { ITEM **my_items; int c; MENU *my_menu; int n_choices, i; ITEM *cur_item; initscr(); cbreak(); noecho(); keypad(stdscr, TRUE); n_choices = ARRAY_SIZE(choices); my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *)); for(i = 0; i \u003c n_choices; ++i) my_items[i] = new_item(choices[i], choices[i]); my_items[n_choices] = (ITEM *)NULL; my_menu = new_menu((ITEM **)my_items); mvprintw(LINES - 2, 0, \"F1 to Exit\"); post_menu(my_menu); refresh(); while((c = getch()) != KEY_F(1)) { switch(c) { case KEY_DOWN: menu_driver(my_menu, REQ_DOWN_ITEM); break; case KEY_UP: menu_driver(my_menu, REQ_UP_ITEM); break; } } free_item(my_items[0]); free_item(my_items[1]); free_menu(my_menu); endwin(); } 本程序演示了使用菜单库创建菜单所涉及的基本概念。首先使用new_item()创建项，然后使用new_menu()函数将它们附加到菜单。在发布菜单并刷新屏幕之后，主处理循环开始。它读取用户输入并采取相应的操作。menu_driver()函数是菜单系统的主要工作对象。这个函数的第二个参数告诉我们要对菜单做什么。根据参数，menu_driver()执行相应的任务。该值可以是菜单导航请求、ascii字符或与鼠标事件关联的KEY_MOUSE特殊键。 menu_driver接受以下导航请求。 REQ_LEFT_ITEM Move left to an item. REQ_RIGHT_ITEM Move right to an item. REQ_UP_ITEM Move up to an item. REQ_DOWN_ITEM Move down to an item. REQ_SCR_ULINE Scroll up a line. REQ_SCR_DLINE Scroll down a line. REQ_SCR_DPAGE Scroll down a page. REQ_SCR_UPAGE Scroll up a page. REQ_FIRST_ITEM Move to the first item. REQ_LAST_ITEM Move to the last item. REQ_NEXT_ITEM Move to the next item. REQ_PREV_ITEM Move to the previous item. REQ_TOGGLE_ITEM Select/deselect an item. REQ_CLEAR_PATTERN Clear the menu pattern buffer. REQ_BACK_PATTERN Delete the previous character from the pattern buffer. REQ_NEXT_MATCH Move to the next item matching the pattern match. REQ_PREV_MATCH Move to the previous item matching the pattern match. 不要被众多的选择压垮。我们将慢慢地看到他们一个接一个。本例中感兴趣的选项是REQ_UP_ITEM和REQ_DOWN_ITEM。当这两个选项传递给menu_driver时，菜单驱动程序将当前项分别更新为向上或向下的一个项。 正如您在上面的例子中看到的，menu_driver在更新菜单中扮演着重要的角色。理解它所需要的各种选项以及它们的作用是非常重要的。如上所述，menu_driver()的第二个参数可以是一个导航请求、一个可打印字符或一个KEY_MOUSE键。让我们分析一下不同的导航请求。 说明 REQ_LEFT_ITEM 和 REQ_RIGHT_ITEM 一个菜单可以显示多个列的一个以上的项目。这可以通过使用menu_format()函数来实现。当显示多栏菜单时，这些请求会导致菜单驱动程序将当前选择向左或向右移动。 REQ_UP_ITEM 和 REQ_DOWN_ITEM 在上面的例子中，您已经看到了这两个选项。当给出这些选项时，使menu_driver将当前选择向上或向下移动到一个项目。 ERQ_SCR_* REQ_SCR_ULINE、REQ_SCR_DLINE、REQ_SCR_DPAGE、REQ_SCR_UPAGE四个选项与滚动有关。如果菜单中的所有项都不能显示在菜单子窗口中，则菜单是可滚动的。这些请求可以交给menu_driver来分别上下滚动一行或一页。 REQ_FIRST_ITEM, REQ_LAST_ITEM, REQ_NEXT_ITEM 和 REQ_PREV_ITEM REQ_TOGGLE_ITEM 给出此请求时，切换当前选择。此选项只能在多值菜单中使用。所以要使用这个请求，O_ONEVALUE选项必须关闭。可以使用set_menu_opts()关闭或打开该选项。 pattern requests 每个菜单都有一个相关联的模式缓冲区，用于查找与用户输入的ascii字符最近的匹配。只要给menu_driver一个ascii字符，它就会被放入模式缓冲区。它还尝试在项目列表中找到与模式最接近的匹配项，并将当前选择移动到该项目。请求REQ_CLEAR_PATTERN清除模式缓冲区。请求REQ_BACK_PATTERN删除模式缓冲区中的前一个字符。如果模式匹配多个项，那么匹配的项可以通过REQ_NEXT_MATCH和REQ_PREV_MATCH循环，它们分别将当前选择移动到下一个和前一个匹配项。 mouse requests 对于KEY_MOUSE请求，根据鼠标位置采取相应的操作。要采取的行动在手册页中解释为如果第二个参数是KEY_MOUSE特殊键，则相关的鼠标事件被转换为上述事件之一预定义的请求。目前只在用户中单击窗口(如菜单内的显示区域或装饰)Tion窗口)被处理。如果你点击上面的显示区域，则生成REQ_SCR_ULINE双击一个REQ_SCR_UPAGE生成，如果您点击三下会生成一个REQ_FIRST_ITEM。如果你点击在菜单显示区域的下面，是REQ_SCR_DLINE生成，如果双击，则会生成REQ_SCR_DPAGE如果你点击三次，就会生成一个REQ_LAST_ITEM。如果你点击菜单显示区域内的一个项目，菜单光标被定位到该项上。 以上每个请求都将在适当的情况下在以下几行中通过几个示例进行解释。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:16:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"Menu Windows 创建的每个菜单都与一个窗口和一个子窗口相关联。菜单窗口显示与菜单相关的任何标题或边框。菜单子窗口显示当前可供选择的菜单项。但是在这个简单的例子中，我们没有指定任何窗口或子窗口。当没有指定窗口时，将stdscr作为主窗口，然后菜单系统计算显示项目所需的子窗口大小。然后项目显示在计算子窗口中。因此，让我们使用这些窗口并显示一个带有边框和标题的菜单。 这个例子创建了一个带有标题、边框和分隔标题和项的花式线的菜单。如您所见，为了将窗口附加到菜单，必须使用函数set_menu_win()。然后我们也附加子窗口。这将显示子窗口中的项目。您还可以使用set_menu_mark()设置显示在所选项目左侧的标记字符串。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:16:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"带滚动的菜单 如果给一个窗口的子窗口不够大，不能显示所有的项目，那么菜单将是可滚动的。当您位于当前列表中的最后一项时，如果您发送REQ_DOWN_ITEM，它将被转换为REQ_SCR_DLINE，并且菜单将按一项滚动。您可以手动给REQ_SCR_操作来进行滚动。让我们看看怎么做。 这个程序是不言自明的。在这个例子中，选择的数量已经增加到10个，这比我们的子窗口大小(可以容纳6个项目)要大。必须使用set_menu_format()函数显式地将此消息传递给菜单系统。在这里，我们指定要为单个页面显示的行数和列数。我们可以在rows变量中指定要显示的任何数量的项，如果它小于子窗口的高度。如果用户按下的键是PAGE UP或PAGE DOWN，则由于提供给menu_driver()的请求(REQ_SCR_DPAGE和REQ_SCR_UPAGE)，菜单将滚动一页。 #include \u003ccurses.h\u003e #include \u003cmenu.h\u003e #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0])) #define CTRLD 4 char *choices[] = { \"Choice 1\", \"Choice 2\", \"Choice 3\", \"Choice 4\", \"Choice 5\", \"Choice 6\", \"Choice 7\", \"Choice 8\", \"Choice 9\", \"Choice 10\", \"Exit\", (char *)NULL, }; void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color); int main() { ITEM **my_items; int c; MENU *my_menu; WINDOW *my_menu_win; int n_choices, i; /* Initialize curses */ initscr(); start_color(); cbreak(); noecho(); keypad(stdscr, TRUE); init_pair(1, COLOR_RED, COLOR_BLACK); init_pair(2, COLOR_CYAN, COLOR_BLACK); /* Create items */ n_choices = ARRAY_SIZE(choices); my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *)); for(i = 0; i \u003c n_choices; ++i) my_items[i] = new_item(choices[i], choices[i]); /* Crate menu */ my_menu = new_menu((ITEM **)my_items); /* Create the window to be associated with the menu */ my_menu_win = newwin(10, 40, 4, 4); keypad(my_menu_win, TRUE); /* Set main window and sub window */ set_menu_win(my_menu, my_menu_win); set_menu_sub(my_menu, derwin(my_menu_win, 6, 38, 3, 1)); set_menu_format(my_menu, 5, 1); /* Set menu mark to the string \" * \" */ set_menu_mark(my_menu, \" * \"); /* Print a border around the main window and print a title */ box(my_menu_win, 0, 0); print_in_middle(my_menu_win, 1, 0, 40, \"My Menu\", COLOR_PAIR(1)); mvwaddch(my_menu_win, 2, 0, ACS_LTEE); mvwhline(my_menu_win, 2, 1, ACS_HLINE, 38); mvwaddch(my_menu_win, 2, 39, ACS_RTEE); /* Post the menu */ post_menu(my_menu); wrefresh(my_menu_win); attron(COLOR_PAIR(2)); mvprintw(LINES - 2, 0, \"Use PageUp and PageDown to scoll down or up a page of items\"); mvprintw(LINES - 1, 0, \"Arrow Keys to navigate (F1 to Exit)\"); attroff(COLOR_PAIR(2)); refresh(); while((c = wgetch(my_menu_win)) != KEY_F(1)) { switch(c) { case KEY_DOWN: menu_driver(my_menu, REQ_DOWN_ITEM); break; case KEY_UP: menu_driver(my_menu, REQ_UP_ITEM); break; case KEY_NPAGE: menu_driver(my_menu, REQ_SCR_DPAGE); break; case KEY_PPAGE: menu_driver(my_menu, REQ_SCR_UPAGE); break; } wrefresh(my_menu_win); } /* Unpost and free all the memory taken up */ unpost_menu(my_menu); free_menu(my_menu); for(i = 0; i \u003c n_choices; ++i) free_item(my_items[i]); endwin(); } void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color) { int length, x, y; float temp; if(win == NULL) win = stdscr; getyx(win, y, x); if(startx != 0) x = startx; if(starty != 0) y = starty; if(width == 0) width = 80; length = strlen(string); temp = (width - length)/ 2; x = startx + (int)temp; wattron(win, color); mvwprintw(win, y, x, \"%s\", string); wattroff(win, color); refresh(); } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:16:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"多栏菜单 在上面的例子中，您已经看到了如何使用set_menu_format()函数。我没有提到cols变量(第三个参数)的作用。如果子窗口足够宽，您可以选择每行显示多个项目。这可以在cols变量中指定。为了简单起见，下面的示例不显示项目的描述。 #include \u003ccurses.h\u003e #include \u003cmenu.h\u003e #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0])) #define CTRLD 4 char *choices[] = { \"Choice 1\", \"Choice 2\", \"Choice 3\", \"Choice 4\", \"Choice 5\", \"Choice 6\", \"Choice 7\", \"Choice 8\", \"Choice 9\", \"Choice 10\", \"Choice 11\", \"Choice 12\", \"Choice 13\", \"Choice 14\", \"Choice 15\", \"Choice 16\", \"Choice 17\", \"Choice 18\", \"Choice 19\", \"Choice 20\", \"Exit\", (char *)NULL, }; int main() { ITEM **my_items; int c; MENU *my_menu; WINDOW *my_menu_win; int n_choices, i; /* Initialize curses */ initscr(); start_color(); cbreak(); noecho(); keypad(stdscr, TRUE); init_pair(1, COLOR_RED, COLOR_BLACK); init_pair(2, COLOR_CYAN, COLOR_BLACK); /* Create items */ n_choices = ARRAY_SIZE(choices); my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *)); for(i = 0; i \u003c n_choices; ++i) my_items[i] = new_item(choices[i], choices[i]); /* Crate menu */ my_menu = new_menu((ITEM **)my_items); /* Set menu option not to show the description */ menu_opts_off(my_menu, O_SHOWDESC); /* Create the window to be associated with the menu */ my_menu_win = newwin(10, 70, 4, 4); keypad(my_menu_win, TRUE); /* Set main window and sub window */ set_menu_win(my_menu, my_menu_win); set_menu_sub(my_menu, derwin(my_menu_win, 6, 68, 3, 1)); set_menu_format(my_menu, 5, 3); set_menu_mark(my_menu, \" * \"); /* Print a border around the main window and print a title */ box(my_menu_win, 0, 0); attron(COLOR_PAIR(2)); mvprintw(LINES - 3, 0, \"Use PageUp and PageDown to scroll\"); mvprintw(LINES - 2, 0, \"Use Arrow Keys to navigate (F1 to Exit)\"); attroff(COLOR_PAIR(2)); refresh(); /* Post the menu */ post_menu(my_menu); wrefresh(my_menu_win); while((c = wgetch(my_menu_win)) != KEY_F(1)) { switch(c) { case KEY_DOWN: menu_driver(my_menu, REQ_DOWN_ITEM); break; case KEY_UP: menu_driver(my_menu, REQ_UP_ITEM); break; case KEY_LEFT: menu_driver(my_menu, REQ_LEFT_ITEM); break; case KEY_RIGHT: menu_driver(my_menu, REQ_RIGHT_ITEM); break; case KEY_NPAGE: menu_driver(my_menu, REQ_SCR_DPAGE); break; case KEY_PPAGE: menu_driver(my_menu, REQ_SCR_UPAGE); break; } wrefresh(my_menu_win); } /* Unpost and free all the memory taken up */ unpost_menu(my_menu); free_menu(my_menu); for(i = 0; i \u003c n_choices; ++i) free_item(my_items[i]); endwin(); } 默认情况下，所有选项都是打开的。您可以使用menu_opts_on()和menu_opts_off()函数打开或关闭特定的属性。还可以使用set_menu_opts()直接指定选项。该函数的实参应该是上述某些常量的一个OR值。函数menu_opts()可用于查找菜单的当前选项。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:16:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"多选菜单 您可能想知道如果关闭O_ONEVALUE选项会发生什么。然后菜单变成多值。这意味着您可以选择多个项目。这将我们带到请求REQ_TOGGLE_ITEM。让我们看看它的实际情况。 #include \u003ccurses.h\u003e #include \u003cmenu.h\u003e #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0])) #define CTRLD 4 char *choices[] = { \"Choice 1\", \"Choice 2\", \"Choice 3\", \"Choice 4\", \"Choice 5\", \"Choice 6\", \"Choice 7\", \"Exit\", }; int main() { ITEM **my_items; int c; MENU *my_menu; int n_choices, i; ITEM *cur_item; /* Initialize curses */ initscr(); cbreak(); noecho(); keypad(stdscr, TRUE); /* Initialize items */ n_choices = ARRAY_SIZE(choices); my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *)); for(i = 0; i \u003c n_choices; ++i) my_items[i] = new_item(choices[i], choices[i]); my_items[n_choices] = (ITEM *)NULL; my_menu = new_menu((ITEM **)my_items); /* Make the menu multi valued */ menu_opts_off(my_menu, O_ONEVALUE); mvprintw(LINES - 3, 0, \"Use \u003cSPACE\u003e to select or unselect an item.\"); mvprintw(LINES - 2, 0, \"\u003cENTER\u003e to see presently selected items(F1 to Exit)\"); post_menu(my_menu); refresh(); while((c = getch()) != KEY_F(1)) { switch(c) { case KEY_DOWN: menu_driver(my_menu, REQ_DOWN_ITEM); break; case KEY_UP: menu_driver(my_menu, REQ_UP_ITEM); break; case ' ': menu_driver(my_menu, REQ_TOGGLE_ITEM); break; case 10: /* Enter */ { char temp[200]; ITEM **items; items = menu_items(my_menu); temp[0] = '\\0'; for(i = 0; i \u003c item_count(my_menu); ++i) if(item_value(items[i]) == TRUE) { strcat(temp, item_name(items[i])); strcat(temp, \" \"); } move(20, 0); clrtoeol(); mvprintw(20, 0, temp); refresh(); } break; } } free_item(my_items[0]); free_item(my_items[1]); free_menu(my_menu); endwin(); } 哇，很多新功能。让我们一个接一个地拍。首先，REQ_TOGGLE_ITEM。在多值菜单中，应该允许用户选择或取消选择多个项目。请求REQ_TOGGLE_ITEM切换当前选择。在这种情况下，当空格被按下时，REQ_TOGGLE_ITEM请求被发送到menu_driver以实现结果。 现在，当用户按下时，我们将显示他当前选择的项目。首先，我们使用menu_items()函数找出与菜单关联的项。然后循环遍历项目，以确定项目是否被选中。函数item_value()如果选择了一个项目，则返回TRUE。函数item_count()返回菜单中项目的数量。项目名称可以通过item_name()找到。您还可以使用item_description()找到与项目关联的描述。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:16:4","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"菜单操作 好吧，到这个时候，你一定渴望你的菜单有一些不同，有很多功能。我知道。你想要颜色!!你想要创建类似于那些文本模式dos游戏的漂亮菜单。函数set_menu_fore()和set_menu_back()可用于更改选定项和未选定项的属性。这些名字具有误导性。他们不改变菜单的前景或背景，这将是无用的。 函数set_menu_grey()可用于设置菜单中不可选择项的显示属性。这为我们带来了一个有趣的项目选项，即唯一的O_SELECTABLE。我们可以通过函数item_opts_off()关闭它，之后该项就不可选了。它就像那些花哨的窗口菜单上的灰色项目。让我们通过这个例子将这些概念付诸实践 #include \u003cmenu.h\u003e #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0])) #define CTRLD 4 char *choices[] = { \"Choice 1\", \"Choice 2\", \"Choice 3\", \"Choice 4\", \"Choice 5\", \"Choice 6\", \"Choice 7\", \"Exit\", }; int main() { ITEM **my_items; int c; MENU *my_menu; int n_choices, i; ITEM *cur_item; /* Initialize curses */ initscr(); start_color(); cbreak(); noecho(); keypad(stdscr, TRUE); init_pair(1, COLOR_RED, COLOR_BLACK); init_pair(2, COLOR_GREEN, COLOR_BLACK); init_pair(3, COLOR_MAGENTA, COLOR_BLACK); /* Initialize items */ n_choices = ARRAY_SIZE(choices); my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *)); for(i = 0; i \u003c n_choices; ++i) my_items[i] = new_item(choices[i], choices[i]); my_items[n_choices] = (ITEM *)NULL; item_opts_off(my_items[3], O_SELECTABLE); item_opts_off(my_items[6], O_SELECTABLE); /* Create menu */ my_menu = new_menu((ITEM **)my_items); /* Set fore ground and back ground of the menu */ set_menu_fore(my_menu, COLOR_PAIR(1) | A_REVERSE); set_menu_back(my_menu, COLOR_PAIR(2)); set_menu_grey(my_menu, COLOR_PAIR(3)); /* Post the menu */ mvprintw(LINES - 3, 0, \"Press \u003cENTER\u003e to see the option selected\"); mvprintw(LINES - 2, 0, \"Up and Down arrow keys to naviage (F1 to Exit)\"); post_menu(my_menu); refresh(); while((c = getch()) != KEY_F(1)) { switch(c) { case KEY_DOWN: menu_driver(my_menu, REQ_DOWN_ITEM); break; case KEY_UP: menu_driver(my_menu, REQ_UP_ITEM); break; case 10: /* Enter */ move(20, 0); clrtoeol(); mvprintw(20, 0, \"Item selected is : %s\", item_name(current_item(my_menu))); pos_menu_cursor(my_menu); break; } } unpost_menu(my_menu); for(i = 0; i \u003c n_choices; ++i) free_item(my_items[i]); free_menu(my_menu); endwin(); } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:16:5","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"有用的用户指针 我们可以将用户指针与菜单中的每一项关联起来。它的工作方式与面板中的用户指针相同。它不受菜单系统影响。你可以在里面存储任何你喜欢的东西。我通常使用它来存储在选择菜单选项时要执行的函数(它被选中，可能是用户按下); #include \u003ccurses.h\u003e #include \u003cmenu.h\u003e #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0])) #define CTRLD 4 char *choices[] = { \"Choice 1\", \"Choice 2\", \"Choice 3\", \"Choice 4\", \"Choice 5\", \"Choice 6\", \"Choice 7\", \"Exit\", }; void func(char *name); int main() { ITEM **my_items; int c; MENU *my_menu; int n_choices, i; ITEM *cur_item; /* Initialize curses */ initscr(); start_color(); cbreak(); noecho(); keypad(stdscr, TRUE); init_pair(1, COLOR_RED, COLOR_BLACK); init_pair(2, COLOR_GREEN, COLOR_BLACK); init_pair(3, COLOR_MAGENTA, COLOR_BLACK); /* Initialize items */ n_choices = ARRAY_SIZE(choices); my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *)); for(i = 0; i \u003c n_choices; ++i) { my_items[i] = new_item(choices[i], choices[i]); /* Set the user pointer */ set_item_userptr(my_items[i], func); } my_items[n_choices] = (ITEM *)NULL; /* Create menu */ my_menu = new_menu((ITEM **)my_items); /* Post the menu */ mvprintw(LINES - 3, 0, \"Press \u003cENTER\u003e to see the option selected\"); mvprintw(LINES - 2, 0, \"Up and Down arrow keys to naviage (F1 to Exit)\"); post_menu(my_menu); refresh(); while((c = getch()) != KEY_F(1)) { switch(c) { case KEY_DOWN: menu_driver(my_menu, REQ_DOWN_ITEM); break; case KEY_UP: menu_driver(my_menu, REQ_UP_ITEM); break; case 10: /* Enter */ { ITEM *cur; void (*p)(char *); cur = current_item(my_menu); p = item_userptr(cur); p((char *)item_name(cur)); pos_menu_cursor(my_menu); break; } break; } } unpost_menu(my_menu); for(i = 0; i \u003c n_choices; ++i) free_item(my_items[i]); free_menu(my_menu); endwin(); } void func(char *name) { move(20, 0); clrtoeol(); mvprintw(20, 0, \"Item selected is : %s\", name); } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:16:6","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"表单（Forms） 好。如果你在网页上看到过这些表单，它们从用户那里获取输入并做各种各样的事情，你可能想知道如何在文本模式下创建这样的表单。用简单的语言写出那些漂亮的形式是相当困难的。表单库试图提供一个基本框架来轻松地构建和维护表单。它有很多特性(功能)，管理验证，动态扩展字段等。让我们来看看它的全部流程。 表单是字段的集合;每个字段可以是一个标签(静态文本)，也可以是一个数据输入位置。表单库还提供了将表单划分为多个页面的函数。 表单的创建方式与菜单的创建方式大致相同。首先使用new_field()创建与表单相关的字段。您可以为字段设置选项，这样它们就可以按设置显示一些属性，在字段失去焦点之前进行验证等等。然后将字段附加到表单。在此之后，表单就可以显示并准备接收输入了。在与menu_driver()类似的行中，使用form_driver()操作表单。我们可以向form_driver发送请求，将焦点移动到某个字段，将光标移动到字段的末尾等。在用户在字段中输入值并完成验证后，表单可以取消张贴，分配的内存可以释放。 表单程序的一般控制流程如下所示。 初始化curses 使用new_field()创建字段。您可以指定字段的高度和宽度，以及它在表单上的位置。 通过指定要附加的字段，使用new_form()创建表单。 使用form_post()提交表单并刷新屏幕。 使用循环处理用户请求，并使用form_driver对form进行必要的更新。 使用form_unpost()取消菜单 释放free_form()分配给菜单的内存 使用free_field()释放分配给项的内存 结束curses 如您所见，使用表单库与处理菜单库非常相似。下面的示例将探讨表单处理的各个方面。让我们从一个简单的例子开始。 #include \u003cform.h\u003e int main() { FIELD *field[3]; FORM *my_form; int ch; /* Initialize curses */ initscr(); cbreak(); noecho(); keypad(stdscr, TRUE); /* Initialize the fields */ field[0] = new_field(1, 10, 4, 18, 0, 0); field[1] = new_field(1, 10, 6, 18, 0, 0); field[2] = NULL; /* Set field options */ set_field_back(field[0], A_UNDERLINE); /* Print a line for the option */ field_opts_off(field[0], O_AUTOSKIP); /* Don't go to next field when this */ /* Field is filled up */ set_field_back(field[1], A_UNDERLINE); field_opts_off(field[1], O_AUTOSKIP); /* Create the form and post it */ my_form = new_form(field); post_form(my_form); refresh(); mvprintw(4, 10, \"Value 1:\"); mvprintw(6, 10, \"Value 2:\"); refresh(); /* Loop through to get user requests */ while((ch = getch()) != KEY_F(1)) { switch(ch) { case KEY_DOWN: /* Go to next field */ form_driver(my_form, REQ_NEXT_FIELD); /* Go to the end of the present buffer */ /* Leaves nicely at the last character */ form_driver(my_form, REQ_END_LINE); break; case KEY_UP: /* Go to previous field */ form_driver(my_form, REQ_PREV_FIELD); form_driver(my_form, REQ_END_LINE); break; default: /* If this is a normal character, it gets */ /* Printed */ form_driver(my_form, ch); break; } } /* Un post form and free the memory */ unpost_form(my_form); free_form(my_form); free_field(field[0]); free_field(field[1]); endwin(); return 0; } 上面的例子很简单。它使用new_field()创建了两个字段。new_field()获取高度、宽度、起始值、startx、屏幕外行数和额外工作缓冲区数。屏幕外行数的第五个参数指定要显示的字段的大小。如果它为零，则始终显示整个字段，否则当用户访问未显示的字段部分时，表单将是可滚动的。表单库为每个字段分配一个缓冲区来存储用户输入的数据。使用new_field()的最后一个参数，我们可以指定它来分配一些额外的缓冲区。这些可以用于任何你喜欢的目的。 在创建字段之后，它们的背景属性都被设置为一个下划线，使用set_field_back()。AUTOSKIP选项使用field_opts_off()关闭。如果打开此选项，一旦活动字段被完全填充，焦点将移动到表单中的下一个字段。 在将字段附加到表单之后，表单就被发布了。在这里，通过向form_driver发出相应的请求，在while循环中处理用户输入。对form_driver()的所有请求的详细信息将在后面解释。 每个表单字段都与许多属性相关联。他们可以被操纵，以获得所需的效果和乐趣!!那为什么还要等待呢? 我们在创建字段时给出的参数可以使用field_info()检索。它返回高度、宽度、起始值、startx、屏幕外行数以及给定参数的附加缓冲区数。它是new_field()的逆函数。 int field_info( FIELD *field, /* field from which to fetch */ int *height, *int width, /* field size */ int *top, int *left, /* upper left corner */ int *offscreen, /* number of offscreen rows */ int *nbuf); /* number of working buffers */ 可以使用move_field()将字段的位置移动到不同的位置。 int move_field( FIELD *field, /* field to alter */ int top, int left); /* new upper-left corner */ 与往常一样，可以使用field_infor()查询更改的位置。 可以使用函数set_field_just()对字段进行校正。 int set_field_just(FIELD *field, /* field to alter */ int justmode); /* mode to set */ int field_just(FIELD *field); /* fetch justify mode of field */ 这些函数接受和返回的调整模式值为NO_JUSTIFICATION、justicy_right、justicy_left或justicy_center。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"字段显示属性 如您所见，在上面的示例中，可以使用set_field_fore()和setfield_back()设置字段的display属性。这些函数设置字段的前景和背景属性。您还可以指定一个填充字符，它将被填充在字段的未填充部分。pad字符通过调用set_field_pad()来设置。pad默认值为空格。函数field_fore()，field_back, field_pad()可用于查询当前前景，背景属性和字段的填充字符。下面的列表给出了函数的用法。 int set_field_fore(FIELD *field, /* field to alter */ chtype attr); /* attribute to set */ chtype field_fore(FIELD *field); /* field to query */ /* returns foreground attribute */ int set_field_back(FIELD *field, /* field to alter */ chtype attr); /* attribute to set */ chtype field_back(FIELD *field); /* field to query */ /* returns background attribute */ int set_field_pad(FIELD *field, /* field to alter */ int pad); /* pad character to set */ chtype field_pad(FIELD *field); /* field to query */ /* returns present pad character */ 虽然上面的函数看起来很简单，但在一开始使用set_field_fore()使用颜色可能会令人沮丧。让我先解释一下字段的前景和背景属性。前台属性与字符相关联。这意味着字段中的字符将使用您使用set_field_fore()设置的属性打印。背景属性是用于填充字段背景的属性，无论是否有字符。那么颜色呢?由于颜色总是成对定义的，那么显示彩色字段的正确方法是什么?下面是一个说明颜色属性的示例。 #include \u003cform.h\u003e int main() { FIELD *field[3]; FORM *my_form; int ch; /* Initialize curses */ initscr(); start_color(); cbreak(); noecho(); keypad(stdscr, TRUE); /* Initialize few color pairs */ init_pair(1, COLOR_WHITE, COLOR_BLUE); init_pair(2, COLOR_WHITE, COLOR_BLUE); /* Initialize the fields */ field[0] = new_field(1, 10, 4, 18, 0, 0); field[1] = new_field(1, 10, 6, 18, 0, 0); field[2] = NULL; /* Set field options */ set_field_fore(field[0], COLOR_PAIR(1));/* Put the field with blue background */ set_field_back(field[0], COLOR_PAIR(2));/* and white foreground (characters */ /* are printed in white */ field_opts_off(field[0], O_AUTOSKIP); /* Don't go to next field when this */ /* Field is filled up */ set_field_back(field[1], A_UNDERLINE); field_opts_off(field[1], O_AUTOSKIP); /* Create the form and post it */ my_form = new_form(field); post_form(my_form); refresh(); set_current_field(my_form, field[0]); /* Set focus to the colored field */ mvprintw(4, 10, \"Value 1:\"); mvprintw(6, 10, \"Value 2:\"); mvprintw(LINES - 2, 0, \"Use UP, DOWN arrow keys to switch between fields\"); refresh(); /* Loop through to get user requests */ while((ch = getch()) != KEY_F(1)) { switch(ch) { case KEY_DOWN: /* Go to next field */ form_driver(my_form, REQ_NEXT_FIELD); /* Go to the end of the present buffer */ /* Leaves nicely at the last character */ form_driver(my_form, REQ_END_LINE); break; case KEY_UP: /* Go to previous field */ form_driver(my_form, REQ_PREV_FIELD); form_driver(my_form, REQ_END_LINE); break; default: /* If this is a normal character, it gets */ /* Printed */ form_driver(my_form, ch); break; } } /* Un post form and free the memory */ unpost_form(my_form); free_form(my_form); free_field(field[0]); free_field(field[1]); endwin(); return 0; } 使用颜色对，试着理解前景和背景属性。在我使用颜色属性的程序中，我通常只使用set_field_back()设置背景。Curses不允许定义单独的颜色属性。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"字段选项 您还可以设置大量的字段选项位来控制表单处理的各个方面。你可以用这些函数来操作它们: int set_field_opts(FIELD *field, /* field to alter */ int attr); /* attribute to set */ int field_opts_on(FIELD *field, /* field to alter */ int attr); /* attributes to turn on */ int field_opts_off(FIELD *field, /* field to alter */ int attr); /* attributes to turn off */ int field_opts(FIELD *field); /* field to query */ 函数set_field_opts()可用于直接设置字段的属性，或者您可以选择使用field_opts_on()和field_opts_off()选择性地打开和关闭一些属性。任何时候都可以使用field_opts()查询字段的属性。下面是可用选项的列表。默认情况下，所有选项都是打开的。 O_VISIBLE 控制该字段在屏幕上是否可见。可用于在表单处理期间根据父字段的值隐藏或弹出字段。 O_ACTIVE 控制字段在表单处理期间是否处于活动状态(即由表单导航键访问)。可用于使带有缓冲区值的标签或派生字段可由表单应用程序而不是用户更改. O_PUBLIC 控制在输入字段时是否显示数据。如果在某个字段上关闭该选项，库将接受并编辑该字段中的数据，但不会显示该数据，可见的字段游标也不会移动。您可以关闭O_PUBLIC位来定义密码字段。 O_EDIT 控制是否可以修改字段的数据。当该选项关闭时，除REQ_PREV_CHOICE和req_next_choice外的所有编辑请求都将失败。这种只读字段可能对帮助消息有用。 O_WRAP 控制多行字段的换行。通常，当一个(空白分隔的)单词的任何字符到达当前行的末尾时，整个单词被换行到下一行(假设有一行)。关闭此选项时，单词将在换行符上被分割。 O_BLANK 控制字段消隐。当该选项打开时，在第一个字段位置输入一个字符将擦除整个字段(除了刚刚输入的字符)。 O_AUTOSKIP 控制在填充此字段时自动跳转到下一个字段。通常，当表单用户试图在字段中输入超出容量的数据时，编辑位置将跳转到下一个字段。当关闭此选项时，用户的光标将挂在字段的末尾。在未达到其大小限制的动态字段中，此选项将被忽略。 O_NULLOK 控制是否将验证应用于空白字段。通常情况下，它不是;用户可以在退出时不调用通常的验证检查而将字段留空。如果该选项在字段上关闭，退出该选项将调用验证检查。 O_PASSOK 控制是否在每个出口上进行验证，还是仅在修改字段之后进行验证。通常后者是正确的。如果字段的验证函数在表单处理过程中发生变化，那么设置O_PASSOK可能会很有用。 O_STATIC 控制字段是否固定为其初始尺寸。如果关闭此选项，该字段将变成动态的，并将拉伸以适应输入的数据。 当字段当前被选中时，不能更改字段的选项。但是，对于已发布的非当前字段，选项可能会被更改。 选项值是位掩码，可以用逻辑或明显的方式组合。您已经看到了关闭O_AUTOSKIP选项的用法。下面的示例说明了更多选项的用法。在适当的地方解释了其他选项。 #include \u003cform.h\u003e #define STARTX 15 #define STARTY 4 #define WIDTH 25 #define N_FIELDS 3 int main() { FIELD *field[N_FIELDS]; FORM *my_form; int ch, i; /* Initialize curses */ initscr(); cbreak(); noecho(); keypad(stdscr, TRUE); /* Initialize the fields */ for(i = 0; i \u003c N_FIELDS - 1; ++i) field[i] = new_field(1, WIDTH, STARTY + i * 2, STARTX, 0, 0); field[N_FIELDS - 1] = NULL; /* Set field options */ set_field_back(field[1], A_UNDERLINE); /* Print a line for the option */ field_opts_off(field[0], O_ACTIVE); /* This field is a static label */ field_opts_off(field[1], O_PUBLIC); /* This filed is like a password field*/ field_opts_off(field[1], O_AUTOSKIP); /* To avoid entering the same field */ /* after last character is entered */ /* Create the form and post it */ my_form = new_form(field); post_form(my_form); refresh(); set_field_just(field[0], JUSTIFY_CENTER); /* Center Justification */ set_field_buffer(field[0], 0, \"This is a static Field\"); /* Initialize the field */ mvprintw(STARTY, STARTX - 10, \"Field 1:\"); mvprintw(STARTY + 2, STARTX - 10, \"Field 2:\"); refresh(); /* Loop through to get user requests */ while((ch = getch()) != KEY_F(1)) { switch(ch) { case KEY_DOWN: /* Go to next field */ form_driver(my_form, REQ_NEXT_FIELD); /* Go to the end of the present buffer */ /* Leaves nicely at the last character */ form_driver(my_form, REQ_END_LINE); break; case KEY_UP: /* Go to previous field */ form_driver(my_form, REQ_PREV_FIELD); form_driver(my_form, REQ_END_LINE); break; default: /* If this is a normal character, it gets */ /* Printed */ form_driver(my_form, ch); break; } } /* Un post form and free the memory */ unpost_form(my_form); free_form(my_form); free_field(field[0]); free_field(field[1]); endwin(); return 0; } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"状态字段 字段状态指定字段是否已被编辑。它最初被设置为FALSE，当用户输入一些东西并且数据缓冲区被修改时，它变成TRUE。因此，可以查询字段的状态，以确定它是否已被修改。以下功能可以协助这些操作。 int set_field_status(FIELD *field, /* field to alter */ int status); /* status to set */ int field_status(FIELD *field); /* fetch status of field */ 最好在离开字段后才检查字段的状态，因为数据缓冲区可能还没有更新，因为验证仍然到期。为了保证返回正确的状态，可以调用field_status() 在字段的退出验证检查例程中 在字段或表单的初始化或终止钩子中，或者 在表单驱动程序处理完REQ_VALIDATION请求之后 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:3","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"用户指针字段 每个字段结构都包含一个指针，用户可以将其用于各种目的。它不受表单库的影响，用户可以将其用于任何目的。下面的函数设置和获取用户指针。 int set_field_userptr(FIELD *field, char *userptr); /* the user pointer you wish to associate */ /* with the field */ char *field_userptr(FIELD *field); /* fetch user pointer of the field */ ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:4","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"Variable大小字段 如果您想要一个具有可变宽度的动态变化字段，这就是您想要充分利用的特性。这将允许用户输入比字段原始大小更多的数据，并让字段增长。根据字段方向，它将水平或垂直滚动以合并新数据。 要使字段可动态增长，应关闭O_STATIC选项。这可以用 field_opts_off(field_pointer, O_STATIC); 但是，让一块地无限生长通常是不可取的。您可以设置一个最大限制的增长领域与 int set_max_field(FIELD *field, /* Field on which to operate */ int max_growth); /* maximum growth allowed for the field */ 动态增长字段的字段信息可以通过 int dynamic_field_info( FIELD *field, /* Field on which to operate */ int *prows, /* number of rows will be filled in this */ int *pcols, /* number of columns will be filled in this*/ int *pmax) /* maximum allowable growth will be filled */ /* in this */ 尽管field_info工作正常，但建议使用此函数获取动态增长字段的适当属性。 调用标准库例程new_field;高度设置为1的新字段将被定义为一行字段。高度大于1的新字段将被定义为多行字段。 关闭O_STATIC的一行字段(动态可增长字段)将包含单个固定行，但如果用户输入的数据超过初始字段所能容纳的数据，则列的数量可能会增加。显示的列数将保持固定，额外的数据将水平滚动。 关闭O_STATIC的多行字段(动态可增长字段)将包含固定数量的列，但如果用户输入的数据多于初始字段所容纳的数据，则行数可以增加。显示的行数将保持固定，额外的数据将垂直滚动。 上面两段描述了动态增长字段的行为。表单库其他部分的行为方式如下所示: 如果O_STATIC选项关闭，并且没有为字段指定最大增长，那么字段选项O_AUTOSKIP将被忽略。目前，当用户输入字段的最后一个字符位置时，O_AUTOSKIP会自动生成一个REQ_NEXT_FIELD表单驱动程序请求。在没有指定最大增长的可增长字段上，没有最后一个字符位置。如果指定了最大增长，那么如果字段已经增长到最大大小，O_AUTOSKIP选项将正常工作。 如果选项O_STATIC被关闭，字段的校正将被忽略。目前，set_field_just可以用来对一行字段的内容进行justicy_left, justicy_right, justicy_center。根据定义，可增长的一行字段将水平增长和滚动，并且可能包含超出合理范围的数据。field_just的返回值将保持不变。 如果字段选项O_STATIC关闭，并且没有为字段指定最大增长，重载表单驱动程序请求REQ_NEW_LINE将以相同的方式操作，而不管O_NL_OVERLOAD表单选项。目前，如果表单选项O_NL_OVERLOAD是打开的，那么如果从字段的最后一行调用REQ_NEW_LINE，则隐式生成一个REQ_NEXT_FIELD。如果字段可以无限制地增长，则没有最后一行，因此REQ_NEW_LINE永远不会隐式生成REQ_NEXT_FIELD。如果指定了最大增长限制，并且打开了O_NL_OVERLOAD表单选项，则REQ_NEW_LINE仅在字段已增长到最大大小且用户位于最后一行时才隐式生成REQ_NEXT_FIELD。 库调用dup_field将照常工作;它将复制字段，包括当前缓冲区大小和被复制字段的内容。任何指定的最大增长也将被复制。 标准库调用link_field将照常工作;它将复制所有字段属性，并与被链接的字段共享缓冲区。如果O_STATIC字段选项随后被一个字段共享缓冲区更改，那么当试图向字段中输入比缓冲区当前持有的数据更多的数据时，系统的反应将取决于当前字段中该选项的设置。 标准库调用field_info将照常工作;变量nrow将包含对new_field的原始调用的值。用户应该使用上面描述的dynamic_field_info来查询缓冲区的当前大小。 只有在解释了表单驱动程序之后，上面的一些观点才有意义。我们将在接下来的几节中讨论这个问题。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:5","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"表格界面 表单窗口的概念与菜单窗口非常相似。每个表单都与一个主窗口和一个子窗口相关联。表单主窗口显示任何相关的标题或边框或任何用户希望的内容。然后子窗口包含所有字段，并根据它们的位置显示它们。这就提供了非常容易地操纵花哨形式显示的灵活性。 因为这与菜单窗口非常相似，所以我只提供了一个例子，不做太多解释。它们的功能相似，工作方式相同。 #include \u003cform.h\u003e void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color); int main() { FIELD *field[3]; FORM *my_form; WINDOW *my_form_win; int ch, rows, cols; /* Initialize curses */ initscr(); start_color(); cbreak(); noecho(); keypad(stdscr, TRUE); /* Initialize few color pairs */ init_pair(1, COLOR_RED, COLOR_BLACK); /* Initialize the fields */ field[0] = new_field(1, 10, 6, 1, 0, 0); field[1] = new_field(1, 10, 8, 1, 0, 0); field[2] = NULL; /* Set field options */ set_field_back(field[0], A_UNDERLINE); field_opts_off(field[0], O_AUTOSKIP); /* Don't go to next field when this */ /* Field is filled up */ set_field_back(field[1], A_UNDERLINE); field_opts_off(field[1], O_AUTOSKIP); /* Create the form and post it */ my_form = new_form(field); /* Calculate the area required for the form */ scale_form(my_form, \u0026rows, \u0026cols); /* Create the window to be associated with the form */ my_form_win = newwin(rows + 4, cols + 4, 4, 4); keypad(my_form_win, TRUE); /* Set main window and sub window */ set_form_win(my_form, my_form_win); set_form_sub(my_form, derwin(my_form_win, rows, cols, 2, 2)); /* Print a border around the main window and print a title */ box(my_form_win, 0, 0); print_in_middle(my_form_win, 1, 0, cols + 4, \"My Form\", COLOR_PAIR(1)); post_form(my_form); wrefresh(my_form_win); mvprintw(LINES - 2, 0, \"Use UP, DOWN arrow keys to switch between fields\"); refresh(); /* Loop through to get user requests */ while((ch = wgetch(my_form_win)) != KEY_F(1)) { switch(ch) { case KEY_DOWN: /* Go to next field */ form_driver(my_form, REQ_NEXT_FIELD); /* Go to the end of the present buffer */ /* Leaves nicely at the last character */ form_driver(my_form, REQ_END_LINE); break; case KEY_UP: /* Go to previous field */ form_driver(my_form, REQ_PREV_FIELD); form_driver(my_form, REQ_END_LINE); break; default: /* If this is a normal character, it gets */ /* Printed */ form_driver(my_form, ch); break; } } /* Un post form and free the memory */ unpost_form(my_form); free_form(my_form); free_field(field[0]); free_field(field[1]); endwin(); return 0; } void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color) { int length, x, y; float temp; if(win == NULL) win = stdscr; getyx(win, y, x); if(startx != 0) x = startx; if(starty != 0) y = starty; if(width == 0) width = 80; length = strlen(string); temp = (width - length)/ 2; x = startx + (int)temp; wattron(win, color); mvwprintw(win, y, x, \"%s\", string); wattroff(win, color); refresh(); } ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:6","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"字段验证 默认情况下，字段将接受用户输入的任何数据。可以将验证附加到字段。然后，当该字段包含与验证类型不匹配的数据时，用户试图离开该字段的任何尝试都将失败。某些验证类型还在字段中每次输入字符时进行字符有效性检查。 可以使用以下函数将验证附加到字段。 int set_field_type(FIELD *field, /* field to alter */ FIELDTYPE *ftype, /* type to associate */ ...); /* additional arguments*/ 设置后，可以使用该字段的验证类型进行查询 FIELDTYPE *field_type(FIELD *field); /* field to query */ 表单驱动程序仅在最终用户输入数据时验证字段中的数据。时不发生验证 应用程序通过调用set_field_buffer来更改字段值。 链接的字段值是间接改变的——通过改变它们链接到的字段 下面是预定义的验证类型。您还可以指定自定义验证，尽管这有点棘手和麻烦。 TYPE_ALPHA 此字段类型接受字母数据;没有空格，没有数字，没有特殊字符(在字符输入时检查)。它的设置为: int set_field_type(FIELD *field, /* field to alter */ TYPE_ALPHA, /* type to associate */ int width); /* maximum width of field */ width参数设置数据的最小宽度。用户必须输入至少宽度的字符数才能离开字段。通常你会把这个设置为字段宽度;如果它大于字段宽度，验证检查将始终失败。最小宽度为零使得字段补全是可选的。 TYPE_ALNUM 此字段类型接受字母数据和数字;没有空格，没有特殊字符(在字符输入时检查)。它的设置为: int set_field_type(FIELD *field, /* field to alter */ TYPE_ALNUM, /* type to associate */ int width); /* maximum width of field */ width参数设置数据的最小宽度。与TYPE_ALPHA一样，通常你需要将其设置为字段宽度;如果它大于字段宽度，验证检查将始终失败。最小宽度为零使得字段补全是可选的。 TYPE_ENUM 此类型允许您将字段的值限制为指定的字符串值集(例如，美国各州的两个字母邮政编码)。它的设置为: int set_field_type(FIELD *field, /* field to alter */ TYPE_ENUM, /* type to associate */ char **valuelist; /* list of possible values */ int checkcase; /* case-sensitive? */ int checkunique); /* must specify uniquely? */ valuelist参数必须指向以null结束的有效字符串列表。checkcase参数如果为真，则与字符串区分大小写进行比较。 当用户退出TYPE_ENUM字段时，验证过程尝试将缓冲区中的数据填充为有效项。如果输入了完整的选择字符串，它当然是有效的。但是也可以输入一个有效字符串的前缀并为您完成它。 缺省情况下，如果输入的前缀在字符串列表中匹配了一个以上的值，则从第一个匹配的值开始补全。但是checkunique参数如果为真，则要求前缀匹配是唯一的，以便有效。 REQ_NEXT_CHOICE和REQ_PREV_CHOICE输入请求对于这些字段特别有用。 TYPE_INTEGER 此字段类型接受一个整数。其设置如下: int set_field_type(FIELD *field, /* field to alter */ TYPE_INTEGER, /* type to associate */ int padding, /* # places to zero-pad to */ int vmin, int vmax); /* valid range */ 有效字符由可选的前导减号和数字组成。在退出时执行范围检查。如果范围最大值小于或等于最小值，则忽略范围。 如果值通过了范围检查，它将填充尽可能多的前导零数字，以满足填充参数。 TYPE_INTEGER值缓冲区可以用C库函数atoi(3)方便地解释。 TYPE_NUMERIC 此字段类型接受十进制数。其设置如下: int set_field_type(FIELD *field, /* field to alter */ TYPE_NUMERIC, /* type to associate */ int padding, /* # places of precision */ int vmin, int vmax); /* valid range */ 有效字符由可选的前导减号和数字组成。可能还包括一个小数点。在退出时执行范围检查。如果范围最大值小于或等于最小值，则忽略范围。 如果值通过了范围检查，它将填充尽可能多的尾随零数字，以满足填充参数。 TYPE_NUMERIC值缓冲区可以用C库函数atof(3)方便地解释。 TYPE_REHEXP 此字段类型接受匹配正则表达式的数据。其设置如下: int set_field_type(FIELD *field, /* field to alter */ TYPE_REGEXP, /* type to associate */ char *regexp); /* expression to match */ 正则表达式的语法是regcomp(3)。正则表达式匹配检查在退出时执行。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:7","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"表单驱动——表单系统主力军 和菜单系统一样，form_driver()在表单系统中扮演着非常重要的角色。对表单系统的所有类型的请求都应该通过form_driver()过滤。 int form_driver(FORM *form, /* form on which to operate */ int request) /* form request code */ 正如您已经看到的上面的一些示例，您必须在循环中寻找用户输入，然后决定它是字段数据还是表单请求。然后表单请求被传递给form_driver()来完成这项工作。 请求大致可以分为以下几类。下面解释不同的请求及其用法: ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:8","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"页面导航请求 这些请求导致页面级的表单移动，触发新表单屏幕的显示。一个表单可以由多个页面组成。如果您有一个包含许多字段和逻辑部分的大表单，那么您可以将表单划分为页面。函数set_new_page()在指定的字段处设置一个新页面。 int set_new_page(FIELD *field,/* Field at which page break to be set or unset */ bool new_page_flag); /* should be TRUE to put a break */ 下面的请求允许您移动到不同的页面 REQ_NEXT_PAGE 移动到下一个表单页面。 REQ_PREV_PAGE 移动到上一个表单页面。 REQ_FIRST_PAGE 移动到第一个表单页面。 REQ_LAST_PAGE 移动到最后一个表单页面。 这些请求将列表视为循环的;也就是说，从最后一页的REQ_NEXT_PAGE到第一页，从第一页的REQ_PREV_PAGE到最后一页。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:9","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"字段内导航请求 REQ_NEXT_FIELD 移动到下一个字段。 REQ_PREV_FIELD 移动到上一个字段。 REQ_FIRST_FIELD 移动到第一个字段。 REQ_LAST_FIELD 移动到最后一个字段。 REQ_SNEXT_FIELD 移动到已排序的下一个字段。 REQ_SPREV_FIELD 移动到排序前一个字段。 REQ_SFIRST_FIELD REQ_SFIRST_FIELD移动到排序的第一个字段。 REQ_SLAST_FIELD移动到最后一个排序字段。 REQ_LEFT_FIELD 向左移动到字段。 REQ_RIGHT_FIELD 右移到字段。 REQ_UP_FIELD上移到field。 REQ_DOWN_FIELD 向下移动到字段。 这些请求将页面上的字段列表作为循环处理;也就是说，从最后一个字段的REQ_NEXT_FIELD到第一个字段，从第一个字段的REQ_PREV_FIELD到最后一个字段。这些(以及REQ_FIRST_FIELD和REQ_LAST_FIELD请求)字段的顺序就是表单数组中字段指针的顺序(由new_form()或set_form_fields()设置) 也可以遍历字段，就像它们按照屏幕位置顺序排序一样，因此序列从左到右，从上到下。为此，使用第二组4个排序移动请求。 最后，还可以使用上、下、右、左的可视方向在字段之间移动。要实现这一点，请使用第三组请求。但是请注意，表单用于这些请求的位置是其左上角。 例如，假设您有一个多行字段B，两个单行字段a和C与B在同一行，a在B的左边，C在B的右边。只有当a、B和C共享相同的第一行时，a的REQ_MOVE_RIGHT才会转到B;否则它将跳过B到C。 These requests drive movement of the edit cursor within the currently selected field. REQ_NEXT_CHAR Move to next character. REQ_PREV_CHAR Move to previous character. REQ_NEXT_LINE Move to next line. REQ_PREV_LINE Move to previous line. REQ_NEXT_WORD Move to next word. REQ_PREV_WORD Move to previous word. REQ_BEG_FIELD Move to beginning of field. REQ_END_FIELD Move to end of field. REQ_BEG_LINE Move to beginning of line. REQ_END_LINE Move to end of line. REQ_LEFT_CHAR Move left in field. REQ_RIGHT_CHAR Move right in field. REQ_UP_CHAR Move up in field. REQ_DOWN_CHAR Move down in field. Each word is separated from the previous and next characters by whitespace. The commands to move to beginning and end of line or field look for the first or last non-pad character in their ranges. 18.6.4. Scrolling Requests Fields that are dynamic and have grown and fields explicitly created with offscreen rows are scrollable. One-line fields scroll horizontally; multi-line fields scroll vertically. Most scrolling is triggered by editing and intra-field movement (the library scrolls the field to keep the cursor visible). It is possible to explicitly request scrolling with the following requests: REQ_SCR_FLINE Scroll vertically forward a line. REQ_SCR_BLINE Scroll vertically backward a line. REQ_SCR_FPAGE Scroll vertically forward a page. REQ_SCR_BPAGE Scroll vertically backward a page. REQ_SCR_FHPAGE Scroll vertically forward half a page. REQ_SCR_BHPAGE Scroll vertically backward half a page. REQ_SCR_FCHAR Scroll horizontally forward a character. REQ_SCR_BCHAR Scroll horizontally backward a character. REQ_SCR_HFLINE Scroll horizontally one field width forward. REQ_SCR_HBLINE Scroll horizontally one field width backward. REQ_SCR_HFHALF Scroll horizontally one half field width forward. REQ_SCR_HBHALF Scroll horizontally one half field width backward. For scrolling purposes, a page of a field is the height of its visible part. 18.6.5. Editing Requests When you pass the forms driver an ASCII character, it is treated as a request to add the character to the field’s data buffer. Whether this is an insertion or a replacement depends on the field’s edit mode (insertion is the default. The following requests support editing the field and changing the edit mode: REQ_INS_MODE Set insertion mode. REQ_OVL_MODE Set overlay mode. REQ_NEW_LINE New line request (see below for explanation). REQ_INS_CHAR Insert space at character location. REQ_INS_LINE Insert blank line at character location. REQ_DEL_CHAR Delete character at cursor. REQ_DEL_PREV Delete previous word at cursor. REQ_DEL_LINE Delete line at cursor. REQ_DEL_WORD Delete word at cursor. REQ_CLR_EOL Clear to end of line. REQ_CLR_EOF Clear to end of field. REQ_CLR_FIELD Clear entire field. REQ_NEW_LINE和REQ_DEL_PREV请求的行为很复杂，部分由一对表单选项控制。当游标位于字段的开头或字段的最后一行时，会触发特殊情况。 首先，我们考虑REQ_NEW_LINE: REQ_NEW_LINE在插入模式下的正常行为是在编辑游标的位置打断当前行，在游标之后插入当前行的部分，作为跟随当前的新行，并将游标移动到新行的开头(您可以认为这是在字段缓冲区中插入换行符)。 REQ_NEW_LINE在叠加模式下的正常行为是清除当前行从编辑光标到行尾的位置。然后将光标移动到下一行的开头。 但是，字段开头或字段最后一行的REQ_NEW_LINE将执行REQ_NEXT_FIELD。O_NL_OVERLOAD选项关闭，此特殊动作被禁用。 现在，让我们考虑REQ_DEL_PREV: REQ_DEL_PREV的正常行为是删除前一个字符。如果插入模式是打开的，并且光标位于一行的开头，并且该行上的文本将与前一行相匹配，那么它会将当前行的内容追加到前一行并删除当前行(您可以将此视为从字段缓冲区中删除换行符)。 但是，字段开头的REQ_DEL_PREV被视为REQ_PREV_FIELD。 如果O_BS_OVERLOA","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:10","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"按顺序请求 如果你的字段类型是有序的，并且有相关的函数来从给定的值中获取该类型的下一个和上一个值，有一些请求可以将该值获取到字段缓冲区: REQ_NEXT_CHOICE 将当前值的后继值放入缓冲区。 REQ_PREV_CHOICE 将当前值的前任值放在缓冲区中。 在内置字段类型中，只有TYPE_ENUM具有内置的后继函数和前任函数。当您定义自己的字段类型(请参阅自定义验证类型)时，您可以关联我们自己的排序函数。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:11","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"程序命令 表单请求表示为curses值大于KEY_MAX且小于或等于常量MAX_COMMAND的整数。在这个范围内的值将被form_driver()忽略。这可以被应用程序用于任何目的。它可以被视为应用程序特定的操作，并采取相应的操作。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:17:12","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"ncurses 工具和窗口库 现在，您已经看到了ncurses及其姐妹库的功能，您可以卷起袖子，为一个大量操纵屏幕的项目做准备了。但是等等. .在普通的ncurses中编写和维护复杂的GUI小部件，甚至使用附加的库都是相当困难的。有一些现成的工具和小部件库，可以用来代替编写自己的小部件。您可以使用其中的一些，从代码中获取想法，甚至扩展它们。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:18:0","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"CDK(curses Development Kit) 用作者的话来说，CDK代表“curses开发工具包”，它目前包含21个准备使用的小部件，以促进全屏curses程序的快速开发。 该工具包提供了一些有用的小部件，可以直接在程序中使用。它写得很好，文档也很好。examples目录中的示例对于初学者来说是一个很好的开始。CDK可以从http://invisible-island.net/cdk/下载。按照README文件中的说明安装它。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:18:1","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["ncurses"],"content":"Widget List 下面是cdk提供的小部件列表及其描述。 Widget类型 描述 Alphalist 允许用户从单词列表中选择属性来缩小搜索列表的范围所需单词的几个字符。 Buttonbox 创建多按钮widget Calendar 创建日历窗口 Dialog 用消息提示用户，而用户可以从提供的按钮中选择答案。 Entry 允许用户输入 File Selector 从Cdk基本小部件构建的文件选择器。这示例显示如何创建更复杂的小部件使用Cdk小部件库。 Graph 绘制图形 Histogram Item List 创建一个弹出字段，允许用户进行选择在一个小领域的几个选择之一。非常有用的比如星期几或月份的名称。 Label 在弹出框中显示消息，或者标签可以是被视为屏幕的一部分。 Marquee 在滚动字幕中显示消息。 Matrix 创建一个复杂的矩阵与许多选项 Menu 创建一个下拉菜单界面。 Multiple Line Entry 多行输入字段。非常有用的对于长字段。(像描述字段) Radio List 创建单选按钮列表。 Scale 创建数字刻度。用于允许用户选择一个数值，并将其限制在值。 Scrolling List 创建一个滚动列表/菜单列表。 Scrolling Window 创建滚动日志文件查看器。可以添加信息进入窗口，而它的运行。一个用于显示进度的好小部件某物(类似于控制台窗口) Selection List 创建多个选项选择列表。 Slider 类似于缩放小部件，此小部件提供了一个可视滑条来表示数值。 Template 创建字符敏感的输入字段的位置。用于预先格式化的字段，如日期和电话号码。 Viewer 这是一个文件/信息查看器。非常有用的当你需要显示大量信息时。 Thomas Dickey在最近的版本中修改了一些小部件。 ","date":"2023-01-11","objectID":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/:18:2","tags":["ncurses","linux"],"title":"ncurses入门","uri":"/2023/01/0001-ncurses%E5%85%A5%E9%97%A8/"},{"categories":["gnome"],"content":"GObject ","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:1:0","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"数据结构 GObject 是基对象类型，在GObject结构体中的所有字段都是私有的，无法直接访问。 从 GLib2.72开始，GObject都至少与最大的基本GLib类型对齐(通常是guint64或者gdouble)。这条规则对GObject及其派生类或者由G_ADD_PRIVATE()添加的私有类都适用（然而栈上结构体大小不能超过64KiB，因此需要如果所写类所占空间太大则应该使用堆heep上存储）。 主要以下是 struct _GObject 的定义，具体定义参看\u003croot\u003e/gobject/gobject.h (其中\u003croot\u003e表示glib源码根目录) struct _GObject { GTypeInstance g_type_instance; // gsize(unsigned long) 用以表明类型 /* private */ guint ref_count; // atomic，引用计数 GData* qdata; }; 主要以下是struct _GObjectConstructParam 的定义 struct _GObjectConstructParam { GParamSpec* pspec; // 构造函数的名 GValue* value; // 构造函数值 }; 主要以下是 struct _GObjectClass 的定义： struct _GObjectClass { GTypeClass g_type_class; /* private */ GSList* construct_properties; /* public */ /* 很少重写 */ GObject* (*constructor) (GType type, guint n_construct_properties, GObjectConstructParam* construct_properties); /* 可重写的方法 */ void (*set_property) (GObject* object, guint property_id, const GValue* value, GParamSpec* pspec); void (*get_property) (GObject* object, guint property_id, GValue* value, GParamSpec* pspec); void (*dispose) (GObject* object); void (*finalize) (GObject* object); /* 很少重写 */ void (*dispatch_properties_changed) (GObject* object, guint n_pspecs, GParamSpec** pspec); /* 信号 */ void (notify) (GObject* object, GParamSpec* pspec); /* 当 constructor 执行完成之后调用 */ void (*constructed) (GObject* object); /* private */ gsize flags; gsize n_construct_properties; gpointer pspecs; gsize n_pspecs; /* padding */ gpointer pdummy[3]; }; 其它结构定义: struct _GData struct _GData { guint32 len; // 元素个数 guint32 alloc; // 已分配元素的数量 GDataElt data[1]; // }; struct _GDataElt struct _GDataElt { GQuark key; // 将字符串映射到唯一整数(hash) gpointer data; GDestroyNotify destroy; // typedef void (*GDestroyNotify) (gpointer data); }; struct _GTypeInstance struct _GTypeInstance { /* private */ GTypeClass* g_class; }; struct _GTypeClass struct _GTypeClass { /* private */ GType g_type; // gsize }; ","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:1:1","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"g_object_new 主要流程（假设没有参数传入，即：无参构造） gpointer g_object_new (GType object_type, const gchar* first_property_name, ...) { return g_object_new_with_properties (object_type, 0, NULL, NULL); } GObject* g_object_new_with_properties (GType object_type, guint n_properties, const char* names[], const GValue value[]) { // object_type 的 GTypeClass，不存在或者是动态加载，则返回NULL // object_type 表示 类的 TypeID GObjectClass* class = g_type_class_peek_static (object_type); if (NULL == class) { class = g_type_class_ref (object_type); } GObject* obj = g_object_new_internal (class, NULL, 0); return obj; } static gpointer g_object_new_internal (GObjectClass* class, GObjectConstructParam* param, guint n_params) { // G_UNLIKELY 提示编译器，表达式不太可能计算为真值 // 检测 GObject 构造函数是否使用自定义的构造， // 默认构造是： // static GObject* g_object_constructor(GType type, guint n_construct_properties, GObjectConstructParam *construct_params) if G_UNLIKELY(CLASS_HAS_CUSTOM_CONSTRUCTOR(class)) { return g_object_new_with_custom_constructor (class, params, n_params); } GObject* object = (GObject*) g_type_create_instance (class-\u003eg_type_class.g_type); if (CLASS_HAS_CUSTOM_CONSTRUCTED (class)) { class-\u003econstructed (object); } return object; } #define CLASS_HAS_CUSTOM_CONSTRUCTOR(class) \\ ((class)-\u003econstructor != g_object_constructor) ","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:1:2","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"小结 gobject 是类的基类 gobject 中关于类的实现其实是在 GType 中。具体： GObject –\u003e GTypeInstance \u003c=\u003e GTypeClass* \u003c=\u003e GType GObjectClass –\u003e GTypeClass \u003c=\u003e GType gobject 实例化主要过程： g_object_new(GType) g_object_new_with_properties(GType, ...)，根据 GType 获取到 GObjectClass* 指针 g_object_new_with_properties(GType, ...)，使用GObjectClass* 调用 g_object_new_internal(GObjectClass*)，根据 GObjectClass* 指针获取到 GObject* 指针 在 g_object_new_internal(GObjectClass*)中，调用 (GObject *) g_type_create_instance (class-\u003eg_type_class.g_type);，其中 class 表示GObjectClass ","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:1:3","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"GType GType 是 GObject 系统的基石。它提供了注册(registering)和管理(managing)所有基本数据类型、用户自定义对象、接口类型的工具。 ","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:2:0","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"GType 创建 GType类型的创建和注册共有两种方式：静态类型和动态类型。 静态类型永远不会像动态类型那样在运行时候加载或卸载，静态类型通过g_type_register_static()创建，创建后可通过GTypeInfo结构体来获取一些特殊信息 动态类型是使用g_type_register_dynamic()创建的，创建后信息保存在GTypePlugin结构中，具体可以使用g_type_plugin_*()接口获取。 注册类型之前已经默认调用了 gobject_init，在g_object_init里自动调用glib_init. GType 提供的注册函数在整个程序声明周期内只会调用一次，这类注册函数唯一的目的就是返回指定类的类型标识符。一旦注册成功这一类型（类或者接口），就可以实例化、继承或者实现它。 另外还有一类注册函数用于注册基本类型，名为g_type_register_fundamental()，它同时需要GTypeInfo结构体和GTypeFundmentalInfo结构体完成注册，但是很少使用，因为大多数基本类型都是预定义的，而不是用户定义的。 类型实例和类的结构体大小被限制最大为 64KiB（包括父类），类型实例的私有数据（由G_ADD_PRIVATED()创建）被限制为总共64KiB。 GType类型名必须至少三个及以上字符组成，组成字符需满足C语言变量命名规则（数字字母下划线，数字不开头）。 ","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:2:1","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"数据结构 typedef gsize GType; struct _GTypeClass { GType g_type; }; struct _GTypeInstance { GTypeClass* g_class; }; struct _GTypeInterface { GType g_type; GType g_instance_type; }; struct _GTypeInfo { /* */ guint16 class_size; GBaseInitFunc base_init; GBaseFinalizeFunc base_finalize; /* */ GClassInitFunc class_init; GClassFinalizeFunc class_finalize; gconstpointer class_data; /* */ guint16 instance_size; guint16 n_preallocs; GInstanceInitFunc instance_init; /* value handling */ const GTypeValueTable* value_table; }; struct _GTypeFundamentalInfo { GTypeFundamentalFlags type_flags; }; struct _GInterfaceInfo { GInterfaceInitFunc interface_init; GInterfaceFinalizeFunc interface_finalize; gpointer interface_data; }; struct _GTypeValueTable { void (*value_init) (GValue* value); void (*value_free) (GValue* value); void (*value_copy) (const GValue* src_value, GValue* dest_value); /**/ gpointer (*value_peek_pointer) (const GValue* value); const gchar* collect_value; gchar* (*collect_value) (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags); const gchar* lcopy_format; gchar* (*lcopy_value) (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags); }; 很重要的两个全局变量: static GHashTable* static_type_nodes_ht = NULL; static TypeNode* static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX \u003e\u003e G_TYPE_FUNDAMENTAL_SHITF) + 1] = {NULL, }; ","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:2:2","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"g_type_register_static // static 信息注册位置：static_type_nodes_ht GType g_type_register_static (GType parent_type, const gchar* type_name, const GTypeInfo* info, GTypeFlags flags) { GType type = 0; // static void gobject_init (void) // 函数里调用：static_quark_type_flags = g_quark_from_static_string (\"-g-type-private--GTypeFlags\"); g_assert_type_system_initialized(); // check_type_name_I: 根据 name 从 static_type_nodes_ht 获取 GType // check_derivation_I: 根据 父类 GType 获取到 TypeNode，根据 TypeNode 获取到 GTypeFundamentalInfo 确定继承深度是否可推倒 if (!check_type_name_I (type_name) || !check_derivation_I (parent_type, type_name)) return 0; // if (info-\u003eclass_finalize) { return 0; } TypeNode* node = NULL; TypeNode* pnode = lookup_type_node_I (parent_type); G_WRITE_LOCK(\u0026type_rw_lock); // 父类引用 +1 type_data_ref_Wm(pnode); // #define NODE_FUNDAMENTAL_TYPE(node) (node-\u003esupers[node-\u003en_supers]) // GTypeFundamentalInfo* == type_node_fundamental_info_I(TypeNode) if (check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE(pnode), type_name, info)) { // 执行 g_hash_table_insert (static_type_nodes_ht, (gpointer) g_quark_to_string (node-\u003eqname), (gpointer) type); node = type_node_new_W (pnode, type_name, NULL); type_add_flags_W (node, flags); // #define NODE_TYPE(node) (node-\u003esupers[0]) type = NODE_TYPE(node); type_data_make_W (node, info, check_value_table_I (type_name, info-\u003evalue_table) ? info-\u003evalue_table : NULL); } G_WRITE_UNLOCK (\u0026type_rw_lock); return type; } check_type_info_I static gboolean check_type_info_I (TypeNode* pnode, GType ftype, const gchar *type_name, const GTypeInfo *info) { GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (lookup_type_node_I (ftype)); gboolean is_interface = ftype == G_TYPE_INTERFACE; g_assert (ftype \u003c= G_TYPE_FUNDAMENTAL_MAX \u0026\u0026 !(ftype \u0026 TYPE_ID_MASK)); if (!(finfo-\u003etype_flags \u0026 G_TYPE_FLAG_INSTANTIATABLE) \u0026\u0026 (info-\u003einstance_size || info-\u003en_preallocs || info-\u003einstance_init)) { if (pnode) { g_critical (\"cannot instantiate '%s', derived from non-instantiatable parent type '%s'\", type_name, NODE_NAME (pnode)); } else { g_critical (\"cannot instantiate '%s' as non-instantiatable fundamental\", type_name); } return FALSE; } /* check class \u0026 interface members */ if (!((finfo-\u003etype_flags \u0026 G_TYPE_FLAG_CLASSED) || is_interface) \u0026\u0026 (info-\u003eclass_init || info-\u003eclass_finalize || info-\u003eclass_data || info-\u003eclass_size || info-\u003ebase_init || info-\u003ebase_finalize)) { if (pnode) g_critical (\"cannot create class for '%s', derived from non-classed parent type '%s'\", type_name, NODE_NAME (pnode)); else g_critical (\"cannot create class for '%s' as non-classed fundamental\", type_name); return FALSE; } /* check interface size */ if (is_interface \u0026\u0026 info-\u003eclass_size \u003c sizeof (GTypeInterface)) { g_critical (\"specified interface size for type '%s' is smaller than 'GTypeInterface' size\", type_name); return FALSE; } /* check class size */ if (finfo-\u003etype_flags \u0026 G_TYPE_FLAG_CLASSED) { if (info-\u003eclass_size \u003c sizeof (GTypeClass)) { g_critical (\"specified class size for type '%s' is smaller than 'GTypeClass' size\", type_name); return FALSE; } if (pnode \u0026\u0026 info-\u003eclass_size \u003c pnode-\u003edata-\u003eclass.class_size) { g_critical (\"specified class size for type '%s' is smaller than the parent type's '%s' class size\", type_name, NODE_NAME (pnode)); return FALSE; } } /* check instance size */ if (finfo-\u003etype_flags \u0026 G_TYPE_FLAG_INSTANTIATABLE) { if (info-\u003einstance_size \u003c sizeof (GTypeInstance)) { g_critical (\"specified instance size for type '%s' is smaller than 'GTypeInstance' size\", type_name); return FALSE; } if (pnode \u0026\u0026 info-\u003einstance_size \u003c pnode-\u003edata-\u003einstance.instance_size) { g_critical (\"specified instance size for type '%s' is smaller than the parent type's '%s' instance size\", type_name, NODE_NAME (pnode)); return FALSE; } } return TRUE; } type_node_new_W static TypeNode* type_node_new_W (TypeNode* pnode, const gchar *name, GTypePlugin *plugin) { g_assert (pnode); g_assert (pnode-\u003en_supers \u003c MAX_N_SUPERS); g_assert (pnode-\u003en_children \u003c MAX_N_CHILDREN); return type_node_any_","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:2:3","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"接着GObject中代码继续追踪g_type_create_instance GTypeInstance* g_type_create_instance (GType type) { // 类型早已注册，后续追相关代码 TypeNode* node = lookup_type_node_I (type); if (G_UNLIKELY (!node || !node-\u003eis_instantiatable)) { g_error (\"cannot create new instance of invalid (non-instantiatable) type '%s'\", type_descriptive_name_I (type)); } /* G_TYPE_IS_ABSTRACT() is an external call: _U */ if (G_UNLIKELY (!node-\u003emutatable_check_cache \u0026\u0026 G_TYPE_IS_ABSTRACT (type))) { g_error (\"cannot create instance of abstract (non-instantiatable) type '%s'\", type_descriptive_name_I (type)); } if (G_UNLIKELY (G_TYPE_IS_DEPRECATED (type))) { maybe_issue_deprecation_warning (type); } // GTypeClass* class = g_type_class_ref (type); gint private_size = node-\u003edata-\u003einstance.private_size; gint ivar_size = node-\u003edata-\u003einstance.instance_size; allocated = instance_alloc (private_size + ivar_size); GTypeInstance* instance = (GTypeInstance *) (allocated + private_size); for (i = node-\u003en_supers; i \u003e 0; i--) { TypeNode* pnode = lookup_type_node_I (node-\u003esupers[i]); if (pnode-\u003edata-\u003einstance.instance_init) { instance-\u003eg_class = pnode-\u003edata-\u003einstance.class; pnode-\u003edata-\u003einstance.instance_init (instance, class); } } instance-\u003eg_class = class; if (node-\u003edata-\u003einstance.instance_init) node-\u003edata-\u003einstance.instance_init (instance, class); TRACE(GOBJECT_OBJECT_NEW(instance, type)); return instance; } lookup_type_node_I static inline TypeNode* lookup_type_node_I (GType utype) { // #define G_TYPE_FUNDAMENTAL_SHIFT (2) // #define G_TYPE_FUNDAMENTAL_MAX (255 \u003c\u003c G_TYPE_FUNDAMENTAL_SHIFT) // 1020 // #define TYPE_ID_MASK ((GType) ((1 \u003c\u003c G_TYPE_FUNDAMENTAL_SHIFT) - 1)) // 3 if (utype \u003e G_TYPE_FUNDAMENTAL_MAX) return (TypeNode*) (utype \u0026 ~TYPE_ID_MASK); else return static_fundamental_type_nodes[utype \u003e\u003e G_TYPE_FUNDAMENTAL_SHIFT]; } g_type_class_ref gpointer g_type_class_ref (GType type) { gboolean holds_ref; TypeNode *node = lookup_type_node_I (type); // 引用 +1 if (G_LIKELY (type_data_ref_U (node))) { if (G_LIKELY (g_atomic_int_get (\u0026node-\u003edata-\u003eclass.init_state) == INITIALIZED)) return node-\u003edata-\u003eclass.class; holds_ref = TRUE; } else { holds_ref = FALSE; } /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */ g_rec_mutex_lock (\u0026class_init_rec_mutex); /* we need an initialized parent class for initializing derived classes */ // #define NODE_PARENT_TYPE(node) (node-\u003esupers[1]) // 递归初始化GObject的所有父类 GTypeClass，引用+1 GType ptype = NODE_PARENT_TYPE (node); GTypeClass *pclass = ptype ? g_type_class_ref (ptype) : NULL; G_WRITE_LOCK (\u0026type_rw_lock); if (!holds_ref) { // 递归初始化父类 GTypeInfo type_data_ref_Wm (node); } /* class uninitialized */ if (!node-\u003edata-\u003eclass.class) { // 递归构造 GTypeClass 类型，分配内存 // 把对象及其父类构造函数放入到一个单链表，依次调用 type_class_init_Wm (node, pclass); } G_WRITE_UNLOCK (\u0026type_rw_lock); if (pclass) { g_type_class_unref (pclass); } g_rec_mutex_unlock (\u0026class_init_rec_mutex); return node-\u003edata-\u003eclass.class; } type_data_ref_U static inline gboolean type_data_ref_U (TypeNode *node) { guint current; do { // #define NODE_REFCOUNT(node) ((guint) g_atomic_int_get ((int*) \u0026(node)-\u003eref_count)) current = NODE_REFCOUNT (node); if (current \u003c 1) return FALSE; // 等价于： // if (*ref_count == current) { *ref_count = current + 1; return TRUE; } else return FALSE; } } while (!g_atomic_int_compare_and_exchange ((int *) \u0026node-\u003eref_count, current, current + 1)); return TRUE; } ","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:2:4","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"结论(针对GObject无参构造类) 类的实例由 struct _GObject 和 struct _GObjectClass 两个结构组成，其中 struct _GObject 继承自 GTypeInstance 并增加了引用计数次数和GData数据；struct _GObjectClass 继承自 GTypeClass 并增加了以下几类信息：构造参数列表、构造和析构函数、属性的set/get。 无论是 GTypeInstance 还是 GTypeClass 都继承自 GType，创建GObject的过程就是创建 GType 并调用 构造函数 的过程，大致过程跟踪 g_object_new 这一函数可知，但是详细过程都在GType里。 g_type_create_instance g_type_class_ref(GType) 这里会递归为父类分配空间，并依次调用父类构造函数 调用自己类的构造函数 问题：如何根据 GType 获取到父类？ #define NODE_PARENT_TYPE(node) (node-\u003esupers[1]) // 注册的时候 获取所有父类保存到 node-\u003esupers 中，node-\u003esupers[0]是自己，node-\u003esupers[1]是父类，不支持多继承 ","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:2:5","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"写一个类 例子很多了：https://github.com/dingjingmaster/demo/tree/master/gobject 其中最简单的例子：demo1中有两个关键的宏： #define DEMO_TYPE_DLIST (demo_dlist_get_type())、GType demo_dlist_get_type (void); G_DEFINE_TYPE (demo_list_t, demo_dlist, G_TYPE_OBJECT); 主要看 G_DEFINE_TYPE， 定义在 gtype.h 中 G_DEFINE_TYPE // TN 表示类名，大小写字幕+下划线组成，一般使用驼峰命名 // t_n 表示类名，大小写字幕+下划线组成，一般使用大小写+下划线命名 // T_P 表示父类的 GType，比如：G_TYPE_OBJECT #define G_DEFINE_TYPE(TN, t_n, T_P) G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, 0, {}) G_DEFINE_TYPE_EXTENDED // TN 类名 // t_n 类名 // T_P 父类 GType // _f_ GTypeFlags to pass to g_type_register_static() // _C_ Custom code that gets inserted in the `*_get_type()` function。这个语句会执行 // // 例子： // G_DEFINE_TYPE_EXTENDED (GtkGadget, gtk_gadget, GTK_TYPE_WIDGET, 0, \\ // G_ADD_PRIVATE (GtkGadget) G_IMPLEMENT_INTERFACE (TYPE_GIZMO, gtk_gadget_gizmo_init)); // // _G_DEFINE_TYPE_EXTENDED_BEGIN: // 1. 在 _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE 中定义了一系列函数 // 2. 在 _G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER 中主要调用：g_type_register_static_simple // 3. 调用用户自定义函数：_C_ // // _G_DEFINE_TYPE_EXTENDED_END 结束 // #define G_DEFINE_TYPE_EXTENDED(TN, t_n, T_P, _f_, _C_) \\ _G_DEFINE_TYPE_EXTENDED_BEGIN (TN, t_n, T_P, _f_) {_C_;} \\ _G_DEFINE_TYPE_EXTENDED_END() _G_DEFINE_TYPE_EXTENDED_BEGIN // 在 _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE 中定义了一系列函数 // 在 _G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER 中主要调用：g_type_register_static_simple #define _G_DEFINE_TYPE_EXTENDED_BEGIN(TypeName, type_name, TYPE_PARENT, flags) \\ _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE(TypeName, type_name, TYPE_PARENT) \\ _G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER(TypeName, type_name, TYPE_PARENT, flags) \\ _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE #define _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE(TypeName, type_name, TYPE_PARENT) \\ \\ static void type_name##_init (TypeName *self); \\ static void type_name##_class_init (TypeName##Class *klass); \\ static GType type_name##_get_type_once (void); \\ static gpointer type_name##_parent_class = NULL; \\ static gint TypeName##_private_offset; \\ \\ _G_DEFINE_TYPE_EXTENDED_CLASS_INIT(TypeName, type_name) \\ \\ /* 获取类的私有成员结构体 */\\ G_GNUC_UNUSED static inline gpointer type_name##_get_instance_private (TypeName *self) \\ { \\ return (G_STRUCT_MEMBER_P (self, TypeName##_private_offset)); \\ } \\ \\ /* 实现： */\\ GType type_name##_get_type (void) \\ { \\ static gsize static_g_define_type_id = 0; /* Prelude goes here */ /* Added for _G_DEFINE_TYPE_EXTENDED_WITH_PRELUDE */ #define _G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER(TypeName, type_name, TYPE_PARENT, flags) \\ if (g_once_init_enter (\u0026static_g_define_type_id)) \\ { \\ GType g_define_type_id = type_name##_get_type_once (); \\ g_once_init_leave (\u0026static_g_define_type_id, g_define_type_id); \\ } \\ return static_g_define_type_id; \\ } /* closes type_name##_get_type() */ \\ \\ \\ G_NO_INLINE static GType type_name##_get_type_once (void) \\ { \\ GType g_define_type_id = \\ /**/ \\ g_type_register_static_simple (TYPE_PARENT, \\ g_intern_static_string (#TypeName), /*gquark.c里有定义，确保字符串被gquark计算后的值是唯一的*/\\ sizeof (TypeName##Class), \\ (GClassInitFunc)(void (*)(void)) type_name##_class_intern_init, \\ sizeof (TypeName), \\ (GInstanceInitFunc)(void (*)(void)) type_name##_init, \\ (GTypeFlags) flags); \\ { /* custom code follows */ #define _G_DEFINE_TYPE_EXTENDED_END() \\ /* following custom code */ \\ } \\ return g_define_type_id; \\ } /* closes type_name##_get_type_once() */ #define _G_DEFINE_TYPE_EXTENDED_CLASS_INIT(TypeName, type_name) \\ static void type_name##_class_intern_init (gpointer klass) \\ { \\ type_name##_parent_class = g_type_class_peek_parent (klass); \\ type_name##_class_init ((TypeName##Class*) klass); \\ } GType g_type_register_static_simple (GType parent_type, const gchar* type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags) { GTypeInfo info; /* Instances are not allowed to be larger than this. If you have a big * fixed-length array or something, point to it instead. */ g_return_val_if_fail (class_size \u003c= G_MAXUINT16, G_TYPE_INVALID); g_return_val_if_fail (inst","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:3:0","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"总结 GObject 类创建过程(G_DEFINE_TYPE)： 声明一系列静态变量和函数 定义type_name##_get_type()为了获取到GType; 其中调用了 g_type_register_static_simple 将类型注册到 GObject 中（一个全局静态的hashmap，其中GType通过） 主调函数里使用 g_object_new(type_name##_get_type, NULL);得到GObject，其中 GType 是 类对应 TypeNode 首地址转为 unsigned long 得到 ","date":"2023-01-08","objectID":"/2023/01/0002-gobject/:4:0","tags":["gobject","glib","gnome","linux"],"title":"GObject","uri":"/2023/01/0002-gobject/"},{"categories":["gnome"],"content":"概念 根据需求，GVariant必须与DBus消息总线系统(在[DBus]中指定)基本兼容。 为此，GVariant中使用的类型系统与DBus中使用的类型系统几乎相同。然而，为了提供一个更好的系统，同时仍然保持高度兼容性，做了一些非常微小的更改;具体来说，可以通过DBus发送的每个消息都可以表示为GVariant。 如果从头开始设计类型系统，则从DBus带入的一些包袱不会出现在类型系统中。例如，对象路径和签名类型是高度特定于dbus的，如果从头创建，则不会出现在通用类型系统中。 ","date":"2022-12-20","objectID":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/:1:0","tags":["GLib","GIO","gnome","linux"],"title":"GVariant规范1.0","uri":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/"},{"categories":["gnome"],"content":"GVariant与DBus类型不同点 为了增加概念的清晰度，一些限制已经被取消，允许调用“永不失败”，而不是必须检查这些特殊情况。 DBus限制了容器类型嵌套的最大深度，而GVariant没有这样的限制;嵌套支持任意深度。 DBus通过将“签名字符串”限制为不超过255个字符来限制其消息的最大复杂度，而GVariant没有这样的限制;支持任意长度的类型字符串，允许创建具有任意复杂类型的值。 DBus只允许字典条目类型作为数组类型的元素类型出现，而GVariant没有这样的限制;字典条目类型可以单独存在，也可以作为任何其他类型构造函数的子类型存在。 DBus要求结构类型至少包含一个子类型，而GVariant没有这样的限制;单元类型在GVariant中是完全有效的类型。 DBus的一些限制是出于安全考虑而施加的(例如，限制处理来自不可信发送方的消息可能导致的递归深度)。如果GVariant的使用方式对这些考虑非常敏感，那么程序员应该在从不可信源输入值到程序时对这些情况进行检查。 此外，DBus没有用于表示可空性概念的类型构造函数。为此，添加了Maybe类型构造函数(在类型字符串中由m表示)。 正在考虑将其中一些更改包含到DBus 2中。 “nullable type”是一种类型，除了包含其正常值范围外，还包含该范围之外的特殊值，称为NULL、Nothing、None或类似的值。在大多数具有引用或指针类型的语言中，这些类型都是可空的。有些语言能够拥有任何类型的可空版本(例如，Haskell中的“Maybe Int”和“Int ?”i; “在c#中)。 在面对面的会议中进行了大量讨论，在DBus邮件列表(http://lists.freedesktop.org/archives/dbus/2007-August/008290.html)上也进行了一些讨论 ","date":"2022-12-20","objectID":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/:1:1","tags":["GLib","GIO","gnome","linux"],"title":"GVariant规范1.0","uri":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/"},{"categories":["gnome"],"content":"各种类型 基础类型 Boolean 取值必为 True 或 False 的一种类型 Byte 可以转为 unsigned 类型，取值范围：0 - 255 Integer Types 共有六种类型：16、32和64整数的字节有符号和无符号版本，带符号的版本具有与二补表示一致的值范围。 Double Precision Floating Point 双精度浮点值由IEEE 754精确定义。 String 字符串是零个或多个字节。官方上，GVariant是编码不可知的，但是使用UTF-8是被期望和鼓励的。 Object Path DBus对象路径，与DBus规范中描述的完全相同。 Signature 与DBus规范中描述的完全相同的DBus签名字符串。由于仅为了与DBus兼容而保留了此类型，因此适用于此类型值范围的所有DBus限制(例如:嵌套深度和最大长度限制)。 容器类型 Variant 变体类型是一个类型(本章描述的任何类型，包括变体类型本身)和该类型的值的依赖对。您可以使用此类型来克服数组的所有元素必须具有相同类型的限制。 Maybe maybe类型构造函数为任何其他单一类型提供了可空性。区分非空情况，这样当多个maybe类型构造函数应用于一个类型时，可以检测到不同级别的null。 Array 数组类型构造函数允许创建与所提供的元素类型对应的数组(或列表)类型。必须只提供一种元素类型，并且该数组类型的任何实例中的所有数组元素都必须具有该元素类型。 Structure 结构类型构造函数允许创建与所提供的元素类型相对应的结构类型。这些“结构”实际上更接近元组，因为它们的字段没有命名，但是使用“结构”是因为DBus规范是这样称呼它们的。 结构类型构造函数是唯一可变的类型构造函数——可以给出任意自然数的类型(包括0和1)。 Dictionary entry 字典条目类型构造函数允许创建一种特殊类型的结构，当该结构用作数组的元素类型时，意味着数组的内容是键/值对的列表。为了与DBus兼容，这个二进制类型构造函数需要一个基本类型作为它的第一个参数(按照惯例，它被视为键)，但任何类型都可以作为第二个参数(按照惯例，值)。 字典条目只是按照惯例这样做;这包括将它们放入数组中以形成“字典”。GVariant没有对字典施加通常期望的限制(例如键的唯一性)。 Strings 类型 与DBus一样，使用简洁的字符串表示来表示类型。 在直接将值作为一阶对象处理的GVariant中，类型字符串(按此名称)是表示单一类型的字符串。 这与DBus中的“签名字符串”形成对比，后者应用于消息，包含零个或多个类型(对应于消息的参数)。 语法 string类型的语言与上下文无关。它也是前缀代码，是语言本身的递归结构使用的属性。 类型字符串可以用无歧义上下文语法来描述。 语义 用于从给定语法获取类型字符串的派生将创建描述类型的抽象语法树。通过右边每个包含终端的项推导的效果如下所示: 表示 含义 b boolean 类型 y byte 类型 n 16-bit 整型 q 16-bit 无符号整型 i 32-bit 整型 u 32-bit 无符号整型 x 64-bit 整型 t 64-bit 无符号整型 d 双精度浮点类型 s 字符串类型 o object path 类型 g signature 类型 v variant 类型 m Maybe类型 a 数组类型 (types) structure 类型 {base_type type} key-value 类型 ","date":"2022-12-20","objectID":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/:1:2","tags":["GLib","GIO","gnome","linux"],"title":"GVariant规范1.0","uri":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/"},{"categories":["gnome"],"content":"序列化格式 本章描述了GVariant使用的序列化格式。这种序列化格式是新开发的，在这里是第一次描述。 ","date":"2022-12-20","objectID":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/:2:0","tags":["GLib","GIO","gnome","linux"],"title":"GVariant规范1.0","uri":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/"},{"categories":["gnome"],"content":"Why not DBus? 由于GVariant在很大程度上与DBus兼容，因此使用DBus的序列化格式(加上适当的修改)作为GVariant的序列化格式是有意义的。 然而，这样做会与为GVariant建立的许多需求相冲突。 最根本的是，需求将被违反。DBus消息以这样一种方式编码:为了从数组中取出第100个项目，您首先必须遍历前99个项目以发现第100个项目的位置。这种迭代的副作用是对需求的违反。 此外，将DBus序列化格式与需求要求的API一起使用可能意味着违反需求，因为DBus消息的子部分在受到不同的起始对齐时可能会改变含义。在简单包含中对此进行了更详细的讨论。 ","date":"2022-12-20","objectID":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/:2:1","tags":["GLib","GIO","gnome","linux"],"title":"GVariant规范1.0","uri":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/"},{"categories":["gnome"],"content":"符号 在本节中，将使用一种通用的类型和值表示法提供一些示例。 用于类型的表示法正是类型中描述的类型字符串。 用于值的符号对于Python或Haskell的用户来说都很熟悉。数组(列表)用方括号表示，结构(元组)用圆括号表示。逗号分隔元素。字符串是单引号的。前缀为0x的数字被视为十六进制。 常量True和False表示布尔常数。maybe类型的空值数据构造函数表示为Nothing，一元类型的空值数据构造函数表示为Just。 ","date":"2022-12-20","objectID":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/:2:2","tags":["GLib","GIO","gnome","linux"],"title":"GVariant规范1.0","uri":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/"},{"categories":["gnome"],"content":"概念 GVariant值序列化是一个从值到字节序列对和类型字符串的总和单射函数。序列化是确定性的，因为序列化给定值只会产生一种可接受的“标准形式”。序列化是非满射的:非正规形式存在。 如果没有类型string，序列化产生的字节序列是无用的。换句话说，反序列化字节序列需要知道这种类型。 在讨论序列化的细节之前，有一些在格式设计中普遍存在的概念应该被理解。 字节序列 字节序列被定义为一个长度已知的字节序列。在所有情况下，在GVariant中，知道长度对于成功地反序列化一个值是至关重要的。 字节边界 GVariant中使用的开始偏移量和结束偏移量不是指字节位置，而是指字节边界。与长度为n的字符串可以有n + 1个前缀一样，大小为n的字节序列也有n + 1个字节边界。 字节边界 当谈到字节序列的开始位置时，开始边界的索引恰好对应于第一个字节的索引。然而，当谈到结束位置时，结束边界的索引将是最后一个字节的索引，加1。这个范例非常常用，并且允许指定零长度的字节序列。 简单限制 存在许多具有子值能力的容器类型。在所有情况下，容器的每个子值的序列化字节序列将作为该容器的序列化字节序列的连续子序列出现——与它单独出现时的形式完全相同。子字节序列将按照它们在容器中的位置顺序出现。 容器的职责是能够确定每个子元素的开始和结束(或等价地，长度)。 此属性允许将容器分解为子值，只需引用容器字节序列的子序列作为子值，这是满足需求的有效方法。 此属性不是DBus序列化格式的情况。在许多情况下(例如，数组)，DBus消息的子值的编码将根据该值出现的上下文而改变。举个例子:在双精度数组的例子中，如果紧挨着数组前面的值的偏移量是8的偶数倍，那么该数组将包含4个填充字节，如果前一个值的结束偏移量向任何一个方向移动了4个字节，则该数组将不包含这些填充字节。 对齐 为了满足这一要求，我们必须为程序员提供一个他们可以舒适使用的指针。在许多机器上，程序员不能直接解引用未对齐的值，即使在可以解引用的机器上，性能也经常受到影响。 因此，序列化格式中的所有类型都有与之相关的对齐方式。对于字符串或单个字节，这种对齐方式是简单的1，但对于32位整数(例如)，这种对齐方式是4。对齐是类型的一个属性——类型的所有实例都具有相同的对齐方式。 所有对齐的值在内存中的起始地址必须是其对齐的整数倍。 容器类型的对齐方式等于该容器的任何潜在子容器的最大对齐方式。这意味着，即使一个32位整数数组是空的，它仍然必须对齐到最近的4字节倍数。这也意味着变体类型(如下所述)的对齐值为8(因为它可能包含任何其他类型的值，并且最大对齐值为8)。 固定大小 为了避免大量的帧开销，可以利用这样一个事实，即对于某些类型，所有实例都具有相同的大小。在本例中，该类型被称为固定大小的类型，其所有值都是固定大小的值。例如单个整数和由整数和浮点数组成的元组。反例是一个字符串和一个整数数组。 如果一个类型具有固定大小，那么这个固定大小必须是该类型对齐方式的整数倍。类型的大小永远不会固定为0。 如果容器类型总是保存固定数量的固定大小的项(例如某些结构体或字典项)，那么该容器类型也将是固定大小的。 帧偏移 如果容器包含非固定大小的子元素，则容器有责任确定它们的大小。这是使用帧偏移量完成的。 帧偏移量是某个预定大小的整数。大小总是2的幂。大小由容器字节序列的总体大小决定。它被选择为足够大，以引用容器中的每个字节边界。 例如，大小为0的容器的帧偏移量为0(因为不需要比特来表示没有选择)。大小从1到255的容器的帧偏移量为1(因为256个选择可以用一个字节表示)。从256到65535的容器的帧偏移量为2。大小为65536的容器的帧偏移量为4。 帧偏移量的大小没有理论上的上限。这一事实(以及序列化格式中没有其他限制)允许任意大小的值。 当序列化时，正确的帧偏移大小必须通过“试错”来确定——检查每个大小以确定它是否有效。由于偏移量的大小包含在容器的大小中，因此较大的偏移量可能会使容器的大小上升到下一个类别，这将需要更大的偏移量。但是，这种容器不被认为是“正常形式”。如果序列化的数据是正常形式，则必须使用尽可能小的偏移量。 框架偏移总是出现在容器的末尾，并且是未对齐的。它们总是以小端字节顺序存储。 字节序 尽管序列化数据的帧偏移始终以小端字节序存储，但用户可见的数据(通过要求的接口)允许以大端字节序或小端字节序存储。这被称为“编码字节顺序”。在传输消息时，如果没有明确约定，则应该指定这个字节顺序。 编码字节顺序只影响7种类型值的表示:6种(16、32和64位，有符号和无符号)整型和双精度浮点型。不同编码字节顺序之间的转换是一个简单的操作，通常可以就地执行(但有关例外情况，请参阅Byteswapping注释)。 ","date":"2022-12-20","objectID":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/:2:3","tags":["GLib","GIO","gnome","linux"],"title":"GVariant规范1.0","uri":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/"},{"categories":["gnome"],"content":"基础类型序列化 Boolean 布尔值的大小固定为1，对齐方式为1。它的值为True为1,False为0。 Bytes 一个字节的固定大小为1，对齐方式为1。它可以有任何有效的字节值。按照惯例，字节是无符号的。 Integers 有16位，32位，64位有符号整数和无符号整数。每个整数类型的大小都是固定的(到它的自然大小)。每个整型都有与固定大小相等的对齐方式。整数按编码字节顺序存储。有符号整数用2的补数表示。 双精度浮点型 双精度浮点数的对齐方式和固定大小为8。双精度值按编码字节顺序存储。 Strings 包括对象路径和签名字符串，字符串的大小不是固定的，对齐方式为1。任何给定的序列化字符串的大小等于字符串的长度加1，最后一个序列化字节是一个null(0)结束符。没有指定字符串的字符集编码，但是不允许在字符串的内容中出现null字节。 ","date":"2022-12-20","objectID":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/:2:4","tags":["GLib","GIO","gnome","linux"],"title":"GVariant规范1.0","uri":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/"},{"categories":["gnome"],"content":"容器序列化 Variants Variant 是通过存储子对象的序列化数据，加上一个零字节，再加上子对象的类型字符串来序列化的。 零字节是必需的，因为尽管类型字符串是前缀代码，但它们不是后缀代码。在没有此分隔符的情况下，考虑序列化为两个字节的变体的情况- “ay”,这是一个字节，‘a’，还是一个空的字节数组? Maybes 可能编码不同，取决于它们的元素类型是否固定大小。 maybe类型的对齐方式始终等于其元素类型的对齐方式。 固定大小元素的 Maybe 对于Nothing情况，序列化的数据是空字节序列。 对于Just情况，序列化的数据完全等于子对象的序列化数据。这总是与Nothing情况相区别，因为所有固定大小的值都具有非零大小。 非固定大小元素的 Maybe 对于Nothing情况，序列化的数据同样是空字节序列。 对于Just情况，序列化形式是子元素的序列化数据，后面跟着一个0字节。这个额外的字节确保即使在子值的大小为0的情况下，也可以将Just大小写与Nothing大小写区分开来。 Arrays 数组被称为固定宽度数组或可变宽度数组，取决于它们的元素类型是否是固定大小的类型。这两种情况的编码非常不同。 数组类型的对齐方式始终等于其元素类型的对齐方式。 固定宽度的 Arrays 在这种情况下，每个数组元素的序列化形式被按顺序打包，没有额外的填充或框架，以获得数组。因为所有固定大小的值的大小都是其对齐要求的倍数，而且数组中的所有元素都有相同的对齐要求，所以所有元素都会自动对齐。 16-bit 整型数组 数组的长度可以通过取数组的大小并除以固定的元素大小来确定。这将始终工作，因为所有固定大小的值都有一个非零大小。 可变宽度 Arrays 在这种情况下，每个数组元素的序列化形式再次按顺序打包。不过，与固定宽度的情况不同的是，为了对齐的目的，可能需要在元素之间添加填充字节。这些填充字节必须为零。 添加完所有元素后，将按顺序为每个元素添加一个帧偏移量。帧偏移量指定该元素的结束边界。 可变宽度数组 每个帧偏移量的大小是数组的序列化大小和最终帧偏移量的函数，通过识别数组中最终元素的结束边界也可以识别帧偏移量的开始边界。由于数组中的每个元素都有一个帧偏移量，我们可以很容易地确定数组的长度。 $$ length = (size - last_offset) / offset_size $$ 要找到任何元素的开始，只需取前一个元素的结束边界，并四舍五入到数组(因此也是元素)对齐的最近整数倍。第一个元素的开始就是数组的开始。 由于确定数组的长度依赖于我们计算帧偏移量的能力，而帧偏移量的数量是由它们占用的空间决定的，因此零字节的帧偏移量在数组中是不允许的，即使在所有其他序列化数据的大小为零的情况下也是如此。这个特殊的异常避免了用0除以0问题。 Structures 与数组一样，结构是通过存储每个子项来序列化的，顺序与填充字节正确对齐，填充字节必须为零。 在添加了所有项之后，对于结构中不是最后一项的每个非固定大小的项，将以相反的顺序追加一个框架偏移量。帧偏移量指定该元素的结束边界。 帧偏移量以相反的顺序存储，以允许基于迭代器的接口开始迭代结构中的项，而无需首先测量类型字符串所隐含的项的数量(该操作所需的时间与字符串的大小成线性)。 结构体容器保存 16-bit 整数和字符串 没有为结构中的最后一项存储框架偏移量的原因是，可以通过从结构的大小中减去框架偏移量的大小来确定其结束边界。在给定类型的结构的任何实例中出现的帧偏移量可以完全由类型确定(遵循上面给出的规则)。 固定大小的项目不存储帧偏移量的原因是，通过将固定大小添加到开始边界，始终可以找到它们的结束边界。 要找到结构中任何项的起始边界，只需从前面最近的非固定大小项的结束边界开始(如果没有前面的非固定大小项，则从0开始)。从这里开始，四舍五入对齐，并为每个中间项添加固定大小。最后，舍入到所需项目的对齐位置。 对于随机访问，似乎这个过程所花费的时间与结构中元素的数量成线性关系，但实际上它可以在非常小的常数时间内完成。参见计算结构项地址。 如果结构中包含的所有项都是固定大小的，那么结构本身就是固定大小的。必须考虑满足这个固定大小值的约束条件。 首先，固定大小必须是非零的。这种情况只会发生在单元类型的结构或只包含这种结构的结构(递归地)。这个问题可以通过任意声明单元类型实例的序列化编码为单个零字节(大小为1)来解决。 第二，固定尺寸必须是结构对齐的倍数。这是通过在任何固定宽度结构的末尾添加零填充字节来实现的，直到此属性为真。这些字节永远不会在定位帧偏移量或可变大小子对象的结束时造成混淆，因为根据定义，这些事情都不会发生在固定大小的结构中。 图2.4描述了类型(nsns)和值[257，‘xx’， 514， “]的结构。对于不是最终项的非固定大小的项(即字符串’xx’)，存在一个帧偏移。说明了“舍入”以找到第二个整数的开始的过程。 Dictionary Entries 字典条目被视为只有两个项的结构——首先是键，然后是值。在键大小固定的情况下，将没有帧偏移，而在键大小非固定的情况下，将只有一个帧偏移。由于该值被视为结构中的最后一项，因此它永远不会有帧偏移。 ","date":"2022-12-20","objectID":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/:2:5","tags":["GLib","GIO","gnome","linux"],"title":"GVariant规范1.0","uri":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/"},{"categories":["gnome"],"content":"例子 本节包含一些说明序列化格式的示例。所有示例都是小端字节顺序。 示例数据每行给出16个字节，每个字节的值由两个字符表示。为了清晰起见，根据不同的目的，字节值使用了许多不同的表示法。 'A shows that a byte has the ASCII value of A (65). sp shows that a byte is an ASCII space character (32). \\0 shows that a byte is a zero byte used to mark the end of a string. -- shows that the byte is a zero-filled padding byte used as part of a structure or dictionary entry. ## shows that the byte is a zero-filled padding byte used as part of an array. @@ shows that the byte is the zero-filled padding byte at the end of a Just value. any two hexadecimal digits show that a byte has that value. 每个例子都指定了一种类型、一个字节序列，以及当用给定类型反序列化时，这个字节序列所代表的值。 String Example 使用类型's'，表示'hellow world': 'h 'e 'l 'l 'o sp 'w 'o 'r 'l 'd \\0 Maybe String 使用类型 'ms'， 表示 Just 'hello world' 'h 'e 'l 'l 'o sp 'w 'o 'r 'l 'd \\0 @@ Array of Booleans Example 使用类型 'ab'，表示[True, False, False, True, Ture] 01 00 00 01 01 Structure Example 使用类型'(si)'，表示('foo', -1). 'f 'o 'o \\0 ff ff ff ff 04 Structure Array Example With type 'a(si)'，has a value of [('hi', -2), ('bye', -1)]. 'h 'i \\0 -- fe ff ff ff 03 ## ## ## 'b 'y 'e \\0 ff ff ff ff 04 09 String Array Example With type 'as'，has a value of ['i', 'can', 'has', 'strings?']. 'i \\0 'c 'a 'n \\0 'h 'a 's \\0 's 't 'r 'i 'n 'g 's '? \\0 02 06 0a 13 Nested Structure Example With type '((ys)as)'，has a value of (('i', 'can'), ['has', 'strings?']) : 'i 'c 'a 'n \\0 'h 'a 's \\0 's 't 'r 'i 'n 'g 's '? \\0 04 05 Simple Structure Example With type '(yy)'，has a value of (0x70, 0x80). 70 80 Padded Structure Example 1 With type '(iy)'，has a value of (96, 0x70). 60 00 00 00 70 -- -- -- Padded Structure Example 2 With type '(yi)'，has a value of (0x70, 96). 70 -- -- -- 60 00 00 00 Array of Structures Example With type 'a(iy)'，has a value of [(96, 0x70), (648, 0xf7)]. 60 00 00 00 70 -- -- -- 88 02 00 00 f7 -- -- -- Array of Bytes Example With type 'ay'，has a value of [0x04, 0x05, 0x06, 0x07]. 04 05 06 07 Array of Integers Example With type 'ai'，has a value of [4, 258]. 04 00 00 00 02 01 00 00 Dictionary Entry Example With type '{si}'，has a value of {'a key', 514}. 'a sp 'k 'e 'y \\0 -- -- 02 02 00 00 06 ","date":"2022-12-20","objectID":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/:2:6","tags":["GLib","GIO","gnome","linux"],"title":"GVariant规范1.0","uri":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/"},{"categories":["gnome"],"content":"非正常序列化数据 名义上，反序列化是序列化的逆操作。这意味着反序列化应该是一个双射部分函数。 如果反序列化是一个局部函数，则必须对序列化的数据不是正常形式的情况进行处理。通常这将导致引发一个错误。 反对错误的观点 要求XXX禁止我们在加载时扫描整个序列化的字节序列;我们现在不能检查是否正常，也不能发布错误。这使得任何可能发生的错误在访问值时作为异常引发。 由于C语言对异常的支持很差(几乎不存在)，并且考虑到对简单数据值的任何访问都可能失败，这种解决方案也很快变得站不住脚。 在给定约束条件下，处理错误的唯一合理解决方案是将它们定义为不存在。接受非正规形式的序列化数据使反序列化成为一个满射(但非单射)的总函数。所有字节序列反序列化为某个有效值。 出于安全考虑，对非正常值执行的操作是精确指定的。可以很容易地想象这样一种情况:内容过滤器对消息的内容起作用，调节对安全敏感组件的访问。如果可以创建一个由过滤器中的反序列化程序和安全敏感组件中的反序列化程序以不同方式解释的消息的非标准形式，则可以“偷偷通过”过滤器。 默认值 当反序列化过程中遇到错误，无法引发异常时，我们被迫进入必须返回预期类型的有效值的情况。因此，为每种类型定义了一个“默认值”。这个值通常是在反序列化过程中遇到错误的结果。 有人可能会说，健壮性的降低是因为忽略错误并向用户返回任意值。不过，应该指出的是，对于大多数类型的序列化数据，一个随机字节错误更有可能导致数据保持正常形式，但值不同。我们无法捕获这些情况，并且这些情况可能导致将给定类型的任何可能值返回给用户。我们被迫接受这样一个事实:在存在损坏的情况下，我们所能做的最好的事情就是确保用户接收到正确类型的一些值。 每种类型的默认值为: 类型 默认值 Boolean False Bytes nul Integers 0 Floats 0 String 空字符串 Object Paths ‘/’ Signatures 空字符串 Arrays 空 Maybes 类型的Nothing Structures 每个元素的默认值 Dictionary Entries 每个元素的默认值 Variants 包含单元类型的子变量 处理非正常序列化数据 在一个正常运行的系统上，通常不会遇到非正常值，因此一旦检测到问题，即使性能任意差也是可以接受的。但是，出于安全原因，在访问不受信任的数据时，必须始终检查其是否正常。由于这些检查的频率，它们必须是快速的。 本节中包含的几乎所有用于非正常数据反序列化的规则都要记住这一要求。具体来说，所有规则都可以在一个很小的常数时间内确定(有几个非常小的例外)。这是不允许的，例如，要求在其帧偏移量中任何地方都不一致的数组被视为空数组，因为这将需要扫描所有偏移量(数组的大小是线性的)，只是为了确定数组的大小。 在序列化的字节序列中，只会发生少量不同种类的异常。每一个问题，以及该怎么做，都将在本节中讨论。 下面的列表是一个明确的列表。如果一个序列化的字节序列没有这些问题，那么它就是正常的形式。如果一个序列化的字节序列有任何这些问题，那么它就不是正常的形式。 固定大小值中错误的大小：如果用户尝试使用固定宽度类型的类型和错误长度的字节序列进行反序列化，则将使用该类型的默认值。 非零填充字节：当任何填充字节非零时，会发生此异常。这适用于数组、maybe、结构和字典条目。这种异常永远不会被检查——子值从它们的容器中反序列化，就好像填充是零一样。 布尔值超出范围：如果一个布尔值中包含的数字不是0或1，那么它就会被视为真值。这是为了与用户直接在C中访问一个布尔数组保持一致。例如，数组中的一个字节包含数字5，在C中这将计算为True。 可能未终止字符串：如果字符串的序列化形式的最后一个字节不是零字节，则字符串的值将被视为空字符串。 带有嵌入式空字符的字符串：如果一个字符串的最后一个字节是null字符，但在这个最终结束符之前还包含另一个null字符，则该字符串的值将被取为嵌入的nul之前的字符串的一部分。这意味着获取一个指向字符串的C指针仍然是一个常数时间操作。 无效对象路径：如果对象路径的序列化形式不是一个有效的对象路径，后面跟着一个零字节，则使用默认值。 无效的签名：如果签名字符串的序列化形式不是一个有效的DBus签名，后面跟着一个零字节，则使用默认值。 可能是固定尺寸的尺寸错了：如果具有固定元素大小的实例不完全等于该元素的大小，则将该值取为Nothing。 固定宽度数组的大小错误：如果固定宽度数组的序列化大小不是固定元素大小的整数倍，则取该值为空数组。 子对象的开始或结束边界落在容器之外：如果帧偏移量(或基于帧偏移量的计算)表明子值的字节序列的任何部分将落在父值的字节序列之外，则为子值提供其类型的默认值。 结束边界先于开始边界：如果帧偏移量(或基于帧偏移量的计算)表明子值的字节序列的结束边界在其开始边界之前，则为子值提供其类型的默认值。在开始边界之前的子节点的结束边界可能导致两个或多个子节点的字节序列重叠。其他子节点将忽略此错误。这些子节点的值对应于在这些字节序列上执行的正常反序列化过程，该过程具有子节点类型。如果容器中的子容器顺序不一致，则表示存在这种异常。没有对顺序不一致的子节点执行其他特定的检查。 子值重叠帧偏移：如果子值的字节序列与其所在容器的帧偏移量重叠，则此错误将被忽略。子进程被赋予一个值，这个值对应于在这个字节序列上执行的正常反序列化过程(包括来自帧偏移的字节)，该字节序列具有子进程的类型。 非固定宽度数组的无意义长度：如果非固定宽度数组的最终分帧偏移量指向数组字节序列之外的边界，或者表明数组中存在非整数值的分帧偏移量，则将该值视为空数组。 结构帧偏移空间不足：如果序列化结构包含的空间不足以存储所需的帧偏移量，则只要正在访问的项具有所需的帧偏移量，错误就会被无声地忽略。试图访问需要偏移量超过可用偏移量的项将导致默认值。 ","date":"2022-12-20","objectID":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/:2:7","tags":["GLib","GIO","gnome","linux"],"title":"GVariant规范1.0","uri":"/2022/12/0001-gvariant%E8%A7%84%E8%8C%831.0/"},{"categories":["c\u0026c++"],"content":" 最近需要实现一个外发阻断的功能，简单点就是给要外发的程序添加Hook，在外发前做数据检查，检查通过后才允许外发，然而实现过程中才发现，给某个程序的动态库添加了Hook，但是始终不见生效，百度、必应、谷歌都用上了也没找到原因，最终只能自己对比可执行文件的区别，问题原因找到了，因此有了这篇文章。 做了以下操作之后，将导致Hook将无法生效： 针对依赖的动态库在编译时候隐藏动态库符号表 ","date":"2022-11-16","objectID":"/2022/11/0012-%E9%98%B2%E6%AD%A2%E7%A8%8B%E5%BA%8F%E8%A2%ABhook%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","tags":["c","c++"],"title":"防止程序被Hook的方法","uri":"/2022/11/0012-%E9%98%B2%E6%AD%A2%E7%A8%8B%E5%BA%8F%E8%A2%ABhook%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["system"],"content":" 计算机网络，说复杂，其实也简单。把它看成一个平面，实际上只有两种物理元素：链路和节点。 计算机网络的通信过程就是在链路和节点上实现的。为了实现通信，必须建立节点和链路上的通信规则，这些通信规则称为协议。 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:0:0","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"计算机网络及其分类 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:0","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"计算机网络及其功能 计算机网路就是用通信介质将多台计算机连接起来形成的计算机系统。 其中的连接有两重含义： 通过传输媒介建立的物理连接 由网络软件实现的逻辑上的连接 进行连接是为了实现以下功能： 通信 资源共享 提高计算机系统的可靠性（主备） ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:1","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"计算机网络的分类 按拓扑结构分类 链路型网络（点到点结构） 点到点结构中，一条链路只能有两个节点互联，两点之间要么直接通信，要么通过中间节点转发。 星型结构：以中央节点为中心，若干外围节点都与中心节点连接，中心节点实施全网控制 树型结构：是由星型结构演变而来，它实际是多个星型结构的级联组合（分级管理的集中式网络）。 环形结构：把所有节点连接成环形，每个节点都有两条链路与之相连。 格状网络：所有节点具有两个或两个以上直接通路的拓扑结构 全互联结构：所有节点之间都有直接连通的拓扑结构。 格状网络和全互联结构也称网状结构，具有较高的可靠性，但是网络结构也比较复杂，链路多、投资大。 广播型网络 广播型网络的特点是，通信线路为多个节点共享。这样一个节点发送的信息可以传输到其它所有节点；当有两个以上节点同时发送信息时候，便会引起冲突。总线型结构是一种应用最普遍的广播型网络拓扑结构。 在总线型结构中，各个计算机网络节点的设备用一根总线连接起来。总线型结构目前在局域网中应用很广，有以下特点： 节点插入、拆卸很方便，易于扩充 不需要中央控制器，有利于分布式控制，某个节点发生故障对整个系统影响很小，网络可靠性高。 总线自身的故障对系统是毁灭性的，因而要有较高的安装质量。 按覆盖地域分类 微微网(Piconet)：微微网是由采用蓝牙技术的设备以特定方式组成的网络，这种网络的建立是从两台设备的连接开始(比如笔记本和移动电话)，同一时刻最多可以激活8态设备。 个人局域网(PAN, Personal Area Network)：各种短距离无线电技术发展而来的新概念，一般覆盖距离为100m以内 局域网(LAN, Local Area Network)：一般是 10km 范围内的网络，例如：一栋办公司、一座仓库、一个学校中的计算机网络 城域网(MAN, Metropolitan Area Network)：一般覆盖一个城市的网络，范围在 5~50km之内。 广域网(WAN, Wide Area Network)：网络延伸到整个国家甚至全世界的网络 按照网络中主机台数分类 分为三大类： A类是大型网络：主机最多可达1600万台 B类是中型网络：主机最多可达65534台 C类是小型网络：主机最多可达254台 其它分类方法 按使用权限分类：公用网络和专用网络 按公司命名分类 按操作系统及其版本分类 按所用技术分类 按使用介质分类 按业务范围分类 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:2","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"计算机网络元素 为了保证网络节点之间能正常通信，必须使元素之间遵守约定的规则和原则。这些规程和规则就是协议。 网络节点 在复杂的网络中进行数据传输，从源节点往往要经过多个中间节点才能传送到目的节点。中间节点大致有四种： 端节点、中继节点、交换节点、路由节点。 端节点 端节点是进行数据处理的节点，在网络中这些节点应当具有两种功能：数据处理和通信。其中： 数据终端设备DTE（Data Terminal Equipment）为具有一定数据处理能力的发送、接收设备，如计算机或各种终端设备。 数据通信设备DCE（Data Communication Equipment）为通信接口设备，在 DTE 与通信网之间提供信号变换及编码功能，并负责建立、维护和释放物理连接，如：波形变换器、基带传输器、调制解调器等。 中继节点 信号在介质中传输时候，随着传输距离的增加，幅度会衰弱，波形会失真。中继器用于同类网络介质之间的互联，起到信号再生、放大作用。 中继器有一通一的中继器，也有一通多的中继器(集线器Hub，一段输入的信号，经整形、方法后转发到其它所有端口上) 交换节点 通信过程往往需要经过多条链路才能实现。转换由交换节点实现。 路由节点 路由节点是一种特殊节点。它位于网络之间，起连接网络的作用，属于所有连接的网络共有，正是由于路由节点，才使互联网得以形成。 把每个网络看成一个通路——链路，那么路由节点的分布就形成了互联网的拓扑结构或框架。 路由的网络连接功能主要体现在它能为到达的数据选择到达目的节点的路由，这就是路由节点称为路由器的原因。 传输链路 传输链路是网络中连接两个节点的直接信息通路，简称链路。 数据在计算机网络中传输，往往要经过多条链路一段一段的传输。中间可能经过中继节点，也可能经过交换节点。 链路可能是物理的，也可能是逻辑的。采用多路复用技术可以把一条物理链路划分成多条逻辑链路。 通信介质就是搭载信号的传输媒介，是链路的物理基础。通信信号是 $10^{4} - 10^{16}Hz$ 频率范围的电磁波。它们的基本传播途径有两种： 有线传输——在有限空间内传输 无线传输——在自由空间中传输 协议 除了节点和链路这样两种物理元素外，网络还有一种非物理的元素 —— 协议。 协议及其内涵 凡是两个以上的对象或系统相互进行联系，都需要建立联系的规则或约定，这些为了通信或联系所指定的约定、规则和标准就被称为协议。 协议存在于任何通信过程中，它包含了传输信息的格式（语法）、语义和定时（传输顺序）三个方面的约束： 语法：语法是关于信息格式的规定，将信息按照一定的格式进行组织和传输。例如：一个数据分组有多长、具体划分为几个字段等。两个不同的网络互联，即当一个数据分组被转换为数字信号以后从一个网络进入另一个网络时候，必须进行数据格式的转换，这就需要根据两种网络协议的规定进行数据的分割和组装。 语义：在计算机网络中，传输的数据有用户信息和控制命令两种。语义用来规定命令和应答的含义。 定时：命令和应答需要一定的次序关系。定时用于规定命令、应答和状态变化的顺序和时间要求。 协议的基本功能 在计算机网络中，协议的目的就是确保通信过程的顺利、安全、可靠的进行，因此它的基本功能有以下几点： 分割与组装：在通信网络中，为了提高传输效率以及客服传输能力的限制，在发送端要将保温分割成一些适合网络传输的数据包——分组，并在分组时候加上控制信息；在接收端要将数据分组重新组装成报文。 规定格式和特性：规定数据格式，规定网络接口的机制、物理、功能和规程特性等。 传输服务：满足一定的性能需求，如在传输过程中要求控制数据优先于信息数据等。不同的通信系统有不同的传输服务，例如：为了在一条下怒上同时传输多路信号，就会要求系统按照何时的顺序发送和接收报文，并规定同步方式和寻址方式等。 传输控制：包括流量控制、差错控制和连接控制。流量控制用于控制数据传输过程中发送方的发送数度和数量，解决信道上拥塞问题；差错控制用于减少、监测和纠正错误；连接控制用于通信实体间连接的建立或拆除。 协议的实现——网卡和网络操作系统 网络协议通常是由网卡和网络操作系统共同实现的。 网卡：网络接口卡简称网卡，又称为网络适配器，该电路板安装在计算机扩展槽中以连接计算机和网络，是网络设备（如工作站、服务器等）与网络的通信介质进行连接的服务设备。它主要实现网络协议中与通信相关的功能。网络正常工作时候，网卡通过通信介质的端口监视网络的状态，接收传输介质上的信号。当网卡接收到有效的数字信号时候，网卡会判断是否发给本站（是，则将数据通过网络设备的接口传输到网络设备；否，则放弃或按原方向转发）；另一方面，要适时将所连设备需发送的数据发送到网上，以实现网络设备间的通信。 网络操作系统：网络操作系统是网络用户与通信网络之间的接口。最早的网络操作系统仅仅用于网络上的文件管理，随着计算机网络的发展，网络操作系统的功能不断丰富和完善，为网上用户提供了遍历的操作和管理平台。目前市场上的几种主要 NOS 为：Linux、Unix和windows等。 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:3","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"链路上的通信技术 链路是指物理链路，即一条无缘的点到点的物理线路段，中间没有任何交换节点。 本章讨论一段链路中的数据传输技术，即将数据从一个节点传送到另一个节点的技术，这些技术包括： 源节点和目标节点之间的交互方式（单工、双工或半双工） 数据的传输形式（并行传输/串行传输） 同步控制方式（同步传输/异步传输） 信号形式（信号分析与编码） 在一条物理信道中传输多路信号——多路复用技术 差错控制技术 流量控制技术 典型传输规程 本章还有另一个术语——信道，应该注意信道与链路的微笑区别 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:0","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"基本通信方式 交互方式 信道的交互方式是指在一条物理信道上所允许的信号流动方向，有三种形式： 一方发送、另一方接收（单工通信）。比如：无线广播、电视等 双方可以同时进行收、发，但是两方收、发智能交替进行，不能同时进行（半双工通信）。比如：对讲机 双方可以同时双向进行发送和接收信号（全双工通信），相当于两个单工显露的组合。比如：电话 并行传输和串行传输 计算机中在数据传输时候，一条线路同一时刻智能传输信号的1位。如果将信号的各位分别在多条线路同时传输，则称为并行传输；如果只用一条先，让信号以位位单位顺序传输，就称为串行传输。 串行通信中的同步控制 同步的概念 为了让计算机的各个部件间协调工作，必须靠时钟对它们分别定时和定序。 在计算机网络中，接收方和发送方的时许协调也要依靠时钟定时，即发送方依靠时钟来决定每一位的起始和终止，接收方也要依靠定时时钟来确定对信号每一位的采样取值位置和时间间隔。然而，任何两个系统间时钟完全准确地同步（一致）是不太可能的。为了解决这一问题，就需要对表一样，每个一个时间间隔，收发两端校对一下时间。收发两端校对时间就称为收发两端的同步。 帧级同步、字节级同步和位级同步 按照传输的数据的长度，可以考虑从三个级别上进行收发两端的同步：帧级、字节级和位级。 帧级同步 帧（Frame）是在链路连接的两端每次所传输的数据块，通常由多个字节组 成，具体长度由链路上所使用协议规定。帧的同步，就是在数据块的两端加上前文（Preamble）和后文（Postamble），表示帧的起始和结束。前文和后文的特性也取 决于所用的协议，并可以分为面向字符和面向位两大类。 在面向字节的同步传输中，帧头包含一个或多个同步字符——SYN。SYN是一个控制字符，后面是控制和数据字节。接收端发现帧头，便开始接收后面的数据块，直至遇到另一个同步字符。IBM的二进制同步规程（BSC或Bisync）是具有代表性的面向字符的同步传输规程。 在面向位的同步传输中，将数据块看作数据流，并用序列\"01111110\"作为开始和结束的标志。为了避免在数据流中出现序列\"01111110\"时引起混乱，发送方总是在其发送的数据流中每出现5个连续的\"1\"就插入一个附加的\"0\"；接收方则每监测到5个连续的\"1\"并其后有一个\"0\"时，就删掉该\"0\"。目前应用最普遍的面向位的同步传输规程是 `HDLC` 和 `SDLC`。 采用帧同步时，接收端时钟和发送端时钟会有微小的差异，会造成帧内各数据位的漂移。由于帧一般较长，位漂移的积累将造成一个帧内后面部分的数据位无法正确接收，所以帧同步不能独立使用。 字节级同步 字节级永不就是两端每次以字节为单位传输数据，并在字节的两端加上特殊极好，表示字节的开始和结束，以实现收发两端同步。通常采用如图2.4所示的方法： 不传送时，信道一直处于高电平，表示停止（状态\"1\"） 用1位低电平（状态\"0\"）表示起始位； 接着传送 1 个字符； 最后用1位或2.5位或2位的高电平表示停止位。 在字节级同步方式中，接收方知道了字节起止后，尽管会由于时钟的差异造成字节内位的漂移，但由于字节较短，还不至于漂移到使接收端脉冲信号不能正确接收的程度，因而它可以直接独立使用。 位级同步 前两种方式都采用附加冗余数据信号来实现同步。但是位级同步不能再采用附加冗余数据信号的方法了。因为这样不仅冗余太大，而且几乎无法实现。因此，位级同步需要采用同步时钟实现，即用发送方时钟直接控制接收方时钟，使双方达到完全同步。发送方对接收方的同步可以通过两种方法进行： 外同步法：在发送方和接收方之间提供单独的时钟显露，发送方在每个比特周期向接收方发送一个同步脉冲。接收方根据这一串同步脉冲来调整自己的接收时许，把接收时钟的重复频率锁定在同步频率上。这种方法在短距离传输中比较有效；长距离传输中，会因同步信号失真而失效。 自同步法：利用特殊编码（如：曼彻斯特编码 或 微分曼彻斯特编码）让数据信号携带时钟信号。 由于实际上不可能以位为单位进行传输，所以位级永不方式也不能独立使用。而字级别同步又可以独立使用，所以位级别同步只能与另外一种不能独立使用的同步方式——帧同步配合使用。 同步传输和异步传输 在实际应用中，通常用位级同步来弥补帧同步的不足，而字节级同步可以独立使用。于是实际应用的同步方式只有两种。位级同步和帧同步结合的同步方式最显著的特点是接收端与发送端具有共同的时钟。这种方式被称为同步传输方式；相对而言，字节级同步方式中接收端与发送端不需要严格的时间标准，因而称为异步传输，或称起止同步方式。异步传输实现简单，设备技术开销小，价格便宜。但由于传输时每个字符都要附加２～３位用于起止位，字节之间还有间隔，因此传输效率低。 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:1","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"数据信号分析和编码 信号是数据在载体中的存在形式，为了便于分析，可以用时域法或频谱法表示 时域表示法 时域表示法就是把信号的幅值表示成时间函数。用时域表示法表示信号 时，可以清楚地看出信号随时间变化的规律。 区分模拟信号和数字信号 频谱表示法 频谱表示法是把信号的幅值表示成频率的函数。这是基于傅里叶分析的一种方法。傅里叶分析表明，基频为 $ｆ$ 的任意周期函数 $g(t)$ 都可以由（无限个）正弦函数和余弦函数合成，即： $$ g(t) = \\frac{1}{2} C + \\displaystyle \\sum^{\\infty}_{n=1} a_{n} sin(2 \\pi nft) + \\displaystyle \\sum^{\\infty}_{n=1} b_{n} cos (2 \\pi nft) $$ 式中：$f$ 称为基频，$C$ 是常数，$a_{n}$、$b_{n}$ 是第 $n$ 次谐波的幅值，$n=1$ 的分量波称为基波。 如果把一个持续时间有限的数据信号想像成一个反复重复的模式，就可以将任意信号作为周期信号进行傅里叶分析，分析出它的谐波组成。一个信号的频率范围称为该信号的绝对带宽。在现实中，许多信号具有无限带宽，即它的傅里叶分析结果是无穷级数之和。不过，信号的大部分能量都集中在某一段频带之中，这个频带称为该信号的有效带宽，简称带宽。 用这种表示方法，可以看出一种信号的频率范围———带宽，以及每一个频率 分量的信号能量的大小。同一信号的时域表示与频谱表示之间有一定的关系。越接近正弦波，信号的带宽就越小，对信道的质量要求就越低；而越接近数字信号，信号的带宽就越宽，对信道的质量要求就越高。 为了有效地解决信号传输中不同频率的谐波分量共存所引起的技术问题，人们把信号分为基带（Base Band）信号和频带信号两大类。 频带信号，一般就指音频模拟信号，即带宽为$300HZ$ ～ $3400HZ$ 的普通电话信号。这种信号对信道质量要求较低。 关于基带信号，有三种层次的定义：最广义的概念是指一切原汁原味的不经任何变换（调制）的原始信号；稍低层次的概念是指最高频率与最低频率相差很大的信号，它既可以是模拟信号（如电视信号，基本频带为０～６ＭＨｚ），也可以是数字信号；在计算机数据通信中，使用的是狭义的概念，主要指数字信号，它是一种矩形波，其分量的频率范围相差很大。 信道的主要性能参数 数据传输的必经之路称为信道。 信道在实际传输信号时，会面临三大损害：衰减、延迟失真和噪声。 衰减：是指信号在传输过程中的能量损耗，与距离有关（用单位ｄＢ／ｋｍ度量） 延迟失真：是指由于信道对信号中的各傅里叶分量，因其频率不同所引起的衰减程度不同而造成的波形失真 噪声：是指信道上的非发送方期待的能量。噪声分为热噪声、串音和脉冲噪声。热噪声是由于线路（主要是电气线路）中的电子自由运动加剧而产生的能量。串音是由于临近线路上传输的信号耦合感应传递的能量；脉冲噪声是由于外界强力的电磁信号（如雷电、电力线路上的尖峰等）传递的能量。 信道的性能可以从信道的传输速率、信道带宽、信道容量、吞吐量、出错率等方面衡量。 传输速率 数据的传输速率是指单位时间内所传输的数据量的多少 带宽 任何信道都不是理想的，每一个信道都对能通过信号的频率范围有一个限制。信道允许通过的信号频率范围，即可传送的信号最高频率与最低频率之差，被称为信道的通频带宽，亦即信道带宽，单位为Ｈｚ 信道容量 信道容量即信道上所允许的最大数据传输速率，这是信道的一个极限参数，即信道传输数据的速率不能超过其最大数据传输速率，它与信道带宽以及噪声强度有关。 信道误码率 误码率是指信道传输信号的出错率，是数据通信系统在正常工作情况下的 传输可靠性指标 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:2","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"数字信号的模拟调制 将不适合信道传输的信号变换为适合信道传输的信号称为调制。数字信号的调制是将数字信号转换为频带信号，以便能将数字数据在传统的模 拟线路（电话网）上进行传输。 调制的逆过程称为解调。由于通信多是双向的，所以在实际应用中调制与解调两部分功能要做在一个设备———调制解调器中。 幅移键控 ASK 用不同幅值的正弦载波信号来分别表示数字1和0 ASK的技术简单、实现容易，但抗干扰能力差 频移键控 FSK 用不同角频率的正弦载波信号来分别表示数字1和0 FSK 的技术简单、实现容易、抗干扰能力强，是目前最常用的方法 相移键控 PSK 用不同初相位的正弦载波信号来分别表示数字1和0 PSK 它的抗干扰能力强，但实现技术复杂 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:3","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"模拟信号的数字编码——脉冲编码调制技术 模拟数据的数字编码是将连续的信号波形用有限个离散（不连续）的值近似 代替的过程。其中最常见的方法是脉冲编码调制（PCM） PCM 基本步骤是： 采样：将原波形的时间坐标离散化，得到一系列的样本值 量化：对采样得到的样本值按量级分级并取整 编码：将分级并取整的样本值转换为二进制（０，１）码 数字化的质量取决于下列技术参数： 采样频率：一秒内采样次数（水平方向的精度） 测量精度：量化等级（垂直方向的精度） ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:4","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"数字编码 虽然\"1\"和\"0\"是两个非常简单的码，但实际传输和使用的信号形式有很大的差别，下面给出了６种具有代表性的二进制数字信号的编码方式： 6中二进制数字信号的编码方式 单极性码和双极性码 (a)和(c)是单极性码，它们的特点是只在表示\"1\" 时才发出电流，表示\"0\"时不发出电流，电流只有一个极性（方向） (b)和(d)是双极性码，它们的特点是表示\"1\"时发出正电流，表示\"0\"时发出负电流，电流具有两个极性（方向） 归零码和不归零码 (c)和(d)是归零码，它们的特点是，每次进行０－１变换或１－０变换时，都要在无电流处停留一下。 (a)和(b)是不归零码，它们的特点是，每次进行０－１变换和１－０变换都是直接的，不在无电流处停留。 曼彻斯特码和差分曼彻斯特码 曼彻斯特码的特点是将每个比特周期分为两部分：前半个比特周期传送该比特的原码，后半个周期传送该比特的反码，于是在每个比特周期的中间产生一个电平跃变。这个跃变信号既可以用做同步信号，也可以用做表示 数据（如图（ｅ）所示，用正跃变表示为\"0\"，用负跃变表示为\"1\"）。 差分曼彻斯特码是对曼彻斯特码的的改进，它用每一码元的开始边界处有无跃变来区别\"0\"和\"1\"，如图（ｆ）所示，有跃变表示为\"0\"，无跃变表示为\"1\"。这时，每个比特周期中间的跃变仅仅用做同步时钟。 评价数字信号编码方式的优缺点可以从以下几点考虑: 脉冲的宽度：脉冲宽度大，信号的能量就大，对于提高接收端的信噪比有利 占用的频带宽度：脉冲宽，占用的频带就窄，如归零码比全宽码占用的 频带要宽 直流分量的成分：直流分量低有利于传输，如双极性码的直流分量较 低，曼彻斯特码和差分曼彻斯特码的每个码元中都有跃变，因而没有直流分量 自同步能力：曼彻斯特码和差分曼彻斯特码的每个码元中都有跃变，可以提供自同步能力。如在IEEE802.5中，正常的信号编码都采用差分曼彻斯特 码，只有起始和结束字段中各有４位“特殊比特”，这些特殊比特的码元中间没有 跃变，要么是全高电平，要么是全低电平，以“特殊比特”来作为信号编码起始和 结束的标志。 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:5","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"信道的多路复用技术 在通信系统中，信道有逻辑信道与物理信道之分。物理信道与逻辑信道之间的关 系有点像铁路与车次之间的关系，物理信道好比是铁路，逻辑信道好比是车次。 北京到重庆之间并没有一条专线，但可以通过连接京广线—陇海线—宝成线— 成渝线，开出一趟或几趟北京至重庆的列车来。 逻辑信道是建立在物理信道基础上的：一条物理信道通过载波、分 时或改变连接方式等，有可能分为几条逻辑信道（好像同一条铁道上同时运行多 趟列车一样）；在复杂拓扑结构的网络上，两点之间的通信并不一定要有一条专 门的物理线路，而可以由其内部节点间的连接来实现。通常把逻辑信道的实现 称为“连接”。 多路复用（MUX）源于拉丁语multi（许多）和plex（混合）。它指在一个物理信道上同时传送多个信号，或者说是把一个物理信道设法分成多个逻辑信道，以提 高信道利用率。 频分多路复用（FDM）技术 FDM（Frequency Division Multiplexing）是模拟传输中常用的一种多路复用技术。它把一个物理信道划分为多个逻辑信道，各个逻辑信道占用互不重叠的频带，相邻信道之间用“警戒频带”隔离，以便将不同路的信号调制（滤波）分别限制 在不同的频带内，在接收端再用滤波器将它们分离。 频分多路复用 目前，FDM 技术已经在一定程度上实现了标准化。其中一个广泛使用的国 际标准是把12×4000Hz的音频信道（用户使用3000Hz，再加两个500Hz的防护频带）复用到60Hz～108Hz的频带上，其单位称为群（Group) 时分多路复用（TDM）技术 TDM基本原理 与FDM的同时发送多路信号相比，时分多路复用（TDM, Time Division Multiplexing）是一种非同时发送的多路复用技术。如下图示，它将一个传送周期划分位多个时隙，让多路信号分别在不同的时隙内传送，形成每一路信号在连续的传送周期内轮流发送的情形。 时分多路复用 数字信号的时分复用也称为复接，参与复接的信号称为支路信号，复用后的信号称为合路信号，从合路信号中将原来的支路信号分离出来称为分接。 通常，话音信号是用脉码调制来编码的。由于典型的电话通道是4KHz，按 照奈奎斯特定理，为了用数字信号精确地表示一个模拟信号，对话音模拟信号的采样频率至少要达到8000Hz。用一个８位字来代表每个采样，则话音信号数字化的结果便是一个8000x8（位字）的数据流，数据传输速率为64kb/ｓ。上述方法称为 PCM 复用。为了提高数码率，对 PCM 复用后的数字信号再进行时分复用，形成更多路的数字通信，目前广泛采用这种数字复用方法来提高通信容量。 下图所示为 TTU-T 推荐的数字速率等级和复接等级，它们都是基于传输速率 64kb/s （称为零次群）的数字信号的。两种等级不同之处在于，一类是用 TDM 技术将 24 路零次群复用到一条线路上，形成数据传输速率为 1.544MB/s 的一次群（称为 T1 次速率，主要在北美应用），并在此基础上形成其二次群、三次 群、四次群等；另一类是用 TDM 技术将 30 路零次群复用到一条线路上，形成数 据传输速率为 2.048MB/s 的一次群（称为 E1 次速率，主要在欧洲应用），并在此基础上形成其二次群、三次群、四次群等。 ITU-T推荐的数字速率等级和复接等级 复接方式 TDM 可以设计成按位、按字节、按字符、按字或按任意多位的方式来对每个终端进行扫描复接。 下图(a)(b)分别为按位和按字节进行扫描复接的示意图： 两种扫描方式 按位复接又称为比特复接，即复接时每支路依次复接一个比特。这是目前 广泛使用的方法，它的设备简单，需容量小，且容易进行，但对信号的交换不利。 按字节复接的方法如下：对基群来说，一个码字有８位，复接前先将８位码 存起来，在规定的时间内一次复接；４个支路轮流复接。这种方法需要较大的存 储容量，适合于数字电话交换。 按帧复接是每次复接一个支路的帧（２５６比特）。这种方法不破坏原来的帧 结构，有利于交换，但需要更大的存储容量。 复接实际上就是通过脉冲采样再生成一定宽度的数字信号的过程，但由于要保持原来的数字信号周期，因此复接生成的方波宽度一定要按复接支路数进行分频。如在下图中，对４路数字信号进行复接后，在合路上的位宽减小到 原来的 1/4，使得４路的总宽等于原来１位的宽度，这样才能保持信号的传输速率不变。 对4路 PCM30/32基群信号按位复接和按字复接 同步时分复用和异步时分复用 下图给出了时分多路复用的两种同步方式———同步时分多路复用（ＳＴＭ）和异步时分多路复用（ＡＴＭ）。同步时分多路复用是指时分方案中的时间片是预先分配好的，时间片与数据源是一一对应的，不管某一个数据源有无数据 要发送，对应的时间片都是属于它的；或者说，各数据源的传输定时是同步的。在接收端，根据时间片的序号来分辨是哪一路数据，以确定各时间片上的数据应 当送往哪一台主机。 同步时分多路复用与异步时分多路复用 采用异步时分多路复用时，各时间片与数据源无对应关系，系统可以按照需 要动态地为各路信号分配时间片，各时间片与数据源无对应关系。为使数据传 输顺利进行，所传送的数据中需要携带供接收端辨认的地址信息，因此异步时分 多路复用也称为标记时分多路复用。ＡＴＭ 技术中的传输就是这种方式。 复接时系统间的同步问题 当由几个低次群数字信号复接成一个高次群数字信号时，如果各低次群采 用独立的时钟，即使每个低次群所使用的时钟的标称数码率相同，也会由于线路 长短不同产生的时延差异等原因，造成瞬时数码率的差异，从而形成如下图所示的重叠或错位现象，使复接合成后的数字信号无法分接恢复成为原来的低 次群数字信号。 瞬时数码率差异造成的重叠和错位 为避免这个问题，需要解决系统与系统间的同步问题。系统间的同步可以 用两种方法实现：一种是用一个高稳定的主时钟来控制被复接的几个低次群，使 它们的数码率统一在主时钟的频率上，从而达到同步的目的；另一种，也是最常 用的，是称为码速调整的方法。码速调整方法是让各低次群仍然使用自己的时 钟，并在复接前插入一些码元。例如，要将支路速率为２０４８ｋｂ／ｓ的４个基群信 号复接到速率为８４４８ｋｂ／ｓ的二次群上，就必须首先对基群的数据速率进行调 整，使之与８４４８ｋｂ／ｓ的４分频速率２１１２ｋｂ／ｓ同步，然后再进行同步复接。这 种调整后的数码率高于调整前的数码率的码速调整方法称为正码码速调整。 下图所示是调整到２１１２ｋｂ／ｓ的基群流帧结构，称为二次群复接子帧结 构。图中 $C_{ij}$ 为插入标志码，用于分接时判断所在基群中的复接子帧中有无插入 码速调整位。有插入位，取全\"1\"；无插入位，取全\"0\"。 $V_{i}$为插入码——位调整码率而插入的码元。支路速率偏低，在该时隙插入一个不含信息的脉冲；支路速率正常，该时隙仍传输支路信息。 调整到2112kb/s基群流的二次群复接子帧结构 在支路级速率调整的基础上，进行二次复接帧的速率调整。下图为PCM二次群复接帧结构。从图中可以看出，二次群的数码率为 8.448Mb/s，帧周期约为 100us，帧周期内共 848 个比特。其中： 第 1 ~ 10 位为插入帧同步码 1111010000 （依据 ITU-T 规定） $F_{33}$ （第11位）作对端告警码 第12比特备用 $C_{11}$、$C_{21}$、$C_{31}$、$C_{41}$、$C_{12}$、$C_{22}$、$C_{32}$、$C_{42}$、$C_{13}$、$C_{23}$、$C_{33}$、$C_{43}$为插入标志码。 $V_{1}$、$V_{2}$、$V_{3}$、$V_{4}$ 位插入码——为调整码率而插入的比特。 PCM二次群复接帧结构 在复接器中为调整码率要插入插入码，在分接器中要将它们去掉———消插。分接器进行消插的依据是“插入标志码”。当插入标志码的４位中有“０００”时，表 示无插入码；当插入标志码的４位中有“１１１”时，表示有插入码。这种方法叫做 “大数判决法”。 实际上，同步复接中也要使用插入码。与异步复接不同的是，它在每一个帧 中都要插入插入码，目的是使低次群的码速能在复接后符合高次群的要求。 准同步数字系列 PDH 准同步数字系列 ＰＤＨ（ＰｌｅｓｉｏｃｈｒｏｎｏｕｓＤｉｇｉｔａｌＨｉｅｒａｒｃｈｙ）是曾广泛使用的数字 传输技术，它采用异步复接，而且大多数采用正码码速调整，即通过插入一些非 信息比特使各支路信号与复接设备信号同步，并复接成高次群信号。这种方式 的最大缺点是很难从高次群信号中直接识别和提取低次群信号。要分接出支路 信号或插入支路信号，惟一的方法是将高次群信号一步一步地分接成所要提取 的低次群信号，然后再一步一步地复接成高次群信号。图２．２３示出了在 ＰＤＨ 系统中从ＰＣＭ 四次群传输速率为１４０Ｍｂ／ｓ信号中提取传输速率为２Ｍｂ／ｓ信号 的过程。 在PDH系统中提取一个低次群信号示例 同步数字系列 SDH …略 光波分多路复用技术(WDM) WDM基本原理 光波分多路复用（ＷＤＭ，ＷａｖｅｌｅｎｇｔｈＤｉｖｉｓｉｏｎＭｕｌｔｉｐｌｅｘｉｎｇ）技术是在一根光纤 中能同时传输多个光波信号的技术。ＷＤＭ 的基本原理如图２．２９所示，是在发 送端将不同波长的光信号组合起来，复用到一根光纤上，在接收端又将组合的光 信号分开（解复用），并送入不同的终端。 光波分多路复用单纤传输 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:6","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"差错控制 差错产生的原因与基本对策 在数据传输中，接收到的数据与原来发送的数据不一致称为传输差错。信道噪声引起传输信号的畸变是产生差错的主要原因。 循环冗余码校验 目前，主要的检错技术是奇偶校验（Ｏｄｄ－ＥｖｅｎＣｈｅｃｋ）和循环冗余码校验 （ＣＲＣ，ＣｙｃｌｉｃＲｅｄｕｎｄａｎｃｙＣｈｅｃｋ）。 奇偶校验码分为垂直奇偶校验码、水平奇偶校验码和水平垂直奇偶校验码。它们的冗余位少、方法简单，但纠错能力差，一般只用于要求较低的通信场合。 这里只介绍循环冗余码校验ＣＲＣ。 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:7","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"流量控制与滑动窗口协议 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:8","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"高级数据链路控制协议 HDLC 数据链路连接管理方式 面向连接的服务 无连接的服务 HDLC的配置和数据传输工作方式 通信站 两种链路配置 HDLC数据传输工作方式 正常响应方式(NRM) 异步平衡方式(ABM) 异步响应方式(ARM) HDLC 帧格式 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:9","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"中间节点上的通信技术 ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:0","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"交换节点上的通信 在多节点的网络中，为了提高线路的利用率，任意两个节点间的通信不可能 都是建立在一条直接通路上，在许多情况下要使用两条以上的线路。把一条线 路上的数据转接到另一条线路上，称为数据交换。或者说，交换的基本功能就是 转发业务流。 电路交换 在电路交换（ＣｉｒｃｕｉｔＳｗｉｔｃｈｉｎｇ或ＣｉｒｃｕｉｔＥｘｃｈａｎｇｉｎｇ）方式下，通信的双方在进 行数据传送之前先要建立一个实际的物理电路连接，连接的电路被通信的一对 用户独占，只有通信结束电路释放后，才能被别人使用。简单地说，它要经过３ 步：建立连接（呼叫），数据传送，线路拆除（释放）。 电话系统是一种电路交换的网络，通信双方一旦接通，便独占一条线路，即 使没有数据传送，别的用户也无法利用。 电路交换有如下特点： 由于需要连接过程，建立连接需要时间，故适合传输大量数据，而传输 少量数据时效率不高； 连接一旦建立，便可以固定的速率传输数据，除了传输延迟外，不再有 别的延迟； 一旦连接成功，就建立了一条临时专线，即使不通话，也被占用，他人不 可使用。 存储——转发交换 存储——转发概念 存储－转发交换（Ｓｔｏｒｅ－ａｎｄ－ＦｏｒｗａｒｄＳｗｉｔｃｈｉｎｇ）是一种不要求建立专用物 理信道的交换技术。当发送方要发送信息时，应把目的地址先加到报文中，然后 从发送节点起，按地址把报文逐节点地转送到目的节点；在转送过程中，中间节 点要先把报文暂时存储起来，然后在线路不忙时将报文转发出去，这就是将其称 为存储－转发交换的缘由。 存储转发交换不像电路交换那样要独占一条固定的 信道，线路利用率高，同时可以根据网络中的流量分布动态地选择报文的通过路径，系统效率高，因而得到了广泛的应用。 为了实现存储－转发，每个交换节点要为每一个端口分别设置一个输入缓 冲区和一个输出缓冲区。 分组交换系统的发展 早期的存储－转发交换以报文（Ｍｅｓｓａｇｅ）形式进行，称为报文交换。下图演示了在连续的４个节点之间用报文分组交换方式进行数据传输的基本过程。 报文交换的基本过程 一般说来，报文较大，因而传输延时较长，不适合传输语音等实时信号；并 且，在传输过程中容易因为个别错误而导致整个报文传输作废。例如，某一线路 允许的差错率为１０－５，若传输的报文长度为１００ｋＢ（Ｂ表示字节），则每次传输中 都可能有１个字符出错。这样的报文很难传到目的节点。为此，在报文交换的 基础上，研制出分组交换（ＰａｃｋｅｔＳｗｉｔｃｈｉｎｇ），也称包交换。报文分组后，就可以避 免上述两个缺点。 在分组交换网中，要先把 在分组交换网中，要先把一个报文分割成规定长度的信息组———分组打包， 然后在每个分组上贴上标签———报头，按编号一批一批地将“数据分组”发出去； 在每一个中间节点上，都要先存储、后转发；传送到达目的地后，再重新装配成完 整的报文。 报文分组 ATM、TCP/IP 都是分组交换。但是，它们的分组大小和具体交换方式各不 相同。 分组交换的虚电路服务和数据报服务 分组交换有虚电路（ＶｉｒｔｕａｌＣｉｒｃｕｉｔ）和数据报（Ｄａｔａｇｒａｍ）两种服务方式 虚电路服务 虚电路的服务过程与下面的部队从Ａ地向Ｄ地转移的过程相似。 ① 先派侦察兵侦察出一条安全的通道（如图中的 Ａ－Ｂ－Ｃ－Ｄ），侦察 工作完成后，向指挥部发回报告； ② 部队接到通道已经侦察好的报告，开始以支队为单位沿侦察好的通道转移，并且是先出发的先到达； ③ 部队转移结束，Ａ地通知Ｄ地，该通道的任务完成，停止使用。 虚电路的通信方式 虚电路服务也分３个阶段。下图说明在Ａ－Ｂ－Ｃ－Ｄ４个节点之间以虚电路方式进行数据传输的时序关系。 虚电路工作时的时序关系 1. 建立虚电路 Ａ启动路由算法，选择下一个节点 Ｂ，并向 Ｂ发送一个“呼叫请求分组”；接 着Ｂ也启动路由算法，选择下一个节点 Ｃ，并向 Ｃ转发“呼叫请求分组”。于是 “呼叫请求分组”沿Ａ－Ｂ－Ｃ的路径到达目的节点Ｄ。目的节点Ｄ则沿Ｄ－Ｃ－ Ｂ－Ａ的路径返回“呼叫应答分组”。至此虚电路建立。 2. 数据传输 Ａ将报文分组打包，不需再加目的主机的全地址，只需带上到Ｂ的虚电路号 （Ａ对可能到达的每个节点编号）即可，按照该虚电路号将各数据分组发送到 Ｂ。 Ｂ如法炮制，将各数据分组发送到Ｃ，由Ｃ再发送到Ｄ。 这里之所以要使用分组（包），而不是将报文作为整体发送，是因为：如果在 某个节点上检验出某个分组有错，只要重发该分组即可，不需将全部报文重发， 这是分组交换比报文交换的优越之处；不会在物理上占用每一段电路。此外，采用虚电路方式可以连续地发送数据分组，数据分组上附 加的地址信息少，且接收到的数据分组顺序与发送的顺序一致，又有些像电路交 换，可以保证数据分组的实时性。所以说，虚电路是电路交换和存储－转发交换 的结合。但是，若在某一对相邻节点间的传送中有一个分组不能被正确接收，其他分组就要等待，从而降低了传送效率。 3. 拆除虚电路 报文传送完毕，Ａ沿 Ａ－Ｂ－Ｃ－Ｄ路径发送“释放请求分组”到 Ｄ；Ｄ 返回 “释放应答分组”，将虚电路拆除。 虚电路 可以 是 临时 的，也 可以 是永 久的。临 时虚 电路 也称 交换 虚电 路 （ＳＶＣ），它在每次数据传输时建立一次连接，每次数据传输结束便拆除。永久虚 电路（ＰＶＣ）则是将连接持续到其中一台计算机关机时为止，两端用户可以随时 使用该逻辑信道。 数据报服务 数据报服务方式犹如大部队化整为零后分头向某地行进集结，每个分组都 加有目的地地址，并且按“各自为战”的策略，依据网络的运行情形各自选择合适 的路径，向目的地进发。这样，就会呈现以下几个传输特点。 每个分组所走过的路径可能是不相同的，例如对于有 Ａ、Ｂ、Ｃ、Ｄ４个节 点的全连通网络，要从节点 Ａ发送数据到节点Ｄ，则可能有下列传输途径： A——B——D A——C——D A——B——C——D A——C——B——D A——D 下图所示出，一个只有Ａ、Ｂ、Ｃ、Ｄ４个节点的网络在数据报方式下进行传输的示意图。 数据报工作原理示意图 由于传输路径不同，各节点交换处理的时间不等，到达目的地的时间也 不相同，于是就会出现到达目的地后各分组的顺序与发送时的顺序不同，必须重 新排序，再装配成报文。 数据报服务不需要进行连接，因此也说它提供无连接的服务。后面要 介绍的ＩＰ就只提供数据报服务。 数据报服务要求在传送过程中每一个数据分组都要带有目的地址和源 地址。同时在传送到目的地后，有可能出现乱序、重复与丢失现象，因而传输延 时较大，适合于突发性通信，不适合于长报文通信。 电路交换、虚电路与数据报的比较 下面主要从三个过程、三个参数上对交换方式进行比较: 三个过程：连接过程； 传输过程； 释放过程。 电路交换和虚电路都有连接和释放过程。但是，电路交换所连接的是物理 信道，而虚电路连接的是逻辑电路。虚电路服务，就是当两个节点之间要传输数 据时，必须首先进行路由选择，建立一条虚电路连接；虚电路连接建立之后，所有 的分组将沿该路径传送；数据传送结束后，要拆除虚电路连接。换句话说，在虚 电路方式中，所有的分组将沿同一条路径传输，整个的传输过程只是连接时进行一次路由选择。 数据报没有连接过程。各分组传输路径不一定相同，是一种各自为政的方 式，并且每做一次转发都要进行一次路由选择。为了不断地进行路由选择，每个 分组都必须具有目的端的完整地址。对于大型网络，目的地址字段会非常长。 而对虚电路来说，由于在数据传输前路径已经确定，每个分组中不一定再需要完 整的地址字段，而只用简短的虚电路号代之。虚电路号表明经过一个节点时，下 一步将从哪一条逻辑电路上发出去。为此，要为每个节点建立一张节点逻辑电 路管理表。 三个参数：时延、顺序、通用性 时延： 呼叫时延：呼叫连接过程花费的时间； 传输时延：从一个节点传输到下一个节点所用的时间； 节点时延（处理延迟）：节点进行数据交换和处理花费的时间。 顺序：分组到达目的节点的顺序是否与源节点发送时的顺序一致。 通用性：是否适合不同类型、不同速率的计算机或终端之间通信。 电路交换一经连接即可以恒定速率进行数据直通传输，只有传输延迟，没有 节点延迟。分组交换，不管是数据报还是虚电路，都有节点延迟，因为每一个中 间节点都要进行存储、转发等处理，因而不仅有传输延迟，还有可变节点延迟。 其中，由于每个数据报都是独立发送的，因而数据包节点延迟要比虚电路长；另 外，由于各数据报报文分组，经过的路径不同，节点延迟不同，因而分组的到达顺 序可能会与发送时不同，传给主机前还要进行重装。 交换机的功能 现代通信网络按照有无交换功能可以分为两大类：交换网与传输网。 传输 网没有交换功能，仅仅用于数据传输。例如 ＤＤＮ（数字数据网）就没有交换功 能，一般用于向用户提供专线服务。在交换网中，数据交换是由交换机实现的。 因此，交换机是交换网的交通枢纽。简单地说，交换机的作用是接收数据，然后 有选择地将数据转发出去，实现交换网中的数据流控制。进一步说，它的功能包括： 数据转发 物理编址 —— 定义数据帧的物理地址 网络拓扑结构设定 —— 定义设备物理连接所形成的网络拓扑结构 差错验证 —— 错误发生时发出告警 数据帧整序 流量控制 —— 延缓数据的传输能力 交换机实现技术 构成交换机构的最基本元件是交换单元。交换单元的基本实现技术有两种：空间交换和时隙交换。 空间交换 空间交换是指交换单元按照链路的空间分布进行交换，将分组从一条链路 转送到另一条链路上。最典型的空间交换机构是下图所示的交叉点矩阵结 构，也称纵横制交换（ｃｒｏｓｓｂａｒｓｗｉｔｃｈｉｎｇ）机构。它的 Ｎ路输入线和 Ｎ路输出线之 间有Ｎ","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:1","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["system"],"content":"路由节点上的通信 路由节点是联结不同网络的节点。当数据分组传输到路由节点时，路由节 点不是对其进行简单的交换；由于它处于几个网络的边界，因此首先要判断该数 据分组的目的地是否与送来的节点在同一个网络———称为本地：如果是，就本地 提交；如果不是，就转发出去。由于它可能联结多个网络，因此转发时还要考虑从哪一条路径上转发出去较好。在路由节点上承担路由工作的设施是路由器。 如果将每个网络看成一条链路，那么网络与路由节点组成的拓扑结构就是互联 网的拓扑结构。所以说，路由器的配置决定了互联网的结构框架。 路由表与路由算法 路由器的主要工作就是为经过路由器的每个数据帧寻找一条最佳传输路 径，并将该数据帧有效地传送到目的站点。为此，每个路由器中都要维护一个路 由表（ＲｏｕｔｉｎｇＴａｂｌｅ），供路由选择时使用。路由表中的每一个表项均为四元组： 〈目的地，下一站地址，下一站网络接口号，距离〉。以目的地址作为关键字，就可 以从路由表中查出下一站路由器的地址以及它所在的接口。因此，路由表就成 为路由器的中枢，它决定了每个数据包的转发方向。于是路由表的建立和维护 就成为路由器技术的关键。建立和维护的算法称为路由算法。 路由选择是一个极为复杂的问题。因为网络中每一个节点的工作都是置于 网络上其他节点形成的环境中，并且网络上各个节点、各条路径的工作状态往往 是随机的。此外，当网络处于拥塞状态时，路由选择应当有利于拥塞的缓解。下 面介绍几种常用的路由选择算法。从总的方面看，它们分别属于静态路由和动态路由。 静态路由 静态路由用预先编好的程序定义通过网络的路径，其算法通常由网络管理 员人工实现。该管理员负责发现和传播通过网络的路由。下面介绍几种常用的静态路由算法。 洪泛(Flooding)算法 洪泛算法也称扩散式算法。它的基本思想是，每个节点收到分组后，即将其 发往除分组来的节点之外的其他各相邻节点。可以想像，按照这种算法，网络上 的分组会像洪水一样泛滥起来，造成大量的分组冗余，导致网络出现拥塞现象。 因此要限制分组复制的数目。可以有３种方法：一是在每个分组的头部设一个 计数器，用来统计分组到达节点的数量，当计数器超过规定值（如端到端最大段 数）时，将之丢弃；另一种方法是，在每个节点上建立一个分组登记表，不接收重 复的分组；还有一种方法是只选择距目标节点近的部分节点发送分组。 洪泛算法具有很好的健壮性和可靠性，适用于规模较小、可靠性要求较高的 场合。 热土豆(Hot Potato)算法 通常每个节点要为其连接的相邻节点各建一个分组队列。热土豆算法是，节点收到一个分组后，为了尽快脱手，要将其放在最短的队列中，而不管该分组的目标节点是什么。 固定路由算法 固定路由算法也称查表法，它是在网络的每个节点上都存放一个预先计算 好的路由表，给出本节点到所有可能的目标节点的最短路径。下图所示为一 个固定路由算法的例子。这样，一个节点每收到一个分组，通过查表就可找出相应的转发出口。 一个固定理由算法的例子 固定路由算法简单、实现容易，选择的是最短路径，但是不适应网络的拓扑 变化，当被选路由出现故障时，影响正常传送。改进的方法是，为每个节点提供 一个次佳路由，当第一路由失效时，起用次佳路由。 固定的路由是静态路由，它由网络管理员事先设置，一般是在系统安装时根 据网络的配置情况预先设定的，不随未来网络结构的改变而改变。当网络的拓 扑结构发生变化时，要由网络管理员手工修改路由表中的相关路由。并且，静态 路由信息在缺省情况下是私有的，不会传递给其他的路由器。不过，网络管理员 也可以将其设置为共享的。 静态路由适合比较简单的网络环境。在这样的环境中，网络管理员易于清 楚地了解网络的拓扑结构，设置正确的路由信息以及网络拓扑变化时进行路由 信息的调整不需太多的精力。此外，静态路由具有较高的安全保密性。 动态路由 动态（Ｄｙｎａｍｉｃ）路由表是路由器根据网络系统的运行情况自动调整的路由表。通常是通过路由器与相邻路由器交换网络信息来动态地进行路由表维护的。路由器间相互交换网络信息的规范由路由协议定义。根据发现和计算到达目的网络的新路径的方法，可以把动态路由算法分为３种： 距离向量算法 距离向量算法的原理非常简单：它把每经过一个路由器称为一跳。一条路 由上的跳数称为“距离”，然后动态地选择最短距离作为路径。下图所示为一个简单的距离向量路由表示的例子。图中给出了Ｒ２、Ｒ３和Ｒ４三个路由器的距 离向量路由表。 距离向量示例 距离向量算法的主要优点是易于实现和调试，主要用于小型网络中。 链路状态(Link State)算法 链路状态是路由器上的接口（网络地址和网络类型等）描述及其与相邻路由 器关系的总称。这些链路状态的集合形成了一个链路状态数据库（Ｌｉｎｋ－Ｓｔａｔｅ Ｄａｔａｂａｓｅ） 用链路状态算法确定网络拓扑的过程非常直截了当。 在Ｉｎｔｅｒｎｅｔ中广泛使用的最短路径优先ＳＰＦ（ＳｈｏｒｔｅｓｔＰａｔｈＦｉｒｓｔ）就是一种分布 式链路状态协议（ＬｉｎｋＳｔａｔｅＰｒｏｔｏｃｏｌ）。它提供了网络的树状表示。树根是运行 ＳＰＦ的设备，用来计算到达每个目的网络的最短路径列表。下图所示为在路 由器Ｒ１上执行最短路径算法的例子： 在路由器R1上执行最短路径算法 (a) 每个路由器标识与它直接相连的网络上的所有路由设备 (b) ＳＰＦ将实际网络、路由器和链路集抽象成有向图，两个路由器间的一系 列链路由一对有向弧表示，各指向一方，且它们的权值可能不同。然后根据有向 弧上的权值计算最短路径。这些权值用专用名词“度”（Ｍｅｔｒｉｃ）称呼，其值可以是 １～６５５３５中的任何一个无量纲的数。“度”的具体内容可以是费用、距离、时延、 带宽等，它们都由网络管理人员决定。在上图中，Ｒ５－３表示到Ｒ５的路径上的度为３。ＳＰＦ处理服务类型路由的办法是保留多张有向图，一张标注以时延为度，一 张标注以吞吐量为度，一张标注以可靠性为度（虽然３张有向图的计算工作量是 一张图的３倍，但却提供了分别按时延、吞吐量和可靠性优先选择路由的可能） (c) 每 个 路 由 器 通 过 与 网 络 中 的 其 他 路 由 器 交 换 ＬＳＡ（Ｌｉｎｋ Ｓｔａｔｅ Ａｄｖｅｒｔｉｓｅｍｅｎｔ，链路状态公告）通知所有与之直接相连的网络链路以及每个链路 关联的度。 每个路由器使用这些ＬＳＡ建立一个详细记录当前网络拓扑结构的链路状 态数据库（因为每个路由器处理相同的ＬＳＡ集合，所以每个路由器建立的链路 状态数据库是相同的）。只要网络拓扑发生任何变化，该链路状态数据库就能很 快进行更新，并且通过各路由器之间频繁地交换信息，维持链路状态数据库在全 网的一致性，即维持各路由器链路状态数据库的同步。 (d) ＳＰＦ提供了网络的树状表示。树根是运行ＳＰＦ的设备，用来计算到达每 个目的网络的理想路径。虽然每个路由器的链路状态数据库相同，但是由于每 个设备占据了网络中的一个不同位置，ＳＰＦ将为每个路由器产生不同的树。 混合(Hybrid)路由算法 混合算法试图综合距离向量算法和链路状态算法的优点： 使用“度”把优先权分配给一个路径（吸取距离向量算法的优点） 通过事件驱动更新路由而不是定期更新路由（吸取链路状态算法的优点） 路由器的基本结构 路由器是一种设备，其基本结构都包括路由器接口（网卡）、路由器软件、接 收／发送缓冲区等。下面介绍各部分的功能。 网络接口 路由器的网络接口用作将路由器连接到网络。对路由器来说，接口的主要 功能是输入和输出。 从大的方面来说，网络接口可以分为局域网接口和广域网接口两种。局域 网接口主要包括：１０Ｍｂ／ｓ以太网接口、１００Ｍｂ／ｓ以太网接口、１０００Ｍｂ／ｓ以太网 接口、１０／１００Ｍｂ／ｓ自适应以太网接口、快速以太网接口、令牌环、令牌总线等网 络接口。广域网接 口主要包括：通用串 行口（可转换成 Ｘ．２１ＤＴＥ／ＤＣＥ、Ｖ．３５ ＤＴＥ／ＤＣＥ、ＲＳ２３２ＤＴＥ／ＤＣＥ、ＲＳ４４９ＤＴＥ／ＤＣＥ、ＥＩＡ５３０ＤＴＥ）、Ｅ１／Ｔ１，Ｅ３／Ｔ３，ＤＳ３， ＡＴＭ 接口（２Ｍ、２５Ｍ、１５５Ｍ、６３３Ｍ 等）、ＰＯＳ接口（１５５Ｍ、６２２Ｍ）等。 网络接口通常由网卡提供，一块网卡一般支持４、８或１６个端口。 路由器软件 路由器软件一般实现路由协议功能、查表转发功能和管理维护功能等。由 于Ｉｎｔｅｒｎｅｔ规模庞大，路由表一般也非常庞大，可能会有几十万条。路由协议是 路由器软件的核心，主要用作建立和维护路由表。 路由交换单元 路由器还可以与交换开关结合在一起，组成一个路由交换单元。交换开关可以使用多种不同的技术来实现。最简单的开关是使用一条总线来连接所有输入和输出端口，总线开关的缺点是其交换容量受限于总线的容量以及为共享总线仲裁所带来的额外开销。交换开关通过开关提供多条数据通路，具有 Ｎ×Ｎ 个交叉点的交换开关可以被认为具有２Ｎ条总线。如果一个交叉点是闭合的， 则输入总线上的数据在输出总线上可用，否则不可用。交叉点的闭合与打开由调度器来控制，因此，调度器限制了交换开关的速度。在共享存储器的路由器中，进来的包被存储在共享存储器中，所交换的仅是包的指针，这提高了交换容量，但是开关的速度受限于存储器的存取速度。尽管存储器容量每１８个月能够翻一番，但存储器的存取时间每年仅降低５％，这是共享存储器交换开关的一个固有限制。 路由队列 路由器是基于ＩＰ分组交换的设备，在每个接口上进行带宽统计复用。所以路由器必须在每个端口上维护一个或多个队列，以处理多个数据包发向一个端 口而端口接收能力有限的矛盾。队列管理的能力直接影响路由器的性能以及拥 塞管理能力。下面是三种常用的队列管理算法","date":"2022-10-01","objectID":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:2","tags":["system","network","网络","网络原理"],"title":"计算机网络组成原理","uri":"/2022/10/0003-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["kernel"],"content":"Linux 内核工程师 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:1:0","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"岗位分布 互联网 云计算 安全 OS发行商 芯片原厂 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:1:1","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"技能点 内存管理、调度、实时性 进程、同步与并发 存储、文件系统 网络子系统 虚拟化、区块链、容器 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:1:2","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"驱动工程师 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:2:0","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"岗位分布 芯片原厂、方案厂商 嵌入式设备厂商 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:2:1","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"技能点 内核编译、移植 设备模型、驱动框架 USB、PCI、I2C、UART 芯片手册、硬件电路 音视频编解码 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:2:2","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"驱动的衍化 Misc驱动：一个驱动对应一个硬件、兼容性最差 字符驱动、设备驱动：读写方式 总线性驱动 物理总线：USB、I2C、PCI 虚拟总线：platform、device tree 驱动框架：framebuffer、input、DRM 用户态驱动：硬件抽象层HAL ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:2:3","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"驱动与内核的关系 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:3:0","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"驱动主要用来驱动各种硬件 驱动是内核代码的一部分：内核中80%的代码都是驱动 驱动不同的CPU、硬件平台、外设、热插拔设备 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:3:1","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"内核一般用来提供OS的各种服务 Linux内核划分为：BSP、驱动、基础服务、应用服务 基础服务：进程、调度、内存管理、同步机制、中断 应用服务：虚拟化、容器、网络、存储、文件系统 随着应用场景的变化，新的功能会不断添加进来 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:3:2","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"Linux内核版本变化 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:4:0","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"Lnux-0.01 源文件: 88个文件、10239行代码 支持平台：X86 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:4:1","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"Linux-5.4 源文件：48815个文件、超过2500万行代码（.h|.c|.S） 支持平台：X86、ARM、RISC-V、MIPS等20多个平台 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:4:2","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"知识体系 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:5:0","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"Linux开发工具 vim Makefile IDE debug ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:5:1","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"工具链 编译 链接 重定位 安装 运行 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:5:2","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"程序主战场 内存管理 堆 栈 堆栈溢出 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:5:3","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"处理器架构 指令集 CPU 工作原理 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:5:4","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"基于Arch搭建实验平台(ARM A9 vexpress) ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:6:0","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"安装qemu-system sudo pacman -S qemu-system-arm ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:6:1","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"编译内核镜像(5.10) 下载linux-5.10镜像:https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x（注意拉到最下边找内核源码压缩包） 编译 # 1. 创建文件夹 mkdir tftpboot chmod 0777 tftpboot tar xf linux-5.10.99tar.gz cd linux-5.10.99 # vim Makefile +371 ; 将 ARCH 变量赋值为 arm，即：ARCH ?= arm # vim Makefile +372 ; 将 CROCESS_COMPILE=arm-none-linux-gnueabihf- make vexpress_defconfig make zImage -j32 make modules -j32 make dtbs -j32 make LOADADDR=0x60003000 uImage -j32 cp arch/arm/boot/zImage ../tftpboot/ cp arch/arm/boot/uImage ../tftpboot/ cp arch/arm/boot/dts/vexpress-v2p-ca9.dtb ../tftpboot/ zImage 为通用内核文件 modules 内核模块 dtbs 编译的设备树 uImage 为专供 u-boot引导的内核 启动脚本 vim start.sh #!/bin/bash qemu-system-arm \\ -M vexpress-a9 \\ -m 512M \\ -kernel zImage \\ -dtb vexpress-v2p-ca9.dtb \\ -nographic \\ -append \"console=ttyAMA0\" ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:6:2","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"制作根文件系统 使用 busybox 制作根文件系统 编译、安装根文件系统 sudo mkdir -p arm-rootfs # 下载 busybox 1.35.0 并解压 cd busybox-1.35.0 # 修改busybox的Makefile +191 # ARCH ?= arm # CROCESS_COMPILE=arm-none-linux-gnueabihf- # make menuconfig 设置安装路径，输入自己的 rootfs 根路径 `/data/learn-kernel/arm-rootfs` make install 完成完整的根文件系统构建 安装动态链接库 mkdir arm-rootfs/lib cp /usr/arm-none-linux-xxx/lib/*.so* arm-rootfs/lib -d 创建设备节点 cd /data/learn-kernel/arm-rootfs/ mkdir dev cd dev sudo mknod -m 666 tty1 c 4 1 sudo mknod -m 666 tty2 c 4 2 sudo mknod -m 666 tty3 c 4 3 sudo mknod -m 666 tty4 c 4 4 sudo mknod -m 666 console c 5 1 sudo mknod -m 666 null c 1 3 设置初始化进程/etc/rcS cd /data/learn-kernel/arm-rootfs mkdir -p etc/init.d cd etc/init.d touch rcS chmod 777 rcS vim rcS #!/bin/sh PATH=/bin:/sbin:/usr/bin:/usr/sbin export LD_LIBRARY_PATH=/lib:/usr/lib /bin/mount -n -t ramfs ramfs /var /bin/mount -n -t ramfs ramfs /tmp /bin/mount -n -t sysfs none /sys /bin/mount -n -t ramfs none /dev /bin/mkdir /var/tmp /bin/mkdir /var/modules /bin/mkdir /var/run /bin/mkdir /var/log /bin/mkdir -p /dev/pts /bin/mkdir -p /dev/shm /sbin/mdev -s /bin/mount -a echo \"----------------------------------------------\" echo \"******** welcome to vexpress board ***********\" echo \"----------------------------------------------\" 设置文件系统/etc/fstab cd /data/learn-kernel/arm-rootfs/etc touch fstab vim fstab proc /proc proc defaults 0 0 none /dev/pts devpts mode=0622 0 0 mdev /dev ramfs defaults 0 0 sysfs /sys sysfs defaults 0 0 tmpfs /dev/shm tmpfs defaults 0 0 tmpfs /dev tmpfs defaults 0 0 tmpfs /mnt tmpfs defaults 0 0 var /dev tmpfs defaults 0 0 tamfs /dev ramfs defaults 0 0 设置初始化脚本 /etc/inittab ::sysinit:/etc/init.d/rcS ::askfirst:-/bin/sh ::ctrlaltdel:/bin/umount -a -r 设置环境变量 /etc/profile USER=\"root\" LOGNAME=$USER export HOSTNAME=`cat /etc/sysconfig/HOSTNAME` export USER=root export HOME=/root export PS1=\"[$USER@$HOSTNAME\\w]\\#\" PATH=/bin:/usr/bin:/sbin:/usr/sbin LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH export PATHLD_LIBRARY_PATH 增加主机名 /etc/sysconfig/HOSTNAME vexpress 创建剩余文件夹 mkdir mnt proc root sys tmp var 封装构建好的根文件系统并挂载 mkdir temp sudo dd if=/dev/zero of=rootfs.ext3 bs=1M count=32 sudo mkfs.ext3 rootfs.ext3 sudo mount -t ext3 rootfs.ext3 temp/ -o temp sudo cp -r /data/learn-kernel/arm-rootfs/* temp/ sudo umount temp sudo mv rootfs.ext3 tftpboot 修改 start.sh #!/bin/bash qemu-system-arm \\ -M vexpress-a9 \\ -m 512M \\ -kernel zImage \\ -dtb vexpress-v2p-ca9.dtb \\ -nographic \\ -append \"root=/dev/mmcblk0 rw console=ttyAMA0\" \\ -sd rootfs.ext3 至此，环境搭建完成 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:6:3","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"使用u-boot加载内核 完成上述步骤后之所以能直接引导内核是因为 qemu 自带bootloader功能。 u-boot编译和安装 mkdir u-boot # 下载并解压u-boot cd u-boot-2022.07 vim Makefile +272 # 修改: ARCH = arm # 修改: CROSS_COMPILE=arm-none-linux-gnueabihf- make vexpress_ca9x4_defconfig make -j32 将编译好的u-boot 放到tftpboot目录下(与start.sh同级)修改 start.sh # 使用 u-boot qemu-system-arm \\ -M vexpress-a9 \\ -kernel u-boot \\ -nographic \\ -m 512M 可以看到 qemu 可以加载 u-boot 接下来使 u-boot 启动后，让 u-boot 通过 tftp 引导内核。 qemu –加载–\u003e u-boot –加载–\u003e kernel+根文件系统 为此需要实体机中安装: tftp环境 构建网桥，让qemu虚拟机内部可以访问 安装tftp pacman -S tftp-hpa bridge-utils # 设置 tftp 路径 vim /etc/default/tftpd-hpa # 修改内容如下： # TFTP_USERNAME=\"tftp\" # TFTP_DIRECTORY=\"/data/learn-kernel/fs\" # TFTP_ADDRESS=\"0.0.0.0\" # TFTP_OPTIONS=\"-l -c -s\" 文件复制 cd /data/learn-kernel/tftpboot/fs cp /\u003cpath\u003e/uImage . 重启tftpd systemctl restart tftpd.service 修改网卡信息，设置桥接 ifconfig # 查看网卡名 我的是:`wlo1` sudo vim /etc/netplan/0 ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:6:4","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["kernel"],"content":"未完待续… 需要补课 Linux 网络部分… ","date":"2022-09-30","objectID":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/:7:0","tags":["linux","kernel"],"title":"Linux Kernel学习准备","uri":"/2022/09/1000-kernel%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"},{"categories":["c\u0026c++"],"content":"功能 类模板std::future提供了一个访问异步操作结果的机制: 异步操作(通过std::async、std::packaged_task或std::promise创建)可以向该异步操作的创建者提供std::future对象。 然后，异步操作的创建者可以使用各种方法来查询、等待或从std::future中提取值。如果异步操作尚未提供值，这些方法可能会阻塞。 当异步操作准备好向创建者发送结果时，它可以通过修改链接到创建者的std::future的共享状态(例如std::promise::set_value)来实现。 ","date":"2022-09-10","objectID":"/2022/09/0011-stdfuture/:1:0","tags":["c++","std","future"],"title":"std::future","uri":"/2022/09/0011-stdfuture/"},{"categories":["c\u0026c++"],"content":"定义 std::funture定义在头文件 \u003cfuture\u003e 中 ","date":"2022-09-10","objectID":"/2022/09/0011-stdfuture/:2:0","tags":["c++","std","future"],"title":"std::future","uri":"/2022/09/0011-stdfuture/"},{"categories":["c\u0026c++"],"content":"构造 templete\u003cclass T\u003e class future; // since c++11 templete\u003cclass T\u003e class future\u003cT\u0026\u003e; // since c++11 templete\u003c\u003e class future\u003cvoid\u003e; // since c++11 ","date":"2022-09-10","objectID":"/2022/09/0011-stdfuture/:2:1","tags":["c++","std","future"],"title":"std::future","uri":"/2022/09/0011-stdfuture/"},{"categories":["c\u0026c++"],"content":"成员方法 操作 说明 operator= 移动future对象 share 将共享状态从*this转移到shared_future并返回 get 返回结果 valid 检查future是否具有共享状态 wait 等待结果可用 wait_for 等待结果，如果在指定的超时时间内不可用则返回 wait_until 等待结果，如果在到达指定的时间点之前它不可用，则返回 ","date":"2022-09-10","objectID":"/2022/09/0011-stdfuture/:2:2","tags":["c++","std","future"],"title":"std::future","uri":"/2022/09/0011-stdfuture/"},{"categories":["c\u0026c++"],"content":"例子 #include \u003ciostream\u003e #include \u003cfuture\u003e #include \u003cthread\u003e int main () { // future from a packaged_task std::packaged_task\u003cint()\u003e task([]{ return 7; }); // wrap the function std::future\u003cint\u003e f1 = task.get_future(); // get a future std::thread t(std::move(task)); // launch on a thread // future from an async() std::future\u003cint\u003e f2 = std::async(std::launch::async, [] { return 8; }); // future from a promise std::promise\u003cint\u003e p; std::future\u003cint\u003e f3 = p.get_future(); std::thread( [\u0026p]{ p.set_value_at_thread_exit(9); }).detach(); std::cout \u003c\u003c \"Waiting...\" \u003c\u003c std::flush; f1.wait(); f2.wait(); f3.wait(); std::cout \u003c\u003c \"Done!\\nResults are: \" \u003c\u003c f1.get() \u003c\u003c ' ' \u003c\u003c f2.get() \u003c\u003c ' ' \u003c\u003c f3.get() \u003c\u003c '\\n'; t.join(); } 输出结果: Waiting...Done! Results are: 7 8 9 #include \u003cthread\u003e #include \u003ciostream\u003e #include \u003cfuture\u003e int main() { std::promise\u003cint\u003e p; std::future\u003cint\u003e f = p.get_future(); std::thread t([\u0026p]{ try { // code that may throw throw std::runtime_error(\"Example\"); } catch(...) { try { // store anything thrown in the promise p.set_exception(std::current_exception()); } catch(...) {} // set_exception() may throw too } }); try { std::cout \u003c\u003c f.get(); } catch(const std::exception\u0026 e) { std::cout \u003c\u003c \"Exception from the thread: \" \u003c\u003c e.what() \u003c\u003c '\\n'; } t.join(); } 输出结果 Exception from the thread: Example ","date":"2022-09-10","objectID":"/2022/09/0011-stdfuture/:3:0","tags":["c++","std","future"],"title":"std::future","uri":"/2022/09/0011-stdfuture/"},{"categories":["linux"],"content":" 书中内容基于 kernel-2.6.34 版本内核，书籍名《Linux内核设计与实现》 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:0:0","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"Linux内核简介 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:1:0","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"kernel许可协议 linux kernel 基于 (GPL v2)作为限制条款，保障每个人都可以自由获取、修改内核，但是也要让得到你修改内核的人同时也享有你曾经享有的权利——开源全部源代码。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:1:1","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"从内核出发 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:0","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"内核源码树 目录 描述 arch 特定体系结构的源码 block 块设备I/O层 crypto 加密API Documentation 内核源码文档 drivers 设备驱动程序 firmware 使用某些驱动程序而需要的设备固件 fs VFS和各种文件系统 include 内核头文件 init 内核引导和初始化 ipc 进程间通信代码 kernel 像调度程序这样的核心子系统 lib 通用内核函数 mm 内存管理子系统和VM net 网络子系统 samples 示例代码 scripts 编译内核所用的脚本 security Linux安全模块 sound 语音子系统 usr 早期用户空间代码(所谓的initramfs) tools 在linux开发中有用的工具 virt 虚拟化基础结构 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:1","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"配置内核 make config make menuconfig make gconfig make defconfig：基于默认配置来编译内核 make oldconfig：基于已有配置来编译内核 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:2","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"编译内核 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:3","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"安装内核 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:4","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"安装内核模块 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:5","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"生成initramfs ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:6","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"更新引导 编译内核时候会在内核代码根目录下创建一个 System.map 文件，这是一份符号对照表，用来将内核符号和他们的起始地址对应起来，调试时候用来把内存地址翻译成容易理解的函数名和变量名。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:7","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"内核开发的特点 内核编程时候既不能访问C库，也不能访问标准的C头文件(常用C库函数在linux内核中已经被实现) 内核编程时候必须使用 GNU C。 内核编程时缺乏用户空间那样的内存保护机制。 内核编程时候难以执行浮点运算。 内核给每个进程只有一个很小的定长堆栈。 由于内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发。 要考虑可移植性 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:8","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"Kernel头文件使用 基本的头文件位于内核源码顶级目录下的include 目录中。例如：头文件\u003clinux/inotify.h\u003e对应内核源码树中的include/linux/inotify.h 体系结构相关的头文件集位于内核源代码树的 arch/\u003carchiecture\u003e/include/asm目录下。梅核代码通过以 asm/为前缀的方式包含这些头文件，例如：\u003casm/ioctl.h\u003e ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:9","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"kernel 打印日志 内核中无printf()函数，但是它提供了printk()，printk()负责把格式化好的字符串拷贝到内核日志缓冲区上，printf()和printk()之间的一个显著区别在于，printk()允许你通过指定一个标志来设置优先级。syslogd会根据这个优先级标志来决定在什么地方显示这条系统信息。 printk(KERN_ERR \"this is an error\\n\"); ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:10","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"GNU C Linux内核是用C语言编写的，但是内核不完全符合ANSIC标准，只要有可能，内核开发者总是要用到 gcc 提供的多语言扩展部分(gcc是多种GNU编译器的集合，它包含的C编译器既可以编译内核，也可以编译Linux系统上用C语言写的其它代码)。 内核开发者使用的C语言涵盖了ISO C99标准和GNU C扩展特性，最早只有 gcc 提供足够多的扩展特性，才可以用来编译linux内核。 以下是一些内核代码中使用到的C语言扩展部分： 内联函数(inline) C99 和 GNU C 都支持内联函数。函数会在调用位置展开，消除函数调用和返回带来的开销(寄存器存储和恢复)。不过也有缺点，这会导致代码变长，意味着占用更多的内存空间或者占用更多的指令缓存。内核开发者通常把那些对事件要求比较高，本身长度又比较短的函数定义成内联函数。如果一个函数较大，会被反复调用，且没有特别的时间上的限制，我们不赞成把它做成内联函数。 定义一个内联函数时候，需要使用static作为关键字，并且用inline限定它。比如：static inline void wolf(unsigned long tail_size); 内核中，为了类型安全和易读性，有限使用内联函数，而不是复杂的宏。 汇编内联 gcc 编译器支持在C函数中嵌入汇编指令。当然在内核编程的时候，只有知道对应的体系结构才能使用这个功能。 通常使用 asm() 指令嵌入汇编代码，例如： unsigned int low, high; // low 和 high 分别包含64位时间戳的低32位和高32位 asm volatile(\"rdtsc\" : \"=a\" (low), \"=d\" (high)); Linux 内核混合使用了C语言和汇编语言。在偏近体系结构的底层或对执行事件要求严格的地方，一般使用的是汇编语言。而内核其它部分的大部分代码是用C语言编写的。 分支声明 对于条件选择语句，gcc内建了一条指令用于优化，在一个条件经常出现，或者该条件很少出现的时候，编译器可以根据这条指令对条件分支选择进行优化。内核把这条指令封装成了宏，比如likely()和unlikely()，这样使用起来比较方便。 例如下面是一个条件选择语句： if (error) { /* ... */ } 如果想要把这个选择标记成绝少发生的分支： // 我们认为 error 绝大部分事件都会是0 if (unlikely(error)) { /* ... */ } 如果想要把一个分支标记位通常为真的选择： // 我们认为 success 通常都不会为0 if (likely(success)) { /* ... */ } 在使用这两个宏之前，一定要搞清楚这个条件，如果判断不准确，那么性能反而会下降。 没有内存保护机制 如果用户程序访问非法内存，内核会发现这个错误，发送 SIGSEGV 信号，并结束整个进程。 如果内核自己非法访问内存，就会导致 oops，且结果很难控制。 另外内核中的内存并不分页，也就是说，你每用掉一个字节，物理内存就减少一个字节。所以，在你想往内核里加入新功能时候要记住这一点。 不要轻易在内核中使用浮点数 在用户空间的进程内使用浮点操作的时候，内核会完成从整数操作模式到浮点数操作模式转换。在执行浮点指令时候因体系结构不同，内核的选择也不同，但是，内核通常捕获陷阱并着手于整数到浮点方式的转变。 与用户空间进程不同，内核并不能完美地支持浮点操作，因为它本身不能陷入。在内核中使用浮点数时候，除了要人工保存和恢复浮点寄存器，还有其它一些琐碎的事情要做。如果要直截了当的回答，那就是：别这样做，除非一些极少情况，否则别在内核中使用浮点操作。 容积小而固定的栈 用户空间的程序可以从栈上分配大量的空间来存放变量，甚至巨大的结构体或者是包含数以千计的数据项的数组都没问题。之所以可以这么做，是因为用户空间的栈本身比较打，而且还能动态增长。 内核堆栈的准确大小随体系结构而变。在 X86 上，栈的大小在编译时候配置，可以是 4KB 也可以是 8KB。 历史上说，内核栈的大小是两页，32位机器内核栈是 8KB，而 64位机器是 16KB，这个固定不变的，每个处理器都有自己的栈。 同步和并发 内核很容易产生竞争条件。和单线程的用户空间程序不同，内核的许多特性都要求能够并发地访问共享数据，这就要求有同步机制以保证不出现竞争条件，特别是： Linux是抢占多任务操作系统。内核的进程调度程序即兴对进程进行调度和重新调度。内核必须和这些任务同步。 Linux内核支持对称多处理器系统(SMP)。所以，如果没有适当的保护，同时在两个或两个以上的处理器上执行的内核代码很可能会同时访问共享的同一个资源。 中断是异步到来的，完全不顾及当前正在执行的代码。也就是说，如果不加以适当的保护，中断完全有可能在代码访问资源的时候到来，这样，中断处理程序就有可能访问同一资源。 Linux内核可以抢占。所以，如果不加以适当的保护，内核中一段正在执行的代码可能会被另外一段代码抢占，从而有可能导致几段代码同时访问相同的资源。 常用的解决竞争的办法是自旋锁和信号量。 可移植性的重要性 大部分 C 代码应该与体系结构无关，在许多不同体系结构的计算机上都能编译和执行，因此，必须把与体系结构相关的代码从内核代码树的特定目录中适当地分离出来。 诸如保持字节序、64位对齐、不假定字长和页面长度等一系列准则都有助于移植性。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:2:11","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"进程管理 进程定义和相关概念，比如：线程 Linux内核如何管理进程 进程在内核中的生命周期 进程管理是整个操作系统的心脏所在 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:0","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"进程 进程是处于执行期的程序(目标码存放在某种介质上)。但进程并不仅仅局限于一段可执行程序代码(Unix称其为代码段，text section)。通常进程还要包含其它资源， 像打开的文件、挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程，当然还包括用来存放全局变量的数据段等。 实际上，进程就是正在执行的程序代码的实时结果。内核需要有效而又透明的管理所有细节。 执行线程，简称线程，是在进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。 在传统的Unix系统中，一个进程只包含一个线程，但现在的系统中，包含多个线程的多线程程序司空见惯。对Linux而言，并不特别区分线程和进程。 在现代操作系统中，进程提供两种虚拟机制：虚拟处理器和虚拟内存。虽然实际上可能是许多进程正在分享一个处理器，但是虚拟处理器给进程一个假象， 让这些进程觉得自己在独享处理器。 程序不是进程，进程是处于执行期间程序及其相关资源的总称。 Linux通过调用 fork() 复制一个现有进程来创建一个全新的进程。调用 fork() 的进程称为父进程，新产生的进程称为 子进程。在调用结束时候， 在返回点这个相同位置上，父进程恢复执行，子进程开始执行。 fork() 系统调用从内核返回两次：一次回到父进程，另一次回到新产生的子进程。 通常，创建新的进程都是为了立即执行新的、不同的程序，接着调用 exec() 这组函数就可以创建新的地址空间，并把新的程序载入其中。 在现代 Linux 内核中， fork() 实际上是由 clone() 系统调用完成的，后者将在后面讨论。 最终，程序通过 exit() 系统调用退出执行。这个函数会终结进程并将其占用的资源释放掉。父进程可以通过 wait() 系统调用查询子进程是否终结， 这其实使得进程拥有了等待特定进程执行完毕的能力。进程退出执行后被设置为僵死状态，直到它的父进程调用 wait() 或者 waitpid() 为止。 注意：进程的另一个名字是 任务。Linux 内核通常把进程也叫做任务，两个术语是一样的。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:1","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"进程描述符及任务结构 内核把进程的列表存放在叫做任务队列(task list)的双向循环列表中。链表中的每一项都是类型为 task_struct、称为进程描述符的结构，该结构定义在 \u003clinux/sched.h\u003e 文件中。进程描述符中包含一个具体进程的所有信息。 task_struct 相对较大，在 32 位机器上，它大约有 1.7KB。但如果考虑到该结构内包含了内核管理一个进程所需的所有信息，那么它的大小也就算 相当小了。进程描述符中包含的数据能完整描述一个正在执行的程序：此进程打开的文件、进程的地址空间、挂起的信号、进程的状态、还有其它更多信息。 分配进程描述符 Linux 通过 slab 分配器分配 task_struct 结构，这样能达到对象复用和缓存着色的目的。在 2.6 以前的内核中，各个进程的 task_struct 存放在它们内核栈的尾端。这样做是为了让那些像X86那样寄存器较少的硬件体系结构只要通过栈指针就能计算出它的位置，从而避免使用额外的寄存器专门记录。 由于现在用 slab 分配器动态生成 task_struct，所以只需在栈底(对于向下增长的栈来说)或栈顶(对于向上增长的栈来说)创建一个新的结构 struct thread_info 在 x86 上， struct thread_info在文件 \u003casm/thread_info.h\u003e中定义如下： struct thread_info { struct task_struct* task; struct exec_domain* exec_domain; __u32 flags; __u32 status; __u32 cpu; int preempt_count; mm_segment_t addr_limit; struct restart_block restart_block; void* sysenter_return; int uaccess_err; }; 进程描述符和内核栈 每个任务的 thread_info 结构在它的内核栈的末尾端分配。结构中 task 域中存放的是指向该任务实际 task_struct 的指针。 通过预先分配和重复使用 task_struct，可以避免动态分配和释放带来的资源消耗。 寄存器较弱的体系结构不是引入 thread_info 结构的唯一原因。这个新建的结构使在汇编代码中计算其偏移变得非常容易。 进程描述符的存放 内核通过一个唯一的进程标识值(process identification value) 或 PID 来标识每个进程。PID 是一个数，标识为 pid_t 隐含类型(隐含类型标识隐藏了该类型实现，用句柄替代类型实现)， 实际上就是一个int类型。为了与老版本的Unix和Linux兼容，PID 的最大值默认设置为 32768 (short int 短整型的最大值)，当然这个值也可以增加到 400万(受 \u003clinux/threads.h\u003e 中所定义PID最大值的限制)。 内核把每个进程 PID 存放在它们各自的进程描述符中。 PID 最大值表明了系统中允许同时存在的进程的最大数目。32768一般来说够用了，而且这个值越小，进程调度一圈就越快。 在内核中，访问任务/进程通常需要获得指向其 task_struct 的指针。实际上，内核中大部分处理进程的代码都是直接通过 task_struct 进行的。因此，通过 current 宏查找到当前正在运行进程的进程描述符的速度就显得尤为重要。硬件体系结构不同， 该宏的实现也不同，它必须针对专门的硬件体系结构做处理。有的硬件体系结构可以拿出一个专门寄存器来存放指向当前进程 task_struct 的指针，用于加快访问速度。而有些像x86这样的体系结构(其寄存器并不富余)，就只能在内核栈的尾端创建 thread_info 结构，通过计算偏移间接地查找 task_struct 结构。 在 X86 系统上，current 把栈指针的后 13 个有效位屏蔽掉，用来计算出 thread_info 的偏移。该操作是通过 current_thread_info() 函数完成的。汇编代码如下： mov1 $-8192, %eax andl %esp, %eax 这里假定栈的大小为 8KB。当 4KB 的栈启用时候，就要用 4096，而不是 8192. 最后，current再从 thread_info 的 task 域中提取并返回 task_struct 的地址： current_thread_info()-\u003etask; 对比一下这部分在 PowerPC (IBM基于RISC 的现代微处理器)，我呢把可以发现 PPC 当前的 task_struct 是保存在一个寄存器中。 也就是说，在 PPC 上， current 宏只需要把 r2 寄存器中的值返回就行了。与 X86 不一样，PPC 有足够多的寄存器，所以它的实现有这样选择的余地。 而访问进程描述符是一个重要的频繁操作，所以 PPC 的内核开发者觉得完全有必要为此使用一个专门的寄存器。 进程状态 进程描述符中的 state 域描述了进程的当前状态。系统中的每个进程都必然处于五种进程状态中的一种。该域的值也必为以下五种状态标识之一： TASK_RUNNING(运行) —— 进程是可执行的：它或者正在执行，或者在运行队列中等待执行。这是进程在用户空间中执行的唯一可能的状态；这种状态也可以应用到内核空间中正在执行的进程。 TASK_INTERRUPTIBLE(可中断) —— 进程正在睡眠(也就是说它被阻塞)，等待某些条件的达成。一旦这些条件达成，内核就会把 进程状态设置为可运行。处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。 TASK_UNINTERRUPTIBLE(不可中断) —— 除了就算是接收到信号也不会被唤醒或者准备投入运行外，这个状态与可打断状态相同。这个状态通常在进程必须等待时不受干扰或等待事件很快就会发生时候出现。由于处于此状态的任务对信号不做响应，所以较之可中断状态使用的比较少。 __TASK_TRACED —— 被其它进程跟踪的进程，例如通过 ptrace 对调试程序进行跟踪。 __TASK_STOPPED(停止) —— 进程停止执行；进程没有投入运行也不能投入运行。通常这种状态发生在接收到 SIGSTOP、SIGTSTP、SIGTTOU 等信号的时候，此外在调试期间收到任何信号，都会使进程进入这种状态。 进程状态转化 设置当前进程状态 内核经常需要调整某个进程的状态。这时最好使用 set_task_state(task, state) 函数： set_task_state(task, state); // 将任务 task 的状态设置为 state 该函数将指定的进程设置为指定状态。必要的时候下，它会设置内存屏障来强制其它处理器做重新排序(一般只有在 SMP 系统中有此必要)。否则，它等价于： task-\u003estate = state; set_current_state(state) 和 set_task_state(current, state) 含义是等同的。参看 \u003clinux/sched.h\u003e 中相关函数的说明。 进程上下文 可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行。当一个程序执行了系统调用或者触发了某个异常，它就陷入了内核空间。 此时，我们称内核 “代表进程执行”并处于进程上下文中。在此上下文中 current 宏是有效的。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复在用户空间会继续执行。 系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行 —— 对内核的所有访问都必须通过这些接口。 进程家族树 Unix 系统的进程之间存在一个明显的继承关系，在linux系统中也是如此。所有的进程都是 PID 为 1 的 init 进程的后代。 内核在系统启动的最后阶段启动 init 进程。该进程读取系统的初始化脚本(initscript) 并执行其它的相关程序，最终完成系统启动的整个过程。 系统中的每个进程必有一个父进程，每个进程也可以拥有零个或多个子进程。拥有同一个父进程的所有进程都被称为兄弟。进程的关系存放在进程描述符中。每个 task_struct 都包含一个指向其父进程的 task_struct、叫做 parent 的指针，还包含一个称为 children 的子进程链表。所以，对于 当前进程，可以通过下面的代码获得其父进程的进程描述符： struct task_struct* myParent = current-\u003eparent; 同样，也可以按以下方式依次访问子进程： struct task_struct* task; struct list_head* list; list_for_each(list, \u0026current-\u003echildren) { task = list_entry(list, struct task_struct, sibling); /* task 现在指向当前的某个子进程 */ } init 进程的描述符是作为 init_task 静态分配的。下面的代码可以很好的演示所有进程之间的关系： struct task_struct* task; for (task = current; task != \u0026init_task; task = task-\u003e","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:2","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"进程创建 Unix 的进程创建很特别。许多其它的操作系统都提供了产生(spawn)进程的机制，首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。 Unix采用了与众不同的实现方式，它把上述步骤分解到两个单独的函数中去执行： fork() 和 exec()。 首先， fork() 通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于 PID(每个进程唯一)、PPID(父进程的进程号，子进程将其设置为被拷贝进程的PID) 和某些资源和统计量(例如，挂起的信号，它没有必要被继承)。 exec()函数负责读取可执行文件并将其载入地址空间开始运行。把这两个函数组合起来使用的效果跟其它系统使用的单一函数的效果相似。 写时拷贝 传统的 fork() 系统调用直接把所有资源复制给新创建的进程。这种实现过于简单且效率低下，因为它拷贝的数据也许并不共享，更糟糕的是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。 Linux 的 fork() 十一鸥鸟更写时拷贝页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。 只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候才进行。 在页根本不会被写入的情况下(距离来说，fork()后立即调用exec())他们就无需复制了。 fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。在一般情况下，进程创建后会马上运行一个可执行文件，这种优化可以避免拷贝大量根本都不会被使用的数据(地址空间里常常包含数十兆的数据)。 由于Unix强调进程快速执行的能力，所以这个优化是很重要的。 fork() Linux 通过 clone() 系统调用实现 fork()。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。 fork()、vfork()和__clone()库函数都根据各自需要的参数标志去调用 clone()，然后由 clone() 去调用 do_fork()。 do_fork()完成创建中的大部分工作(定义在 kernel/fork.c 中)，该函数调用 copy_process() 函数，然后让进程开始运行。 copy_process()完成以下主要工作： 调用 dup_task_struct() 为新进程创建一个内核栈、thread_info 结构和 task_struct，这些值与当前进程的值相同。此时，子进程和父进程的描述符是完全相同的。 检查并确保新创建这个子进程后，当前用户拥有的进程数目没有超出给它分配的资源的限制。 子进程着手使自己与父进程区别开来。进程描述符内的许多成员都要被清零或设为初始值。那些不是继承而来的进程描述符成员，主要是统计信息。task_struct中的大多数数据都依然未被修改。 子进程的状态被设置为 TASK_UNINTERRUPTIBLE，以保证它不会投入运行。 copy_process()调用 copy_flags() 以更新 task_struct 的 flags 成员。表明进程是否拥有超级用户权限的 PF_SUPERPRIV标志被清零。表明进程还没有调用 exec() 函数的 PF_FORKNOEXEC 标志被设置。 调用 alloc_pid() 为新进程分配一个有效的 PID。 根据传递给 clone() 的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。 在一般情况下，这些资源会被给定进程的所有线程共享；否则，这些资源对每个进程是不同的，因此被拷贝在这里。 最后，copy_process()做收尾工作并返回一个指向子进程的指针。 再回到 do_fork()函数，如果 copy_process() 函数返回成功，新创建的子进程被唤醒并让其投入运行。内核有意选择子进程首先执行。因为一般子进程都会马上调用 exec()函数，这样可以避免写时拷贝的额外开销，如果父进程首先 执行的话，有可能会开始向地址空间写入。 vfork() 除了不拷贝父进程的页表项外，vfork()系统调用和fork()的功能相同。子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，直到子进程退出或执行 exec()。子进程不能向地址空间写入。在过去的 3BSD 时期，这个优化是有意义的，那时并未使用写时拷贝页来实现 fork()。现在由于在执行fork()十引入了写时拷贝页而且明确了子进程先执行，vfork()的好处就仅限于不拷贝父进程的页表项了。 如果 Linux 将来fork()有了写时拷贝页表项，那么vfork()就彻底没用了。另外由于vfork()语义非常微妙(试想，如果exec()调用失败会发生什么)， 所以理想情况下，系统最后不要调用 vfork()，内核也不用实现它。完全可以把 vfork() 实现成一个普普通通的 fork() —— 实际上，Linux2.2以前就是这么做的。 vfork()系统调用的实现是通过向 clone() 系统调用传递一个特殊标志来进行的。 在调用 copy_process() 时候，task_struct 的 vfork_done成员被设置为 NULL。 在执行 do_fork() 时，如果给定特别标志，则 vfork_done会指向一个特定地址。 子进程先开始执行后，父进程不是马上恢复执行，而是一直等待，直到子进程通过vfork_done指针向他发送信号。 在调用 mm_release() 时候，该函数用于进程退出内存地址空间，并且检查 vfork_done 是否为空，如果不为空，则会向父进程发送信号。 回到 do_fork()，父进程醒来并返回。 如果一切执行顺利，子进程在新的地址空间里运行而父进程也恢复了在原地址空间的运行。这样，开销确实降低了，不过它的实现并不是优良的。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:3","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"线程在Linux中的实现 线程机制是现代编程技术中非常常用的一种抽象概念。该机制提供了在同一个程序内共享内存地址空间运行的一组线程。这些线程还可以共享打开的文件和其它资源线程机制支持并发程序设计技术，在多处理器系统上，它也能保证真正的并行处理。 Linux 实现线程的机制非常独特。从内核角度来说，它并没有线程这个概念。Linux把所有的线程都当作进程来实现。内核并没有准备特别的调度算法或者定义特别的数据结构来表征线程。 相反，线程仅仅被视为一个与其它进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的 task_struct，素以在内核中，它看起来就像是一个普通的进程 (只是线程和其它一些进程共享某些资源，如地址空间)。 上述线程机制的实现与Windows 或是 Sun Solaris 等操作系统的实现差异非常大。这些系统都在内核中提供了专门支持线程的机制(这写系统常常把线程称作轻量级进程)。 “轻量级进程”这种叫法本身就概括了Linux在此处与其它系统的差异。 在其它系统中，相较于重量级的进程，线程被抽象成一种耗费较少资源，运行迅速的执行单元。而对于linux来说，它只是一种进程间共享资源的手段(Linux进程本身就够轻量级的来)。 举个例子来说，假如我们有一个包含四个线程的进程，在提供专门线程支持的系统中，通常会有一个包含指向四个不同线程的指针的进程描述符。 该描述符负责描述像地址空间、打开的文件这样的共享资源。线程本身再去描述它独占的资源。相反，Linux仅仅创建四个进程并分配四个普通的 task_struct结构。建立这四个进程时候指定他们共享某些资源，这是相当高雅的做法。 创建线程 线程的创建和普通进程的创建类似，只不过在调用 clone() 的时候需要传递一些参数标志来指明需要共享的资源： clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND, 0); 上面的代码产生的结果和调用fork()差不多，只是父子俩共享地址空间、文件系统资源、文件描述符和信号处理程序。换个说法就是，新建的进程和它的父进程就是流行的所谓线程。 对比以下，一个普通的 fork() 的实现是： clone(CLONE_VFORK|CLONE_VM|SIGCHLE, 0); 传递给 clone() 的参数标志决定了新创建进程的行为方式和父子进程之间共享的资源种类。 表3-1列举了这些clone()用到的参数标志以及他们的作用，这些是在\u003clinux/sched.h\u003e中定义的。 参数标志 含义 CLONE_FILES 父子进程共享打开的文件 CLONE_FS 父子进程共享文件系统信息 CLONE_IDLETASK 将PID设置为0(只供idle进程使用) CLONE_NEWNS 为子进程创建新的命名空间 CLONE_PARENT 指定子进程与父进程拥有同一个父进程 CLONE_PTRACE 继续调试子进程 CLONE_SETTID 将 TID 回写至用户空间 CLONE_SETTLS 为子进程创建新的 TLS(thread-local storage) CLONE_SIGHAND 为父进程共享信号处理函数及被阻断的信号 CLONE_SYSVSEM 父子进程共享 System V SEM_UNDO 语义 CLONE_THREAD 父子进程放入相同的线程组 CLONE_VFORK 调用vfork()，所以父进程准备睡眠等待子进程将其唤醒 CLONE_UNTRACED 防止跟踪进程在子进程上强制执行 CLONE_PTRACE CLONE_STOP 以TASK_STOPPED状态开始进程 CLONE_CHILD_CLEARTID 清除子进程的TID CLONE_CHILD_SETTID 设置子进程的TID CLONE_PARENT_SETTID 设置父进程的TID CLONE_VM 父子进程共享地址空间 内核线程 内核经常需要在后台执行一些操作。这种任务可以通过内核线程完成 —— 独立运行在内核空间的标准进程。 内核线程与普通进程间的区别在于内核线程没有独立的地址空间(实际上指向地址空间的mm指针被设置为NULL)。 它们只在内核空间运行，从来不切换到用户空间去，内核进程和普通进程一样，可以被调度，也可以被抢占。 Linux确实会把一些任务交给内核线程去做，像flush和ksofirqd这些任务就是明显的例子。 内核线程是在系统启动时候由其它内核线程创建。内核是通过从kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的。在 \u003clinux/kthread.h\u003e中声明有接口，于是，从现有内核线程中创建一个新的内核线程的方法如下： struct task_struct* kthread_create (int (*threadfn) (void* data), void* data, const char namefmt[], ...) 新的任务是由 kthread 内核进程通过 clone()系统调用而创建的。新的进程将运行 threadfn 函数，给其传递的参数是data。 进程会被命名为 namefmt, namefmt接受可变参数列表类似于 printf() 的格式化参数。新创建的进程处于不可运行状态，如果不通过调用 wake_up_process()明确地唤醒它，它不会主动运行。创建一个进程并让它运行起来，可以通过调用 kthread_run()来达到： struct task_struct* kthread_run (int (*threadfn) (void* data), void* data, const char namefmt[], ...) 这个例程是以宏实现的，只是简单地调用了 kthread_create() 和 wake_up_process()： #define kthread_run(threadfn, data, namefmt, ...) \\ ({ \\ struct task_struct* k; \\ k = kthread_create(threadfn,data,namefmt,## __VA_ARGS__); \\ if (!IS_ERR(k)) \\ wake_up_process(k); \\ k; \\ }) 内核线程启动后就一直运行直到调用 do_exit() 退出，或者内核的其它部分调用 kthread_stop()退出，传递给 kthread_stop()的参数为kthread_create()函数返回的 task_struct结构的地址： int kthread_stop(struct task_struct* k); ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:4","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"进程终结 进程终结时候，内核必须释放它所占有的资源，并把这一消息告知父进程。 一般来说，进程的析构是自身引起的。它发生在进程调用exit()系统调用时候，既可能显示地调用这个系统调用，也可能显示地从某个程序的主函数返回 (其实C语言编译器会在main()函数的返回点后面放置调用exit()的代码)。当进程接受到它既不能处理也不能忽略的信号或异常时候，它还可能主动被终结。不管进程是怎么终结的，该任务 大部分要靠do_exit()(定义于kernel/exit.c)来完成，它要做下面这些繁琐工作： 将 task_struct 中的标志成员设置为 PF_EXITING 调用 del_timer_sync() 删除任一内核定时器。根据返回的结果，它确保没有定时器在排队，也没有定时器处理程序在运行。 如果 BSD 的进程记账功能是开启的，do_exit() 调用 acct_update_integrals() 来输出记账信息。 然后调用 exit_mm()函数释放进程占用的 mm_struct，如果没有别的进程使用它们(也就是说，这些地址空间没有被共享)，就彻底释放它们。 接下来调用 sem_exit() 函数。如果进程排队等候 IPC 信号，它则离开队列。 调用 exit_files() 和 exit_fs()，以分别递减文件描述符、文件系统数据的引用计数。如果某个引用计数值为0，那么就代表没有进程在使用相应的资源，此时可以释放。 接着把存放在 task_struct 的 exit_code 成员中的任务退出代码置为由 exit() 提供的退出代码，或者去完成任何其它由内核机制规定的退出动作。退出代码存放在这里供父进程随时检索。 调用 exit_notify() 向父进程发送信号，给子进程重新找养父，养父为线程组中的其它线程或者为 init 进程，并把进程状态(存放在task_struct结构的 exit_state中)设成 EXIT_ZOMBIE。 do_exit()调用 schedule() 切换到新的进程。因为处于 EXIT_ZOMBIE 状态的进程不会再被调度，所以这时进程所执行的最后一段代码。do_exit() 永不返回。 至此，与进程相关联的所有资源都被释放掉了(假设该进程是这些资源的唯一使用者)。进程不可运行(实际上也没有地址空间让他运行)并处于EXIT_ZOMBIE 退出状态。它占用的所有内存就是内核栈、thread_info结构和task_struct结构。此时进程存在的唯一目的就是向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关的信息后，由进程所持有的剩余内存被释放，归还给系统使用。 删除进程描述符 在调用了 do_exit() 之后，尽管线程已经僵死不能再运行了，但是系统还是保留了它的进程描述符。前面说过，这样做可以让系统有办法在子进程终结后仍然获得它的信息。因此，进程终结时候所需的清理工作和进程描述符的删除被分开执行。 在父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的task_struct结构才被释放。 wait()这一族函数都是通过唯一(但是很复杂)的一个系统调用 wait4()来实现的。它的标准动作是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的PID。 此外，调用该函数时候提供的指针会包含子函数退出时候的退出码。 当最终需要释放进程描述符时候，release_task()会被调用，用以完成以下工作： 它调用 __exit_signal()，该函数调用__unhash_process()，后者又调用 detach_pid() 从 pidhash 上删除该进程，同时也要从任务列表中删除该进程。 _exit_signal()释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录。 如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么 release_task() 就要通知僵死的领头进程的父进程。 release_task() 调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放task_struct所占的 slab 高速缓存。 至此，进程描述符和所有进程独享的资源全部被释放掉。 孤儿进程造成的进退维谷 如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些成为孤儿的进程就会在退出时候永远处于僵死状态，白白地耗费内存。 前面的部分已经有所暗示，对于这个问题，解决方法是给子进程在当前线程组内找一个线程作为父亲，如果不行，就让 init 做它们的父进程。在 do_exit() 中会调用 exit_notify()，该函数会调用 forget_original_parent()，而后者会调用 find_new_reaper() 来执行寻父过程： static struct task_struct* find_new_reaper (struct task_struct* father) { struct pid_namespace* pid_ns = task_active_pid_ns (father); struct task_struct* thread; thread = father; while_each_thread(father, thread) { if (thread-\u003eflags \u0026 PF_EXITING) continue; if (unlikely(pid_ns-\u003echild_reaper == father)) pid_ns-\u003echild_reaper = thread; return thread; } if (unlikely (pid_ns-\u003echild_reaper == father)) { write_unlock_irq (\u0026tasklist_lock); if (unlikely(pid_ns == \u0026init_pid_ns)) panic (\"Attempted to kill init!\"); zap_pid_ns_processes (pid_ns); write_lock_irq(\u0026tasklist_lock); pid_ns-\u003echild_reaper = init_pid_ns.child_reaper; } return pid_ns-\u003echild_reaper; } 这段代码试图找到进程所在线程组内的其它进程。如果线程组内没有其它进程，他就找到并返回的是 init 进程。现在，给子进程找到合适的养父进程来， 只需遍历所有子进程并为它们设置新的父进程： reaper = find_new_reaper(father); list_for_each_entry_safe(p, n, \u0026father-\u003echildren, sibling) { p-\u003ereal_parent = reaper; if (p-\u003eparent == father) { BUG_ON(p-\u003eptrace); p-\u003eparent = p-\u003ereal_parent; } reparent_thread(p, father); } 然后调用 ptrace_exit_finish() 同样进行新的寻父过程，不过这次是给 ptraced 的子进程寻找父亲。 void exit_ptrace(struct task_struct* tracer) { struct task_struct *p, *n; LIST_HEAD(ptrace_dead); write_lock_irq(\u0026tasklist_lock); list_for_each_entry_safe(p, n, \u0026tracer-\u003eptraced, ptrace_entry) { if (__ptrace_detach(tracer, p)) { list_add (\u0026p-\u003eptrace_entry, \u0026ptrace_dead); } } write_unlock_irq(\u0026tasklist_lock); BUG_ON(!list_empty(\u0026tracer-\u003eptraced)); list_for_each_entry_safe(p, n, \u0026ptrace_dead, ptrace_entry) { list_del_init(\u0026p-\u003eptrace_entry); release_task(p); } } 这段代码遍历了两个链表：子进程链表和ptrace子进程链表，给每个子进程设置新的父进程。这两个链表同时存在的原因很有意思，它也是2.6内核的一个新特性。 当一个进程被跟踪时，它的临时父亲设定为调试进程。此时如果它的父进程退出了，系统会为它和它的所有兄弟重新找一个父进程。在以前的内核中，这就需要遍历系统所有 的进程来找这些子进程。现在的解决方法是在一个单独的被ptrace跟踪的子进程链表中搜索相关的兄弟进程 —— 用两个相对较小的链表减轻了遍历带来的消耗。 一旦系统为进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了。init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:5","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"小结 本章主要考察了系统中的核心概念 —— 进程。讨论了进程的一般特性，它为何如此重要，以及进程和线程之间的关系 讨论了Linux如何存放和表示进程(task_struct和thread_info)，如何创建进程(通过 fork()，实际上最终是 clone())，如何把新的执行镜像装入到地址空间 (通过 exec() 系统调用族)，如何表示进程的层次关系，父进程又是如何收集其后代的信息(通过 wait() 系统调用族)，以及进程最终如何消亡 (强制或者自愿地调用exit())。进程是一个非常基础、非常关键的抽象概念，位于每一种现代操作系统的核心位置，也是我们拥有操作系统(用来运行程序)的最终原因。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:3:6","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"进程调度 上边讲到的进程，他在操作系统看来是程序的运行态表现形式。接下来讨论进程调度，它是确保进程能有效工作的一个内核子系统。 调度程序负责决定将哪个进程投入运行，何时运行以及运行多长时间。进程调度程序(常常简称调度程序)可看做在可运行态进程之间分配有限的处理器事件资源 的内核子系统。调度程序是像Linux这样的多任务操作系统的基础。只有通过调度程序的合理调度，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。 调度程序没有太复杂的原理。最大限度地利用处理器时间的原则是，只要有可以执行的进程，那么就总会有进程正在执行。但是只要系统中可运行的进程数目比处理器 的个数多，就注定某一个给定时刻会有一些进程不能执行。这些进程在等待运行。在一组处于可运行状态的进程中选择一个来执行，是调度程序所需完成的基本工作。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:0","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"多任务 多任务操作系统就是能同时并发地交互执行多个进程的操作系统，但是这些进程并不都处于运行状态。 多任务系统可以分为两类：非抢占式多任务 和 抢占式多任务。像所有 Unix 的变体和许多其它现代操作系统一样，Linux提供了抢占式的多任务模式。 在此模式下，由调度程序来决定什么时候停止一个进程的运行，以便其它进程能够得到执行机会。这个强制的挂起动作就叫做抢占。进程在被抢占之前能够运行的时间 是预先设置好的，而且有一个专门的名字，叫做进程的时间片。时间片实际上就是分配给每个可运行进程的处理器时间段。有效管理时间片能使调度程序从系统全局的 角度作出调度决定，这样做还可以避免个别进程独占系统资源。当今众多现代操作系统对程序运行都采用了动态时间片计算的方式，并且引入了可配置的计算策略。不过我们 将看到，Linux独一无二的“公平”调度程序本身并没有采取时间片来达到公平调度。 相反，在非抢占式多任务模式下，除非进程自己主动停止运行，否则它会一直执行。进程主动挂起自己的操作称为让步。理想情况下，进程通常作出让步，以便让每个可运行进程享有足够的处理器时间。但这种机制有很多缺陷： 调度程序无法对每个进程该执行多长时间作出统一规定，所以进程独占的处理器时间可能超出用户的预料；更糟的是，一个决不做出让步的悬挂进程就能使系统崩溃。 Unix从一开始采用的就是抢先式的多任务，Mac OS 9(以及其前身)、Windows3.1(以及其前身)这些不是。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:1","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"Linux的进程调度 从 1991 年 Linux 的第一版到后来的 2.4 内核系列，Linux 的调度程序都相当简陋，设计近乎原始。当然它容易理解，但是它在众多可运行进程或者多处理器的环境下都 难以胜任。 正因为如此，在 Linux2.5 开发系列的内核中，调度程序做了大手术。开始采用一种叫做 O(1) 调度程序的新调度程序 —— 它是因为其算法的行为而得名。它解决了先前版本 Linux 调度程序的许多不足，引入了许多强大的新特性和性能特征。这里主要要感谢静态时间片算法和针对每一处理器的运行队列，它们帮助我们摆脱了先前调度程序设计上的限制。 O(1)调度器虽然在拥有数以十计(不是数以百计)的多处理器环境下尚能表现出近乎完美的性能和可扩展性，但是时间证明该调度算法对于调度那些响应时间敏感的程序却 有一些先天不足。这些程序我们称其为交互进程 —— 它无疑包括了所有需要用户交互的程序。正因为如此，O(1)调度程序虽然对于大服务器的工作负载很理想，但是在有 很多交互程序要运行的桌面系统上则表现不佳，因为其缺少交互进程。自 2.6 内核系统开发初期，开发人员为了提高对交互程序的调度性能引入了新的进程调度算法。 其中最为著名的是**“反转楼梯最后期限调度算法(RSDL)”**，该算法吸取了队列理论，将公平调度的概念引入了Linux调度程序。并且最终在 2.6.23 内核版本中替代了 O(1) 调度算法，它此刻被称为 “完全公平调度算法”，简称 CFS。 接下来讲解调度程序设计的基础和完全公平调度程序如何运用、如何设计、如何实现以及与它相关的系统调用。我们当然也会讲解O(1)调度程序，因为它毕竟是 经典Unix调度程序模型的实现方式。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:2","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"策略 策略决定调度程序在何时让什么进程运行。调度器的策略往往就决定系统的整体印象，并且，还要负责优化使用处理器时间。无论从哪个方面来看，它都是至关重要的。 I/O消耗型和处理器消耗型的进程 进程可被分为I/O消耗型和处理器消耗型。前者指进程的大部分时间用来提交 I/O 请求或是等待 I/O 请求。因此，这样的进程经常处于可运行状态，但通常都是运行短短的一会儿，因为 它在等待更多的I/O请求时候最后总会阻塞(这里所说的I/O是指任何类型的可阻塞资源，比如键盘输入，或者是网络I/O)。举例来说，多数用户图形界面程序(GUI) 都属于I/O密集型，即便它们从不读取或者写入磁盘，它们也会在多数时间里都在等待来自鼠标或者键盘的用户交互操作。 相反，处理器耗费型进程把时间大多用在执行代码上。除非被抢占，否则它们通常都一直不停的运行，因为它们没有太多的I/O需求。但是，因为它们不属于 I/O驱动型，所以从系统响应速度考虑，调度器不应该经常让它们运行。对于这类处理器消耗型的进程，调度策略往往是尽量降低它们的调度频率，而延长其运行时间。处理器消耗型进程的 极端例子就是无线循环地执行。更具代表性的例子就是那些执行大量数学计算的程序，如 sshkeygen 或者 MATLAB。 当然，这种划分方法并非是绝对的。进程可以同时展示这两种行为：比如，X Window 服务器既是 I/O 消耗型，也是处理器消耗型。 还有些进程可以是I/O消耗型，但不属于处理器消耗型活动范围。其典型例子就是字处理器，其通常以等待键盘输入。但在任一时刻可能又粘住处理器疯狂地进行 拼写检查或者宏计算。 调度撤略通常需要在两个矛盾的目标中寻找平衡：进程响应迅速(响应时间短)和最大系统利用率(高吞吐量)。为了满足上述需求，调度程序通常采用一套非常复杂的 算法来决定最值得运行的进程投入运行，但是它往往并不保证低优先级进程会被公平对待。Unix系统的调度程序更倾向于 I/O 消耗型程序，以便提供更好的程序 响应速度。Linux为了保证交互式应用和桌面系统的性能，所以对进程的响应做了优化(缩短响应时间)，更倾向于有限调度I/O消耗型进程。虽然如此，但在下面你会看到， 调度程序也并未忽略处理器消耗型的进程。 进程优先级 调度算法中最基本的一类就是基于优先级的调度。这时一种根据进程的价值和其对处理器时间的需求来对进程分级的想法，通常做法是(其并未被Linux系统完全采用) 优先级高的进程先运行，低的后运行，相同优先级的进程按轮询的方式进行调度(一个接一个，重复进行)。在某些系统中，优先级高的进程使用的时间片也较长。调度程序总是选择时间片未用尽而且优先级最高的进程运行。用户和系统都可以通过设置进程的优先级来影响系统的调度。 Linux采用了两种不同的优先级范围。第一种是 nice值，它的范围是从 -20 到 +19，默认值为0；越大的nice值意味着更低的优先级(nice意味着你对其它系统中的进程更\"优待\"\")。 相比高 nice 值的进程，低 nice 值的进程可以获得更多的处理器时间。nice 值是所有 Unix 系统中的标准化概念——但不同的 Unix 系统由于调度算法不同，因此 nice 值的运用方式有所差异。比如一些基于Unix的操作系统， 如 Mac OS X，进程的 nice 值代表分配给进程的时间片的绝对值；而 Linux 系统中，nice 值则代表了时间片的比例。 第二种范围是实时优先级，其值的可配置的，默认情况下它的变化范围是 0 到 99(包括 0 和 99).与 nice 值意义相反，越高的实时优先级数值意味着进程优先级越高。 任何实时进程的优先级都高于普通进程，也就是说实时优先级和nice优先级处于互补相交的两个范畴。Linux 实时优先级的实现参考了 Unix 相关标准 —— 特别是 POSIX.1b。 大部分现代的 Unix 操作系统也都提供类似的机制。你可以通过命令： ps -eo state,uid,pid,ppid,rtprio,time,comm 查看你系统中的进程列表，以及它们对应的实时优先级(位于RTPRIO列下)，其中如果有进程对应列显示 “-”，则说明它不是实时进程。 时间片 时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。调度策略必须规定一个默认的时间偏，但这并不是件简单的事情。时间片过长会导致系统对交互的 响应表现欠佳，让人觉得系统无法并发执行应用程序；时间片太短会明显增大进程切换带来的处理器耗时，因为肯定会有相当一部分系统时间用在进程切换上，而这些进程能够用来运行的时间片却很短。此外，I/O 消耗型和处理器消耗型的进程之间的矛盾在这里也再次显露出来；I/O消耗型不需要长的时间片，而处理器消耗型的进程则希望越长越好(比如这样可以让它们的高速缓存命中率更高)。 从上面的争论中可以看出，任何长时间片都将导致系统交互表现欠佳。很多操作系统中都特别重视这一点，所以默认的时间片很短，如 10ms。但是 Linux 的 CFS 调度器并没有直接分配时间片到进程，它是将处理器的使用比例划分给了进程。这样一来，进程所获的的处理器时间其实是和系统负载密切相关的。 这个比例进一步还会受进程 nice 值的影响， nice 值作为权重将调整进程所使用的处理器时间使用比。具有更高 nice 值(更低优先权) 的进程将被赋予低权重，从而 丧失了一小部分的处理器使用比；而具有更小nice值(更高优先级)的进程则会被赋予高权重，从而抢得更多的处理器使用比。 像前面所说的，Linux系统是抢占式的。当一个进程进入可运行态，他就被准许投入运行。在多数操作系统中，是否要将一个进程立刻投入运行(也就是抢占当前进程)， 是完全由进程优先级和是否有时间片决定的。而在 Linux 中使用新的 CFS 调度器，其抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，则新 进程立刻投入运行，抢占当前进程。肉则，将推迟其运行。 调度策略的活动 想象下面这样一个系统，它拥有两个可运行的进程：一个文字编辑程序和一个视频编码程序。文字编辑程序很明显是 I/O 消耗型的，因为大多数时间都在等待用户的键盘输入 (无论用户的输入速度有多快，都不可能赶上处理的速度)。用户总是希望按下键系统能马上响应。 相反，视频编码程序是处理器消耗型的。除了最开始从磁盘上读出原始数据流和最后把处理好的视频输出外，程序所有的时间都用来对原始数据进行视频编码，处理器 很轻易地被 100% 使用。它对什么时间开始运行并没有太严格的要求 —— 用户几乎分辨不出也并不关心它到底是立刻就运行还是半秒钟以后才开始的。当然，它完成的越早越好，至于所花时间并不是我们关注的主要问题。 在这样的场景中，理想情况是调度器应该给予文本编辑器程序相比视频编码程序更多的处理器时间，因为它属于交互式应用。对于文本编辑器而言，我们有两个目标。第一是希望系统给它更多的处理器时间，这并非因为它需要更多的处理器时间 (其实它并不需要)，是因为我们我们希望在它需要时总能得到处理器；第二是我们希望文本编辑器能在其被唤醒时候(也就是当用户打字时候)抢占视频解码程序。 这样才能确保文本编辑器具有很好的交互性能，以便能响应用户输入。 在多数操作系统中，上述目标达成是要依赖系统分配给文本编辑器比视频解码程序更高的优先级和更多的时间片，先进的操作系统可以自动发现文本编辑器是交互型程序， 从而自动地完成上述分配动作。 Linux操作系统同样需要追求上述目标，但是它采用不同的方法。它不再通过给文本编辑器分配给定的优先级和时间片，而是分配一个给定的处理器使用比。加入文本编辑器和视频编码程序是仅有的两个运行程序，并且又具有同样的 nice 值， 那么处理器的使用比将都是 50% —— 它们平分了处理器时间。但是因为文本编辑器将更多的时间用于等待用户输入，因此它肯定不会用到处理器的 50%。同时， 视频解码程序无疑将能有机会用到超过 50% 的处理器时间，以便它能更快速的完成解码任务。 这里关键的问题是，当文本编辑器程序被唤醒的时候将会发生什么。我们首先目标是确保其能在用户输入发生时候立刻运行。在上述场景中，一旦文本编辑器被唤醒， CFS发现文本编辑器比视频解码器运行的时间短的多。这种情况下，为了兑现让所有进程都能公平分享处理器的承诺，它会立即抢占视频解码程序，让文本编辑器 投入运行。文本编辑器运行后，立即处理了用户的击键输入后，又一次进入睡眠等待用户下一次输入。因为文本编辑器并没消费掉承诺给它的50%处理器使用比，因此情况依旧，CFS总会毫不犹豫的让文本编辑器在需要时候被投入运行，而让视频处理程序 只能在剩余下的时刻运行。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:3","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"Linux 调度算法 在前面内容中，我们抽象地讨论了进程调度原理，只是偶尔提及 Linux 如何把给定的理论应用到实际中。在已有的调度原理基础上，我们进一步探讨具有Linux特色的进程调度程序。 调度器类 Linux 调度器是以模块方式提供的，这样做的目的是运行不同类型的进程可以又针对性的选择调度算法。 这种模块化结构被称为调度器类，它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。每个调度器都有一个优先级，基础的调度器代码定义在 kernel/sched.c文件中，它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，去选择下面要执行的那一个程序。 完全公平调度(CFS)是一个针对普通进程的调度类，在 Linux 中称为 SCHED_NORMAL (在 POSIX 中称为 SCHED_OTHER)，CFS 算法实现定义在文件 kernel/sched_fair.c 中。本节下面的内容将重点介绍 CFS 算法。 Unix系统中的进程调度 在讨论公平调度算法前，我们必须首先认识一下传统 Unix 系统的调度过程。正如前面所述，现代进程调度器有两个通用的概念：进程优先级和时间片。时间片是指进程运行多少时间， 进程一旦启动就会有一个默认时间片。具有更高优先级的进程将运行的更频繁，而且(在多数系统上)也会被赋予更多的时间片。在 Unix 系统上，优先级以 nice 值形式 输出给用户空间。这点听起来简单，但是在现实中，却会导致许多反常的问题，我们下面具体讨论。 第一个问题，若要将 nice 值映射到时间片，就必然需要将 nice 单位值对应到处理器的绝对时间。但这样做将导致进程切换无法最优化进行。举例说明， 假定我们将默认 nice 值(0) 分配给一个进程 —— 对应的是一个 100ms 的时间片：同时再分配一个最高 nice 值(+20，最低的优先级)给另一个进程 —— 对应的时间片是 5ms。我们接着假定上述两个进程都处于可运行状态。那么默认优先级的进程将获得 20/21 (105ms中的100ms) 的处理器时间，而低优先级的进程会获得 1/21(105ms中的5ms)的处理器时间。我们可以选择任意数值用于本例子中。现在，我们看看如果运行两个同等低优先级的进程的情况将如何。我们是希望它们能各自获得 一半的处理器时间，事实上也确实如此。但是另一个进程每次只能获得 5ms 的处理器时间(10ms中各占一般)。也就是说，相比刚才例子中 105ms 内进行一次上下文切换，现在则需要在 10ms 内继续进行两次上下文切换。类推，如果是两个具有普通优先级的进程，它们同样会每个获得 50% 的处理器时间，但是是在 100ms 内各获得一般。显然，我们看到这些时间片的分配方式并不很理想：它们是给定 nice 值到时间片映射与进程运行优先级混合的共同作用结果。事实上，给定高 nice 值(低优先级)的进程往往是后台进程，且多是计算密集型；而普通优先级的进程则更多的是前台用户任务。所以这种时间片分配方式显然是和初衷背道而驰的。 第二个问题 设计相对 nice 值，同时和前面的 nice 值到时间片映射关系也脱不了关系。假设我们有两个进程，分别具有不同的优先级。第一个假设 nice 值只是0， 第二个假设是1。它们将被分别映射到时间片 100ms 和 95ms (O(1)调度算法确实就这么干类)。它们的时间片几乎一样，差别微乎其微。但是如果我们的进程分别赋予 18 和 19 的 nice 值，那么它们则分别被映射为 10ms 和 5ms 的时间片。如果这样，前者相比后者获得了两倍的处理器时间！不过 nice 值通常都使用相对值(nice系统调用是在原值上 增加或减少，而不是在绝对值上操作)，也就是说：“把进程的nice值减少1”所带来的效果极大的取决于其 nice 的初始值。 第三个问题 如果执行 nice 值到时间片的映射，我们需要能分配一个绝对时间片，而且这个绝对时间片必须能在内核的测试范围内。在多数操作系统中，上述要求意味着时间片必须是 定时器节拍的整数倍。但是这么做必然会引发了几个问题。首先，最小时间片必然是定时器节拍的整数倍，也就是 10ms 或者 1ms 的倍数。 其次，系统定时器限制了两个时间片的差异：连续的 nice 值映射到时间片，其差别范围多至 10ms 或者 少则 1ms。最后，时间偏还会随着定时器节拍改变。 第四个问题 也是最后一个关于基于优先级的调度器为了优化交互任务而唤醒相关进程的问题。这种系统中，你可能为了进程能更快的投入运行，而去对新要唤醒的进程提升优先级，即便它们的 时间片已经用尽了。虽然上述方法确实能提升不少交互性能，但是一些例外情况也有可能发生，因为它同时也给某些特殊的睡眠/唤醒用例一个玩弄调度器的后门， 使得给定进程打破公平原则，获得更多处理器时间，顺还系统中其它进程的利益。 上述问题中的绝大多数都可以通过对传统 Unix 调度器进行改造解决，虽然这种改造修改不小，但是也并非是结构性的调整。比如，将 nice 值呈几何增加而非算数增加 的方式解决第二个问题：采用一个新的度量机制将从 nice 值到时间片的映射与定时器节拍分离开来，一次解决第三个问题。但是这些解决方案都回避了实质问题 —— 即 分配绝对的时间片引发的固定的切换频率，给公平性造成了很大变数。CFS采用的方法是对时间片分配方式进行根本性的重新设计(就进程调度器而言)：完全摒弃时间片 而是分配给进程一个处理器使用比重。这种方式下，CFS 确保了进程调度中能有恒定的公平性，而将切换频率置于不断变动中。 公平调度 CFS 的出发点基于一个简单的理念：进程调度的效果应如同系统具备一个理想中的完美多任务处理器。在这种系统中，每个进程将获得 $1/n$ 的处理器时间 —— n 是指可运行进程的数量。 同时，我们可以调度给它们无限小的时间周期，所以在任何可测量周期内，我们给予 n 和进程中每个进程同样多的运行时间。距离说明，加入我们有两个运行进程，在标准 Unix 调度模型中，我们先运行其中一个 5ms，然后再运行另一个 5ms。但它们任何一个运行时候都将占有 100% 的处理器，它们各自使用处理器一半的能力。 当然，上述理想模型并非显示，因为我们无法在一个处理器上真的同时运行多个进程。而且如果每个进程运行无限小的时间周期也是不高效的 —— 因为调度时进程抢占会带来一定的 代价：将一个进程换出，另一个换入本身有消耗，同时还会影响到缓存的效率。因此虽然我们希望所有进程能值运行一个非常短的周期，但是 CFS 充分考虑了这将带来的额外消耗，现实中首先要 确保系统新能不受损失。CFS的做法是允许每一个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法了， CFS 在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠 nice 值来计算时间片。nice值在 CFS 中被作为进程获得的处理器运行比的权重，这是相对默认 nice 值 进程的进程而言的；相反，更低的 nice 值(越高的优先级)的进程获得更好的处理器使用权重。 每个进程都按其权重在全部可运行进程中所占的 “时间片” 来运行，为了计算准确的时间片，CFS 为完美多任务中的无限小调度周期的近似值设立了一个目标。而这个目标称作 “目标延迟”， 越小的调度周期将带来越好的交互性，同时也更接近完美的多任务。但是你必须承受更高的切换代价和更差的系统总吞吐能力。让我们假定目标延迟值是 20ms，我们有两个同样优先级 的可运行任务(无论这些任务的优先级是多少)。每个任务在被其它任务抢占前运行 10ms，如果我们有 4 个这样的任务，则每个智能运行 5ms。进一步设想， 如果有 20 个这样的任务，那么每个仅仅只能获得 1ms 的运行时间。 你一定注意到了，当可运行任务数量趋于无限时候，它们各自获得的处理器时间比和时间片都将趋于0.这样无疑造成了不可接收的切换消耗。CFS 为此引入每个进程获得的 时间片底线，这个底线称为最小粒度。默认情况下这个值是 1ms。如此依赖，即便是可运行进程数量趋于无穷，每个最少也能获得 1ms 的运行时间，确保切换消耗被限制在一定 范围内(敏锐的读者会注意到假如在进程数量变得非常多的情况下，CFS并非一个完美的公平制度，因为这时处理器时间片再小也无法突破最小粒度。的却如此， 尽管修改过的公平队列方法确实能提高这方面的公平性，但是 CFS 的算法本身其实已经决定在这方面折中了。但还好，因为通常情况下系统中只会有几百个可运行进程，无疑， 这时 CFS 的相当公平的)。 现在，让我们再看看具有不同 nice 值的两个可运行进程的运行情况 —— 比如一个具有默认 nice 值(0)，另一个具有额 nice 值为 5.这些不同的 nice 值对应不同的权重， 所以上述两个进程将获得不同的处理器使用比。这个例子中，nice 值是 5 的进程的权重是默认 nice 进程的 1/3.如果我们的目标延迟是 20ms，那么这两个进程将分别获得 15ms 和 5ms 的 处理器时间。再比如我们的两个可运行进程的 nice 值分别是 10 和 15，它们分配的时间片将是多少呢？还是 15ms 和 5ms！可见，绝对的 nice 值不再影响调度决策：只有相对值才会影响处理器时间的分配比例。 总结以下，任何进程所获得的处理器时间是由它自己和其它所有可运行进程 nice 值的相对差值决定的。nice值对时间片的作用不再是算数加权，而是几何加权。任何ni","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:4","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"Linux 调度的实现 在讨论了采用 CFS 调度算法的动机和其内部逻辑后，我们现在可以开始具体探索 CFS 是如何得以实现的。其相关代码位于文件 kernel/sched_fair.c 中。我们将特别关注其四个组成部分： 时间记账 进程选择 调度器入口 睡眠和唤醒 时间记账 所有的调度器都必须对进程运行时间做记账。多数 Unix 系统，正如我们前面所说，分配一个时间片给每一个进程。那么每次系统时钟节拍发生时候，时间片都被减少一个节拍周期。 当一个进程的时间片被减少到0时候，它就会被另一个尚未减到 0 的时间片可运行进程抢占。 调度器实体结构 CSF 不再有时间片的概念，但是它也必须维护每个进程运行的时间记账，因为它需要确保每个进程只在公平分配给它的处理器时间内运行。CFS使用调度器实体结构 (定义在文件\u003clinux/sched.h\u003e的 struct_sched_entity 中)来追踪进程运行记账： struct sched_entity { struct load_weight load; struct rb_node run_node; struct list_head group_node; unsigned int on_rq; u64 exec_start; u64 sum_exec_runntime; u64 vruntime; u64 prev_sum_exec_runtime; u64 last_wakeup; u64 avg_overlap; u64 nr_migrations; u64 start_runtime; u64 avg_wakeup; // 这里省略了很多统计变量，只有在设置了 CONFIG_SCHEDSTATS 时候才启用这些变量 }; 调度器实体结构作为一个名为 se 的成员变量，嵌入在进程描述符 struct task_struct 内。 虚拟实时 vruntime 变量存放进程的虚拟运行时间，该运行时间(华仔运行上的时间和)的计算是经过了所有可运行进程总数的标准化(或者说是被加权的)。虚拟时间是以 ns 为单位的， 所以 vruntime 和定时器节拍不再相关。虚拟运行时间可以帮助我们逼近 CFS 模型所追求的 “理想多任务处理器”。如果我们真有这样一个理想的处理器，那么我们就不再需要 vruntime 了。因为优先级相同的所有进程的虚拟运行时间都是相同的 —— 所有任务都被接收到相等的处理器份额。但是因为处理器无法实现完美的多任务，它必须依次运行每个任务。 因此 CFS 使用 vruntime 变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。 定义在 kernel/sched_fair.c 文件中的 update_curr() 函数实现了该记账功能： static void update_curr (struct cfs_rq* cfs_rq) { struct sched_entity* curr = cfs_rq-\u003ecurr; u64 now = rq_of(cfs_rq)-\u003eclock; unsigned long delta_exec; if (unlikely(!curr)) { return; } // 获得从最后依次修改负载后当前任务所占用的运行总时间(在 32 位系统上这不会溢出) delta_exec = (unsigned long) (now - curr-\u003eexec_start); if (!delta_exec) return; __update_curr(cfs_rq, curr, delta_exec); curr-\u003eexec_start = now; if (entity_is_task(curr)) { struct task_struct* curtask = task_of (curr); trace_shced_stat_runtime(curtask, delta_exec, curr-\u003evruntime); cpuacct_charge(curtask, delta_exec); account_group_exec_runtime(curtask, delta_exec); } } update_curr() 计算了当前进程的执行时间，并且将其存放在变量 delta_exec 中。然后它又将运行时间传递给了 __update_curr()，由后者再根据当前可运行进程总数对运行时间进行加权计算。 最终将上述的权重值与当前运行进程的 vrunntime 相加。 // 更新当前任务的运行时统计数据。跳过不在调度类中的当前任务 static inline void __update_curr (struct cfs_rq* cfs_rq, struct shced_entity* curr, unsigned long delta_Exec) { unsigned long delta_exec_weighted; schedstat_set (curr-\u003eexec_max, max((u64)delta_exec,curr-\u003eexec_max)); curr-\u003esum_exec_runtime += delta_exec; schedstat_add (cfs_rq, exec_clock, delta_Exec); delta_exec_weighted = calc_delta_fair (delta_exec, curr); curr-\u003evruntime += delta_exec_weighted; update_min_vruntime(cfs_rq); } update_curr()是由系统定时器周期性调用，无论在进程处于可运行状态，还是被阻塞处于不可运行状态。根据这种方式，vruntime 可以准确地测量给定进程的运行时间， 而且可直到谁应该是下一个被运行的进程。 进程选择 在前面内容中我们的讨论中谈到若存在一个完美的多任务处理器。所有可运行进程的 vruntime 值将一致。但事实上我们没有找到完美的多任务处理器，因此 CFS 试图利用一个简单的 规则去均衡进程的虚拟运行时间：当 CFS 需要选择下一个运行时间时候，它会挑一个具有最小 vruntime 的进程。这其实就是 CFS 调度算法的核心：选择具有最小 vruntime 的任务。 那么剩下的内容我们就来讨论到底是如何实现选择具有最小 vruntime 值的进程。 CFS 使用红黑树来组织可运行进程队列，并利用其迅速找到最小 vruntime 值的进程 在 linux 中，红黑树被称为 btree，它是一个自平衡二叉搜索树。 挑选下一个任务 我们先假设，有那么一个红黑树存储了系统中所有的可运行进程，其中节点的键值便是可运行进程的虚拟运行时间。稍后我们将看到如何生成该树，但现在我们假定已经拥有它来。CFS 调度器选取待运行的下一个进程， 是所有进程中 vruntime 最小的哪个，它对应的便是在树中最左侧的叶子节点。实现这一过程的函数是：__pick_next_entity()，它定义在文件 kernel/sched_fair.c 中： static struct sched_entity* __pick_next_entity(struct cfs* cfs_rq) { struct rb_node* left = cfs_rq-\u003erb_leftmost; if (!left) return NULL; return rb_entry(left, struct sched_entity, run_node); } 注意 __pick_next_entity() 函数本身并不会遍历树找到最左叶子节点，因为该值已经缓存在 rb_leftmost 字段中。虽然红黑树让我们可以很有效地找到最左叶子节点(O(树的高度))等于 树节点总数的 O(log n)，这是平衡树的优势)，但是更容易的做法是把最左叶子节点缓存起来。这个函数的返回值便是 CFS 调度选择的下一个运行进程。如果该函数返回值是 NULL， 那么表示没有最 左叶子节点，那就是说树中没有任何节点了。这种情况下，表示没有可运行进程， CFS 调度器便选择 idle 任务运行。 向树中加入进程 现在，我们来看 CFS 如何将进程加入 rbtree 中，以及如何缓存最左叶子节点。这一切发生在进程变为可运行状态(被唤醒)或者是通过fork()调用第一次创建进程时。enqueue_entity()函数实现了这一目的： static void enqueue_entity (struct cfs_rq* cfs_rq, struct sched_entity* se, int flags) { // 通过调用 update_curr()，在更新 min_vruntime 之前先更新规范化的 vruntime if (!(flags \u0026 ENQUEUE_WAKEUP) || (flags \u0026 ENQUEUE_MIGRATE)) se-\u003evruntime += cfs_rq-\u003emin_vruntime; // 更新 当前任务 的运行时统计数据 update_curr(cfs_rq); account_entity_enqueue(cfs_rq, se); if (flags \u0026 ENQUEUE_WAKEUP) { place_entity(cfs_rq, se, 0); enqueue_sleeper(cfs_rq, se); } update_s","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:5","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"调度器入口 进程调度的主要入口点是函数 schedule()，它定义在文件 kernel/sched.c 中。它正是内核其它部分用于调度进程调度器的入口：选择哪个进程可以运行，合适将其投入运行。 Schedule() 通常都需要和一个具体的调度类相关联，也就是说，它会找到一个最高优先级的调度类 —— 后者需要由自己的可运行队列，然后问后者谁才是下一个该运行的进程。 知道了这个背景就不会吃惊 schedule() 函数为何实现得如此简单。该函数中唯一重要的事情是，它会调用 pick_next_task()(也定义在文件 kernel/sched.c中)。 pick_next_task() 会以优先级为序，从高到低，依次检查每一个调度类，并且从最高优先级的调度类中，选择最高优先级的进程： // 挑选最高优先级的任务 static inline struct task_struct* pick_next_task (struct rq* rq) { const struct sched_class* class; struct task_struct* p; // 优化：我们知道如果所有任务都在公平类中，那么我们就可以直接调用哪个函数 if (likely(rq-\u003enr_running == rq-\u003ecfs.nr_running)) { p = fair_sched_class.pick_next_task(rq); if (likely(p)) { return p; } } class = sched_class_highest; for (;;) { p = class-\u003epick_next_task(req); if (p) return p; // 永不会 NULL，因为 idle 类总会返回非 NULL 的 p class = class-\u003enext; } } 注意该函数开始部分的优化。因为 CFS 是普通进程的调度类，而系统运行的绝大多数进程都是普通进程，因此这里有一个小技巧用来加速选择下一个 CFS 提供的进程， 前提是所有可运行进程数量等于 CFS 类对应的可运行进程数(这样就说明所有的可运行进程就是 CFS 类的)。 该函数的核心是 for() 循环，它以优先级为序，从最高的优先级类开始，遍历了每一个调度类。每一个调度类都实现了 pick_next_task() 函数，它会 返回指向下一个可运行进程的指针，或者没有时返回 NULL。我们会从第一个返回非 NULL 值的类中选择下一个可运行进程。 CFS 中 pick_next_task() 实现会调用 pick_next_entity()，而该函数会再来调用我们前面内容中讨论过的 __pick_next_entity() 函数。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:6","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"睡眠和唤醒 休眠(被阻塞) 的进程处于一个特殊的不可执行状态。这点非常重要，如果没有这种特殊状态的话，调度器程序就可能选出一个本不愿意被执行的进程，更糟糕的是， 休眠就必须以轮询的方式实现了。进程休眠由多种原因，但肯定都是为了等待一些事件。事件可能是一段时间从文件 I/O 读更多数据，或者是某个硬件事件。 一个进程还有可能在尝试获取一个已被占用的内核信号量时被迫进入休眠。休眠的一个常见原因就是文件 I/O —— 如进程对一个文件执行了 read() 操作， 而这需要从磁盘里读取。还有，进程在获取键盘输入的时候也许要等待。无论哪种情况，内核的操作都相同：进程把自己标记成休眠状态，从可执行红黑树中移出，放入 等待队列，然后调用 schedule() 选择和执行一个其它进程。唤醒的过程刚高相反：进程被设置为可执行状态，然后再从等待队列中移到可执行红黑树中。 之前讨论过，休眠有两种相关的进程状态：TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE。它们的唯一区别是处于 TASK_UNINTERRUPTIBLE 的进程 会忽略信号，而处于 TASK_INTERRUPTIBLE状态的进程如果接收到一个信号，会被提前唤醒并响应该信号。两种状态的进程位于同一个等待队列上，等待某些事件，不能够运行。 1. 等待队列 休眠通过等待队列进行处理。等待队列是由等待某些事件发生的进程组成的简单链表。内核用 wake_queue_head_t 来代表等待队列。等待队列可以通过 DECLARE_WAITQUEUE() 静态创建，也可以由 init_waitqueue_head() 动态创建。进程把自己放入等待队列中并设置成不可执行状态。当与等待队列相关的事件发生的时候，队列上的进程会被唤醒。 为了避免产生竞争条件，休眠和唤醒的实现不能有纰漏。 针对休眠，以前曾经使用过一些简单的接口。但那些接口会带来竞争条件：有可能导致在判定条件变为真后，进程却开始了休眠，那样就会使进程无限期的休眠下去。所以，在内核中进行休眠的推荐操作就相对复杂了一些： // 'q' 是我们希望休眠的等待队列 DEFINE_WAIT(wait); add_wait_queue(q, \u0026wait); while(!condition) { // condition 是我们在等待的事件 prepare_to_Wait(\u0026q, \u0026wait, TASK_INTERRUPTIBLE); if (signal_pending(current)) // 处理信号 schedule(); } finish_Wait (\u0026q, \u0026wait); 进程通过执行下面几个步骤将自己加入到一个等待队列中： 调用宏 DEFINE_WAIT() 创建一个等待队列的项。 调用宏 add_wait_queue() 把自己加入到队列中。该队列会在进程等待的条件满足时候唤醒它。当然我们必须在其它地方撰写相关代码，在事件发生时候，对等待队列执行 wake_up() 操作。 调用 prepare_to_wait() 方法将进程的状态变为 TASK_INTERRUPTIBLE 或 TASK_UNINTERRUPTIBLE。而且该函数如果有必要的话会将进程加回到等待队列，这时在接下来的循环遍历中所需的 如果状态被设置为 TASK_INTERRUPTIBLE，则信号唤醒进程。这就是所谓的伪唤醒(唤醒不是因为事件的发生)，因此检查并处理信号。 当进程被唤醒的时候，它会再次检查条件是否为真。如果是，它会退出循环；如果不是，它再次调用 schedule() 并一直重复这步操作。 当条件满足后，进程将自己设置为 TASK_RUNNING 并调用 finish_wait() 方法把自己移出等待队列。 如果在进程开始休眠之前条件就已经达成了，那么循环会退出，进程不会存在错误地进入休眠的倾向。需要注意的是，内核代码在循环体内常常需要完成一些其它任务，比如，它可能在调用 schedule() 之前需要 释放掉锁，而在这以后再重新获取它们，或者响应其它事件。 函数 inotify_read()，位于文件 fs/notify/inotify/inotify_user.c 中，负责从通知文件描述符中读取信息，它的实现无疑是等待队列的一个典型用法： static ssize_t inotify_read (struct file* file, char __user* buf, size_t count, loff_t* pos) { struct fsnotify_group* group; struct fsnotify_event* kevent; char __user* start; int ret; DEFINE_WAIT(wait); start = buf; group = file-\u003eprivate_data; while (1) { prepare_to_wait(\u0026group-\u003enotification_waitq, \u0026wait, TASK_INTERRUPTIBLE); mutex_lock(\u0026group-\u003enotification_mutex); kevent = get_one_event(group, count); mutex_unlock (\u0026group-\u003enotification_mutex); if (kevent) { ret = PTR_ERR(kevent); if (IS_ERR(kevnet)) break; ret = copy_event_to_user(group, kevent, buf); fsnotify_put_event(kevent); if (ret \u003c 0) { break; } buf += ret; count -= ret; continue; } ret = -EAGAIN; if (file-\u003ef_flags \u0026 O_NONBLOCK) { break; } ret = - EINTR; if (signal_pending(current)) { break; } if (start != buf) { break; } schedule(); } finish_wait (\u0026group-\u003enotification_waitq, \u0026wait); if (start != buf \u0026\u0026 ret != -EFAULT) { ret = buf - start; } return ret; } 这个函数遵循了我们例子中的使用模式，主要的区别是它在 while 循环中检查了状态，而不是在 while 循环条件语句中。原因是该条件的检测更复杂一些，而且需要 获得锁。也正因为如此，循环退出是通过 break 完成的。 2. 唤醒 唤醒操作是通过函数 wake_up() 进行，它会唤醒指定的等待队列上的所有进程。它调用函数 tray_to_wake_up()，该函数负责将进程设置为 TASK_RUNNING状态，调用 enqueue_task() 将此进程放入红黑树中，如果被唤醒的进程优先级比当前正在执行的进程的优先级高，还要设置 need_resched标志。通常哪段代码促使等待条件达成，它就要负责随后调用 wake_up() 函数。举例来说，当磁盘数据到来时候，VFS就要负责对等待队列调用 wake_up()，以唤醒队列中等待这些数据的进程。 关于休眠有一点需要注意，存在虚假的唤醒。有时候进程被唤醒并不是因为它所等待的条件达成了才需要用一个循环处理来保证它等待的条件真正达成。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:7","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"抢占和上下文切换 上下文切换，也就是从一个可执行进程切换到另一个可执行进程，由定义在 kernel/sched.c 中的 context_switch() 函数负责处理。每当一个新的进程被选出来准备投入运行的时候， schedule()就会调用该函数。它完成了两项基本的工作： 调用声明在 \u003casm/mmu_context.h\u003e 中的 switch_mm()，该函数负责把虚拟内存从上一个进程映射切换到新进程中。 调用声明在 \u003casm/system.h\u003e 中的 switch_to()，该函数负责从上一个进程的处理器状态切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，还有其它任何与体系结构相关的状态信息，都必须以每个进程为对象进行管理和保存。 休眠和唤醒 内核必须知道在什么时候调用 schedule()。如果仅靠用户程序代码显式调用 schedule()，它们可能会永远地执行下去。相反，内核提供了一个 need_resched 标志来表明是否需要重新执行一次调度。当某个进程应该被抢占时候，scheduler_tick() 就会设置这个标志：当一个优先级高的进程 进入可执行状态的时候，try_to_wake_up()也会设置这个标志，内核检查该标志，确认其被设置，调用 schedule() 来切换到一个新的进程。该标志对于 内核来讲是一个信息，它表示有其它进程应当被运行来，要尽快调用调度程序。 以下是用于访问和操作 need_resched 的函数 函数 目的 set_tsk_need_resched() 设置指定进程中的 need_resched 标志 clear_tsk_need_resched() 清除指定进程中的 need_resched 标志 need_resched() 检查 need_resched 标志的值，如果被设置就返回真，否则返回假 再返回用户空间以及从中断返回的时候，内核也会检查 need_resched 标志。如果已被设置，内核会在继续执行之前调用调度程序。 每个进程都包含一个 need_resched 标志，这时因为访问进程描述符内的数值要比访问一个全局变量快(因为 current 宏速度很快并且描述符通常都在 高速缓存中)。在 2.2 以前的内核版本中，该标志曾经是一个全局变量。 2.2 到 2.4 版内核中它在 task_struct 中。而在 2.6 版中，它被移到 thread_info 结构体中，用一个特别的标志变量中的一位来表示。 1. 用户抢占 内核即将返回用户空间的时候，如果 need_resched 标志被设置，会导致 schedule() 被调用，此时就会发生用户抢占。在内核返回用户空间的时候，它 知道自己是安全的，因为既然它可以继续去执行当前进程，那么它自然可以再去选择一个新的进程去执行。所以，内核无论是在中断处理程序还是在系统调用后返回， 都会检查 need_resched 标志。如果它被设置来，那么，内核会选择一个其它(更合适的)进程投入运行。从中断处理程序或系统调用返回的返回路径都是跟体系结构相关的 在 entry.S (此文件不仅包含内核入口部分的程序，内核退出部分的相关代码也在其中)文件中通过汇编语言来实现。 简而言之，用户抢占在以下情况时候产生： 从系统调用返回用户空间时候 从中断处理程序返回用户空间时候 2. 内核抢占 与其它大部分的 Unix 变体和其它大部分操作系统不同， Linux 完整地支持内核抢占。在不支持内核抢占的内核中，内核代码可以一直执行，到它完成为止。也就是说，调度程序没有办法在一个内核级 的任务正在执行的时候重新调度 —— 内核中的各任务是以协作方式调度的，不具备抢占性。内核代码一致要执行到完成(返回用户空间)或明显的阻塞为止。 在 2.6 版的内核中，内核引入来抢占能力。现在，只要重新调度是安全的，内核就可以在任何时间抢占正在执行的任务。 那么，什么时候重新调度才是安全的呢？只要没有持有锁，内核就可以进行抢占。锁是非抢占区域的标志。由于内核是支持 SMP 的，所以，如果没有持有锁， 正在执行的代码就是可重新导入的，也就是可以抢占的。 为了支持内核抢占所做的第一处变动，就是为每个进程的 thread_info 引入 preempt_count 计数器。该计数器初始值为0，每当使用锁的时候数值 加1，释放锁的时候数值减1.当数值为0的时候，内核就可执行抢占。从中断返回内核空间的时候，内核会检查 need_resched 和 preempt_count 的 值。如果 need_resched 被设置，并且 preempt_count 为零的话，这说明有一个更为重要的任务需要执行并且可以安全的抢占，此时，调度程序就会被调用。 如果 need_resched 被设置，并且 preempt_count 为 0 的话，这说明有一个更为重要的任务需要执行并且可以安全的抢占，此时，调度程序就会被调用。 如果 preempt_count 不为0，说明当前任务持有锁，所以抢占是不安全的。这时，内核就会像通常那样直接从中断返回当前执行过程。如果当前进程持有的 所有的锁都被释放掉来，preempt_count都会重新为0.此时，释放锁的代码会检查 need_resched 是否被设置。如果是的话，就会调用调度程序。 有些内核代码需要允许或禁止内核抢占。 如果内核中的进程被阻塞了，或者它显式的调用了 schedule()，内核抢占也会显式地发生。这种形式的内核抢占从来都是受支持的，因为根本无须额外的逻辑来 保证内核可以安全地被抢占。如果代码显式的调用了 schedule()，那么它应该清除自己是可以安全地被抢占的。 内核抢占会发生在： 中断处理程序正在执行，且返回内核空间之前。 内核代码再一次具有可强占性的时候。 如果内核中的任务显式地调用 schedule()。 如果内核中的任务阻塞(这同样也会导致调用schedule())。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:8","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"实时调度策略 Linux 提供了两种实时调度策略：SCHED_FIFO和SCHED_RR 。而普通的、非实时的调度策略是 SCHED_NORMAL。借助调度类的框架，这些实时策略并不被完全公平调度器来管理， 而是被一个特殊的实时调度器管理。具体实现定义在文件 kernel/sched_rt.c 中，在接下来的内容中我们将讨论实时调度策略和算法。 SCHED_FIFO实现了一种简单的、先入先出的调度算法：它不使用时间片。处于可运行状态的 SCHED_FIFO级的进程会比任何 SCHED_NORMAL 级的进程都先得到调度。一旦 一个 SCHED_FIFO级进程处于可执行状态，就会一直执行，直到它自己受阻塞或显式地释放处理器为止：它不基于时间片，可以一直执行下去。只有更高优先级的 SCHED_FIFO或者SCHED_RR任务才能抢占 SCHED_FIFO 任务。如果有两个或者更多的同优先级的 SCHED_FIFO 级进程，它们会轮流执行，但是依然只有在它们愿意 让出处理器时候才会退出。只要有 SCHED_FIFO 级进程在执行，其它级别较低的进程就只能等待它变为不可运行态后才有机会执行。 SCHED_RR和SCHED_FIFO大体相同，只是 SCHED_RR 级的进程在耗尽实现分配给它的时间后就不能在继续执行了。也就是说， SCHED_RR是带有时间片的 SCHED_FIFO —— 这时一种实时轮流调度算法。当 SCHED_RR 任务耗尽它的时间片时，在同一优先级的其它实时进程被轮流调度。时间片只用来重新调度同一 优先级的进程。对于 SCHED_FIFO 进程，高优先级总是立即抢占低优先级，但低优先级决不能抢占 SCHED_RR 任务，即使它的时间片耗尽。 这两种实时算法实现的都是静态优先级。内核不为实时进程计算动态优先级。这能保证给定优先级别的实时进程总能抢占优先级比它低的进程。 Linux 的实时调度算法提供了一种软实时工作方式。软实时的含义是，内核调度进程，尽力使进程在它的限定时间到来前运行，但内核不保证总能满足这些进程的要求。相反，硬实时系统保证在一定条件下， 可以满足任何调度的要求。Linux对于实时任务的调度不做任何保证。虽然不能保证硬实时工作方式，但 Linux 的实时调度算法的性能还是不错的。2.6版本的内核可以满足严格的时间要求。 实时优先级范围从 0 到 MAX_RT_PRIO 减1.默认情况下，MAX_RT_PRIO 为 100 —— 所以默认的实时优先级范围是从 0 到 99。SCHED_NORMAL 级进程的 nice 值共享了这个取值空间；它的取值范围是从 MAX_RT_PRIO 到(MAX_RT_PRIO + 40)。也就是说，在默认情况下，nice 值从 -20 到 +19直接对应的是从 100 到 139 的实时优先级范围。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:9","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"与调度相关的系统调用 Linux 提供了一个系统调用族，用于管理与调度程序相关的参数。这些系统调用可以用来操作和处理进程优先级、调度策略以及处理器绑定，同时还提供了显式的将处理器交给其它进程的机制。 与调度有关的系统调用： 系统调用 描述 nice() 设置进程的nice值 sched_setscheduler() 设置进程的调度策略 sched_getscheduler() 获取进程的调度策略 sched_setparam() 设置进程的实时优先级 sched_getparam() 获取进程的实时优先级 sched_get_priority_max() 获取实时优先级的最大值 sched_get_priority_min() 获取实时优先级的最小值 sched_rr_get_interval() 获取进程的时间片值 sched_setaffinity() 设置进程的处理器的亲和力 sched_getaffinity() 获取进程的处理器的亲和力 sched_yield() 暂时让出处理器 与调度策略和优先级相关的系统调用 sched_setscheduler() 和 sched_getscheduler() 分别用于设置和获取进程的调度策略和实时优先级。与其它的系统调用相似，它们的实现也是 由许多参数检查、初始化和清理构成的。其实最重要的工作在于读取或改写进程task_struct的policy和rt_priority的值。 sched_setparam()和sched_getparam()分别用于设置和获取进程的实时优先级。这两个系统调用获取封装在sched_param特殊结构体的 rt_priority中。sched_get_priority_max()和sched_get_priority_min()分别用于返回给定调度策略的最大和最小优先级。实时调度策略 的最大优先级是 MAX_USER_RT_PRIO 减1，最小优先级等于1. 对于一个普通的进程，nice()函数可以将给定进程的静态优先级增加一个给定的量。只有超级用户才能在调用它时候使用负值，从而提高进程的优先级。 nice()函数会调用内核的 set_user_nice()函数，这个函数会设置进程的 task_struct 的 static_prio 和 prio值。 与处理器绑定有关的系统调用 Linux 调度程序提供强制的处理器绑定机制。也就是说，虽然它尽力通过一种软的(或者说自然的)亲和性试图使进程尽量在同一个处理器上运行，但是它也 允许用户强制指定“这个进程无论如何都必须在这些处理器上运行”。这种强制的亲和性保存在进程 task_struct 的 cpus_allowed这个位掩码标志中。 该掩码标志的每一位对应一个系统可用的处理器。默认情况下，所有的位都被设置，进程可以在系统中所有可用的处理器上执行。用户可以通过 sched_setaffinity() 设置不同的一个或几个位组合的位掩码，而调用 sched_getaffinity() 则返回当前的 cpu_allowed 位掩码。 内核提供的强制处理器绑定的方法很简单。首先，当处理进行第一次创建时候，它继承了其父进程的相关掩码。由于父进程运行在指定处理器上，子进程也运行在 相应处理器上。最后，加载平衡器只把任务拉到允许的处理器上，因此，进程只运行在指定处理器上，对处理器的指定是由该进程描述符的cpus_allowed域设置的。 放弃处理器时间 Linux 通过 sched_yield() 系统调用，提供了一种让进程显式将处理器时间让给其它等待执行进程的机制。它是通过将进程从活动队列中(因为进程正在执行， 所以它肯定位于此队列当中)移到过期队列中实现的。有此产生的效果不仅抢占了该进程并将其放入优先级队列的最后面，还将其放入过期队列中——这样能确保在 一段时间内它都不再被执行了。由于实时进程不会过期，所以属于例外。它们只被移动到其优先级队列的最后面(不会放到过期队列中)。在Linux的早期版本中， sched_yield()的语义有所不同，进程只会被放置到优先级队列的末尾，放弃的时间往往不会太长。现在，应用程序甚至内核代码在调用 sched_yield()前， 应该仔细考虑是否真的希望舍弃处理器时间。 内核代码为了方便，可以直接调用 yield()，先要确定给定进程确实处于可执行状态，然后再调用 sched_yield()。用户空间的应用程序直接使用 sched_yield()系统调用就可以了。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:10","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"小结 进程调度程序是内核重要的组成部分，因为运行着的进程首先在使用计算机。然而，满足进程调度的各种需要绝不是轻而易举的：很难找到“一刀切”的算法， 既适合众多的可运行进程，又具有可伸缩性，还能在调度周期和吞吐量之间求得平衡，同时还满足各种负载的需求。不过，Linux 内核的新 CFS 调度程序 尽量满足了各个方面的需求，并以较完善的可伸缩性和新颖的方法提供了最佳的解决方案。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:4:11","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"系统调用 在现代操作系统中，内核提供了用户进程与内核进行交互的一组接口。这些接口让应用程序受限的访问硬件设备，提供了创建新进程并与已有进程进行通信的机制，也提供了申请操作系统其它资源的能力。这些接口在应用程序 和内核之间扮演了使者的角色，应用程序发出各种请求，而内核负责满足这些请求(或者无法满足时候返回一个错误)。实际上提供这些接口主要是为了保证系统稳定可靠，避免应用程序恣意妄行。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:0","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"与内核通信 系统调用在用户空间进程和硬件设备之间添加了一个中间层。该层主要作用由三个。受限，它位用户空间提供了一种硬件的抽象接口。距离来说，当需要读写文件的时候，应用程序就可以不去管理磁盘类型和介质， 甚至不用去管文件所在的文件系统到底是哪种类型。第二，系统调用包整了系统的稳定性和安全。作为硬件设备和应用程序之间的中间人，内核可以基于权限、用户类型和其它一些 规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确的使用硬件设备，窃取其它进程的资源，或是作出其它危害操作系统的事情。 第三，之前曾经提到过，每个基础南横都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。如果应用程序可以随意访问硬件而内核又对此一无所知的话，几乎就没法实现 多任务和虚拟内存，当然也不可能实现良好的稳定性和安全性。在 Linux 中，系统调用是用户空间访问内核的唯一手段，除了异常和陷入之外，它们是内核唯一的合法入口，实际上，其它的像 设备文件和/proc之类的方式，最终还是要通过系统调用进行访问的。而有趣的是，Linux提供的系统调用却比大部分操作系统都少得多。 接下来讨论Linux系统调用的规则和实现方法 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:1","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"API、POSIX和C库 一般情况下，应用程序通过在用户空间实现的应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用对应。 一个 API 定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系统调用也不存在问题。实际上，API可以在各种不同 的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。下图给出了 POSIX、API、C库以及系统调用之间的关系。 调用printf()函数时，应用程序、C库和内核之间的关系 在 Unix 世界中，最流行的应用编程接口是基于 POSIX 标准的。从纯技术的角度来看，POSIX 是由 IEEE 的一组标准组成，其目标是提供一套大体上基于 Unix 的可移植 操作系统标准。在应用场合，Linux尽力与POSIX和SUSv3兼容。 POSIX是说明 API 和系统调用之间关系的一个极好例子。在大多数 Unix 系统上，根据 POSIX 定义的 API 函数和系统调用之间有着直接关系。实际上，POSIX标准就是仿照早期 Unix 系统的接口建立的。另一方面，许多操作系统，像微软的 Windows，尽管是非 Unix 系统，也提供了与 POSIX 兼容的库。 Linux的系统调用像绝大多数 Unix 系统一样，作为 C 库的一部分提供。C库实现了 Unix 系统的主要 API， 包括标准C库函数和系统调用接口。所有的 C 程序都可以使用 C 库，而由于 C 语言本身的特点，其它语言也可以很方便的把它们封装起来使用。此外， C 库提供了 POSIX 的绝大部分 API。 从程序员的角度来看，系统调用无关紧要，它们只需要跟 API 打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用，不是内核 所关心的。但是，内核必须时刻牢记系统调用所有潜在的用途，并保证它们由良好的通用性和灵活性。 关于 Unix 的接口设计由一句格言 “提供机制而不是策略”。换句话说，Unix的系统调用抽象出了用于完成某种确定的目的的函数。至于这些函数怎么用完全不需要内核去关心。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:2","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"系统调用 要访问系统调用(在Linux中常称为 syscall)，通常通过 C 库中定义的函数调用来进行。它们通常都需要定义零个、一个或几个参数(输入)而且可能产生一些副作用， 例如：写某个文件或向给定的指针拷贝数据等。系统调用还会通过一个 long 类型的返回值来表示成功或者错误。通常，但也不绝对，用一个负的返回值来表明错误。返回一个 0 值通常 表示成功。系统调用在出现错误的时候 C 库会把错误码写入 errno 全局变量。通过调用 perror() 库函数，可以把变量翻译成用户可以理解的错误字符串。 当然，系统调用最终具有一种明确的操作。例如 getpid() 系统调用，根据定义它会返回当前进程的 PID。内核中它的实现非常简单： SYSCALL_DEFINED(getpid) { return task_tgid_vnr(current); // returns current-\u003etgid } 注意，定义中并没有规定它要如何实现。内核必须提供系统调用所希望完成的功能，但它完全可以按照自己预期的方式去实现，只要最后的结果正确就行了。当然，上面的系统调用 太简单，也没有什么更多的实现手段。 SYSCALL_DEFINE0 只是一个宏，它定义一个无参数的系统调用(因此这里为数字0)，展开后的代码如下： asmlinkage long sys_getpid(void) 我们看一下如何定义系统调用。首先，注意函数声明中的 asmlinkage限定词，这是一个编译指令，通知编译器仅从栈中提取该函数的参数。所有的系统调用都需要这个限定词。 其次，函数返回 long。为了保证 32位和64位系统的兼容，系统调用在用户空间和内核空间由不同的返回值类型，在用户空间为 int，在内核空间为 long。 最后，注意系统调用 get_pid() 在内核中被定义成 sys_getpid()。这是 Linux 中所有系统调用都应该遵守的命名规则 系统调用号 在 Linux 中，每个系统调用被赋予一个系统调用号。这样，通过这个独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统 调用号就用来指明到底是要执行哪个系统调用；进程不会提及系统调用的名称。 系统调用号相当重要，一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用， 否则，以前编译过的代码会调用这个系统调用，但事实上却调用的是另一个系统调用。Linux 有一个“未实现”系统调用 sys_ni_syscall() 它返回 除了 -ENOSYS 外不做任何其它工作，这个错误号就是专门针对无效的系统调用而设的。虽然很罕见，但是如果一个系统调用被删除，或者变得不可用，这个函数就要负责 “填补空缺”。 内核记录了系统调用表中的所有已注册过的系统调用的列表，存储在 sys_call_table 中。每一种体系结构中，都明确定义了这个表，在 X86-64 中，它定义于 arch/i386/kernel/syscall_64.c 文件中。这个表为每一个有效的系统调用指定了唯一的系统调用号。 系统调用的性能 Linux 系统调用比其它许多系统执行的要快。Linux很短的上下文切换时间是一个重要原因，进出内核都被优化得简洁高效。另外一个原因是系统调用处理程序和 每个系统调用本身也都非常简洁。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:3","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"系统调用处理程序 用户空间的程序无法直接执行内核代码。它们不能直接调用内核空间中的函数，因为内核驻留在受保护的地址空间上。如果进程可以直接在内核的地址空间上读写的话，系统的安全性和稳定性 将不复存在。 所以，应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，希望系统切换到内核态，这样内核就可以代表应用程序在内核空间执行系统调用。 通知内核的机制是靠软中断实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理函数。此时的异常处理程序实际上就是系统调用处理程序。 在 X86 系统上预定义的软中断是中断号 128，通过 int $0x80 指令触发该中断。这条指令会触发一个异常导致系统切换到内核态并执行第 128 号 异常处理程序，而该程序正是系统调用处理程序。这个处理程序名字叫 system_call()。它与硬件体系紧密相关， x86-64 的系统上在 entry_64.S 文件 中用汇编语言编写。最近，x86 处理器增加了一条叫做 sysenter 的指令。与 int 中断指令相比，这条指令提供了更快、更专业的陷入内核执行系统调用的方式。 对这条指令的支持很快被加入内核。且不管系统调用处理程序被如何调用，用户空间引起异常或陷入内核就是一个重要的概念。 指定恰当的系统调用 因为所有的系统调用陷入内核的方式都一样，所以仅仅是陷入内核空间是不够的。因此必须把系统调用号一并传给内核。在 x86 上，系统调用号是通过 eax 寄存器传递给内核的。 在陷入内核之前，用户空间就把相应系统调用所对应的号放入 eax 中。这样系统调用处理程序一旦运行，就可以从 eax 中得到数据。其它体系结构上的实现 也都类似。 system_call()函数通过将给定的系统调用号与 NR_syscalls 做比较来检查其有效性。如果它大于或者等于 NR_syscalls，该函数就返回 -ENOSYS。 否则，就执行相应的系统调用： call* sys_call_table(,%rax,8) 由于系统调用表中的表项是以64位(8字节)类型存放的，所以内核需要将给定的系统调用号乘以 4，然后用所得的结果在该表中查询其位置。在 x86-32 系统上，代码很类似，只是用 4 代替 8 参数传递 除了系统调用号以外，大部分系统调用都还需要一些外部的参数输入。所以，在发生陷入的时候，应该把这些参数从用户空间传给内核。最简单的办法就是像传递系统调用号一样，把这些 参数也存放在寄存器里。在 x86-32 系统上， ebx、ecx、edx 和 edi 按照顺序存放前五个参数。 需要六个或六个以上参数的情况不多见，此时，应该用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。 调用系统调用处理程序以执行一个系统调用 给用户空间的返回值也通过寄存器传递。在 X86 系统上，它存放在 eax 寄存器中。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:4","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"系统调用的实现 实际上，一个 Linux 的系统调用在实现时候并不需要太关心它和系统调用处理程序之间的关系。给 Linux 添加一个新的系统调用是件相对容易的工作。 怎样设计和实现一个系统调用是难题所在，而把它加到内核里却无须太多周折。 接下来关注实现一个新的 Linux 系统调用所需的步骤。 实现系统调用 实现一个新的系统调用的第一步是决定它的用途。每个系统调用都应该有一个明确的用途，Linux中不提倡多用途的系统调用(一个系统调用通过传递不同的参数值来选择完成不同的工作)。 ioctl() 就是一个很好的例子，告诉了我们不应该去做什么。 增加新的系统调用应该考虑以下要求： 调用参数、返回值、错误码 接口力求简洁、参数尽量少 系统调用的语义和行为力求稳定，不做改动 设计接口时候尽量为将来多做考虑，系统调用设计的越通用越好(不要设想这个系统调用现在怎么用将来也一定就这么用，系统调用的目的可能不变，但用法可能改变) 系统调用的可移植性(别对机器的字节长度和字节序做假设) 记住 Unix 的格言：“提供机制而不是策略”。 参数验证 系统调用必须仔细检查它们所有的参数是否合法有效。系统调用都在内核空间执行，如果任由用户将不合法的输入传递给内核，那么系统的安全和稳定将面临极大的考验。 举例来说，与文件I/O相关的系统调用必须检查文件描述符是否有效、与进程相关的函数必须检查提供的PID是否有效，必须检查每个参数，保证它们不但合法有效，而且正确。 进程不应当让内核去访问那些无权访问的资源。 最重要的一种检查就是检查用户提供的指针是否有效，在接收一个用户空间的指针之前，内核必须保证： 指针指向的内存区域属于用户空间。进程决不能哄骗内核去读取内核空间的数据。 指针指向的内存区域在进程的地址空间里。进程决不能哄骗内核去读取其它进程的数据。 如果是读，该内存应被标记为可读；如果是写，该内存应该被标记为可写；如果是可执行，该内存被标记为可执行。进程决不能绕过内存访问限制。 内核提供了两个方法来完成必须的检查和内核空间与用户空间之间数据的来回拷贝。注意，内核无论合适都不能轻率的接收来自用户空间的指针！ 为了向用户空间写入数据，内核提供了 copy_to_user()，它需要三个参数，第一个是进程空间中的目的内存地址；第二个是内核空间内的源地址；最后 一个参数是需要拷贝的数据长度(字节数) 为了从用户空间读取数据，内核提供了 copy_from_user()，它和 copy_to_user() 相似。该函数把第二个参数指定的位置上的数据拷贝到第一个参数指定的位置上，拷贝的数据长度 由第三个参数决定。 如果执行失败，这两个函数返回的都是没能完成拷贝的数据的字节数，如果成功，则返回0.让出现上述错误时候，系统调用返回标准的 -EFAULT。 系统调用 silly_copy()中既有 copy_from_user() 又有 copy_to_user()，它毫无实际用处，让内核空间作为中转站，把用户空间的数据从一个位置复制到另一个位置 SYSCALL_DEFINE3(silly_copy, unsigned long*, src, unsigned long*, dst, unsigned long, len) { unsigned long buf; // 将用户地址空间中的 src 拷贝金 buf if (copy_from_user(\u0026buf, src, len)) return -EFAULT; // 将 buf 拷贝进用户地址空间中的 dst if (copy_to_user(dst, \u0026buf, len)) return -EFAULT; // 返回拷贝的数据量 return len; } 注意，copy_to_user()和copy_from_user()都有可能引起阻塞。当包含用户数据的页被换出到硬盘上而不是在物理内存上的时候，这种情况就会发生。此时，进程就会休眠，直到 缺页处理程序将该页从硬盘重新换回物理内存。 最后一项检查针对是否合法权限。老版本的Linux内核中，需要超级用户权限的系统调用才可以通过调用 suser() 函数这个标准动作来完成检查。这个函数智能检查 用户是否为超级用户；现在它已经被一个更细粒度的“权能”机制代替。新的系统允许检查针对特定资源的特殊权限。调用者可以使用 capable() 函数来 检查是否有权能对指定的资源进行操作，如果它返回非0值，调用这就有权进行操作，返回0则无权操作。举个例子，capable(CAP_SYS_NICE)可以检查 调用者是否有权改变其它进程的 nice 值。 下面是 reboot*() 系统调用 SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd, void __user*, arg) { char buffer[256]; if (!capable(CAP_SYS_BOOT)) return -EPERM; // 为了安全起见，我们需要 “magic” 参数 if (magic1 != LINUX_REBOOT_MAGIC1 || (magic2 != LINUX_REBOOT_MAGIC2 \u0026\u0026 magic2 != LINUX_REBOOT_MAGIC2A \u0026\u0026 magic2 != LINUX_REBOOT_MAGIC2B \u0026\u0026 magic2 != LINUX_REBOOT_MAGIC2C)) return -EINVAL; // 当未设置 pm_power_off 时候，请不要试图让 power_off 的代码看起来像是可以停机，而应该采用更简单的方式 if ((cmd == LINUX_REBOOT_CMD_POWER_OFF) \u0026\u0026 !pm_power_off) cmd = LINUX_REBOOT_CMD_HALT; lock_kernel(); switch (cmd) { case LINUX_REBOOT_CMD_RESTART: { kernel_restart(NULL); break; } case LINUX_REBOOT_CMD_CAD_ON: { C_A_D = 1; break; } case LINUX_REBOOT_CMD_CAD_OFF: { C_A_D = 0; break; } case LINUX_REBOOT_CMD_HALT: { kernel_halt(); unlock_kernel(); do_exit(0); break; } case LINUX_REBOOT_CMD_POWER_OFF: { kernel_power_off(); unlock_kernel(); do_exit(0); break; } case LINUX_REBOOT_CMD_RESTART2: { if (strncpy_from_user(\u0026buffer[0], arg,sizeof(buffer) - 1) \u003c 0) { unlock_kernel(); return -EFAULT; } buffer[sizeof(buffer) - 1] = '\\0'; kernel_restart(buffer); break; } default: { unlock_kernel(); return -EINVAL; } } unlock_kernel(); return 0; } 参见\u003clinux/capability.h\u003e，其中包含一份所有这些权能和其对应的权限的列表。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:5","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["linux"],"content":"系统调用上下文 内核在执行系统调用的时候处于进程上下文。current 指针指向当前任务，即引发系统调用的那个进程。 ","date":"2022-09-09","objectID":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/:5:6","tags":["linux","kernel","kernel-2.6.34"],"title":"Linux内核设计与实现","uri":"/2022/09/0008-linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"categories":["c\u0026c++"],"content":"智能指针的作用 在使用C/C++时候，使用指针理由之一就是希望变量在需要的时候突破作用域边界的限制。然而，实际使用中，确保“指针的寿命”和“其所指对象的寿命”一致是件很棘手的事情，特别是多个指针指向同一个对象时候。 避免上述问题的一个通常做法就是使用智能指针(smart pointer)。 自C++11起，C++标准库提供了两大类型的 smart pointer: class shared_ptr 实现共享式拥有概念。多个 smart pointer 可以指向相同对象，该对象和其相关资源会在最后一个引用被销毁时候释放。此类指针有：weak_ptr、bad_weak_ptr class unique_ptr 实现独占式拥有或严格拥有概念。保证同一时间内只有一个 smart pointer 可以指向该对象。你只可以移交拥有权。它对于避免内存泄漏(以new创建对象后忘记调用delete)特别有用。 c++98标准库中提供给了一个smart pointer: auto_ptr\u003c\u003e，其设计是为了执行现今unique_ptr的功能。但是，它缺乏现代语言特性支持，比如：“针对构造和赋值”的move语义，以及其它瑕疵，在C++11之后被正式反对使用。 所有 smart pointer 类都被定义于头文件 \u003cmemory\u003e 内。 ","date":"2022-08-29","objectID":"/2022/08/0009-c-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/:1:0","tags":["c++","smart pointer","pointer","c++11","智能指针"],"title":"C++11智能指针","uri":"/2022/08/0009-c-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"categories":["c\u0026c++"],"content":"两类智能指针的使用 ","date":"2022-08-29","objectID":"/2022/08/0009-c-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/:2:0","tags":["c++","smart pointer","pointer","c++11","智能指针"],"title":"C++11智能指针","uri":"/2022/08/0009-c-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"categories":["c\u0026c++"],"content":"class shared_ptr shared_ptr主要应用场景是 —— 同一时间在多处地点使用同一个对象实例，当最后一个对象实例不再被需要时候才释放内存资源。 顾名思义，多个 shared_ptr 共享同一个对象(多个shared_ptr指向同一个被共享的对象)，对象最后一个拥有者销毁对象时候，调用此对象的析构函数，在此之前，其它shared_ptr的销毁并不会触发对象的销毁操作(引用计数，每多一个共享对象，引用计数+1，每销毁一个对象，引用计数-1，当引用计数是0则销毁对象资源)。 如果对象以 new 产生，默认清理工作由 delete 完成，若对象以 new[] 分配，则必须由 delete[] 加以清理，当然还有其它情况，因此shared_ptr智能指针在创建时候可以定义其对象销毁的方式。 创建 shared_ptr 指针 // 1. shared_ptr\u003cstring\u003e ptr1(new string(\"shared ptr\")); // OK shared_ptr\u003cstring\u003e ptr2 = new string(\"shared ptr\"); // 错误，单一参数构造函数是 explicit shared_ptr\u003cstring\u003e ptr3{new string(\"shared ptr\")}; // OK // 2. shared_ptr\u003cstring\u003e ptr4 = make_shared\u003cstring\u003e(\"shared ptr\"); // OK // 3. shared_ptr\u003cstring\u003e ptr5; ptr5.reset(new(\"shared ptr\")); // OK ptr5 = new string(\"shared ptr\"); // 错误， 上述三种创建 shared_ptr 指针的方式，推荐使用 第二种：make_shared\u003c\u003e()。这种方式比较快、安全。 使用 shared_ptr 指针 一般使用 使用智能指针与使用普通指针是一样的，因为它重载了 operator* 和 operator-\u003e，但是 shared_ptr 不提供 operator[] 和 指针运算，因此要想访问内存，必须使用get()获得被 shared_ptr 包裹的内部指针。 smp.get()[i] = i * 42; // 等价 (\u0026*smp)[i] = i * 42; 放入容器 但凡容器，总为传入的元素创建属于容器自己的copy，直接插入string，插入的实际上是 string 的拷贝，然而放进去的是指向 string 的指针，被复制的就是指针，于是容器内涵多个“指向同一对象”的引用。 shared_ptr 对应的删除操作 程序终点处，当 string 最后一个拥有者被销毁时候，shared pointer 对其所指向的对象调用 delete。 当最后一个 shared pointer 被赋值 nullptr 时候也会使 shared pointer 对其所指向的对象调用 delete。 shared_ptr 定义自己的delete操作 auto del = [] (string* p) { count \u003c\u003c \"delete \" \u003c\u003c *p \u003c\u003c std::endl; delete p; } shared_ptr\u003cstring\u003e ptr (new string(\"shared ptr\"), del); ptr = nullptr; // 这里会导致 shared ptr 调用销毁操作 注意：shared_ptr 提供的默认 delete 操作调用的是 delete，不是 delete[]，因此，当你使用 new[] 创建的数组对象，则必须自定义shared_ptr的销毁操作，否则会造成内存泄漏。 也可以使用 unique_ptr 提供的辅助函数作为 deleter，其内调用 delete[]： std::shared_ptr\u003cint\u003e p(new int[10], std::default_delete\u003cint[]\u003e()); shared_ptr和unique_ptr以稍稍不同的方式处理deleter。例如：unique_ptr允许你只传递对应的元素类型作为模板实参，但对 shared_ptr 就不可行： std::unique_ptr\u003cint[]\u003e p(new int[10]); // OK std::shared_ptr\u003cint[]\u003e p(new int[10]); // 错误 \u003c我这边亲测可以了...\u003e 错误用法 int* p = new int; shared_ptr\u003cint\u003e sp1(p); shared_ptr\u003cint\u003e sp2(p); // 会出错，因为两个shared_ptr 都会在作用域之外释放对象`p`，导致对象被两次释放。 ","date":"2022-08-29","objectID":"/2022/08/0009-c-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/:2:1","tags":["c++","smart pointer","pointer","c++11","智能指针"],"title":"C++11智能指针","uri":"/2022/08/0009-c-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"categories":["c\u0026c++"],"content":"class weak_ptr weak_ptr 是解决shared_ptr以下两种情况下无法正常使用的问题而引入的。 环式指向： 如果两个对象使用 shared_ptr 互相指向对方，一旦不存在其它引用指向它们时候，shared_ptr 并不会自动释放资源，因为每个shared_ptr对象的use_count()仍然是1. 明确想共享对象，但并不想拥有对象的情况： 引用(引用指的是shared_ptr智能指针)的寿命比其所指对象的寿命更长，因此通过使用智能指针可以获取到其指向对象是否还有效```class weak_ptr允许你\"共享但不拥有\"某对象，一旦最末一个拥有该对象的 shared_ptr 失去了拥有权(对象释放)，任何weak_ptr` 都会自动成空(empty)。 在默认的default和copy构造函数外，class weak_ptr只提供一个shared_ptr构造函数。 注意：你不能直接使用操作符*和-\u003e访问 weak_ptr指向的对象，而是必须另外建立一个shared_pointer，原因如下： 1. 在weak pointer之外建立一个shared pointer可因此检查是否存在一个相应的对象。如果不，操作会抛出异常或建立一个空的共享指针。 2. 当指向的对象正被操作时候，shared pointer 无法被释放。 基于以上所述，class weak_ptr 只提供小量操作，只够用来创建、赋值、赋值weak pointer，以及转换为一个shared pointer，或检查自己是否指向某对象。 ","date":"2022-08-29","objectID":"/2022/08/0009-c-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/:2:2","tags":["c++","smart pointer","pointer","c++11","智能指针"],"title":"C++11智能指针","uri":"/2022/08/0009-c-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"categories":["c\u0026c++"],"content":"class unique_ptr unique_ptr 是C++标准库自 C++11 起开始提供的类型。它避免在异常发生时候造成资源泄漏。一般而言，这个 smart pointer 实现了独占式拥有概念，意味着它可能确保一个对象和其相应资源同一时间只被一个 pointer 拥有。一旦拥有者被销毁或编程empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。 class unique_ptr的目的 通常往往以下列方式运作： 获得某些资源 执行某些操作 将取得的资源是放掉 #include \u003cmemory\u003e void f () { std::unique\u003cClassA\u003e ptr(new ClassA); // 其它操作 } unique_ptr 使用 unique_ptr和寻常指针接口很相似，*用来提取指向对象；-\u003e用来访问成员；不提供++操作。 std::unique_ptr\u003cint\u003e up = new int; // 错误，不允许 std::unique_ptr\u003cint\u003e up (new int); // OK std::unique_ptr\u003cint\u003e up; // unique_ptr 不必一定拥有对象，也可以是 empty 转移unique_ptr所有权 std::move() 可以将拥有权转移给另一个 unique_ptr 不可对unique_ptr执行copy和assign，unique_ptr唯一的独占一个对象… auto_ptr使用 copy 来移交拥有权，后续不再使用 auto_ptr，这块需要了解。 源头和去处 函数可利用它们将拥有权转移给其它函数。这会发生在两种情况下： 函数是接收端。如果将一个由std::move()建立起来的unique_ptr以右值引用身份当作函数参数，那么被调用函数的参数将会取得unique_ptr的拥有权。因此，如果该函数不再转移拥有权，对象会在函数结束时候被deleted。 void sink(std::unique_ptr\u003cClassA\u003e up) { // .... } sink (std::move(up)); // up 将失去所有权 函数是供应端。当函数返回一个unique_ptr，其拥有权会转移至调用端场景内。下面的例子展示了这项技术： std::unique_ptr\u003cClassA\u003e source() { std::unique_ptr\u003cClassA\u003e ptr(new ClassA); // ptr 拥有新对象 return ptr; // 把所有权转移给函数调用者 } void g () { std::unique_ptr\u003cClassA\u003e p; for (int i = 0; i \u003c 10; ++i) { p = source(); // p 将得到返回对象的所有权 } } // 此后，p对象指向的指针将会被删除 unique_ptr被当成成员 在 class 内使用unique_ptr可避免资源泄漏，因为只有已经完全构造好的对象，其析构函数才会被调用，所以对于拥有多个指针的类，构造期间，第一个new成功而第二个new失败就可能导致资源泄漏。 class B { private: ClassA* ptr1; // 使用 std::unique_ptr\u003cClassA\u003e ptr1; ClassA* ptr2; // 使用 std::unique_ptr\u003cClassA\u003e ptr2; public: B (int val1, int val2) : ptr1(new ClassA(val1)), ptr2(new ClassA(val2)) { // 构造时候，第一个new成功，第二个new失败，则会导致内存泄漏 } ~B () { if (ptr1) delete ptr1; if (ptr2) delete ptr2; } }; 针对 array 使用unique_ptr std::unique_ptr\u003cstd::string\u003e up (new std::string[10]); // 运行时候出错，无法正确被析构 std::unique_ptr\u003cstd::string[]\u003e up(new std::string[10]); // OK std::cout \u003c\u003c *up \u003c\u003c std::endl; // 错误, * 没有针对数组的定义 ","date":"2022-08-29","objectID":"/2022/08/0009-c-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/:2:3","tags":["c++","smart pointer","pointer","c++11","智能指针"],"title":"C++11智能指针","uri":"/2022/08/0009-c-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"categories":["c\\c++"],"content":"说明 gRPC 是一款好用的 RPC 框架，它使用 protobuf 做为接口定义和底层消息交换格式。 使用 gRPC，一个客户端程序可以直接调用另一台机器上服务端程序的方法，这使的你可以很容易创建分布式程序和服务。 与大多数 RPC 框架一样，gRPC 定义一个service的方法是：指定方法、远程调用参数和返回值。在服务端这边，需要实现定义的接口，并且运行一个grpc server 去处理客户端请求；在客户端这边有一个与服务端相同方法的 stub，通过这个方法获取服务端返回值。 gRPC调用 ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:1:0","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"gRPC c++环境搭建 ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:2:0","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"环境准备 cmake autoconf libtool pkg-config 其它一些编译必须的环境 ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:2:1","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"克隆代码 git clone --recurse-submodules -b v1.46.3 --depth 1 --shallow-submodules https://github.com/grpc/grpc ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:2:2","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"下载依赖的源码 # 在源码目录执行，第一步克隆时候没有下载子项目的执行下面命令可以下载 make -j8 ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:2:3","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"编译 # 在源码目录下执行 mkdir build \u0026\u0026 cd build \u0026\u0026 cmake .. \u0026\u0026 make -j8 编译后安装: sudo make install，默认安装到/usr/local/下，而不是/usr下，所以使用时候要注意。 我这有一例子，可供参考： https://github.com/dingjingmaster/demo/tree/master/grpc 可以看 demo1/ 目录下的 Makefile ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:2:4","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"与protocol Buffers一起使用的例子 定义一个.proto文件，gRPC 提供了 proto buffer 编译插件用来产生客户端和服务端代码。使用 gRPC 通常是在客户端调用这些产生的接口并且在服务端实现这些接口。 ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:3:0","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"1. protobuf 定义 syntax = \"proto3\"; service MsgService { rpc GetMsg (MsgRequest) returns (MsgResponse) {} } message MsgRequest { string name = 1; int32 num1 = 2; double num2 = 3; } message MsgResponse { string msg = 1; int32 num1 = 2; double num2 = 3; } ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:3:1","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"2. 生成服务端代码 # makefile 里部分代码 protoc -I $(cur_dir) --grpc_out=$(cur_dir) --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` msg.proto ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:3:2","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"3. 实现服务端 继承生成服务端里的服务端类 实现在proto文件里定义的方法 绑定端口并运行 #include \u003cstring\u003e #include \u003cmemory\u003e #include \u003ciostream\u003e #include \u003cstdio.h\u003e #include \u003cgrpcpp/grpcpp.h\u003e #include \"msg.pb.h\" #include \"msg.grpc.pb.h\" using grpc::Server; using grpc::Status; using grpc::ServerBuilder; using grpc::ServerContext; class MyMsgServer final : public MsgService::Service { virtual Status GetMsg (ServerContext* ctx, const MsgRequest* req, MsgResponse* rsp) override { std::string str1 (\"Hello \"); rsp-\u003eset_msg (str1 + req-\u003ename()); rsp-\u003eset_num1 (32); rsp-\u003eset_num2 (3.1415); return Status::OK; } }; void RunServer () { std::string serverAddr(\"0.0.0.0:50000\"); MyMsgServer service; // 创建工厂类 ServerBuilder builder; // 监听端口 builder.AddListeningPort (serverAddr, grpc::InsecureServerCredentials()); // 注册服务 builder.RegisterService(\u0026service); // 创建和启动一个RPC服务器 std::unique_ptr\u003cServer\u003e server(builder.BuildAndStart()); std::cout \u003c\u003c \"server listening on \" \u003c\u003c serverAddr \u003c\u003c std::endl; server-\u003eWait(); } int main (int argc, char* argv[]) { RunServer(); return 0; } ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:3:3","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"4. 生成客户端代码 # makefile 里的部分代码 g++ $^ -L/usr/local/lib `pkg-config --with-path=$(pkg_path) --cflags --libs grpc++ protobuf` -lpthread -lgrpc++_reflection -ldl -o $@ ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:3:4","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"5. 实现客户端调用服务端 #include \u003cmemory\u003e #include \u003cstring\u003e #include \u003ciostream\u003e #include \u003cgrpcpp/grpcpp.h\u003e #include \"msg.grpc.pb.h\" using grpc::Channel; using grpc::ClientContext; using grpc::Status; class MsgClient { public: MsgClient (std::shared_ptr\u003cChannel\u003e channel) : stub_(MsgService::NewStub(channel)) { } MsgResponse GetMsg (const std::string\u0026 user, int num1, double num2) { MsgRequest request; request.set_name(user); request.set_num1(num1); request.set_num2(num2); // 服务器返回端 MsgResponse reply; ClientContext context; Status status = stub_-\u003eGetMsg(\u0026context, request, \u0026reply); if (status.ok()) { return reply; } else { std::cout \u003c\u003c status.error_code() \u003c\u003c \": \" \u003c\u003c status.error_message() \u003c\u003c std::endl; return reply; } } private: std::unique_ptr\u003cMsgService::Stub\u003e stub_; }; int main (int argc, char* argv[]) { MsgClient z_msg (grpc::CreateChannel(\"127.0.0.1:50000\", grpc::InsecureChannelCredentials())); std::string user(\"world\"); MsgResponse reply = z_msg.GetMsg(user, 234, 3.14); std::cout \u003c\u003c reply.msg() \u003c\u003c std::endl; printf (\"num1 = %d; num2 = %f\\n\", reply.num1(), reply.num2()); return 0; } ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:3:5","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"gRPC中一些概念 ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:4:0","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":".proto文件中的写法 当客户端发送一个请求到服务端并获取响应时候使用rpc定义一个方法。 rpc SayHello(HelloRequest) returns (HelloResponse); 服务器流rpc，客户机向服务器发送一个请求，来读取返回的消息序列，grpc 保证了返回数据的顺序与定义的一致。 rpc LostOfReplies(HelloRequest) returns (stream HelloResponse); 客户端流rpc，客户端发送请求后会一直等待服务端返回结果 rpc LostsOfGreetings (stream HelloRequest) returns (HelloResponse); 双向流RPCs, 双方使用读-写流发送消息。这两个流独立操作，因此客户端和服务端可以按照自己喜欢的顺序进行读写。 rpc BidiHello (stream HelloRequest) returns (stream HelloResponse); ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:4:1","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"同步与异步 同步RPC(synchronous RPC)调用会阻塞，直到服务端那边返回消息。另一方面，网络本身是异步的，在许多场景中，能够在不阻塞当前线程的情况下启动RPC是很有用的。大多数语言中的gRPC编程API有同步和异步两种形式。您可以在每种语言的教程和参考文档中找到更多信息。 ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:4:2","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"RPC生命周期 本节你将进一步了解 gRPC 客户端调用 gRPC 服务器时候会发生什么。 最简单的RPC 客户端发送一个请求并且阻塞等待一个响应。 一旦客户端调用了服务器方法，服务器会收到通知，RPC已经被调用，其中包括客户端用于该调用的元数据、方法名称和指定的截止日期(如果使用的话)。 然后服务器可以直接发送回自己的初始元数据(必须在任何响应之前发送)，或者等待客户机的请求消息。首先发生的是特定于应用程序的。 一旦服务器获得了客户机的请求消息，它就会执行创建和填充响应所需的任何工作。然后将响应连同状态详细信息和可选尾随元数据一起返回给客户机。 如果响应状态为OK，那么客户端将获得响应，从而在客户端完成调用。 服务端流式RPC 服务器流RPC类似于一元RPC，不同的是服务器返回一个消息流来响应客户端的请求。在发送完所有消息后，服务器的状态详细信息(状态代码和可选的状态消息)和可选的尾随元数据被发送给客户端。这样就完成了服务器端的处理。一旦客户端获得了服务器的所有消息，它才算执行完成了。 客户端流式RPC 客户端流RPC类似于一元RPC，不同之处是客户端向服务器发送消息流而不是单个消息。服务器响应一条消息(以及它的状态详细信息和可选的尾随元数据)通常但不一定是在它收到客户端的所有消息之后。 双向流RPC 在双向流RPC中，调用方法的客户端和接收客户端元数据、方法名称和截止日期的服务器发起调用。服务器可以选择发送回它的初始元数据，或者等待客户机开始流消息。 客户端和服务器端流处理是特定于应用程序的。由于两个流是独立的，客户端和服务器可以以任何顺序读取和写入消息。例如，服务器可以等待，直到它收到了客户端的所有消息才写入它的消息，或者服务器和客户端可以打“乒乓”——服务器获得一个请求，然后发回一个响应，然后客户端根据响应发送另一个请求，以此类推。 截止时间/超时 gRPC允许客户端指定在RPC因DEADLINE_EXCEEDED错误而终止之前，他们愿意等待多长时间来完成RPC。在服务器端，服务器可以查询查看某个特定RPC是否超时，或者还剩多少时间来完成RPC。 指定截止时间或超时是特定于语言的:一些语言api根据超时(时间持续时间)工作，而一些语言api根据截止时间(一个固定的时间点)工作，可能有也可能没有默认的截止时间。 RPC终止 在gRPC中，客户端和服务器端对调用的成功与否进行独立的、本地的判断，其结论可能不匹配。这意味着，例如，您可能有一个RPC在服务器端成功完成(“我已经发送了我所有的响应!”)，但在客户端失败(“响应在我的截止日期之后到达!”)。服务器也可能在客户端发送所有请求之前决定是否完成。 取消一个RPC 客户端或服务器都可以在任何时候取消RPC。取消操作会立即终止RPC，这样就不会完成进一步的工作。 取消之前所做的更改不会回滚 元数据 元数据是关于特定RPC调用的信息(如身份验证细节)，形式为键值对列表，其中键是字符串，值通常是字符串，但也可以是二进制数据。 键由ASCII字母、数字和特殊字符-、_、组成，不区分大小写。并且不能以grpc-开头(这是为grpc本身保留的)。二进制值的键以-bin结尾，而ascii值的键则不是。 元数据对于gRPC本身是不透明的—它允许客户端提供与服务器调用相关的信息，反之亦然。 对元数据的访问依赖于语言 Channels(通道) gRPC通道用于连接指定主机和端口的gRPC服务器。它在创建客户端存根时使用。客户端可以指定通道参数来修改gRPC的默认行为，例如打开或关闭消息压缩。通道有状态，包括连接状态和空闲状态。 gRPC如何关闭通道取决于语言。有些语言还允许查询通道状态。 ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:4:3","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"异步(Async)接口 此节使用 gRPC 的异步/非阻塞 api，用C++编写一个简单的服务器和客户端。 gRPC使用 CompletetionQueue API 进行异步操作，基本流程如下： 绑定COmpletionQueue到RPC调用 做一些读/写操作，呈现一个唯一的void*标记 调用CompletionQueue::Next来等待操作完成，如果出现标记，则表示响应操作完成。 ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:5:0","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"异步客户端 要使用异步客户端调用远程方法，首先创建通道和存根，就像在同步客户端中所做的那样。一旦你有了你的存根，你做以下事情来进行异步调用: 启动RPC并为其创建句柄。将RPC绑定到CompletionQueue CompletionQueue cq; std::unique_ptr\u003cClientAsyncResponseReader\u003cHelloReply\u003e \u003e rpc(stub_-\u003eAsyncSayHello(\u0026context, request, \u0026cq)); 使用唯一标签询问回复和最终状态 Status status; rpc-\u003eFinish(\u0026reply, \u0026status, (void*)1); 等待完成队列返回下一个标记，一旦返回传递给相应Finish()调用的标记，应答和状态就就绪了。 void* got_tag; bool ok = false; cq.Next(\u0026got_tag, \u0026ok); if (ok \u0026\u0026 got_tag == (void*)1) { // check reply and status } ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:5:1","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"异步服务端 服务器实现请求一个带有标记的RPC调用，然后等待完成队列返回标记。异步处理RPC的基本流程是: 构建导出异步服务的服务器 helloworld::Greeter::AsyncService service; ServerBuilder builder; builder.AddListeningPort(\"0.0.0.0:50051\", InsecureServerCredentials()); builder.RegisterService(\u0026service); auto cq = builder.AddCompletionQueue(); auto server = builder.BuildAndStart(); 请求一个RPC，提供一个惟一的标记 ServerContext context; HelloRequest request; ServerAsyncResponseWriter\u003cHelloReply\u003e responder; service.RequestSayHello(\u0026context, \u0026request, \u0026responder, \u0026cq, \u0026cq, (void*)1); 等待完成队列返回标记。一旦检索到标记，上下文、请求和响应程序就准备好了 HelloReply reply; Status status; void* got_tag; bool ok = false; cq.Next(\u0026got_tag, \u0026ok); if (ok \u0026\u0026 got_tag == (void*)1) { // set reply and status responder.Finish(reply, status, (void*)2); } 等待完成队列返回标记。返回标签后，RPC就完成了 void* got_tag; bool ok = false; cq.Next(\u0026got_tag, \u0026ok); if (ok \u0026\u0026 got_tag == (void*)2) { // clean up } 然而，这个基本流没有考虑服务器并发处理多个请求的情况。为了处理这个问题，我们的完整异步服务器示例使用一个CallData对象来维护每个RPC的状态，并使用这个对象的地址作为调用的唯一标记。 class CallData { public: // Take in the \"service\" instance (in this case representing an asynchronous // server) and the completion queue \"cq\" used for asynchronous communication // with the gRPC runtime. CallData(Greeter::AsyncService* service, ServerCompletionQueue* cq) : service_(service), cq_(cq), responder_(\u0026ctx_), status_(CREATE) { // Invoke the serving logic right away. Proceed(); } void Proceed() { if (status_ == CREATE) { // As part of the initial CREATE state, we *request* that the system // start processing SayHello requests. In this request, \"this\" acts are // the tag uniquely identifying the request (so that different CallData // instances can serve different requests concurrently), in this case // the memory address of this CallData instance. service_-\u003eRequestSayHello(\u0026ctx_, \u0026request_, \u0026responder_, cq_, cq_, this); // Make this instance progress to the PROCESS state. status_ = PROCESS; } else if (status_ == PROCESS) { // Spawn a new CallData instance to serve new clients while we process // the one for this CallData. The instance will deallocate itself as // part of its FINISH state. new CallData(service_, cq_); // The actual processing. std::string prefix(\"Hello \"); reply_.set_message(prefix + request_.name()); // And we are done! Let the gRPC runtime know we've finished, using the // memory address of this instance as the uniquely identifying tag for // the event. responder_.Finish(reply_, Status::OK, this); status_ = FINISH; } else { GPR_ASSERT(status_ == FINISH); // Once in the FINISH state, deallocate ourselves (CallData). delete this; } } } 为简单起见，服务器只对所有事件使用一个完成队列，并在HandleRpcs中运行一个主循环来查询该队列: void HandleRpcs() { // Spawn a new CallData instance to serve new clients. new CallData(\u0026service_, cq_.get()); void* tag; // uniquely identifies a request. bool ok; while (true) { // Block waiting to read the next event from the completion queue. The // event is uniquely identified by its tag, which in this case is the // memory address of a CallData instance. cq_-\u003eNext(\u0026tag, \u0026ok); GPR_ASSERT(ok); static_cast\u003cCallData*\u003e(tag)-\u003eProceed(); } } ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:5:2","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"关闭服务器 我们一直在使用一个完成队列来获得异步通知。在关闭服务器之后，必须小心关闭它。 记住，我们在ServerImpl::Run()中通过运行cq_ = builder.AddCompletionQueue()获得了完成队列实例cq_。看ServerBuilder::AddCompletionQueue的文档，我们看到 调用者需要在关闭返回的完成队列之前关闭服务器 更多细节请参考ServerBuilder::AddCompletionQueue的完整文档字符串。在我们的例子中，这意味着ServerImpl的析构函数是这样的: ~ServerImpl() { server_-\u003eShutdown(); // Always shutdown the completion queue after the server. cq_-\u003eShutdown(); } ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:5:3","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"ALTS 身份验证 c++中使用应用层传输安全(ALTS)的gRPC认证。 ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:6:0","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"概述 ALTS (Application Layer Transport Security)是谷歌开发的一种双向认证和传输加密系统。它用于保护谷歌基础架构内的RPC通信。ALTS类似于相互TLS，但经过了设计和优化，以满足谷歌的生产环境的需求。要了解更多信息，请查看ALTS白皮书。 gRPC中的ALTS具有以下特点: 创建gRPC服务器和客户端，使用ALTS作为传输安全协议 ALTS连接端到端受到隐私和完整性保护 应用程序可以访问对等信息，如对等服务帐户 客户端授权和服务器授权支持 最小的代码更改来启用ALTS gRPC用户可以配置他们的应用程序，使用ALTS作为传输安全协议，只需要几行代码。 注意，如果应用程序运行在谷歌云平台上，那么ALTS是完全有效的。通过可插拔的ALTS握手器服务，ALTS可以在任何平台上运行。 ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:6:1","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"使用ALTS传输安全协议的gRPC客户端 gRPC客户端可以使用ALTS凭证连接到服务器，如下所示的代码摘录: #include \u003cgrpcpp/grpcpp.h\u003e #include \u003cgrpcpp/security/credentials.h\u003e using grpc::experimental::AltsCredentials; using grpc::experimental::AltsCredentialsOptions; auto creds = AltsCredentials(AltsCredentialsOptions()); std::shared_ptr\u003cgrpc::Channel\u003e channel = CreateChannel(server_address, creds); ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:6:2","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"使用ALTS传输安全协议的gRPC服务器 gRPC服务器可以使用ALTS凭证来允许客户端连接到它们，如下图所示: #include \u003cgrpcpp/security/server_credentials.h\u003e #include \u003cgrpcpp/server.h\u003e #include \u003cgrpcpp/server_builder.h\u003e using grpc::experimental::AltsServerCredentials; using grpc::experimental::AltsServerCredentialsOptions; grpc::ServerBuilder builder; builder.RegisterService(\u0026service); auto creds = AltsServerCredentials(AltsServerCredentialsOptions()); builder.AddListeningPort(\"[::]:\u003cport\u003e\", creds); std::unique_ptr\u003cServer\u003e server(builder.BuildAndStart()); ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:6:3","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"服务器授权 gRPC内置了使用ALTS的服务器授权支持。使用ALTS的gRPC客户端可以在建立连接之前设置预期的服务器服务帐户。然后，在握手结束时，服务器授权保证服务器标识与客户机指定的服务帐户之一匹配。否则连接失败。 #include \u003cgrpcpp/grpcpp.h\u003e #include \u003cgrpcpp/security/credentials.h\u003e using grpc::experimental::AltsCredentials; using grpc::experimental::AltsCredentialsOptions; AltsCredentialsOptions opts; opts.target_service_accounts.push_back(\"expected_server_service_account1\"); opts.target_service_accounts.push_back(\"expected_server_service_account2\"); auto creds = AltsCredentials(opts); std::shared_ptr\u003cgrpc::Channel\u003e channel = CreateChannel(server_address, creds); ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:6:4","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["c\\c++"],"content":"客户端授权 在一个成功的连接上，对等信息(例如，客户端的服务帐户)被存储在AltsContext中。gRPC为客户端授权检查提供了一个实用程序库。假设服务器知道预期的客户机标识(例如foo@iam.gserviceaccount.com)，它可以运行以下示例代码来授权传入的RPC。 #include \u003cgrpcpp/server_context.h\u003e #include \u003cgrpcpp/security/alts_util.h\u003e grpc::ServerContext* context; grpc::Status status = experimental::AltsClientAuthzCheck( context-\u003eauth_context(), {\"foo@iam.gserviceaccount.com\"}); ","date":"2022-08-01","objectID":"/2022/08/0007-grpc-c-hello-world/:6:5","tags":["c++","grpc"],"title":"gRPC C++ 例子","uri":"/2022/08/0007-grpc-c-hello-world/"},{"categories":["linux"],"content":" 列数 含义 1 设备名 2 挂载点 3 文件系统格式(比如:ext, ext2, msdos, iso9660, nfs, swap), 字段来源:/proc/filesytems 4 挂载参数，详细看 man mount，不同文件系统挂载参数可能不同。常见参数:auto: 系统自动挂载;defaults: rw,suid,dev,exec,auto,nousernoauto:开机不自动挂载;nouser: 只有超级用户可以挂载;ro: 只读挂载; rw: 读写挂载; user: 任何用户都可挂载; 注意: 光驱和软驱只有再装有介质时候才能挂载，因此它是noauto 5 转储参数(0: 不备份; 1: 要备份，一般根分区都要备份) 6 自检顺序(0: 不自检; 1和2都是要自检，根分区一定设为1,其它分区要自检只能是2)，数字越小越先检查，数字相同则同时检查 ","date":"2022-08-01","objectID":"/2022/08/0011-linux-fstab%E9%85%8D%E7%BD%AE%E6%AF%8F%E5%88%97%E5%90%AB%E4%B9%89/:0:0","tags":["linux","fstab"],"title":"Linux Fstab配置每列含义","uri":"/2022/08/0011-linux-fstab%E9%85%8D%E7%BD%AE%E6%AF%8F%E5%88%97%E5%90%AB%E4%B9%89/"},{"categories":["linux"],"content":"从 windows 换成 linux 之后发现 vmware 在linux 下运行很卡，于是考虑使用 qemu，图形界面开源安装 virt-manager 方便使用，而 vmware 的虚拟磁盘用的是 vmdk， 需要转为qemu支持的 qcow2。 使用 qemu-img 完成 vmdk 转 qcow2 qemu-img convert -f vmdk \u003c此处写vmware虚拟磁盘 xxx.vmdk 文件路径\u003e -O qcow2 \u003c此处写转换后要保存的 qemu 虚拟文件路径\u003e 亲测原先vmware装的linux虚拟机可以很容易转成功，但是vmware虚拟机是windows10转换后没办法引导，以后解决引导问题再补充。 ","date":"2022-07-24","objectID":"/2022/07/0009-vmware%E8%BD%ACqemu/:0:0","tags":["linux","qemu","vmware"],"title":"Vmware转qemu","uri":"/2022/07/0009-vmware%E8%BD%ACqemu/"},{"categories":["linux"],"content":" 确定linux是否有nbd模块 modinfo nbd 插入nbd 模块 sudo modprobe nbd 使用qemu-nbd 工具关联 qcow2 文件和 nbd 设备节点 sudo qemu-nbd -c /dev/nbd0 \u003cqcow2的路径\u003e 通过/dev/nbd0px按需挂载 qcow2 设备 最后 卸载设备 sudo qemu-nbd -d /dev/nbd0 ","date":"2022-07-24","objectID":"/2022/07/0010-linux%E6%8C%82%E8%BD%BDqcow2/:0:0","tags":["linux","qcow2","kvm"],"title":"Linux挂载qcow2","uri":"/2022/07/0010-linux%E6%8C%82%E8%BD%BDqcow2/"},{"categories":["apache"],"content":"tika 是什么 Apache Tika 用于文件类型检测和从各种格式的文件内容提取的库。在内部，Tika使用现有的各种文件解析器和文档类型的检测技术来检测和提取数据。使用Tika，人们可以开发出通用型检测器和内容提取到的不同类型的文件，如电子表格，文本文件，图像，PDF文件甚至多媒体输入格式，在一定程度上提取结构化文本以及元数据。 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:1:0","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika 特点 支持上千种不同的文件类型 提供了多种实用工具，如tika-app, tika-server等 除了Java，还提供了其他编程语言的调用，如Julia，Python 扩展性很好，支持自定义文件类型和解析器 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:2:0","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika 组成 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:0","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-core tika-core是tika的核心，提供了文件类型检测，语言检测，以及解析器框架。tika-core并不包含具体的解析器，而是提供了一个api，实际的解析器实现放在tika-parsers中。 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:1","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-parsers 解析文件 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:2","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-app tika-app包含了tika核心类库和它的相关依赖，提供了命令行工具和图形用户界面，可以在脚本中使用，并支持管道。 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:3","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-server 一个restful服务，方便和现有应用系统集成: $ curl -X PUT --data-binary @GeoSPARQL.pdf http://localhost:9998/tika --header \"Content-type: application/pdf\" $ curl -T price.xls http://localhost:9998/tika --header \"Accept: text/html\" ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:4","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-bundle 一个OSGi bundle，方便和基于OSGi的应用系统集成 OSGi: 开放服务网关协议，支持模块的动态加载，热拔插，可以在不停机的情况下，让应用程序加载新的模块，并提供新的服务 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:5","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-eval 一个命令行工具，可以批量解析文件，然后把结果保存到数据库，支持多种类型的数据库，如h2，mysql…，默认数据库为h2，使用其他类型的数据库需要在启动时将相关的依赖放到classpath下 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:6","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika 设计与实现 tika的核心功能是文件内容分析，这里分析主要有两个含义，一是提取文件的元数据(Metadata)，包括文件类型，版本，作者，编辑工具，压缩算法等；二是解析文件得到文本内容(Text)，这里的文本是指在相应的阅览软件中打开文件时看到的内容。 为了实现上述目标，tika设计了一个扩展性极强的框架，主要包括文件类型检测和内容解析两个部分。首先判断文件类型(Detector)，再根据文件类型选用适当的解析器(Parser)，解析结果保存在Metadata和ContentHandler中，我们可以通过自定义ContentHandler来得到想要的信息。 tika ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:4:0","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["c\u0026c++"],"content":"ProtoBuf 简介 ProtoBuf(Protocol Buffers) 是 Google 用于实现序列化与反序列化的开源项目，支持多语言、跨平台、可扩展的用于结构化数据的解决方案。 目前常见的序列化、反序列化方法包括但不限于以下几种： JSON XML ProtoBuf Boost Serialization ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:1:0","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"ProtoBuf 数据结构 proto文件消息类型 C++ 类型 说明 double double 双精度浮点型 float float 单精度浮点型 int32 int32 使用可变长编码方式，负数时不够高效，应该使用sint32 int64 int64 同上 uint32 uint32 使用可变长编码方式 uint64 uint64 同上 sint32 int32 使用可变长编码方式，有符号的整型值，负数编码时比通常的int32高效 sint64 sint64 同上 fixed32 uint32 总是4个字节，如果数值总是比2^28大的话，这个类型会比uint32高效 fixed64 uint64 总是8个字节，如果数值总是比2^56大的话，这个类型会比uint64高效 sfixed32 int32 总是4个字节 sfixed64 int64 总是8个字节 bool bool string string 一个字符串必须是utf-8编码或者7-bit的ascii编码的文本 bytes string 可能包含任意顺序的字节数据 ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:2:0","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":".proto 文件 关键字 说明 syntax 指定proto语言版本 option 修改配置选项 service 声明一个服务 rpc 声明一个方法 resturns 方法的返回值 message 定义一个消息类型 repeated 数组 stream 用流来交互 ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:3:0","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"一些例子 指定一个版本 syntax = \"proto3\" 定义一个服务和方法 service TestService { rpc testMethod(Request) returns (Result) {} } message Request { } message Result { } ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:3:1","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"ProtoBuf使用一般步骤 ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:4:0","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"1. 定义proto文件 proto文件中就是定义了我们需要存储或传输的数据结构/传输协议 proto文件的定义主要分为两部分： 为每一个需要序列化的数据结构添加一个消息(message)。 为消息(message)中的每一个字段(field)指定一个名字、类型和修饰符以及唯一标识(tag)。 其中每一个消息对应到C++就是一个类，嵌套消息对应的就是嵌套类。 另外，一个proto文件中可以定义多个消息，就像一个头文件中可以定义多个类一样。 // [START declaration] syntax = \"proto3\"; package tutorial; import \"google/protobuf/timestamp.proto\"; // [END declaration] // [START java_declaration] option java_multiple_files = true; option java_package = \"com.example.tutorial.protos\"; option java_outer_classname = \"AddressBookProtos\"; // [END java_declaration] // [START csharp_declaration] option csharp_namespace = \"Google.Protobuf.Examples.AddressBook\"; // [END csharp_declaration] // [START go_declaration] option go_package = \"github.com/protocolbuffers/protobuf/examples/go/tutorialpb\"; // [END go_declaration] // [START messages] message Person { string name = 1; int32 id = 2; // Unique ID number for this person. string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { string number = 1; PhoneType type = 2; } repeated PhoneNumber phones = 4; google.protobuf.Timestamp last_updated = 5; } // Our address book file is just one of these. message AddressBook { repeated Person people = 1; } // [END messages] package 声明：.proto 文件以一个 package 声明开始，这个声明是为了防止不同项目之间的命名冲突，对应到 c++ 中，这个 .proto 文件生成的类将被放置在一个与package名相同的命名空间中。 字段类型：定义 message 时候，一个 message 就是某些类型字段的集合。具体支持的字段类型见：字段类型 修饰符：每个字段都必须用以下之一的修饰符来修饰： 修饰符 含义 required 必须提供字段值，否则对应的消息会被认为是\"未初始化“的。注意：解析\"未初始化\"的消息会导致失败。 optional 字段值指定与否都可以，它是每个字段默认值。调用时候没有指定message的字段值，会自动使用默认值：string默认值是空字符串；int默认值是0 repeated 字段会重复N次(N可以是0)，重复值的顺序会被保存在ProtoBuf中注意：可以把重复字段视为数组。 唯一编号：每个消息中的每个字段都有唯一的编号，字段后边的=1、=2等。这些字段编号用于标识消息二进制中的字段，并且在使用消息类型后不应该再更改。注意：1 ~ 15 中的字段需要一个字节进行编码，包括字段编号和字段类型。16 ~ 2047 中的字段编号需要两个字节。所以保留 1 - 15 作为非常频繁出现的消息元素，也要注意为将来可能频繁出现的消息元素预留位置。 可以指定的最小字段编号为：1，最大字段编号：$2^{29}-1$ 或 536 870 911。 也不能使用数字19 000 到 19 999，他们是 protobuf 保留的。 ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:4:1","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"2. 编译proto文件 protoc --cpp_out=/data/code/demo/protobuf/c++ -I/data/code/demo/protobuf/c++ xxx.proto 其中： --cpp_out=\u003cdir\u003e 表示生成代码输出到的指定文件夹 -I\u003cdir\u003e 表示在哪个文件夹下寻找 xxx.proto 文件 xxx.proto 就是我们写好的 .proto 文件 完整例子 注意：如果编译上述例子出错，则可以重新编译安装 protobuf，几乎没有依赖，克隆源码就可编译安装。 亲测我的 archlinux 使用包管理器安装的 protobuf 是不能用的。 编译 protobuf 源码具体步骤如下： 克隆源码：https://github.com/protocolbuffers/protobuf.git 进入源码目录执行安装：./autogen.sh \u0026\u0026 ./configure --prefix=/usr \u0026\u0026 make -j8 \u0026\u0026 sudo make install ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:4:2","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"3. 使用生成的代码来读写消息 // [1] 验证版本 GOOGLE_PROTOBUF_VERIFY_VERSION; // [2] 根据 protobuf 中 message 生成的对象 test1::Response p1; p1.set_data(\"data\"); p1.set_status(1); cout \u003c\u003c \"=================================\\n\"; cout \u003c\u003c \"p1.data: \" \u003c\u003c p1.data() \u003c\u003c \"\\n\" \u003c\u003c \"p1.status: \" \u003c\u003c p1.status() \u003c\u003c \"\\n\"; // [3] 执行序列化 // 注意：序列化之后可以用 p1.DebugString(); 来查看序列化字符串 cout \u003c\u003c \"serialize string:\" \u003c\u003c p1.SerializeAsString() \u003c\u003c \"\\n\"; cout \u003c\u003c \"=================================\\n\"; // [4] 反序列化 // 反序列化之前也可以使用 DebugString() 来查看要反需列化的字符串是否正确 // 反序列化 bool ParseFromString(const string\u0026 data); // [5] 释放 protobuf 相关内存 google::protobuf::ShutdownProtobufLibrary(); 序列化与反序列化过程中尽量保证使用 char* 或 std::string 来接收数据。 亲测QString参与会导致反序列化失败。 完整例子 ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:4:3","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["git"],"content":"问题描述 电脑使用了clash代理工具，配好环境之后浏览器可以访问谷歌和github，但是终端无法推送代码到github ","date":"2022-07-19","objectID":"/2022/07/0003-linux%E7%BB%88%E7%AB%AFgit%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/:1:0","tags":["git"],"title":"Linux终端git无法联网","uri":"/2022/07/0003-linux%E7%BB%88%E7%AB%AFgit%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/"},{"categories":["git"],"content":"解决方法 打开终端执行如下命令： git config --global http.proxy 'sockets5://127.0.0.1:7891' git config --global https.proxy 'sockets5://127.0.0.1:7891' # 或者 git config --global http.proxy 'http://127.0.0.1:7890' git config --global https.proxy 'https://127.0.0.1:7890' 具体看使用啥代理方式 ","date":"2022-07-19","objectID":"/2022/07/0003-linux%E7%BB%88%E7%AB%AFgit%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/:2:0","tags":["git"],"title":"Linux终端git无法联网","uri":"/2022/07/0003-linux%E7%BB%88%E7%AB%AFgit%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/"},{"categories":["c\u0026c++"],"content":"原理 Linux 允许让我们自己的动态库加载在其它动态库之前，甚至是系统库(libc.so.6)，如此我们可以通过自己实现动态库并提前加载来拦截系统调用。 具体例子参看: https://github.com/dingjingmaster/demo/tree/master/syscall/dlopen 编译之后根据Makefile提示设置环境变量，然后在终端内执行任何包含读写操作的命令，都会有相关打印输出。 ","date":"2022-07-12","objectID":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/:1:0","tags":["linux","c"],"title":"用户空间拦截系统调用","uri":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"},{"categories":["c\u0026c++"],"content":"实现过程 通过 dlopen() 打开动态库 使用 dlsym() 确对应系统调用的地址 自定义系统调用(自定义函数名并保证函数类型与系统调用一致)，可以在自定义函数中实现系统调用拦截操作 将以上代码打包成动态库并编译为 xxx.so 当前终端配置环境变量: export LD_PRELOAD=/path/to/xxx.so 在当前终端执行包含要拦截系统调用的命令 ","date":"2022-07-12","objectID":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/:2:0","tags":["linux","c"],"title":"用户空间拦截系统调用","uri":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"},{"categories":["c\u0026c++"],"content":"以拦截 open() read() 系统调用为例 动态库源码 #include \u003cstdio.h\u003e #include \u003cdlfcn.h\u003e #include \u003cstdarg.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003cstdbool.h\u003e void* libc_handle = NULL; int (*open_ptr) (const char*, int) = NULL; int (*close_ptr) (int) = NULL; ssize_t (*read_ptr) (int, void*, size_t) = NULL; static bool inited = false; _Noreturn void die (const char* fmt, ...) { va_list va; va_start (va, fmt); vprintf (fmt, va); _exit (0); } static void find_original_function () { if (inited) return; printf (\"libc path: %s\\n\", LIBC); libc_handle = dlopen (LIBC, RTLD_LAZY); if (libc_handle == NULL) { die (\"cannot open libc.so\\n\"); } open_ptr = dlsym (libc_handle, \"open\"); if (open_ptr == NULL) { die (\"cannot find open()\\n\"); } close_ptr = dlsym (libc_handle, \"close\"); if (close_ptr == NULL) { die (\"cannot find close()\\n\"); } read_ptr = dlsym (libc_handle, \"read\"); if (read_ptr == NULL) { die (\"cannot find read()\\n\"); } inited = true; } int open (const char* pathName, int flag) { find_original_function(); printf (\"start open()\\n\"); int fd = (*open_ptr) (pathName, flag); printf (\"end open()\\n\"); return fd; } int close (int fd) { find_original_function(); printf (\"start close()\\n\"); int ret = (*close_ptr) (fd); printf (\"end close()\\n\"); return ret; } ssize_t read (int fd, void* buf, size_t count) { find_original_function(); printf (\"start read()\\n\"); ssize_t ret = (*read_ptr) (fd, buf, count); printf (\"end read()\\n\"); return ret; } 编译成动态库 gcc -fpic -shared -Wall -o dlopen-shared-lib.so dlopen-shared-lib.c -ldl -DLIBC=\\\"`find /usr/lib -name \"libc.so.6\"`\\\" 通过uptime命令验证 LD_PRELOAD=$PWD/dlopen-shared-lib.so \u0026\u0026 export LD_PRELOAD \u0026\u0026 uptime uptime 命令会读取 /proc/uptime 文件 ","date":"2022-07-12","objectID":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/:3:0","tags":["linux","c"],"title":"用户空间拦截系统调用","uri":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"},{"categories":["linux"],"content":"BPF与eBPF是什么 BPF(Berkeley Packet Filter)，伯克利数据包过滤器，这项技术诞生于 1992 年，其作用是提升网络包过滤工具的性能，2014年正式加入Linux内核主线。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:0","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 作用 BPF 提供了一种在各种内核事件和应用程序事件发生时候运行一段小程序的机制。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:1","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 组成 BPF 由指令集、存储对象、辅助函数等几部分组成 BPF 采用虚拟指令规范，因此也将它视为一种虚拟机实现，BPF 指令由 linux 内核中的运行时模块执行。 BPF 运行时的两种执行机制：1. 解释器；2. 将BPF指令动态转换为本地化指令的即时(JIT)编译器 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:2","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 执行 在实际执行之前，BPF 指令必须先通过验证器的安全性检查，以确保 BFP 程序自身不会崩溃或者损坏内核 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:3","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 应用领域 网络 客观测性 安全 扩展后的 BPF 就是 eBPF ，官方的 BPF 不带 e，实际上指的就是 eBPF ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:4","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"名词: 跟踪、嗅探、采样、剖析、可观测性 跟踪(嗅探) 跟踪是基于事件的记录，这也是 BPF 工具所使用的监测方式。比如：strace 可以记录和打印系统调用事件的信息；top 使用固定的计数器统计监测事件的频次。 跟踪工具的一个显著标志是，它具备记录原始事件和事件元数据的能力，既可以是直接输出原始事件，也可以是统计原始事件的频次。 嗅探(跟踪) 嗅探实际上和跟踪指的是一回事，嗅探更多的适用于solaris系统上的跟踪工具 采样 采样工具通过获取全部管测量的子集来描绘目标的大致图像，这也被称为 生成性能剖析样本 或 profiling。比如：profile命令，它基于计时器来对运行中的代码定时采样(每隔10s采样一次)。 采样工具的优点是：其性能开销比跟踪工具小 缺点是：它只提供大致画像，会遗漏事件 可观测性 可观测性指通过全面观测来理解一个系统，可以实现这一目标的工具就可以归纳为可观测性工具。 可观测性工具包括：跟踪工具、采样工具、基于固定计数器的工具。 可观测性工具不包括基准测量工具(benchmark)，基准测量工具在系统上模拟业务负载，会更改系统的状态。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:5","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"编写 BPF 程序(BCC、bpftrace) 直接编写 BPF 程序是繁琐的，在跟踪用途方面，可以使用支持高级语言的 BPF 前端编写 BPF 程序——BCC和bpftrace BPF编译集合(BPF Compiler Collection, 即BCC) BCC 是最早用于开发 BPF 跟踪程序的高级框架。它提供了一个编写内核 BPF 程序的 C 语言环境，同时还提供了其它高级语言(如：Python、Lua和C++)环境来实现用户端接口。它也是 libbcc 和 libbpf 库的前身，这两个库提供了使用 BPF 程序对事件进行观测的库函数。 BCC 源代码库中提供了 70 多个 BPF 工具，可以用来支持性能分析和排障工作。 BCC 适合开发复杂的脚本和作为后台进程使用，它还可以调用其它库的支持。比如：使用python开发的BCC程序，还使用python的argparse库来提供复杂、惊喜的工具命令行参数支持。 bpftrace bpftrace 是新近出现的前端，也是基于 libbcc 和 libbpf 库进行构建的。 bpftrace 适合编写功能强大的单行程序、短小的脚本。 bpftrace 和 BCC 可以互补使用 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:6","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"IO Visor BCC 和 bpftrace 不在内核代码仓库中，而是属于 IO Visor 的 Linux 基金会项目 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:7","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 跟踪的能见度 BPF 跟踪可以在整个软件栈范围内提供能见度，允许我们随时根据需要开发新的工具和监测功能。 在生产环境中可以立即部署 BPF 跟踪程序，不需要重启系统，也不需要以特殊方式重启应用软件。 下图展示了一个通用的系统软件栈，用相应的 BPF 性能工具对各个部分进行了标记。工具基本来自 BCC 和 bpftrace。 BPF 工具对应的通用系统软件栈 下图列出传统工具与 BPF 工具对组建监测的支持情况 组件 传统分析工具 BPF跟踪 基于语言运行时开发的应用程序:Java、Nodee.js、Ruby、PHP 运行时调试器 是，在运行时支持的情况下 基于编译型代码开发的应用程序:C、C++、Golang 系统调试器 是 系统库:/lib/* ltrace(1) 是 系统调用接口 strace(1)、perf(1) 是 内核:调度器、文件系统、TCP、IP等 用于采样的perf(1) 是，更加详尽 硬件:CPU核心、设备 perf、sar、/proc计数器 是，直接或间接(BPF无法直接对设备上的固件进行观测，可以通过对内核驱动事件或者性能监测计数器PMC进行跟踪，间接推断相关行为) 传统工具提供的信息可以作为性能分析的起点，后续则可以通过 BPF 跟踪工具做更加深入的调查 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:8","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"动态插桩: kprobes 和 uprobes 动态插桩技术(也叫动态跟踪技术)——在生产环境中对正在运行的软件插入观测点的能力，具体插桩的函数可以是软件栈中运行函数的任意一个(在内核函数或应用函数的开始或结束位置进行插桩)。 动态插桩技术是2012年在Linux上开始支持，具体使用例子如下: 探针 描述 kprobe:vfs_read 在内核函数vfs_read()的开始位置进行插桩 kretprobe:vfs_read 在内核函数vfs_read()的返回位置处进行插桩 uprobe:/bin/bash:readline 在/bin/bash程序中的readline()函数开始位置进行插桩 uretprobe:/bin/bash:readline 在/bin/bash程序中的readline()函数返回位置进行插桩 未启用时候动态插桩开销为0。 动态插桩有一点不好：随着软件版本的变更，被插桩的函数有可能被重新命名，或者移除，导致 BPF 无法正常工作，或者可能打印出一写错误信息；另一个问题是编译器启动优化，把某些函数做内联处理，使得这些函数无法做动态插桩。以上问题，使用静态插桩技术解决。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:9","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"静态插桩 tracepoint和USDT 静态插桩将稳定的事件名字编码到软件代码中，由开发者维护。BPF 跟踪工具支持内核的静态跟踪点插桩技术，也支持用户态的静态定义跟踪插桩技术USDT(user level statically defined tracing)。 静态插桩问题：增加开发者维护成本，因此软件中的静态插桩要数量有限。 除非需要自己开发 BPF 工具，否则上边提到的静态插桩、动态插桩细节无须关注。如果确实要开发 BPF 工具，一个推荐的策略是：首先尝试静态跟踪技术(跟踪点或USDT)，如果不够的话再使用动态跟踪技术(kprobes或uprobes)。 下边是 bpftrace 用到的跟踪点和USDT例子 探针 描述 tracepoint:syscalls:sys_enter_open 对open(2)系统调用进行插桩 usdt:/usr/sbin/mysqld:mysql:query_start 对/usr/sbin/mysqld程序中的query_start探针进行插桩 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:10","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"例子 bpftrace跟踪open() bpftrace -e 'tracepoint:syscalls:sys_enter_open {printf(\"%s %s\\n\", comm, str(args-\u003efilename));}' 输出结果打印了进程的名字和传递给 open(2) 系统调用的文件名: bpftrace 是全系统层面的跟踪，因此任何调用了 open(2) 的应用都能覆盖。 BPF 程序被定义在单引号所包围的代码内，当敲击Enter键运行bpftrace命令时候，它会立即被编译并且运行。 当然 open() 函数还有其它变体，比如：openat()，可以使用如下命令列出所有与open系统调用相关的跟踪点 # -l 和通配符 一起使用，列出所有与 open 系统调用相关的跟踪点 bpftrace -l 'tracepoint:syscalls:sys_enter_open*' # open() 及其变体的使用频率 bpftrace -e 'tracepoint:syscalls:sys_enter_open* {@[probe] = count();}' ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:11","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 技术原理 BPF 技术原理 BPF 程序使用 BPF字节码(BPF虚拟机的指令集)定义过滤表达式，然后传递给内核，由解释器执行，无须数据包复制。 BPF 提供了安全保障，用户自定义的过滤器在执行前必须先通过安全性验证，且必须在内核空间执行。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:2:0","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"早期BPF和扩展版BPF 1997年进入Linux2.1.75：最初BPF被称为“经典BPF”，它是一个功能有限的虚拟机。 2011年7月Linux3.0 中增加了BPF即时编译器(just-in-time, JIT)，相比解释器来说，它执行效率更高。 2012年 Will Drewry 为安全计算系统调用添加了 BPF 过滤器，这是第一次运用在网络领域之外，也先是出BPF可以作为一个通用执行引擎的潜力。 2013年12月提议在此之前创造的eBPF合入Linux内核 2014年eBPF补丁开始合入Linux内核 2014年6月，JIT组件并入Linux内核3.15中 2014年12月，用于控制BPF的bpf(2)系统调用进入Linux3.18版本中。之后在Linux4.x内核增加了对 kprobes、uprobes、tracepoints 和 perf_events 的BPF支持。 目前所说的BPF都指eBPF ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:2:1","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 运行时 下图展示 BPF 指令如何通过BPF验证器验证，再由BPF虚拟机执行过程： BPF 运行时各模块架构 BPF 虚拟机实现包括:解释器和JIT编译器，JIT编译器负责生成处理器可直接执行的机器指令。验证器会拒绝那些不安全的操作，这包括针对无界循环的检查：BPF程序必须在有限的时间内执行完成。 BPF 可以利用辅助函数获取内核状态，利用BPF映射表进行存储。BPF程序在特定事件发生时候执行，包括 kprobes、uprobes和跟踪点等事件。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:2:2","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"使用 BPF 或 内核模块实现性能分析工具的思路 …. ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:2:3","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"编写BPF程序 很多前端工具可以用来支持 BPF 编程，在跟踪观测方面，主要的前端按照开发语言从低级到高级排列如下： LLVM BCC bpftrace LLVM 编译器支持将 BPF 作为编译目标体系结构。BPF 程序可以使用 LLVM 支持的更高级语言编写，比如 C 语言(借助Clang)或LLVM中间表示形式，然后再编译成 BPF。 LLVM 自带优化器，可以对它生成的 BPF 指令进行效率和体积上的优化。 …. 留坑后续再填… ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:2:4","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"参考 BPF 相关源码所在仓库: https://github.com/iovisor 以 Arch Linux 为例，使用 BCC 则执行pacman -S bcc bcc-tools python-bcc，同时要注意一些内核编译配置。安装成功之后进入本地系统 /usr/share/bcc查看相关工具 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:3:0","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["IDE"],"content":"问题 已经安装好go并配置好GOROOT和GOPATH之后，在Goland无法自动识别出GOROOT。在Goland设置选择go安装目录下，提示\"Go SDK 非法的家目录\" ","date":"2022-06-21","objectID":"/2022/06/0003-golang%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABgoroot/:1:0","tags":["go","goland","GOROOT"],"title":"Golang无法识别GOROOT","uri":"/2022/06/0003-golang%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABgoroot/"},{"categories":["IDE"],"content":"解决 修改${GROOT}/src/runtime/internal/sys/zversion.go，添加go SDK 对应的版本号信息: const TheVersion = 'go1.18.3' ","date":"2022-06-21","objectID":"/2022/06/0003-golang%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABgoroot/:2:0","tags":["go","goland","GOROOT"],"title":"Golang无法识别GOROOT","uri":"/2022/06/0003-golang%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABgoroot/"},{"categories":["linux"],"content":"pkcheck 检查进程是否被授权 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:0","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"说明 pkcheck用于检查进程(由–process(见下文)或–system-bus-name指定)是否被授权执行操作。可以多次使用–detail选项传递有关操作的细节。如果–allow-user-interaction被传递，pkcheck在等待身份验证时阻塞。 调用pkcheck –list-temp将列出当前会话的所有临时授权，而pkcheck –revoke-temp将撤销当前会话的所有临时授权。 这个命令是对polkit D-Bus接口的简单包装;详细信息请参见D-Bus接口文档。 Usage: pkcheck [OPTION...] Help Options: -h, --help Show help options Application Options: -a, --action-id=ACTION Check authorization to perform ACTION -u, --allow-user-interaction Interact with the user if necessary -d, --details=KEY VALUE Add (KEY, VALUE) to information about the action --enable-internal-agent Use an internal authentication agent if necessary --list-temp List temporary authorizations for current session -p, --process=PID[,START_TIME,UID] Check authorization of specified process --revoke-temp Revoke all temporary authorizations for current session -s, --system-bus-name=BUS_NAME Check authorization of owner of BUS_NAME --version Show version Report bugs to: http://lists.freedesktop.org/mailman/listinfo/polkit-devel polkit home page: \u003chttp://www.freedesktop.org/wiki/Software/polkit\u003e ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:1","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"返回值 如果指定的进程被授权，pkcheck将以0的返回值退出。如果授权结果包含任何详细信息，它们将使用环境样式的报告作为键/值对打印在标准输出上，例如，首先键后跟一个等号，然后值后跟一个换行符。 KEY1=VALUE1 KEY2=VALUE2 KEY3=VALUE3 ... 不包含在[a-zA-Z0-9_]中的八进制代码使用以\\为前缀的八进制代码进行转义。例如,utf-8字符串flø你好将 将显示为: \\303\\270l\\54\\344\\275\\240\\345\\245\\275。 如果指定的进程未被授权，pkcheck将退出，返回值为1，并在标准错误时打印诊断消息。详细信息打印在标准输出上。 如果指定的进程没有获得授权，因为没有合适的身份验证代理可用，或者没有通过 –allow-user-interaction，那么pkcheck将退出，返回值为2，并在标准错误时打印一条诊断消息。详细信息打印在标准输出上。 如果指定的进程没有被授权，因为身份验证对话框/请求被用户驳回，pkcheck退出，返回值为3，并在标准错误上打印诊断消息。详细信息打印在标准输出上。 如果在检查授权时发生错误，pkcheck退出，返回值为127，并在标准错误上打印诊断消息。 如果传递的一个或多个选项是不规范的，则pkcheck退出，返回值为126。如果stdin是一个tty，那么也会显示此手册页。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:2","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"注意 不要针对 –process 选项仅仅使用pid或pid,start-time 语法。新代码应该总是使用pid,pid-start-time,uid。start-time的值可以通过参考proc(5)文件系统来确定，具体取决于操作系统。如果传入的参数少于3个，pkcheck将尝试在内部查找它们，但注意这可能是不正常的。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:3","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"pkaction 获取已注册操作的详细信息 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:0","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"说明 pkaction用于获取关于已注册polkit操作的信息。如果调用时没有使用–action-id，则显示所有操作。如果调用时不带–verbose选项，则只显示操作的名称。否则将显示有关操作的详细信息。 Usage: pkaction [OPTION?] [--action-id ACTION] Help Options: -h, --help Show help options Application Options: -a, --action-id=ACTION Only output information about ACTION -v, --verbose Output detailed action information --version Show version Report bugs to: http://lists.freedesktop.org/mailman/listinfo/polkit-devel polkit home page: \u003chttp://www.freedesktop.org/wiki/Software/polkit\u003e ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:1","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"返回值 如果成功，pkaction返回0。否则将返回非零值，并在标准错误时打印诊断消息。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:2","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"pkexec 以其他用户身份执行命令 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:0","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"说明 pkexec允许授权用户作为另一个用户执行PROGRAM。如果没有指定PROGRAM，将运行默认的shell。如果没有指定用户名，那么程序将以管理超级用户root执行。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:1","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"返回值 成功完成后，返回值就是PROGRAM的返回值。如果调用进程未被授权或无法通过身份验证获得授权或发生错误，则pkexec退出，返回值为127。如果由于用户取消了身份验证对话框而无法获得授权，则pkexec退出，返回值为126。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:2","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"认证代理 与任何其他polkit应用程序一样，pkexec将使用为调用进程或会话注册的身份验证代理。但是，如果没有可用的身份验证代理，那么pkexec将注册它自己的文本身份验证代理。可以通过传递–disable-internal-agent选项来关闭此行为。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:3","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"安全方面 作为另一个用户执行程序是一种特权操作。默认情况下，要检查的操作(请参阅“action AND AUTHORIZATIONS”一节)需要管理员身份验证。此外，呈现给用户的身份验证对话框将显示要执行的程序的完整路径，以便用户知道将发生什么。 PROGRAM运行它的环境将被设置为最小已知和安全的环境，以避免通过LD_LIBRARY_PATH或类似机制注入代码。另外，PKEXEC_UID环境变量被设置为调用pkexec的进程的用户id。因此，pkexec默认情况下不允许您以另一个用户的身份运行X11应用程序，因为没有设置$DISPLAY和$XAUTHORITY环境变量。如果action上的org.freedesktop.policykit.exec.allow_gui注释被设置为非空值，那么这两个变量将被保留;但是，这是不鼓励的，应该只用于遗留程序。 注意，pkexec不验证传递给PROGRAM的ARGUMENTS。在正常情况下(每次使用pkexec时都需要管理员身份验证)，这不是问题，因为如果用户是管理员，他可能只需要运行pkexec bash来获得根用户。 但是，如果使用了用户可以保留授权的操作(或者用户是隐式授权的)，这可能是一个安全漏洞。因此，根据经验，更改默认所需授权的程序永远不应该隐式信任用户输入(例如，像任何其他编写良好的suid程序)。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:4","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"action和授权 默认使用“org.freedesktop.policykit.exec”动作。要使用另一个操作，请在一个action上使用org.freedesktop.policykit.exec.path注释，该注释的值设置为程序的完整路径。除了指定程序之外，还可以指定身份验证消息、描述、图标和默认值。如果有org.freedesktop.policykitexec.argv1注释，则只有当程序的第一个参数与注释的值匹配时，才会选择该操作。 请注意，身份验证消息可能会引用变量(请参阅“变量”一节)，例如$(user)将被扩展为用户变量的值。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:5","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"包装使用 为了避免修改现有软件以使用pkexec作为命令行调用的前缀，可以在she-bang包装器中使用pkexec，如下所示: #!/usr/bin/pkexec /usr/bin/python import os import sys print \"Hello, I'm running as uid %d\"%(os.getuid()) for n in range(len(sys.argv)): print \"arg[%d]=`%s'\"%(n, sys.argv[n]) 如果这个脚本被安装到/usr/bin/my-pk-test，那么下面的注释 [...] \u003cannotate key=\"org.freedesktop.policykit.exec.path\"\u003e/usr/bin/python\u003c/annotate\u003e \u003cannotate key=\"org.freedesktop.policykit.exec.argv1\"\u003e/usr/bin/my-pk-test\u003c/annotate\u003e [...] 可以用来选择合适的polkit动作。注意正确使用后面的注释，否则它将匹配/usr/bin/python脚本的任何pkexec调用。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:6","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"变量 以下变量是由pkexec设置的。它们可以用于授权规则和身份验证对话框中显示的消息: 参数 说明 program 要执行程序的完全限定路径。例如:“/bin/cat” command_line 请求的命令行(不要将其用于任何安全检查，它不安全)。示例:“cat /srv/xyz/foobar” user 执行程序的用户的用户名 user.gecos 执行程序的用户的全名 user.display 用户执行程序的一种表示形式，适合在身份验证对话框中显示。通常设置为用户名和全名的组合。例如:“David Zeuthen (davidz)” ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:7","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"pkttyagent 文本验证助手 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:4:0","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"说明 pkttyagent用于启动由 –process 或 –system-bus-name指定的主题的文本身份验证代理。如果没有提供这两个选项，则使用父进程。 要在注册身份验证代理时获得通知，可以侦听changed D-Bus信号，或使用–notify-fd传递已传递给程序的文件描述符的编号。当身份验证代理成功注册后，将关闭此文件描述符。 如果使用 –fallback，文本身份验证代理将不会替换现有的身份验证代理。 Usage: pkttyagent [OPTION?] Help Options: -h, --help Show help options Application Options: --fallback Don't replace existing agent if any --notify-fd=FD Close FD when the agent is registered -p, --process=PID[,START_TIME] Register the agent for the specified process -s, --system-bus-name=BUS_NAME Register the agent for the owner of BUS_NAME --version Show version Report bugs to: http://lists.freedesktop.org/mailman/listinfo/polkit-devel polkit home page: \u003chttp://www.freedesktop.org/wiki/Software/polkit\u003e ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:4:1","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"返回值 如果无法注册身份验证代理，pkttyagent将退出，退出码为127。诊断消息在标准错误时打印。 如果传递的一个或多个选项是不正确的，pkttyagent将退出，退出代码为126。如果stdin是一个tty，那么也会显示此手册页。 如果成功注册了身份验证代理，pkttyagent将继续运行，根据需要与用户交互。当不再需要它的服务时，可以终止该进程。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:4:2","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"注意 因为进程标识符可以循环使用，所以在使用 –process选项时，调用者应该始终使用pid,pid-start-time。pid-start-time的值可以通过参考proc(5)文件系统来确定，具体取决于操作系统。如果只将pid传递给–process选项，那么pkttyagent将查找启动时间本身，但请注意，这可能是不正常的。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:4:3","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"说明 polkit提供了一个授权API，特权程序(“MECHANISMS”)使用它为非特权程序(“SUBJECTS”)提供服务，这些服务通常通过某种进程间通信机制实现。在这种情况下，特权程序通常将非特权程序视为不可信的。对于来自某个非特权程序的每个请求，该特权程序需要确定该请求是被授权的，还是应该拒绝为该非特权程序服务。使用polkit api，一种机制可以将此决策转移给受信任的一方:polkit。 polkit是作为系统守护进程polkitd(8)实现的，它本身没有什么特权，因为它是作为polkitd系统用户运行的。机制、主体和身份验证代理使用系统消息总线与权威机构通信。 除了充当授权机构之外，polkit还允许用户通过对管理用户或客户端所属会话的所有者进行身份验证来获得临时授权。这对于需要验证系统操作员是否真的是用户或管理用户的机制非常有用。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:1:0","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"系统架构 polkit的系统体系结构由Authority(作为系统消息总线上的服务实现)和每个用户会话(由用户的图形环境提供和启动)的Authentication Agent组成。操作由应用程序定义。厂商、站点和系统管理员可以通过“授权规则”控制授权策略。 polkit 系统架构 为了方便起见，libpolkit-gobject-1库封装了polkit D-Bus API，可用于任何C/C++程序以及支持GObjectIntrospection的高级语言，如JavaScript和Python。一种机制也可以使用D-Bus API或pkcheck(1)命令来检查授权。libpolkit-agent-1库提供了一个本地认证系统的抽象，例如pam(8)，还提供了注册和与polkit D-Bus服务通信的设施。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:1:1","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"认证代理 身份验证代理用于使会话的用户证明该会话的用户确实是该用户(通过身份验证为用户)或管理用户(通过身份验证为管理员)。为了与用户会话的其他部分很好地集成(例如匹配外观和感觉)，身份验证代理应该由用户使用的用户会话提供。例如，身份验证代理可能看起来像这样: 如果系统配置为没有root帐户，它可能会提示指定一个特定的用户作为管理用户: 不运行在桌面环境下的应用程序(例如，如果从ssh(1)登录启动)可能没有与它们相关联的身份验证代理。这样的应用程序可以使用PolkitAgentTextListener类型或pkttyagent(1)助手，这样用户可以使用文本接口进行身份验证。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:1:2","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"声明的Action 特权程序需要声明一组actions才能使用polkit。action对应于客户机可以请求特权程序执行的操作，并定义在XML文件中，特权程序将这些文件安装到/usr/share/polkit-1/actions目录中。 polkit操作有名称空间，只能包含字符“[A-Z][a-z][0-9].-”，即: ASCII、数字、句点和连字符。每个XML文件可以包含多个操作，但是所有操作都需要在同一个名称空间中，并且文件需要以名称空间命名并具有.policy扩展名。 XML文件必须具有以下doctype声明 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE policyconfig PUBLIC \"-//freedesktop//DTD polkit Policy Configuration 1.0//EN\" \"http://www.freedesktop.org/software/polkit/policyconfig-1.dtd\"\u003e policyconfig元素必须只出现一次。可以在policyconfig中使用的元素包括: 字段 说明 vendor 在XML文档中提供操作的项目或供应商的名称。可选的 vendor_url 指向在XML文档中提供操作的项目或供应商的URL。可选的 icon_name 表示在XML文档中提供操作的项目或供应商的图标。图标名称必须遵循Freedesktop.org图标命名规范。可选的 action 声明了一个action。操作名称使用id属性指定，并且只能包含字符“[A-Z][A-Z][0-9].-”，即: ASCII、数字、句点和连字符 可以在内部操作中使用的元素包括: 字段 说明 description 对操作的可读描述 message 当用户需要身份验证时要求凭证时，显示给用户的提示消息，说明为什么要做权限验证 defaults 此元素用于为客户端指定隐式授权。可以在默认值中使用的元素包括:allow_any: 适用于任何客户端的隐式授权。可选的。allow_inactive: 隐式授权，应用于本地控制台上非活动会话中的客户端。可选 allow_active: 应用于本地控制台活动会话中的客户端的隐式授权。可选的。其中allow_any, allow_inactive和allow_active元素可以包含以下值:no:未验证通过yes:验证通过auth_self:需要由客户机所在会话的所有者进行身份验证。注意，对于多用户系统的大多数使用，这是不够严格的;一般推荐使用auth_admin*auth_admin:需要由管理用户进行身份验证auth_self_keep:类似于auth_self，但授权只保留一小段时间(例如5分钟)。上面关于auth_self的警告同样适用auth_admin_keep:同上 annotate 用于用键/值对注释操作。键是使用key属性指定的，值是使用value属性指定的。该元素可以出现0次或多次。见下面的已知注释。 vendor 用于在每个操作的基础上重写供应商。可选的 vendor_url 用于在每个操作的基础上重写供应商URL。可选的 icon_name 用于在每个操作的基础上重写图标名称。可选的 对于本地化，description和message元素可以在不同的xml:lang属性中出现多次。 要列出已安装的polkit action，使用pkaction(1)命令。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:1:3","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"已知的annotations polkit附带的pkexec程序使用org.freedesktop.policykit.exec.path annotations 请参阅pkexec(1)手册页了解详细信息。 org.freedesktop.policykit.imply annotations(它的值是一个包含空格分隔的操作标识符列表的字符串)可以用来定义元操作。它的工作方式是，如果一个主题被授权执行带有该注释的操作，那么它也被授权执行该注释指定的任何操作。这个注释的典型用法是在定义带有单个锁定按钮的UI shell时，该按钮应该可以从不同的机制解锁多个操作。 org.freedesktop.policykit.owner annotations可用于定义一组用户，这些用户可以查询客户端是否被授权执行此操作。如果没有指定此注释，则只有根用户可以查询作为不同用户运行的客户端是否被授权执行某个操作。这个注释的值是一个字符串，包含一个空格分隔的PolkitIdentity条目列表，例如“unix-user:42 unix-user:colord”。这个注释的典型用途是作为系统用户而不是根用户运行的守护进程。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:1:4","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"验证规则 polkitd从 /etc/polkit-1/rules.d 和 /usr/share/polkit-1/rules.d 中读取 .rules， 方法是根据每个文件的基名按词法顺序对文件进行排序(如果有一个tie， /etc中的文件会在/usr中的文件之前处理)。例如，对于以下四个文件，顺序是 /etc/polkit-1/rules.d/10-auth.rules /usr/share/polkit-1/rules.d/10-auth.rules /etc/polkit-1/rules.d/15-auth.rules /usr/share/polkit-1/rules.d/20-auth.rules 这两个目录都受到监控，因此，如果更改、添加或删除规则文件，则清除现有的规则，并再次读取和处理所有文件。规则文件是用JavaScript编程语言编写的，并通过全局polkit对象(类型为polkit)与polkitd接口。 虽然在polkit的特定版本中使用的JavaScript解释器可能支持非标准特性(比如let关键字)，但授权规则必须符合ECMA-262 edition 5(换句话说，在polkit的未来版本中使用的JavaScript解释器可能会改变)。 授权规则针对两个特定的受众: 系统管理员 特殊用途的操作系统/环境 而且只针对这些观众。特别是，应用程序、机制和通用操作系统绝不能包含任何授权规则。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:2:0","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"The Polkit type 以下方法在polkit对象上可用: void addRule(polkit.Result function(action, subject) {...}); void addAdminRule(string[] function(action, subject) {...}); void log(string message); string spawn(string[] argv); addRule()方法用于添加一个函数，在执行动作和主题的授权检查时可以调用该函数。函数被调用的顺序是它们被添加的顺序，直到其中一个函数返回一个值。因此，要添加一个在其他规则之前处理的授权规则，请将其放在/etc/polkit-1/rules.d的文件中，其名称排在其他规则文件之前，例如00-early-checks.rules。每个函数都应该从polkit.Result返回一个值 polkit.Result = { NO : \"no\", YES : \"yes\", AUTH_SELF : \"auth_self\", AUTH_SELF_KEEP : \"auth_self_keep\", AUTH_ADMIN : \"auth_admin\", AUTH_ADMIN_KEEP : \"auth_admin_keep\", NOT_HANDLED : null }; 对应于可以用作默认值的值。如果函数返回polkit.Result.NOT_HANDLED、null、undefined或不返回值，将尝试下一个用户函数。 记住，如果返回polkit.result.AUTH_SELF_KEEP或polkit.Result.AUTH_ADMIN_KEEP，那么在下一个短时间内(例如5分钟)，对相同动作标识符和主题的授权检查将会成功(即返回polkit.Result.YES)，即使检查传递的变量不同。因此，如果授权规则的结果依赖于这些变量，那么它不应该使用“*_KEEP”常量(如果需要类似的功能，那么授权规则可以使用时间戳的Date类型轻松实现临时授权)。 addAdminRule()方法用于添加一个函数，在需要进行管理员身份验证时可以调用该函数。该函数用于指定哪些身份可以用于管理员身份验证，以便进行由动作和主题标识的授权检查。添加的函数将按照添加的顺序调用，直到其中一个函数返回值为止。每个函数都应该返回一个字符串数组，其中每个字符串的形式为\"unix-group:\"， “unix-netgroup:“或\"unix-user:\"。如果函数返回null、未定义或根本不返回值，则尝试下一个函数。 不能保证使用addRule()或addAdminRule()注册的函数会被调用——例如，早期的规则文件可以注册一个总是返回值的函数，从而确保以后添加的函数永远不会被调用。 如果用户提供的代码执行时间较长，则会抛出异常，通常会导致函数终止(当前限制为15秒)。这用于捕获失控脚本。 spawn()方法生成一个由参数向量argv标识的外部helper，并等待它终止。如果发生错误或helper没有以退出码0正常退出，则会抛出异常。如果助手没有在10秒内退出，它就会被杀死。否则，程序的标准输出将作为字符串返回。应该谨慎使用spawn()方法，因为helper可能需要很长时间或不确定的时间来完成，并且在helper运行时不能处理其他授权检查。注意，生成的程序将作为无特权的polkitd系统用户运行。 log()方法将给定的消息写入以JavaScript文件名和行号为前缀的系统日志记录器。日志条目是使用LOG_AUTHPRIV标志发出的，这意味着日志条目通常最后出现在文件/var/log/secure中。log()方法通常只在调试规则时使用。Action和Subject类型有适合于方便日志记录的toString()方法，例如， polkit.addRule(function(action, subject) { if (action.id == \"org.freedesktop.policykit.exec\") { polkit.log(\"action=\" + action); polkit.log(\"subject=\" + subject); } }); 当用户在shell中运行’pkexec -u bateman bash -i’时将产生以下结果: May 24 14:28:50 thinkpad polkitd[32217]: /etc/polkit-1/rules.d/10-test.rules:3: action=[Action id='org.freedesktop.policykit.exec' command_line='/usr/bin/bash -i' program='/usr/bin/bash' user='bateman' user.gecos='Patrick Bateman' user.display='Patrick Bateman (bateman)'] May 24 14:28:50 thinkpad polkitd[32217]: /etc/polkit-1/rules.d/10-test.rules:4: subject=[Subject pid=1352 user='davidz' groups=davidz,wheel, seat='seat0' session='1' local=true active=true] ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:2:1","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"The Action type 传递给用户函数的action参数是一个对象，其中包含正在检查的操作的信息。它的类型是Action，具有以下属性: string id: 动作标识符，例如org.freedesktop.policykit.exec。 以下方法在Action类型上可用: string lookup(string key); lookup()方法用于查找从该机制传递的polkit变量。例如，pkexec(1)机制设置可以在JavaScript中使用表达式action.lookup(“program”)获得的变量程序。如果给定的键没有值，则返回undefined。 请参阅每种机制的文档，了解每个操作可以使用哪些变量。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:2:2","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"The Subject type 传递给用户函数的subject参数是一个带有正在检查的进程信息的对象。它的类型是Subject，具有以下属性 类型 说明 int pid 进程id string user 用户名 string[] groups 用户所属的组 string seat subject所属的seat，不是本地seat则为空(ps:关于seat查看linux seat了解) string session subject所属session boolean local 仅仅是本地seat才会设置为 true boolean active 当session是active才会设置为true 以下方法可用于Subject类型: boolean isInGroup(string groupName); boolean isInNetGroup(string netGroupName); isInGroup()方法可以用来检查subject是否在给定的组中，isInNetGroup()方法可以用来检查subject是否在给定的网络组中。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:2:3","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"Authorization Rules Examples 允许admin组的所有用户进行用户管理，不改变其他用户的策略: polkit.addRule(function(action, subject) { if (action.id == \"org.freedesktop.accounts.user-administration\" \u0026\u0026 subject.isInGroup(\"admin\")) { return polkit.Result.YES; } }); 定义管理用户为wheel组中的用户: polkit.addAdminRule(function(action, subject) { return [\"unix-group:wheel\"]; }); 禁止子组中的用户更改主机名配置(即任何标识符以org.freedesktop.hostname1开头的操作)，并允许其他任何人在验证为自己之后这样做: polkit.addRule(function(action, subject) { if (action.id.indexOf(\"org.freedesktop.hostname1.\") == 0) { if (subject.isInGroup(\"children\")) { return polkit.Result.NO; } else { return polkit.Result.AUTH_SELF_KEEP; } } }); 运行一个外部助手来确定当前用户是否可能重启系统: polkit.addRule(function(action, subject) { if (action.id.indexOf(\"org.freedesktop.login1.reboot\") == 0) { try { // user-may-reboot exits with success (exit code 0) // only if the passed username is authorized polkit.spawn([\"/opt/company/bin/user-may-reboot\", subject.user]); return polkit.Result.YES; } catch (error) { // Nope, but do allow admin authentication return polkit.Result.AUTH_ADMIN; } } }); 下面的例子展示了授权决策如何依赖于pkexec(1)机制传递的变量: polkit.addRule(function(action, subject) { if (action.id == \"org.freedesktop.policykit.exec\" \u0026\u0026 action.lookup(\"program\") == \"/usr/bin/cat\") { return polkit.Result.AUTH_ADMIN; } }); 下面的示例展示了从该机制传递的变量的另一种用法。在这种情况下，机制是UDisks，它定义了一组用于匹配的操作和变量: // Allow users in group 'engineers' to perform any operation on // some drives without having to authenticate // polkit.addRule(function(action, subject) { if (action.id.indexOf(\"org.freedesktop.udisks2.\") == 0 \u0026\u0026 action.lookup(\"drive.vendor\") == \"SEAGATE\" \u0026\u0026 action.lookup(\"drive.model\") == \"ST3300657SS\" \u0026\u0026 subject.isInGroup(\"engineers\")) { return polkit.Result.YES; } } }); ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:2:4","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"polkit是什么? polkit提供了一个授权API，旨在由特权程序(“机制”)使用，为非特权程序(“客户端”)提供服务。查看polkit手册页面了解系统架构和总体情况。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:0","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"polkit 程序 Polkit 应用程序是使用 Polkit 权限作为决策组件的应用程序(polkitd)。他们通过将.policy文件安装到/usr/share/polkit-1/actions目录中，并在运行时与polkitd进行通信(通过D-Bus API或间接通过libpolkit-gobject-1库或pkcheck命令)。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:1","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"polkit 适用场景 如果您正在编写特权机制(即以root身份运行或具有特殊权限)，打算由非特权程序使用，则使用polkit。 认真考虑定义什么行为。在许多情况下，操作和polkit动作之间没有1:1的映射。通常，polkit操作与操作所处理的对象的关系比操作本身的关系更大。在粒度过细和粒度过粗之间取得适当的平衡是很重要的。 尝试选择操作和隐式授权，以便使用您的机制的应用程序能够为在控制台登录的用户开箱即用。应该优先考虑不使用身份验证对话框打断控制台用户。例如，对于添加打印机队列这样的普通任务，要求控制台用户进行身份验证是不明智的(如果管理员真的希望操作系统以这种方式工作，他总是可以部署合适的授权规则)。 考虑所选择的隐式授权对多用户系统的影响。一般情况下，普通用户既不能为其他用户修改重要系统的行为/配置，也不能查看其他用户的私人数据。如果您的应用程序需要授权框架，那么至少在某些情况下，默认配置很可能会拒绝授权。默认使用auth_admin 而不是auth_self。(在单用户桌面中，单个用户通常被配置为polkit管理员，因此这两种变体的行为是相同的。在多用户系统中，非管理员用户将受到默认配置的限制。) 将polkit变量与CheckAuthorization()请求一起传递，这样就可以编写与这些请求匹配的授权规则。还要在文档中记录这些变量(例如，请参阅udisks2操作和变量)。 传递一个定制的身份验证消息(使用polkit.message 和 polkit.gettext_domain 变量)，它包含比.policy文件的message元素中声明的请求更详细的信息。例如：显示 “需要身份验证来格式化INTEL SSDSA2MH080G1GC (/dev/sda)”，而不是仅仅显示“需要身份验证来格式化设备”。 确保您的应用程序工作，即使当org.freedesktop.PolicyKit1 D-Bus 服务不可用(这可能发生，如polkitd(8)没有安装或polkit.service被屏蔽)。如果你使用libpolkit-gobject-1库，这意味着处理polkit_authority_get_sync()或polkit_authority_get_finish()返回NULL或polkit_authority_check_authorization() / polkit_authority_check_authorization_sync()失败，返回错误不在POLKIT_ERROR域。处理polkit权限不可用的一种适当方法可以是只允许uid 0执行操作，禁止所有操作或其他操作。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:2","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"polkit 不适用的场景 如果您的程序不打算供非特权程序使用，则不要使用polkit。例如，如果您正在编写开发人员工具或低级核心OS命令行工具，那么只要求用户是root就可以了。用户可以通过sudo(8)， pkexec(1)或编写一个简单的使用polkit的机制来访问工具的(安全)子集。 除非必要，否则不要使用polkit。换句话说，并不是每个为非特权程序提供服务的特权程序都必须使用polkit。 不要在每次授权机构发出change信号时对所有操作调用CheckAuthorization()。这不仅是对资源的浪费，结果也可能不准确，因为授权规则可以在任何时候返回它们想要的任何内容。 在等待权限回复时，不要阻塞你的主线程(例如用于服务来自非特权程序的IPC请求的主线程)——CheckAuthorization()调用可能需要很长时间(秒，甚至分钟)才能完成，因为可能涉及用户交互。相反，可以使用异步API，或者使用带有同步API的专用线程。 不要在应用程序中包含任何授权规则，因为这只适用于管理员和特殊用途的操作系统/环境。有关更多信息，请参阅“授权规则”一节。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:3","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"在非特权程序中的使用 非特权程序通常不直接使用polkit——它只是调用特权机制，该机制在使用polkit进行检查(可能包括显示身份验证对话框)后呈现服务(或拒绝请求)。在这种设置中，非特权程序不知道正在使用polkit—它只是等待特权机制执行请求(如果涉及身份验证对话框，这可能需要许多秒)。这是一件好事，因为不必担心诸如polkit之类的实现细节，这有助于简化非特权程序。 有时，没有特权的程序需要禁用、修改或删除UI元素，以向用户传达某些操作无法执行(例如，用户没有获得授权)或需要验证(例如，在UI中显示挂锁图标)。在这种情况下，最好的方法通常是让非特权程序从特权机制(而不是polkit)获得该信息。这一点尤其正确，因为通常没有可靠的方法可以让非特权程序知道将要使用什么polkit操作。一般来说,不能保证操作(如d-bus方法)映射 1:1: 到 polkit 的某个 action ——例如,一个磁盘管理器服务的Format()方法可能检查net.company.diskmanager.format-removable 磁盘是否可移除 和 net.company.diskmanager.format-fixed 磁盘是固定的格式。 然而，在某些情况下，例如在使用org.freedesktop.policykit.imply (参见polkit(8)手册页)时，对于非特权程序查询polkit权限它是有意义的(如更新UI元素),只要无特权的程序不通过任何变量随着CheckAuthorization()调用，这种查询操作是被允许的(否则很容易欺骗身份验证对话框和旁路授权规则)。事实上，由于这个用例是如此常见，libpolkit-gobject-1提供了可以与GtkLockButton一起使用的PolkitPermission类型(它派生自GPermission)。注意，要使GtkLockButton正常工作，支持它的polkit操作应该使用auth_admin_keep作为隐式授权(或者很少使用auth_self_keep作为不影响其他用户的服务)。这通常用于实现一个即时应用范例，用户解锁(通过身份验证)，例如一个首选项窗格窗口，然后可以自由更改设置，直到授权过期或被撤销。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:4","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"没有身份验证代理 如果一个polkit应用程序想要处理没有身份验证代理存在的情况(例如，如果应用程序是通过ssh(1)登录启动的)，应用程序可以使用PolkitAgentTextListener类型来根据需要生成自己的身份验证代理。另外，也可以使用pkttyagent(1) helper来完成此任务。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:5","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"编写polkit认证代理 认证代理由桌面环境提供。当用户会话开始时，代理使用RegisterAuthenticationAgent()方法向polkit Authority注册。当需要服务时，机构将调用org.freedesktop.PolicyKit1.AuthenticationAgent D-Bus接口上的方法。一旦用户通过身份验证，(特权部分)代理将调用AuthenticationAgentResponse2()方法。这个方法应该被视为内部实现细节，调用者应该使用PolkitAgentSession API来调用它，它目前使用一个setuid助手程序。 libpolkit-agent-1库提供了帮助程序，使构建使用本机身份验证系统的身份验证代理变得容易，例如pam(8)。 如果设置了环境变量POLKIT_DEBUG，则libpolkit-agent-1库将在标准输出中输出诊断信息。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:2:0","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["c++"],"content":" 现代C++，快速上手 C++11、C++14、C++17、C++20 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:0:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"概述 C++98 是C++第一个版本 C++98 之后积累十年出现 C++11 C++14/17 对C++11做了重要补充和优化 C++20 则将这门语言领进了现代的大门 将将C++98划分为传统C++；C++11、C++14、C++17、C++20划分为现代C++ 注意：现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会 变得合法，为了提高可移植性，写代码时候尽量使用标准的语法和特性。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:1:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"迈向现代C++ 编译环境：clang++ 编译器 + std=c++2a 编译标志 clang++ 版本大于10 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:2:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"被弃用的特性 注意：弃用并非彻底不能用，只是暗示程序员这些特性将从未来的标准中消失，要避免使用。但是，已弃用的特性仍然是标准库的一部分，并且出于兼容性的考虑，大部分特性会「永久」保留。 从C++11 开始被弃用的主要特性： 不再允许字符串字面值常量赋值给一个 char *。如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto。 char *str = \"hello world!\"; // 将出现弃用警告 C++98 异常说明、unexpected_handler、set_unexpected() 相关特性被弃用，应该使用 noexcept。 auto_ptr 被弃用，应该使用 unique_ptr。 register 关键字被弃用，可以使用但不具备任何实际含义。 bool类型的++操作被弃用。 如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。 C 语言风格的类型转换被弃用(即在变量前使用 (convert_type))，应该使用 static_cast、 reinterpret_cast、const_cast 来进行类型转换。 特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 \u003cccomplex\u003e、 \u003ccstdalign\u003e、\u003ccstdbool\u003e 与 \u003cctgmath\u003e 等 … 其他\u003c待补充\u003e 还有一些其他诸如参数绑定(C++11 提供了 std::bind 和 std::function)、export 等特性也均 被弃用。前面提到的这些特性如果你从未使用或者听说过，也请不要尝试去了解他们，应该向新标准靠 拢，直接学习新特性。毕竟，技术是向前发展的。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:2:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"与C的兼容性 早期C++中使用了一些C语言代码(例如：Linux系统调用)，所以大多数人认为C++是C的超集，其实这个观念是不对的(从一开始就不是)，在写C++代码的时候要避免使用C中的程序风格，而不得不使用C的时候，要注意使用extern \"C\" 这种特性，将C语言的代码与C++代码进行分离编译再统一链接这一做法。 例如： // foo.h #ifdef __cplusplus extern \"C\" { #endif int add(int x, int y); #ifdef __cplusplus } #endif // foo.c int add(int x, int y) { return x+y; } // 1.1.cpp #include \"foo.h\" #include \u003ciostream\u003e #include \u003cfunctional\u003e int main() { [out = std::ref(std::cout \u003c\u003c \"Result from C code: \" \u003c\u003c add(1, 2))](){ out.get() \u003c\u003c \".\\n\"; }(); return 0; } // 应先使用 gcc 编译 C 语言的代码 gcc -c foo.c // 编译出 foo.o 文件，再使用 clang++ 将 C++ 代码和 .o 文件链接起来(或者都编译为 .o 再统一 链接) clang++ 1.1.cpp foo.o -std=c++2a -o xxx.out 下图为C与C++关系 C与C++相互兼容情况 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:2:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"进一步阅读的参考文献 c++语言导学 C++历史 C++特性在GCC/Clang等编译器中的支持情况 C++98 与 C99之间的区别 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:2:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"语言可用性的强化 当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都 是运行时之前，可能发生在编写代码或编译器编译代码时的行为。为此，我们通常谈及语言可用性，是指那些发生在运行时之前的语言行为。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"常量 nullptr nullptr 出现的目的是为了替代 NULL。在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。 C++ 不允许直接将 void * 隐式转换到其他类型。但如果编译器尝试把NULL定义为((void*)0)那么针对如下代码： void foo (char*); void foo (int); char* ch = NULL; // 会使调用 void foo(int)，导致违反本意 没有了 void* 隐式转换的 C++ 只好将 NULL 定义为 0。这将导致C++重载特性发生混乱。 NULL毕竟是C代码里的语法，((void*)0)这种写法在C++里不推荐，C里0和空指针就是一个值，但是C++里涉及到函数重载就不行了。 为了解决上述问题，C++引入了关键字nullptr，专门区分空指针、0。nullptr 类型为nullptr_t constexpr C++ 本身已经具备了常量表达式的概念，比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没 有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。 C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式。 注意：是编译期就是常量表达式。 此外，constexpr 修饰的函数可以使用递归 从 C++14 开始，`constexpr` 函数可以在内部使用局部变量、循环和分支等简单语句，代码在C++11标准下是不能通过编译的： constexpr int fibonacci(const int n) { // 循环语句在 c++14 才支持 if(n == 1) return 1; if(n == 2) return 1; return fibonacci(n-1) + fibonacci(n-2); } 为此，我们可以写出下面这类简化的版本来使得函数从 C++11 开始即可用: constexpr int fibonacci(const int n) { return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2); } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"变量及其初始化 if/switch 变量声明强化 在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终没有办法在 if 和 switch 语句中声明一个临时的变量。 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e int main() { std::vector\u003cint\u003e vec = {1, 2, 3, 4}; // 在 c++17 之前 const std::vector\u003cint\u003e::iterator itr = std::find(vec.begin(), vec.end(), 2); if (itr != vec.end()) { *itr = 3; } // 需要重新定义一个新的变量 const std::vector\u003cint\u003e::iterator itr2 = std::find(vec.begin(), vec.end(), 3); if (itr2 != vec.end()) { *itr2 = 4; } // 将输出 1, 4, 3, 4 for (std::vector\u003cint\u003e::iterator element = vec.begin(); element != vec.end(); ++element) std::cout \u003c\u003c *element \u003c\u003c std::endl; } 在上面的代码中，我们可以看到 itr 这一变量是定义在整个 main() 的作用域内的，这导致当我们 需要再次遍历整个 std::vectors 时，需要重新命名另一个变量。C++17 消除了这一限制，使得我们可 以在 if(或 switch)中完成这一操作: // 将临时变量放到 if 语句内 // 注意，if 条件是由两个表达式组成 if (const std::vector\u003cint\u003e::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) { *itr = 4; } 初始化列表 初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。在传统 C++ 中， 不同的对象有着不同的初始化方法，例如普通数组、POD (Plain Old Data，即没有构造、析构和虚函 数的类或结构体)类型都可以使用 {} 进行初始化，也就是我们所说的初始化列表。而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 () 进行。这些不同方法都针对各自对象，不能通用。例如: #include \u003ciostream\u003e #include \u003cvector\u003e class Foo { public: int value_a; int value_b; // 类的初始化 Foo(int a, int b) : value_a(a), value_b(b) {} }; int main() { // before C++11 int arr[3] = {1, 2, 3}; Foo foo(1, 2); std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; std::cout \u003c\u003c \"arr[0]: \" \u003c\u003c arr[0] \u003c\u003c std::endl; std::cout \u003c\u003c \"foo:\" \u003c\u003c foo.value_a \u003c\u003c \", \" \u003c\u003c foo.value_b \u003c\u003c std::endl; for (std::vector\u003cint\u003e::iterator it = vec.begin(); it != vec.end(); ++it) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } return 0; } 为了解决这个问题，C++11 首先把初始化列表的概念绑定到了类型上，并将其称之为 std::initializer_list， 允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初 始化方法提供了统一的桥梁，例如: #include \u003cinitializer_list\u003e #include \u003cvector\u003e class MagicFoo { public: std::vector\u003cint\u003e vec; MagicFoo(std::initializer_list\u003cint\u003e list) { for (std::initializer_list\u003cint\u003e::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it); } }; int main() { // after C++11 MagicFoo magicFoo = {1, 2, 3, 4, 5}; } 这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。 初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如: class MagicFoo { public: void foo(std::initializer_list\u003cint\u003e list) { for (std::initializer_list\u003cint\u003e::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it); } }; // 使用时候 magicFoo.foo({6,7,8,9}); 其次，C++11 还提供了统一的语法来初始化任意的对象，例如: Foo foo2 {3, 4}; 结构化绑定 结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新 增了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11/14 并没有提供一种 简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。 C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码: #include \u003ciostream\u003e #include \u003ctuple\u003e std::tuple\u003cint, double, std::string\u003e f() { return std::make_tuple(1, 2.3, \"456\"); } int main() { auto [x, y, z] = f(); std::cout \u003c\u003c x \u003c\u003c \", \" \u003c\u003c y \u003c\u003c \", \" \u003c\u003c z \u003c\u003c std::endl; return 0; } 关于 auto 类型推导会在auto 类型推导一节中进行介绍 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"类型推导 在传统 C 和 C++ 中，参数的类型都必须明确定义，这其实对我们快速进行编码没有任何帮助，尤 其是当我们面对一大堆复杂的模板类型时，必须明确的指出变量的类型才能进行后续的编码，这不仅拖 慢我们的开发效率，也让代码变得又臭又长。 C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。这 使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。 auto auto 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 register 并 存。在传统 C++ 中，如果一个变量没有声明为 register 变量，将自动被视为一个 auto 变量。 随着 register 被弃用(在 C++17 中作为保留关键字，以后使用，目前不具备实际意义)，对 auto 的语义变 更也就非常自然了。 使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。你应该在前面的小节里看到 了传统 C++ 中冗长的迭代写法: // c++11 之前 for(vector\u003cint\u003e::const_iterator it = vec.cbegin(); itr != vec.cend(); ++it) ... // c++11 之后使用 auto for (auto it = list.begin(); it != list.end(); ++it) ... auto 其他写法 auto i = 5; // i 被推导为 int auto arr = new auto(10); // arr 被推导为 int * 从 C++ 20 起，auto 甚至能用于函数传参，考虑下面的例子: int add(auto x, auto y) { return x+y; } auto i = 5; // 被推导为 int auto j = 6; // 被推导为 int std::cout \u003c\u003c add(i, j) \u003c\u003c std::endl; 注意:auto 还不能用于推导数组类型 auto auto_arr2[10] = {arr}; // 错误, 无法推导数组元素类型 decltype decltype 用来对表达式进行推导 decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 typeof 很相似: decltype(表达式) 有时候，我们可能需要计算某个表达式的类型，例如: auto x = 1; auto y = 2; decltype(x+y) z; 下面这个例子就是判断x, y, z 是否是同一类型: auto x = 1; auto y = 2; decltype(x+y) z; if (std::is_same\u003cdecltype(x), int\u003e::value) std::cout \u003c\u003c \"type x == int\" \u003c\u003c std::endl; if (std::is_same\u003cdecltype(x), float\u003e::value) std::cout \u003c\u003c \"type x == float\" \u003c\u003c std::endl; if (std::is_same\u003cdecltype(x), decltype(z)\u003e::value) std::cout \u003c\u003c \"type z == type x\" \u003c\u003c std::endl; 其中，std::is_same\u003cT, U\u003e 用于判断 T 和 U 这两个类型是否相等。 输出结果为: type x == int type z == type x 返回类型推导 你可能会思考，在介绍 auto 时，我们已经提过 auto 不能用于函数形参进行类型推导，那么 auto 能不能用于推导函数的返回类型呢?还是考虑一个加法函数的例子，在传统 C++ 中我们必须这么写: template\u003ctypename R, typename T, typename U\u003e R add(T x, U y) { return x+y; } 注意: typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。 但在模板中定义有嵌套依赖类型的变量时，需要用 typename 消除歧义 在 C++11 中这个问题得到解决，为了解决这个问题，C++11 还引入了一个叫做尾返回类型(trailing return type)，利用 auto 关键 字将返回类型后置： template\u003ctypename T, typename U\u003e auto add2(T x, U y) -\u003e decltype(x+y) { return x + y; } 令人欣慰的是从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法: template\u003ctypename T, typename U\u003e auto add3(T x, U y) { return x + y; } 可以检查一下类型推导是否正确: // after c++11 auto w = add2\u003cint, double\u003e(1, 2.0); if (std::is_same\u003cdecltype(w), double\u003e::value) { std::cout \u003c\u003c \"w is double: \"; } std::cout \u003c\u003c w \u003c\u003c std::endl; // after c++14 auto q = add3\u003cdouble, int\u003e(1.0, 2); std::cout \u003c\u003c \"q: \" \u003c\u003c q \u003c\u003c std::endl; decltype(auto) decltype(auto) 是 C++14 开始提供的一个略微复杂的用法。 要理解它你需要知道 C++ 中参数转发的概念，我们会在语言运行时强化一章中详细介绍，你可以到时再回来看这一小节的内容。 简单来说，decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 decltype 的参数表达式。 考虑看下面的例子，当我们需要对下面两个函数进行封装时: std::string lookup1(); std::string\u0026 lookup2(); 在 C++11 中，封装实现是如下形式: std::string look_up_a_string_1() { return lookup1(); } std::string\u0026 look_up_a_string_2() { return lookup2(); } 而有了 decltype(auto)，我们可以让编译器完成这一件烦人的参数转发: decltype(auto) look_up_a_string_1() { return lookup1(); } decltype(auto) look_up_a_string_2() { return lookup2(); } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"控制流 if constexpr 正如本章开头出，我们知道了 C++11 引入了 constexpr 关键字，它将表达式或函数编译为常量结 果。一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断， 岂不是能让程序效率更高? C++17 将 constexpr 这个关键字引入到 if 语句中，允许在代码中声明常量 表达式的判断条件，考虑下面的代码: #include \u003ciostream\u003e template\u003ctypename T\u003e auto print_type_info(const T\u0026 t) { if constexpr (std::is_integral\u003cT\u003e::value) { return t + 1; } else { return t + 0.001; } } int main() { std::cout \u003c\u003c print_type_info(5) \u003c\u003c std::endl; std::cout \u003c\u003c print_type_info(3.14) \u003c\u003c std::endl; } 在编译时，实际代码就会表现为如下: int print_type_info(const int\u0026 t) { return t + 1; } double print_type_info(const double\u0026 t) { return t + 0.001; } int main() { std::cout \u003c\u003c print_type_info(5) \u003c\u003c std::endl; std::cout \u003c\u003c print_type_info(3.14) \u003c\u003c std::endl; } 区间 for 迭代 终于，C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句，我们可以进一步简化前面的例子: #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e int main() { std::vector\u003cint\u003e vec = {1, 2, 3, 4}; if (auto itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) *itr = 4; for (auto element : vec) std::cout \u003c\u003c element \u003c\u003c std::endl; // read only for (auto \u0026element : vec) { element += 1; // writeable } for (auto element : vec) std::cout \u003c\u003c element \u003c\u003c std::endl; // read only } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"模版 C++ 的模板一直是这门语言的一种特殊的艺术，模板甚至可以独立作为一门新的语言来进行使用。 模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动 态服务，进而大幅优化运行期的性能。 因此模板也被很多人视作 C++ 的黑魔法之一。 外部模版 传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元(文件)中 编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。 并且，我们没有办法通知编译器不要触发模板的实例化。 为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能 够显式的通知编译器何时进行模板的实例化： template class std::vector\u003cbool\u003e; // 强行实例化 extern template class std::vector\u003cdouble\u003e; // 不在该当前编译文件中实例化模板 尖括号\"\u003e\" 在传统 C++ 的编译器中，» 一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌 套模板的代码: std::vector\u003cstd::vector\u003cint\u003e\u003e matrix; 这在传统 C++ 编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且 能够顺利通过编译。甚至于像下面这种写法都能够通过编译: template\u003cbool T\u003e class MagicType { bool magic = T; }; // in main function: std::vector\u003cMagicType\u003c(1\u003e2)\u003e\u003e magic; // 合法, 但不建议写出这样的代码 类型别名模版 在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话:模板是用来产生类型的。在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如： template\u003ctypename T, typename U\u003e class MagicType { public: T dark; U magic; }; // 不合法 template\u003ctypename T\u003e typedef MagicType\u003cstd::vector\u003cT\u003e, std::string\u003e FakeDarkMagic; C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效: typedef int (*process)(void *); using NewProcess = int(*)(void *); template\u003ctypename T\u003e using TrueDarkMagic = MagicType\u003cstd::vector\u003cT\u003e, std::string\u003e; int main() { TrueDarkMagic\u003cbool\u003e you; } 通常我们使用 typedef 定义别名的语法是:typedef 原名称 新名称 但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。 变长参数模版 在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数 而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。 template\u003ctypename... Ts\u003e class Magic; 模版类 Magic 对象，能够接受不受限制个数的 typename 作为模版的形式参数，例如下边的定义： class Magic\u003cint, std::vector\u003cint\u003e, std::map\u003cstd::string, std::vector\u003cint\u003e\u003e\u003e darkMagic; 既然是任意形式，所以个数为0 的模板参数也是可以的:class Magic\u003c\u003e nothing;。 如果不希望产生的模板参数个数为 0，可以手动的定义至少一个模板参数: template\u003ctypename Require, typename... Args\u003e class Magic; 变长参数模板也能被直接调整到到模板函数上。传统 C 中的 printf 函数，虽然也能达成不定个数的形参的调用，但其并非类别安全。而 C++11 除了能定义类别安全的变长参数函数外，还可以使类似 printf 的函数能自然地处理非自带类别的对象。除了在模板参数中能使用 … 表示不定长模板参数外，函数参数也使用同样的表示法代表不定长参数，这也就为我们简单编写变长参数函数提供了便捷的手段，例如: template\u003ctypename... Args\u003e void printf(const std::string \u0026str, Args... args); 那么我们定义了变长的模板参数，如何对参数进行解包呢? 首先，我们可以使用 sizeof… 来计算参数的个数: template\u003ctypename... Ts\u003e void magic(Ts... args) { std::cout \u003c\u003c sizeof...(args) \u003c\u003c std::endl; } 我们可以传递任意个参数给 magic 函数: magic(); // 输出 0 magic(1); // 输出 1 magic(1, \"\"); // 输出 2 其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法: 递归模版函数 递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的: #include \u003ciostream\u003e template\u003ctypename T0\u003e void printf1(T0 value) { std::cout \u003c\u003c value \u003c\u003c std::endl; } template\u003ctypename T, typename... Ts\u003e void printf1(T value, Ts... args) { std::cout \u003c\u003c value \u003c\u003c std::endl; printf1(args...); } int main() { printf1(1, 2, \"123\", 1.1); return 0; } 变参模版展开 你应该感受到了这很繁琐，在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 printf 的编写： template\u003ctypename T0, typename... T\u003e void printf2(T0 t0, T... t) { std::cout \u003c\u003c t0 \u003c\u003c std::endl; if constexpr (sizeof...(t) \u003e 0) printf2(t...); } 事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 std::bind 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。 初始化列表展开 递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。 这里介绍一种使用初始化列表展开的黑魔法: template\u003ctypename T, typename... Ts\u003e auto printf3(T value, Ts... args) { std::cout \u003c\u003c value \u003c\u003c std::endl; (void) std::initializer_list\u003cT\u003e {([\u0026args] { std::cout \u003c\u003c args \u003c\u003c std::endl; }(), value)...}; } 在这个代码中，额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性(下一节中将 提到)。 通过初始化列表，(lambda 表达式, value)… 将会被展开。由于逗号表达式的出现，首先会执行 前面的 lambda 表达式，完成参数的输出。为了避免编译器警告，我们可以将 std::initializer_list 显式的转为 void。 折叠表达式 C++ 17 中将变长参数这种特性进一步带给了表达式，考虑下面这个例子: #include \u003ciostream\u003e template\u003ctypename ... T\u003e auto sum(T ... t) { return (t + ...); } int main() { std::cout \u003c\u003c sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) \u003c\u003c std::endl; } 非类型模版参数推导 前面我们主要提及的是模板参数的一种形式:类型模板参数 template \u003ctypename T, typename U\u003e auto add(T t, U u) { return t+u; } 其中模板的参数 T 和 U 为具体的类型。但还有一种常见模板参数形式可以让不同字面量成为模板参 数，即非类型模板参数: template \u003ctypename T, int BufSize\u003e class buffer_t { public: T\u0026 alloc(); void free(T\u0026 item); private: T data[BufSize]; } buffer_t\u003cint, 100\u003e buf; // 100 作为模板参数 在这种模板参数形式下，我们可以将 100 作为模板的参数进行","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:5","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 本节介绍了现代 C++ 中对语言可用性的增强，其中笔者认为最为重要的几个特性是几乎所有人都 需要了解并熟练使用的: auto 类型推导 范围 for 迭代 初始化列表 变参模板 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:6","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"语言运行期间的强化 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"Lambda表达式 Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类 似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用 的。这样的场景其实有很多很多，所以匿名函数几乎是现代编程语言的标配。 基础 Lambda 表达式的基本语法如下: [捕获列表](参数列表) mutable(可选) 异常属性 -\u003e 返回类型 { // 函数体 } 上面的语法规则除了 [捕获列表] 内的东西外，其他部分都很好理解，只是一般函数的函数名被略 去，返回值使用了一个 -\u003e 的形式进行(我们在上一节前面的尾返回类型已经提到过这种写法了)。 所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能 够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列 表也分为以下几种: 值捕获 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝，而非调用时才拷贝: void lambda_value_capture() { int value = 1; auto copy_value = [value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout \u003c\u003c \"stored_value = \" \u003c\u003c stored_value \u003c\u003c std::endl; // 这时, stored_value == 1, 而 value == 100. // 因为 copy_value 在创建时就保存了一份 value 的拷贝 } 引用捕获 与引用传参类似，引用捕获保存的是引用，值会发生变化。 void lambda_reference_capture() { int value = 1; auto copy_value = [\u0026value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout \u003c\u003c \"stored_value = \" \u003c\u003c stored_value \u003c\u003c std::endl; // 这时, stored_value == 100, value == 100. // 因为 copy_value 保存的是引用 } 隐式捕获 手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时 候可以在捕获列表中写一个 \u0026 或 = 向编译器声明采用引用捕获或者值捕获. 总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是: [] 空捕获列表 [name1, name2, …] 捕获一系列变量 [\u0026] 引用捕获，让编译器自行推导引用列表 [=] 值捕获，让编译器自行推导值捕获列表 表达式捕获 这部分内容需要了解后面马上要提到的右值引用以及智能指针 上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左 值，而不能捕获右值。 C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被 声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的: #include \u003ciostream\u003e #include \u003cmemory\u003e // std::make_unique #include \u003cutility\u003e // std::move void lambda_expression_capture() { auto important = std::make_unique\u003cint\u003e(1); auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -\u003e int { return x+y+v1+(*v2); }; std::cout \u003c\u003c add(3,4) \u003c\u003c std::endl; } 在上面的代码中，important 是一个独占指针，是不能够被 “=” 值捕获到，这时候我们可以将其转 移为右值，在表达式中初始化。 范型Lambda 上一节中我们提到了 auto 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生 冲突。但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。这就为我们造成了 一定程度上的麻烦:参数表不能够泛化，必须明确参数表类型。 幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型: auto add = [](auto x, auto y) { return x+y; }; add(1, 2); add(1.1, 2.2); ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"函数对象包装器 这部分内容虽然属于标准库的一部分，但是从本质上来看，它却增强了 C++ 语言运行时的能力，这 部分内容也相当重要，所以放到这里来进行介绍。 std::function Lambda 表达式的本质是一个和函数对象类型相似的类类型(称为闭包类型)的对象(称为闭包对 象)，当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如: #include \u003ciostream\u003e using foo = void(int); // 定义函数类型, using 的使用见上一节中的别名语法 // 定义在参数列表中的函数类型 foo 被视为退化后的函数指针类型 foo* void functional(foo f) { f(1); // 通过函数指针调用函数 } int main() { auto f = [](int value) { std::cout \u003c\u003c value \u003c\u003c std::endl; }; functional(f); // 传递闭包对象，隐式转换为 foo* 类型的函数指针值 f(1); // lambda 表达式调用 return 0; } 上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用，而另一种则是直接调用 Lambda 表达式 在 C++11 中，统一了这些概念，将能够被调用的对象的类型，统一称之为可调用类型。而这种类型，便是通过 std::function 引入的。 C++11 std::function 是一种通用、多态的函数封装，它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，它也是对 C++ 中现有的可调用实体的一种类型安全的包裹(相对来说，函数指针的调用不是类型安全的)，换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。例如: #include \u003cfunctional\u003e #include \u003ciostream\u003e int foo(int para) { return para; } int main() { // std::function 包装了一个返回值为 int, 参数为 int 的函数 std::function\u003cint(int)\u003e func = foo; int important = 10; std::function\u003cint(int)\u003e func2 = [\u0026](int value) -\u003e int { return 1+value+important; }; std::cout \u003c\u003c func(10) \u003c\u003c std::endl; std::cout \u003c\u003c func2(10) \u003c\u003c std::endl; } std::bind 和 std::placeholder 而 std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。例如: int foo(int a, int b, int c) { ; } int main() { // 将参数 1,2 绑定到函数 foo 上，但是使用 std::placeholders::_1 来对第一个参数进行占位 auto bindFoo = std::bind(foo, std::placeholders::_1, 1,2); // 这时调用 bindFoo 时，只需要提供第一个参数即可 bindFoo(1); } 提示：注意 auto 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型，但是我们却可以通过 auto 的使用来规避这一问题的出现。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"右值引用 右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大量的历史遗留问题，消除了诸如 std::vector、std::string 之类的额外开销，也才使得函数对象容器 std::function 成为了可能。 左值、右值的纯右值、将亡值、右值 左值 顾名思义就是赋值符号左边的值。准确来说，左值是表达式(不一定是 赋值表达式)后依然存在的持久对象。 右值 右边的值，是指表达式结束后就不再存在的临时对象 而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为:纯右值、将亡值。 纯右值 纯粹的右值，要么是纯粹的字面量，例如 10, true;要么是求值 结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、原 始字面量、Lambda 表达式都属于纯右值。 需要注意的是，字符串字面量只有在类中才是右值，当其位于普通函数中是左值。例如: class Foo { const char*\u0026\u0026 right = \"this is a rvalue\"; // 此处字符串字面量为右值 public: void bar() { right = \"still rvalue\"; // 此处字符串字面量为右值 } }; int main() { const char* const \u0026left = \"this is an lvalue\"; // 此处字符串字面量为左值 } 将亡值 将亡值 (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念(因此在传统 C++ 中，纯右值和右值是同一个概念)，也就是即将被销毁、却能够被移动的值。 将亡值可能稍有些难以理解，我们来看这样的代码: std::vector\u003cint\u003e foo() { std::vector\u003cint\u003e temp = {1, 2, 3, 4}; return temp; } std::vector\u003cint\u003e v = foo(); 在这样的代码中，就传统的理解而言，函数 foo 的返回值 temp 在内部创建然后被赋值给 v，然而 v 获得这个对象时，会将整个 temp 拷贝一份，然后把 temp 销毁，如果这个 temp 非常大，这将造成大量额外的开销(这也就是传统 C++ 一直被诟病的问题)。 在最后一行中，v 是左值、foo() 返回的值就是右值(也是纯右值)。但是，v 可以被别的变量捕获到，而 foo() 产生的那个返回值作为一个临时值，一旦被 v 复制后，将立即被销毁，无法获取、也不能修改。而将亡值就定义了这样一种行为:临时的值能够被识别、同时又能够被移动。 在 C++11 之后，编译器为我们做了一些工作，此处的左值 temp 会被进行此隐式右值转换，等价于 static_cast\u003cstd::vector\u003cint\u003e \u0026\u0026\u003e(temp)，进而此处的 v 会将 foo 局部返回的值进行移动。也就是后面我们将会提到的移动语义。 右值引用和左值引用 要拿到一个将亡值，就需要用到右值引用:T \u0026\u0026，其中 T 是类型。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。 C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象，例如: #include \u003ciostream\u003e #include \u003cstring\u003e void reference(std::string\u0026 str) { std::cout \u003c\u003c \" 左值\" \u003c\u003c std::endl; } void reference(std::string\u0026\u0026 str) { std::cout \u003c\u003c \" 右值\" \u003c\u003c std::endl; } int main() { std::string lv1 = \"string,\"; // lv1 是一个左值 // std::string\u0026\u0026 r1 = lv1; // 非法, 右值引用不能引用左值 std::string\u0026\u0026 rv1 = std::move(lv1); // 合法, std::move 可以将左值转移为右值 std::cout \u003c\u003c rv1 \u003c\u003c std::endl; // string, const std::string\u0026 lv2 = lv1 + lv1; // 合法, 常量左值引用能够延长临时变量的生命周期 // lv2 += \"Test\"; // 非法, 常量引用无法被修改 std::cout \u003c\u003c lv2 \u003c\u003c std::endl; // string,string, std::string\u0026\u0026 rv2 = lv1 + lv2; // 合法, 右值引用延长临时对象生命周期 rv2 += \"Test\"; // 合法, 非常量引用能够修改临时变量 std::cout \u003c\u003c rv2 \u003c\u003c std::endl; // string,string,string,Test reference(rv2); // 输出左值 return 0; } rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。 注意，这里有一个很有趣的历史遗留问题，我们先看下面的代码: #include \u003ciostream\u003e int main() { // int \u0026a = std::move(1); // 不合法，非常量左引用无法引用右值 const int \u0026b = std::move(1); // 合法, 常量左引用允许引用右值 std::cout \u003c\u003c a \u003c\u003c b \u003c\u003c std::endl; } 第一个问题，为什么不允许非常量引用绑定到非左值?这是因为这种做法存在逻辑错误: void increase(int \u0026 v) { v++; } void foo() { double s = 1; increase(s); } 由于 int\u0026 不能引用 double 类型的参数，因此必须产生一个临时值来保存 s 的值，从而当 increase() 修改这个临时值时，调用完成后 s 本身并没有被修改。 第二个问题，为什么常量引用允许绑定到非左值?原因很简单，因为 Fortran 需要。 移动语义 传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的 移动操作，调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。试想，搬家的 时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份(重买)再放到新家、再把原来的东 西全部扔掉(销毁)，这是非常反人类的一件事情。 传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间。右值 引用的出现恰好就解决了这两个概念的混淆问题，例如: #include \u003ciostream\u003e class A { public: int *pointer; A() : pointer(new int(1)) { std::cout \u003c\u003c \" 构造\" \u003c\u003c pointer \u003c\u003c std::endl; } A(A\u0026 a) : pointer(new int(*a.pointer)) { std::cout \u003c\u003c \" 拷贝\" \u003c\u003c pointer \u003c\u003c std::endl; } // 无意义的对象拷贝 A(A\u0026\u0026 a):pointer(a.pointer) { a.pointer = nullptr; std::cout \u003c\u003c \" 移动\" \u003c\u003c pointer \u003c\u003c std::endl; } ~A() { std::cout \u003c\u003c \" 析构\" \u003c\u003c pointer \u003c\u003c std::endl; delete pointer; } }; // 防止编译器优化 A return_rvalue(bool test) { A a,b; if(test) return a; // 等价于 static_cast\u003cA\u0026\u0026\u003e(a); else return b; // 等价于 static_cast\u003cA\u0026\u0026\u003e(b); } int main() { A obj = return_rvalue(false); std::cout \u003c\u003c \"obj:\" \u003c\u003c std::endl; std::cout \u003c\u003c obj.pointer \u003c\u003c std::endl; std::cout \u003c\u003c *obj.pointer \u003c\u003c std::endl; return 0; } 在上面的代码中: 首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出; 函数返回后，产生一个将亡值，被 A 的移动构造(A(A\u0026\u0026))引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。 从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子: #include \u003ciostream\u003e // std::cout #include \u003cutility\u003e // std::move #include \u003cvector\u003e // std::vector #include \u003cstring\u003e // std::string int main() { std::string str = \"Hello world.\"; std::vector\u003cstd::string\u003e v; // 将使用 push_back(const T\u0026), 即产生拷贝行","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 本章介绍了现代 C++ 中最为重要的几个语言运行时的增强，其中笔者认为本节中提到的所有特性 都是值得掌握的: Lambda 表达式 函数对象容器 std::function 3. 右值引用 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"进一步阅读参考文献 Bjarne Stroustrup, C++ 语言的设计与演化 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:5","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"容器 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:5:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"线性容器 std::array 看到这个容器的时候肯定会出现这样的问题: 为什么要引入 std::array 而不是直接使用 std::vector? 已经有了传统数组，为什么要用 std::array? 先回答第一个问题，与 std::vector 不同，std::array 对象的大小是固定的，如果容器大小是固 定的，那么可以优先考虑使用 std::array 容器。另外由于 std::vector 是自动扩容的，当存入大量的 数据后，并且对容器进行了删除操作，容器并不会自动归还被删除元素相应的内存，这时候就需要手动 运行 shrink_to_fit() 释放这部分内存。 std::vector\u003cint\u003e v; std::cout \u003c\u003c \"size:\" \u003c\u003c v.size() \u003c\u003c std::endl; // 输出 0 std::cout \u003c\u003c \"capacity:\" \u003c\u003c v.capacity() \u003c\u003c std::endl; // 输出 0 // 如下可看出 std::vector 的存储是自动管理的，按需自动扩张 // 但是如果空间不足，需要重新分配更多内存，而重分配内存通常是性能上有开销的操作 v.push_back(1); v.push_back(2); v.push_back(3); std::cout \u003c\u003c \"size:\" \u003c\u003c v.size() \u003c\u003c std::endl; // 输出 3 std::cout \u003c\u003c \"capacity:\" \u003c\u003c v.capacity() \u003c\u003c std::endl; // 输出 4 // 这里的自动扩张逻辑与 Golang 的 slice 很像 v.push_back(4); v.push_back(5); std::cout \u003c\u003c \"size:\" \u003c\u003c v.size() \u003c\u003c std::endl; // 输出 5 std::cout \u003c\u003c \"capacity:\" \u003c\u003c v.capacity() \u003c\u003c std::endl; // 输出 8 // 如下可看出容器虽然清空了元素，但是被清空元素的内存并没有归还 v.clear(); std::cout \u003c\u003c \"size:\" \u003c\u003c v.size() \u003c\u003c std::endl; // 输出 0 std::cout \u003c\u003c \"capacity:\" \u003c\u003c v.capacity() \u003c\u003c std::endl; // 输出 8 // 额外内存可通过 shrink_to_fit() 调用返回给系统 v.shrink_to_fit(); std::cout \u003c\u003c \"size:\" \u003c\u003c v.size() \u003c\u003c std::endl; // 输出 0 std::cout \u003c\u003c \"capacity:\" \u003c\u003c v.capacity() \u003c\u003c std::endl; // 输出 0 而第二个问题就更加简单，使用 std::array 能够让代码变得更加 现代化，而且封装了一些操作函 数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 std::sort。 使用 std::array 很简单，只需指定其类型和大小即可: std::array\u003cint, 4\u003e arr = {1, 2, 3, 4}; arr.empty(); // 检查容器是否为空 arr.size(); // 返回容纳的元素数 // 迭代器支持 for (auto \u0026i : arr) { // ... } // 用 lambda 表达式排序 std::sort(arr.begin(), arr.end(), [](int a, int b) { return b \u003c a; }); // 数组大小参数必须是常量表达式 constexpr int len = 4; std::array\u003cint, len\u003e arr = {1, 2, 3, 4}; // 非法, 不同于 C 风格数组，std::array 不会自动退化成 T* // int *arr_p = arr; 当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法: void foo(int *p, int len) { return; } std::array\u003cint, 4\u003e arr = {1,2,3,4}; // C 风格接口传参 // foo(arr, arr.size()); // 非法, 无法隐式转换 foo(\u0026arr[0], arr.size()); foo(arr.data(), arr.size()); // 使用 ‘std::sort‘ std::sort(arr.begin(), arr.end()); std::forward_list std::forward_list 是一个列表容器，使用方法和 std::list 基本类似，因此我们就不花费篇幅进 行介绍了。 需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问(这也是链表的特点)，也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:5:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"无序容器 我们已经熟知了传统 C++ 中的有序容器 std::map/std::set，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 \u003c 操作符比较元素大小并判断 元素是否相同，并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 \u003c 操作符的顺序来逐个遍历。 而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。 C++11 引入了的两组无序容器分别是:std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。 它们的用法和原有的 std::map/std::multimap/std::set/set::multiset 基本类似，由于这些容器我们已经很熟悉了，便不一一举例，我们直接来比较一下 std::map 和 std::unordered_map: #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cunordered_map\u003e #include \u003cmap\u003e int main() { // 两组结构按同样的顺序初始化 std::unordered_map\u003cint, std::string\u003e u = { {1, \"1\"}, {3, \"3\"}, {2, \"2\"} }; std::map\u003cint, std::string\u003e v = { {1, \"1\"}, {3, \"3\"}, {2, \"2\"} }; // 分别对两组结构进行遍历 std::cout \u003c\u003c \"std::unordered_map\" \u003c\u003c std::endl; for( const auto \u0026 n : u) std::cout \u003c\u003c \"Key:[\" \u003c\u003c n.first \u003c\u003c \"] Value:[\" \u003c\u003c n.second \u003c\u003c \"]\\n\"; std::cout \u003c\u003c std::endl; std::cout \u003c\u003c \"std::map\" \u003c\u003c std::endl; for( const auto \u0026 n : v) std::cout \u003c\u003c \"Key:[\" \u003c\u003c n.first \u003c\u003c \"] Value:[\" \u003c\u003c n.second \u003c\u003c \"]\\n\"; } 最终输出结果为： std::unordered_map Key:[2] Value:[2] Key:[3] Value:[3] Key:[1] Value:[1] std::map Key:[1] Value:[1] Key:[2] Value:[2] Key:[3] Value:[3] ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:5:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"元组 了解过 Python 的程序员应该知道元组的概念，纵观传统 C++ 中的容器，除了 std::pair 外，似 乎没有现成的结构能够用来存放不同类型的数据(通常我们会自己定义结构)。但 std::pair 的缺陷是 显而易见的，只能保存两个元素。 元组基本操作 关于元组的使用有三个核心的函数: std::make_tuple: 构造元组 std::get: 获得元组某个位置的值 std::tie: 元组拆包 #include \u003ctuple\u003e #include \u003ciostream\u003e auto get_student(int id) { // 返回类型被推断为 std::tuple\u003cdouble, char, std::string\u003e if (id == 0) return std::make_tuple(3.8, ’A’, \" 张三\"); if (id == 1) return std::make_tuple(2.9, ’C’, \" 李四\"); if (id == 2) return std::make_tuple(1.7, ’D’, \" 王五\"); return std::make_tuple(0.0, ’D’, \"null\"); // 如果只写 0 会出现推断错误, 编译失败 } int main() { auto student = get_student(0); std::cout \u003c\u003c \"ID: 0, \" \u003c\u003c \"GPA: \" \u003c\u003c std::get\u003c0\u003e(student) \u003c\u003c \", \" \u003c\u003c \" 成绩: \" \u003c\u003c std::get\u003c1\u003e(student) \u003c\u003c \", \" \u003c\u003c \" 姓名: \" \u003c\u003c std::get\u003c2\u003e(student) \u003c\u003c ’\\n’; double gpa; char grade; std::string name; // 元组进行拆包 std::tie(gpa, grade, name) = get_student(1); std::cout \u003c\u003c \"ID: 1, \" \u003c\u003c \"GPA: \" \u003c\u003c gpa \u003c\u003c \", \" \u003c\u003c \" 成绩: \" \u003c\u003c grade \u003c\u003c \", \" \u003c\u003c \" 姓名: \" \u003c\u003c name \u003c\u003c ’\\n’; } std::get 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象: std::tuple\u003cstd::string, double, double, int\u003e t(\"123\", 4.5, 6.7, 8); std::cout \u003c\u003c std::get\u003cstd::string\u003e(t) \u003c\u003c std::endl; std::cout \u003c\u003c std::get\u003cdouble\u003e(t) \u003c\u003c std::endl; // 非法, 引发编译期错误 std::cout \u003c\u003c std::get\u003c3\u003e(t) \u003c\u003c std::endl; 运行期索引 如果你仔细思考一下可能就会发现上面代码的问题，std::get\u003c\u003e 依赖一个编译期的常量，所以下面 的方式是不合法的: int index = 1; std::get\u003cindex\u003e(t); 那么要怎么处理?答案是，使用 std::variant\u003c\u003e(C++ 17 引入)，提供给 variant\u003c\u003e 的类型模板 参数可以让一个 variant\u003c\u003e 从而容纳提供的几种类型的变量(在其他语言，例如 Python/JavaScript 等， 表现为动态类型): #include \u003cvariant\u003e template \u003csize_t n, typename... T\u003e constexpr std::variant\u003cT...\u003e _tuple_index(const std::tuple\u003cT...\u003e\u0026 tpl, size_t i) { if constexpr (n \u003e= sizeof...(T)) throw std::out_of_range(\" 越界.\"); if (i == n) return std::variant\u003cT...\u003e{ std::in_place_index\u003cn\u003e, std::get\u003cn\u003e(tpl) }; return _tuple_index\u003c(n \u003c sizeof...(T)-1 ? n+1 : 0)\u003e(tpl, i); } template \u003ctypename... T\u003e constexpr std::variant\u003cT...\u003e tuple_index(const std::tuple\u003cT...\u003e\u0026 tpl, size_t i) { return _tuple_index\u003c0\u003e(tpl, i); } template \u003ctypename T0, typename ... Ts\u003e std::ostream \u0026 operator\u003c\u003c (std::ostream \u0026 s, std::variant\u003cT0, Ts...\u003e const \u0026 v) { std::visit([\u0026](auto \u0026\u0026 x){ s \u003c\u003c x;}, v); return s; } 这样我们就能： int i = 1; std::cout \u003c\u003c tuple_index(t, i) \u003c\u003c std::endl; 元组合并与遍历 还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现: auto new_tuple = std::tuple_cat(get_student(1), std::move(t)); 马上就能够发现，应该如何快速遍历一个元组?但是我们刚才介绍了如何在运行期通过非常数索引 一个 tuple 那么遍历就变得简单了，首先我们需要知道一个元组的长度，可以: template \u003ctypename T\u003e auto tuple_len(T \u0026tpl) { return std::tuple_size\u003cT\u003e::value; } 这样就能够对元组进行迭代了: // 迭代 for(int i = 0; i != tuple_len(new_tuple); ++i) std::cout \u003c\u003c tuple_index(new_tuple, i) \u003c\u003c std::endl; ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:5:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 本章简单介绍了现代 C++ 中新增的容器，它们的用法和传统 C++ 中已有的容器类似，相对简单， 可以根据实际场景丰富的选择需要使用的容器，从而获得更好的性能。 std::tuple 虽然有效，但是标准库提供的功能有限，没办法满足运行期索引和迭代的需求，好在我 们还有其他的方法可以自行实现。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:5:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"智能指针与内存管理 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"RAII 与引用计数 了解 Objective-C/Swift 的程序员应该知道引用计数的概念。引用计数这种计数是为了防止内存泄 露而产生的。基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那 么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减 为零时，就自动删除指向的堆内存。 在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源 而导致泄露。所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数(在 离开作用域时调用)的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。 凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 new 和 delete 去『记得』对资源进行释放。而 C++11 引入智能指针的概念，使用引用计数的想法，让程序员不 再需要关心手动释放内存。这些智能指针就包括 std::shared_ptr/std::unique_ptr/std::weak_ptr， 使用它们需要包含头文件 。 注意:引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过 程中也不会造成长时间的等待，更能够清晰明确的表明资源的生命周期。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"std::shared_ptr std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当引用计数变为零的时候就会将对象自动删除。 但还不够，因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。 std::make_shared 就能够用来消除显式的使用 new，所以 std::make_shared 会分配创建传入参数中的对象，并返回这个对象类型的 std::shared_ptr 指针。例如: #include \u003ciostream\u003e #include \u003cmemory\u003e void foo(std::shared_ptr\u003cint\u003e i) { (*i)++; } int main() { // auto pointer = new int(10); // illegal, no direct assignment // Constructed a std::shared_ptr auto pointer = std::make_shared\u003cint\u003e(10); foo(pointer); std::cout \u003c\u003c *pointer \u003c\u003c std::endl; // 11 // The shared_ptr will be destructed before leaving the scope return 0; } std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数，并通过 use_count() 来查看一个对象的引用计数。例如: auto pointer = std::make_shared\u003cint\u003e(10); auto pointer2 = pointer; // 引用计数 +1 auto pointer3 = pointer; // 引用计数 +1 int *p = pointer.get(); // 这样不会增加引用计数 std::cout \u003c\u003c \"pointer.use_count() = \" \u003c\u003c pointer.use_count() \u003c\u003c std::endl; // 3 std::cout \u003c\u003c \"pointer2.use_count() = \" \u003c\u003c pointer2.use_count() \u003c\u003c std::endl; // 3 std::cout \u003c\u003c \"pointer3.use_count() = \" \u003c\u003c pointer3.use_count() \u003c\u003c std::endl; // 3 pointer2.reset(); std::cout \u003c\u003c \"reset pointer2:\" \u003c\u003c std::endl; std::cout \u003c\u003c \"pointer.use_count() = \" \u003c\u003c pointer.use_count() \u003c\u003c std::endl; // 2 std::cout \u003c\u003c \"pointer2.use_count() = \" \u003c\u003c pointer2.use_count() \u003c\u003c std::endl; // 0, pointer2 已 reset std::cout \u003c\u003c \"pointer3.use_count() = \" \u003c\u003c pointer3.use_count() \u003c\u003c std::endl; // 2 pointer3.reset(); std::cout \u003c\u003c \"reset pointer3:\" \u003c\u003c std::endl; std::cout \u003c\u003c \"pointer.use_count() = \" \u003c\u003c pointer.use_count() \u003c\u003c std::endl; // 1 std::cout \u003c\u003c \"pointer2.use_count() = \" \u003c\u003c pointer2.use_count() \u003c\u003c std::endl; // 0 std::cout \u003c\u003c \"pointer3.use_count() = \" \u003c\u003c pointer3.use_count() \u003c\u003c std::endl; // 0, pointer3 已 reset ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"std::unique_ptr std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代 码的安全: std::unique_ptr\u003cint\u003e pointer = std::make_unique\u003cint\u003e(10); // make_unique 从 C++14 引入 std::unique_ptr\u003cint\u003e pointer2 = pointer; // 非法 make_unique 并不复杂，C++11 没有提供 std::make_unique，可以自行实现: template\u003ctypename T, typename ...Args\u003e std::unique_ptr\u003cT\u003e make_unique( Args\u0026\u0026 ...args ) { return std::unique_ptr\u003cT\u003e( new T( std::forward\u003cArgs\u003e(args)... ) ); } 至于为什么没有提供，C++ 标准委员会主席 Herb Sutter 在他的博客中提到原因是因为『被 他们忘记了』。 既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr，例如: #include \u003ciostream\u003e #include \u003cmemory\u003e struct Foo { Foo() { std::cout \u003c\u003c \"Foo::Foo\" \u003c\u003c std::endl; } ~Foo() { std::cout \u003c\u003c \"Foo::~Foo\" \u003c\u003c std::endl; } void foo() { std::cout \u003c\u003c \"Foo::foo\" \u003c\u003c std::endl; } }; void f(const Foo \u0026) { std::cout \u003c\u003c \"f(const Foo\u0026)\" \u003c\u003c std::endl; } int main() { std::unique_ptr\u003cFoo\u003e p1(std::make_unique\u003cFoo\u003e()); // p1 不空, 输出 if (p1) p1-\u003efoo(); { std::unique_ptr\u003cFoo\u003e p2(std::move(p1)); // p2 不空, 输出 f(*p2); // p2 不空, 输出 if(p2) p2-\u003efoo(); // p1 为空, 无输出 if(p1) p1-\u003efoo(); p1 = std::move(p2); // p2 为空, 无输出 if(p2) p2-\u003efoo(); std::cout \u003c\u003c \"p2 被销毁\" \u003c\u003c std::endl; } // p1 不空, 输出 if (p1) p1-\u003efoo(); // Foo 的实例会在离开作用域时被销毁 } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"std::weak_ptr 如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。看下面这个例子: struct A; struct B; struct A { std::shared_ptr\u003cB\u003e pointer; ~A() { std::cout \u003c\u003c \"A 被销毁\" \u003c\u003c std::endl; } }; struct B { std::shared_ptr\u003cA\u003e pointer; ~B() { std::cout \u003c\u003c \"B 被销毁\" \u003c\u003c std::endl; } }; int main() { auto a = std::make_shared\u003cA\u003e(); auto b = std::make_shared\u003cB\u003e(); a-\u003epointer = b; b-\u003epointer = a; } 运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，这使得 a,b 的引 用计数均变为了 2，而离开作用域时，a,b 智能指针被析构，却只能造成这块区域的引用计数减一，这样 就导致了 a,b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了 内存泄露，如图 shared_ptr 相互引用导致无法释放 解决这个问题的办法就是使用弱引用指针 std::weak_ptr，std::weak_ptr 是一种弱引用(相比较而言 std::shared_ptr 就是一种强引用)。弱引用不会引起引用计数增加，当换用弱引用时候，最终的 释放流程如图所示: weak_ptr 相互引用可以释放 在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。 std::weak_ptr 没有 * 运算符和 -\u003e 运算符，所以不能够对资源进行操作，它可以用于检查 std::shared_ptr 是否存在，其 expired() 方法能在资源未被释放时，会返回 false，否则返回 true; 除此之外，它也可以用于获取指向原始对象的 std::shared_ptr 指针，其 lock() 方法在原始对象未被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回 nullptr。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 智能指针这种技术并不新奇，在很多语言中都是一种常见的技术，现代 C++ 将这项技术引进，在 一定程度上消除了 new/delete 的滥用，是一种更加成熟的编程范式。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:5","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"进一步阅读的参考资料 stackoverflow 上关于『C++11 为什么没有 make_unique』的讨论 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:6","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"正则表达式 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:7:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"正则表达式简介 正则表达式不是 C++ 语言的一部分，这里仅做简单的介绍。 正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求: 检查一个串是否包含某种形式的子串; 将匹配的子串替换; 从某个串中取出符合条件的子串。 正则表达式是由普通字符(例如 a 到 z)以及特殊字符组成的文字模式。模式描述在搜索文本时要 匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所 有数字、所有标点符号和一些其他符号。 特殊字符 特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表: 特殊字符 说明 $ 匹配输入字符串的结尾位置 (,) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用 * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 . 匹配除换行符 \\n 之外的任何单字符 [ 标记一个中括号表达式的开始 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如，n 匹配字符 n。\\n 匹配换行符。序列 \\\\ 匹配 \\ 字符，而 \\( 则匹配 ( 字符。 ˆ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合 { 标记限定符表达式的开始 | 指明两项之间的一个选择 限定符 限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表: 限定符 说明 * 匹配前面的子表达式零次或多次。例如，foo* 能匹配 fo 以及 foooo。* 等价于 {0,} + 匹配前面的子表达式一次或多次。例如，foo+ 能匹配 foo 以及 foooo，但不能匹配 fo。+ 等价于 {1,} ? 匹配前面的子表达式零次或一次。例如，Your(s)? 可以匹配 Your 或 Yours 中的 Your 。? 等价于 {0,1} {n} n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 for 中的 o，但是能匹配 foo 中的两个 o {n,} n 是一个非负整数。至少匹配 n 次。例如，o{2,} 不能匹配 for 中的 o，但能匹配 foooooo 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o* {n,m} m 和 n 均为非负整数，其中 n 小于等于 m。最少匹配 n 次且最多匹配 m 次。例如,o{1,3} 将匹配 foooooo 中的前三个o。o{0,1} 等价于 o?。注意，在逗号和两个数之间不能有空格 有了这两张表，我们通常就能够读懂几乎所有的正则表达式了。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:7:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"std::regex 及其相关 对字符串内容进行匹配的最常见手段就是使用正则表达式。可惜在传统 C++ 中正则表达式一直没有得到语言层面的支持，没有纳入标准库，而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时，使用正则表达式也是工业界最为成熟的普遍做法。 一般的解决方案就是使用 boost 的正则表达式库。而 C++11 正式将正则表达式的的处理方法纳入标准库的行列，从语言级上提供了标准的支持，不再依赖第三方。 C++11 提供的正则表达式库操作 std::string 对象，模式 std::regex (本质是 std::basic_regex) 进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch(本质是 std::match_results 对象)。 我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式: [a-z]+\\.txt: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多次，因此 [a-z]+ 能够匹配一个小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字符，而 \\. 则表示匹配字符 .，最后的 txt 表示严格匹配 txt 这三个字母。因此这个正则表达式的 所要匹配的内容就是由纯小写字母组成的文本文件。 std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是 传入 std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。例如: #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cregex\u003e int main() { std::string fnames[] = {\"foo.txt\", \"bar.txt\", \"test\", \"a0.txt\", \"AAA.txt\"}; // 在 C++ 中 \\ 会被作为字符串内的转义符，为使 \\. 作为正则表达式传递进去生效，需要对 \\ 进行二次转义， std::regex txt_regex(\"[a-z]+\\\\.txt\"); for (const auto \u0026fname: fnames) std::cout \u003c\u003c fname \u003c\u003c \": \" \u003c\u003c std::regex_match(fname, txt_regex) \u003c\u003c std::endl; } 另一种常用的形式就是依次传入 std::string/std::smatch/std::regex 三个参数，其中std::smatch 的本质其实是 std::match_results。在标准库中，std::smatch 被定义为了 std::match_results\u003cstd::string 也就是一个子串迭代器类型的 match_results。使用 std::smatch 可以方便的对匹配的结果进行获取，例如: std::regex base_regex(\"([a-z]+)\\\\.txt\"); std::smatch base_match; for(const auto \u0026fname: fnames) { if (std::regex_match(fname, base_match, base_regex)) { // std::smatch 的第一个元素匹配整个字符串 // std::smatch 的第二个元素匹配了第一个括号表达式 if (base_match.size() == 2) { std::string base = base_match[1].str(); std::cout \u003c\u003c \"sub-match[0]: \" \u003c\u003c base_match[0].str() \u003c\u003c std::endl; std::cout \u003c\u003c fname \u003c\u003c \" sub-match[1]: \" \u003c\u003c base \u003c\u003c std::endl; } } } 以上两个代码段的输出结果为: foo.txt: 1 bar.txt: 1 test: 0 a0.txt: 0 AAA.txt: 0 sub-match[0]: foo.txt foo.txt sub-match[1]: foo sub-match[0]: bar.txt bar.txt sub-match[1]: bar ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:7:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 本节简单介绍了正则表达式本身，然后根据使用正则表达式的主要需求，通过一个实际的例子介绍了正则表达式库的使用。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:7:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"进一步阅读的参考资料 知乎『如何评价 GCC 的 C++11 正则表达式?』中原库作者 Tim Shen 的回答 正则表达式库文档 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:7:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"并行与并发 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"并行基础 std::thread 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含 \u003cthread\u003e 头文件，它提供了很多基本的线程操作，例如 get_id() 来获取所创建线程的线程 ID，使用 join() 来加入一个线程等等，例如: #include \u003ciostream\u003e #include \u003cthread\u003e int main() { std::thread t([]() { std::cout \u003c\u003c \"hello world.\" \u003c\u003c std::endl; }); t.join(); return 0; } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"互斥量与临界区 我们在操作系统、亦或是数据库的相关知识中已经了解过了有关并发技术的基本知识，mutex 就是其中的核心之一。C++11 引入了 mutex 相关的类，其所有相关的函数都放在 头文件中。 std::mutex 是 C++11 中最基本的 mutex 类，通过实例化 std::mutex 可以创建互斥量，而通过其 成员函数 lock() 可以进行上锁，unlock() 可以进行解锁。但是在实际编写代码的过程中，最好不去直 接调用成员函数，因为调用成员函数就需要在每个临界区的出口处调用 unlock()，当然，还包括异常。 这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类 std::lock_guard。RAII 在不失代码简洁性 的同时，很好的保证了代码的异常安全性。 在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如: #include \u003ciostream\u003e #include \u003cmutex\u003e #include \u003cthread\u003e int v = 1; void critical_section(int change_v) { static std::mutex mtx; std::lock_guard\u003cstd::mutex\u003e lock(mtx); // 执行竞争操作 v = change_v; // 离开此作用域后 mtx 会被释放 } int main() { std::thread t1(critical_section, 2), t2(critical_section, 3); t1.join(); t2.join(); std::cout \u003c\u003c v \u003c\u003c std::endl; return 0; } 由于 C++ 保证了所有栈对象在生命周期结束时会被销毁，所以这样的代码也是异常安全的。无论 critical_section() 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 unlock()。 而 std::unique_lock 则相对于 std::lock_guard 出现的，std::unique_lock 更加灵活，std::unique_lock 的对象会以独占所有权(没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权)的方式管理 mutex 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 std::unique_lock。 std::lock_guard 不能显式的调用 lock 和 unlock，而 std::unique_lock 可以在声明后的任意位置调用，可以缩小锁的作用范围，提供更高的并发度。 如果你用到了条件变量 std::condition_variable::wait 则必须使用 std::unique_lock 作为参数。 例如： #include \u003ciostream\u003e #include \u003cmutex\u003e #include \u003cthread\u003e int v = 1; void critical_section(int change_v) { static std::mutex mtx; std::unique_lock\u003cstd::mutex\u003e lock(mtx); // 执行竞争操作 v = change_v; std::cout \u003c\u003c v \u003c\u003c std::endl; // 将锁进行释放 lock.unlock(); // 在此期间，任何人都可以抢夺 v 的持有权 // 开始另一组竞争操作，再次加锁 lock.lock(); v += 1; std::cout \u003c\u003c v \u003c\u003c std::endl; } int main() { std::thread t1(critical_section, 2), t2(critical_section, 3); t1.join(); t2.join(); return 0; } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"期物 期物(Future)表现为 std::future，它提供了一个访问异步操作结果的途径，这句话很不好理解。为了理解这个特性，我们需要先理解一下在 C++11 之前的多线程行为。 试想，如果我们的主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务，并返回我一个结 果。而这时候，线程 A 可能正在忙其他的事情，无暇顾及 B 的结果，所以我们会很自然的希望能够在某 个特定的时间获得线程 B 的结果。 在 C++11 的 std::future 被引入之前，通常的做法是:创建一个线程 A，在线程 A 里启动任务 B，当准备完毕后发送一个事件，并将结果保存在全局变量中。而主函数线程 A 里正在做其他的事情，当 需要结果的时候，调用一个线程等待函数来获得执行的结果。 而 C++11 提供的 std::future 简化了这个流程，可以用来获取异步任务的结果。自然地，我们很 容易能够想象到把它作为一种简单的线程同步手段，即屏障(barrier)。 为了看一个例子，我们这里额外使用 std::packaged_task，它可以用来封装任何可以调用的目标， 从而用于实现异步的调用。举例来说: #include \u003ciostream\u003e #include \u003cfuture\u003e #include \u003cthread\u003e int main() { // 将一个返回值为 7 的 lambda 表达式封装到 task 中 // std::packaged_task 的模板参数为要封装函数的类型 std::packaged_task\u003cint()\u003e task([](){return 7;}); // 获得 task 的期物 std::future\u003cint\u003e result = task.get_future(); // 在一个线程中执行 task std::thread(std::move(task)).detach(); std::cout \u003c\u003c \"waiting...\"; result.wait(); // 在此设置屏障，阻塞到期物的完成 // 输出执行结果 std::cout \u003c\u003c \"done!\" \u003c\u003c std:: endl \u003c\u003c \"future result is \" \u003c\u003c result.get() \u003c\u003c std::endl; return 0; } 在封装好要调用的目标后，可以使用 get_future() 来获得一个 std::future 对象，以便之后实施 线程同步。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"条件变量 条件变量 std::condition_variable 是为了解决死锁而生，当互斥操作不够用而引入的。比如，线程 可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临 界区使得条件为真时，就会发生死锁。所以，condition_variable 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。std::condition_variable 的 notify_one() 用于唤醒一个线程;notify_all() 则是通知所有线程。下面是一个生产者和消费者模型的例子: #include \u003cqueue\u003e #include \u003cchrono\u003e #include \u003cmutex\u003e #include \u003cthread\u003e #include \u003ciostream\u003e #include \u003ccondition_variable\u003e int main() { std::queue\u003cint\u003e produced_nums; std::mutex mtx; std::condition_variable cv; bool notified = false; // 通知信号 // 生产者 auto producer = [\u0026]() { for (int i = 0; ; i++) { std::this_thread::sleep_for(std::chrono::milliseconds(900)); std::unique_lock\u003cstd::mutex\u003e lock(mtx); std::cout \u003c\u003c \"producing \" \u003c\u003c i \u003c\u003c std::endl; produced_nums.push(i); notified = true; cv.notify_all(); // 此处也可以使用 notify_one } }; // 消费者 auto consumer = [\u0026]() { while (true) { std::unique_lock\u003cstd::mutex\u003e lock(mtx); while (!notified) { // 避免虚假唤醒 cv.wait(lock); } // 短暂取消锁，使得生产者有机会在消费者消费空前继续生产 lock.unlock(); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // 消费者慢于生产者 lock.lock(); while (!produced_nums.empty()) { std::cout \u003c\u003c \"consuming \" \u003c\u003c produced_nums.front() \u003c\u003c std::endl; produced_nums.pop(); } notified = false; } }; // 分别在不同的线程中运行 std::thread p(producer); std::thread cs[2]; for (int i = 0; i \u003c 2; ++i) { cs[i] = std::thread(consumer); } p.join(); for (int i = 0; i \u003c 2; ++i) { cs[i].join(); } return 0; } 值得一提的是，在生产者中我们虽然可以使用 notify_one()，但实际上并不建议在此处使用，因为在多消费者的情况下，我们的消费者实现中简单放弃了锁的持有，这使得可能让其他消费者争夺此锁，从 而更好的利用多个消费者之间的并发。话虽如此，但实际上因为 std::mutex 的排他性，我们根本无法 期待多个消费者能真正意义上的并行消费队列的中生产的内容，我们仍需要粒度更细的手段。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"原子操作与内存模型 细心的读者可能会对前一小节中生产者消费者模型的例子可能存在编译器优化导致程序出错的情况 产生疑惑。例如，布尔值 notified 没有被 volatile 修饰，编译器可能对此变量存在优化，例如将其作 为一个寄存器的值，从而导致消费者线程永远无法观察到此值的变化。这是一个好问题，为了解释清楚 这个问题，我们需要进一步讨论从 C++ 11 起引入的内存模型这一概念。我们首先来看一个问题，下面 这段代码输出结果是多少？ #include \u003cthread\u003e #include \u003ciostream\u003e int main() { int a = 0; int flag = 0; std::thread t1([\u0026]() { while (flag != 1); int b = a; std::cout \u003c\u003c \"b = \" \u003c\u003c b \u003c\u003c std::endl; }); std::thread t2([\u0026]() { a = 5; flag = 1; }); t1.join(); t2.join(); return 0; } 从直观上看，t2 中 a = 5; 这一条语句似乎总在 flag = 1; 之前得到执行，而 t1 中 while (flag != 1) 似乎保证了 std::cout \u003c\u003c \"b = \" \u003c\u003c b \u003c\u003c std::endl; 不会再标记被改变前执行。从逻辑上看，似乎 b 的值应该等于 5。但实际情况远比此复杂得多，或者说这段代码本身属于未定义的行为，因为对于 a 和 flag 而言，他们在两个并行的线程中被读写，出现了竞争。除此之外，即便我们忽略竞争读写，仍然可能受 CPU 的乱序执行，编译器对指令的重排的影响，导致 a = 5 发生在 flag = 1 之后。 从而 b 可能输出 0。 原子操作 std::mutex 可以解决上面出现的并发读写的问题，但互斥锁是操作系统级的功能，这是因为一个互斥锁的实现通常包含两条基本原理: 提供线程间自动的状态转换，即『锁住』这个状态 保障在互斥锁操作期间，所操作变量的内存与临界区外进行隔离 这是一组非常强的同步条件，换句话说当最终编译为 CPU 指令时会表现为非常多的指令(我们之 后再来看如何实现一个简单的互斥锁)。这对于一个仅需原子级操作(没有中间态)的变量，似乎太苛刻 了。 关于同步条件的研究有着非常久远的历史，我们在这里不进行赘述。读者应该明白，在现代 CPU 体 系结构下提供了 CPU 指令级的原子操作，因此在 C++11 中多线程下共享变量的读写这一问题上，还引 入了 std::atomic 模板，使得我们实例化一个原子类型，将一个原子类型读写操作从一组指令，最小化 到单个 CPU 指令。例如: std::atomic\u003cint\u003e counter; 并为整数或浮点数的原子类型提供了基本的数值成员函数，举例来说，包括 fetch_add, fetch_sub 等，同时通过重载方便的提供了对应的 +，- 版本。比如下面的例子: #include \u003catomic\u003e #include \u003cthread\u003e #include \u003ciostream\u003e std::atomic\u003cint\u003e count = {0}; int main() { std::thread t1([](){ count.fetch_add(1); }); std::thread t2([](){ count++; // 等价于 fetch_add count += 1; // 等价于 fetch_add }); t1.join(); t2.join(); std::cout \u003c\u003c count \u003c\u003c std::endl; return 0; } 当然，并非所有的类型都能提供原子操作，这是因为原子操作的可行性取决于 CPU 的架构以及所实 例化的类型结构是否满足该架构对内存对齐条件的要求，因而我们总是可以通过 std::atomic::is_lock_free 来检查该原子类型是否需支持原子操作，例如: #include \u003catomic\u003e #include \u003ciostream\u003e struct A { float x; int y; long long z; }; int main() { std::atomic\u003cA\u003e a; std::cout \u003c\u003c std::boolalpha \u003c\u003c a.is_lock_free() \u003c\u003c std::endl; return 0; } 一致性模型 并行执行的多个线程，从某种宏观层面上讨论，可以粗略的视为一种分布式系统。在分布式系统中，任何通信乃至本地操作都需要消耗一定时间，甚至出现不可靠的通信。 如果我们强行将一个变量 v 在多个线程之间的操作设为原子操作，即任何一个线程在操作完 v 后， 其他线程均能同步感知到 v 的变化，则对于变量 v 而言，表现为顺序执行的程序，它并没有由于引入多 线程而得到任何效率上的收益。对此有什么办法能够适当的加速呢?答案便是削弱原子操作的在进程间 的同步条件。 从原理上看，每个线程可以对应为一个集群节点，而线程间的通信也几乎等价于集群节点间的通信。削弱进程间的同步条件，通常我们会考虑四种不同的一致性模型: 线性一致性 又称强一致性或原子一致性。它要求任何一次读操作都能读到某个数据的最近一次写 的数据，并且所有线程的操作顺序与全局时钟下的顺序是一致的。 线性一致性 在这种情况下线程 T1, T2 对 x 的两次写操作是原子的，且 x.store(1) 是严格的发生在 x.store(2) 之前，x.store(2) 严格的发生在 x.load() 之前。值得一提的是，线性一致性对全局时钟的要求 是难以实现的，这也是人们不断研究比这个一致性更弱条件下其他一致性的算法的原因。 顺序一致性 同样要求任何一次读操作都能读到数据最近一次写入的数据，但未要求与全局时钟的 顺序一致。 或者： 顺序一致性 在顺序一致性的要求下，x.load() 必须读到最近一次写入的数据，因此 x.store(2) 与 x.store(1) 并无任何先后保障，即只要 T2 的 x.store(2) 发生在 x.store(3) 之前即可。 因果一致性 它的要求进一步降低，只需要有因果关系的操作顺序得到保障，而非因果关系的操作顺序则不做要求。 或者： 亦或者： 因果一致性 上面给出的三种例子都是属于因果一致的，因为整个过程中，只有 c 对 a 和 b 产生依赖，而 x 和 y 在此例子中表现为没有关系(但实际情况中我们需要更详细的信息才能确定 x 与 y 确实无关) 最终一致性 是最弱的一致性要求，它只保障某个操作在未来的某个时间节点上会被观察到，但并 未要求被观察到的时间。因此我们甚至可以对此条件稍作加强，例如规定某个操作被观察到的时间 总是有界的。当然这已经不在我们的讨论范围之内了。 最终一致性 在上面的情况中，如果我们假设 x 的初始值为 0，则 T2 中四次 x.read() 结果可能但不限于以下 情况: 3 4 4 4 // x 的写操作被很快观察到 0 3 3 4 // x 的写操作被观察到的时间存在一定延迟 0 0 0 4 // 最后一次读操作读到了 x 的最终值，但此前的变化并未观察到 0 0 0 0 // 在当前时间段内 x 的写操作均未被观察到，但未来某个时间点上一定能观察到 x 为 4 的情况 内存顺序 为了追求极致的性能，实现各种强度要求的一致性，C++11 为原子操作定义了六种不同的内存顺序 std::memory_order 的选项，表达了四种多线程间的同步模型: 宽松模型 在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间 原子操作的顺序是任意的。类型通过 std::memory_order_relaxed 指定。我们来看一个例子: std::atomic\u003cint\u003e counter = {0}; std::vector\u003cstd::thread\u003e vt; for (int i = 0; i \u003c 100; ++i) { vt.emplace_back([\u0026](){ counter.fetch_add(1, std::memory_order_relaxed); }); } for (auto\u0026 t : vt) { t.join(); } std::cout \u003c\u003c \"current counter:\" \u003c\u003c counter \u003c\u003c std::endl; 释放/消费模型 在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但另一个线程会对该值的某次操作产生依赖，即后者依赖前者。具体而言，线程 A 完成了三次对 x 的 写操作，线程 B 仅依赖其中第三次 x 的写操作，与 x 的前两次写行为无关，则当 A 主动 x.release() 时候(即使用 std::memory_order_release)，选项 std::memory_order_consume 能够确保 B 在 调用 x.load() 时候观察到 A 中第三次对 x 的写操作。我们来看一个例子: // 初始化为 nullptr 防止 consumer 线程从野指针进行读取 std::atomic\u003cint*\u003e ptr(nullptr); int v; std::thread producer([\u0026]() { int* p = new int(42); v = 1024; ptr.store(p, std::memory_order_release); }); std::thr","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:5","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 C++11 语言层提供了并发编程的相关支持，本节简单的介绍了 std::thread, std::mutex, std::future 这些并发编程中不可回避的重要工具。除此之外，我们还介绍了 C++11 最重要的几个特 性之一的『内存模型』，它们为 C++ 在标准化高性能计算中提供了重要的基础。 ### 进一步阅读的参考资料 [C++ 并发编程 (中文版)](https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details) [线程支持库文档](https://en.cppreference.com/w/cpp/thread) ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:6","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"文件系统 文件系统库提供了文件系统、路径、常规文件、目录等等相关组件进行操作的相关功能。和正则表达式库类似，他也是最先由 boost 发起，并最终被合并为 C++ 标准的众多库之一。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:9:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"其他杂项 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"新类型 long long int long long int 并不是 C++11 最先引入的，其实早在 C99，long long int 就已经被纳入 C 标 准中，所以大部分的编译器早已支持。C++11 的工作则是正式把它纳入标准库，规定了一个 long long int 类型至少具备 64 位的比特数。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"noexcept 的修饰和操作 C++ 相比于 C 的一大优势就在于 C++ 本身就定义了一套完整的异常处理机制。然而在 C++11之前，几乎没有人去使用在函数名后书写异常声明表达式，从 C++11 开始，这套机制被弃用，所以我们不去讨论也不去介绍以前这套机制是如何工作如何使用，你更不应该主动去了解它。 C++11 将异常的声明简化为以下两种情况: 函数可能抛出任何异常 函数不能抛出任何异常 并使用 noexcept 对这两种行为进行限制，例如: void may_throw(); // 可能抛出异常 void no_throw() noexcept; // 不可能抛出异常 使用 noexcept 修饰过的函数如果抛出异常，编译器会使用 std::terminate() 来立即终止程序运 行。 noexcept 还能够做操作符，用于操作一个表达式，当表达式无异常时，返回 true，否则返回 false。 #include \u003ciostream\u003e void may_throw() { throw true; } auto non_block_throw = [] { may_throw(); }; void no_throw() noexcept { return; } auto block_throw = []() noexcept { no_throw(); }; int main() { std::cout \u003c\u003c std::boolalpha \u003c\u003c \"may_throw() noexcept? \" \u003c\u003c noexcept(may_throw()) \u003c\u003c std::endl \u003c\u003c \"no_throw() noexcept? \" \u003c\u003c noexcept(no_throw()) \u003c\u003c std::endl \u003c\u003c \"lmay_throw() noexcept? \" \u003c\u003c noexcept(non_block_throw()) \u003c\u003c std::endl \u003c\u003c \"lno_throw() noexcept? \" \u003c\u003c noexcept(block_throw()) \u003c\u003c std::endl; return 0; } noexcept 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发。 例如: try { may_throw(); } catch (...) { std::cout \u003c\u003c \" 捕获异常, 来自 may_throw()\" \u003c\u003c std::endl; } try { non_block_throw(); } catch (...) { std::cout \u003c\u003c \" 捕获异常, 来自 non_block_throw()\" \u003c\u003c std::endl; } try { block_throw(); } catch (...) { std::cout \u003c\u003c \" 捕获异常, 来自 block_throw()\" \u003c\u003c std::endl; } 最终输出为： 捕获异常, 来自 may_throw() 捕获异常, 来自 non_block_throw() ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"字面量 原是字符串字面量 传统 C++ 里面要编写一个充满特殊字符的字符串其实是非常痛苦的一件事情，比如一个 包含 HTML 本体的字符串需要添加大量的转义符，例如一个 Windows 上的文件路径经常会: C:\\File\\To\\Path。 C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 R 来修饰这个字符串，同时， 将原始字符串使用括号包裹，例如: #include \u003ciostream\u003e #include \u003cstring\u003e int main() { std::string str = R\"(C:\\File\\To\\Path)\"; std::cout \u003c\u003c str \u003c\u003c std::endl; return 0; } 自定义字面量 C++11 引进了自定义字面量的能力，通过重载双引号后缀运算符实现: // 字符串字面量自定义必须设置如下的参数列表 std::string operator\"\" _wow1(const char *wow1, size_t len) { return std::string(wow1)+\"woooooooooow, amazing\"; } std::string operator\"\" _wow2 (unsigned long long i) { return std::to_string(i)+\"woooooooooow, amazing\"; } int main() { auto str = \"abc\"_wow1; auto num = 1_wow2; std::cout \u003c\u003c str \u003c\u003c std::endl; std::cout \u003c\u003c num \u003c\u003c std::endl; return 0; } 自定义字面量支持四种字面量: 整型字面量:重载时必须使用 unsigned long long、const char *、模板字面量算符参数，在上 面的代码中使用的是前者; 浮点型字面量:重载时必须使用 long double、const char *、模板字面量算符; 字符串字面量:必须使用 (const char *, size_t) 形式的参数表; 字符字面量:参数只能是 char, wchar_t, char16_t, char32_t 这几种类型。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"内存对齐 C++ 11 引入了两个新的关键字 alignof 和 alignas 来支持对内存对齐进行控制。alignof 关键字 能够获得一个与平台相关的 std::size_t 类型的值，用于查询该平台的对齐方式。当然我们有时候并不 满足于此，甚至希望自定定义结构的对齐方式，同样，C++ 11 还引入了 alignas 来重新修饰某个结构 的对齐方式。我们来看两个例子: #include \u003ciostream\u003e struct Storage { char a; int b; double c; long long d; }; struct alignas(std::max_align_t) AlignasStorage { char a; int b; double c; long long d; }; int main() { std::cout \u003c\u003c alignof(Storage) \u003c\u003c std::endl; std::cout \u003c\u003c alignof(AlignasStorage) \u003c\u003c std::endl; return 0; } 其中 std::max_align_t 要求每个标量类型的对齐方式严格一样，因此它几乎是最大标量没有差异， 进而大部分平台上得到的结果为 long double，因此我们这里得到的 AlignasStorage 的对齐要求是 8 或 16。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 本节介绍的几个特性是从仍未介绍的现代 C++ 新特性里使用频次较靠前的特性了，noexcept 是最 为重要的特性，它的一个功能在于能够阻止异常的扩散传播，有效的让编译器最大限度的优化我们的代 码。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:5","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"展望 C++20 C++20 如同 C++11 一样，似乎能够成为一个振奋人心的更新。例如，早在 C++11 时期就跃跃欲 试呼声极高却最终落选的 Concept，如今已经箭在弦上。C++ 组委会在讨论投票最终确定 C++20 有很 多提案，诸如 Concepts/Module/Coroutine/Ranges/ 等等。本章我们就来一览 C++20 即将引入的 那些重要特性。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:11:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"概念与约束 概念(Concepts)是对 C++ 模板编程的进一步增强扩展。简单来说，概念是一种编译期的特性，它 能够让编译器在编译期时对模板参数进行判断，从而大幅度增强我们在 C++ 中模板编程的体验。使用 模板进行编程时候我们经常会遇到各种令人发指的错误，这是因为到目前为止我们始终不能够对模板参 数进行检查与限制。举例而言，下面简单的两行代码会造成大量的几乎不可读的编译错误: #include \u003clist\u003e #include \u003calgorithm\u003e int main() { std::list\u003cint\u003e l = {1, 2, 3}; std::sort(l.begin(), l.end()); return 0; } 而这段代码出现错误的根本原因在于，std::sort 对排序容器必须提供随机迭代器，否则就不能使 用，而我们知道 std::list 是不支持随机访问的。用概念的语言来说就是:std::list 中的迭代器不满 足 std::sort 中随机迭代器这个概念的约束(Constraint)。在引入概念后，我们就可以这样对模板参数 进行约束: template \u003ctypename T\u003e requires Sortable\u003cT\u003e // Sortable 是一个概念 void sort(T\u0026 c); 缩写为： template\u003cSortable T\u003e // T 是一个 Sortable 的类型名 void sort(T\u0026 c) 甚至直接将其作为类型来使用： void sort(Sortable\u0026 c); // c 是一个 Sortable 类型的对象 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:11:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 总的来说，终于在 C++20 中看到 Concepts/Ranges/Modules 这些令人兴奋的特性，这对于一门已 经三十多岁『高龄』的编程语言，依然是充满魅力的。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:11:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"进一步阅读参考资料 Why Concepts didn’t make C++17? C++11/14/17/20 编译器支持情况 C++ 历史 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:11:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["git"],"content":"简单概括 git rebase 和 git merge 这两个命令旨在将更改代码从一个分支合并到另一个分支，只是两者合并方式不一样。 融合代码到公共分支的时候用 git merge，而不能使用 git rebase 融合代码到个人分支的时候用 git rebase， 可以不污染分支的提交记录，形成简洁的线性提交历史记录 git rebase aa bb, 会把 bb 合并到 aa 的头部 git checkout main \u0026\u0026 git rebase bb 会把 main 放到 bb 头部 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"rebase 详细过程 初始状态 git checkout -b aa \u0026\u0026 git commit -m \"aa\" git checkout -b main \u0026\u0026 git commit -m \"main\" git rebase aa main git commit -m \"rebase\" 上图中 main 原来的 HEAD 是 c3，rebase 之后变成了 c3'，main 分支到了 c2 之后，c3' 与 c3 相比就是 commit id 发生了变化 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:1:1","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"场景模拟 假设当前我们有master和feature分支，当你在专用分支上开发新 feature 时，然后另一个团队成员在 master 分支提交了新的 commits，这种属于正常的Git工作场景。如下图： 实际工作场景 现在，假设在 master 分支上的新提交与你正在开发的 feature 相关，需要master分支将新提交的记录合并到你的 feature 分支中。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git merge 合并master到feature git checkout feature git merge master 或者缩写一句 git merge feature master git merge feature master 由此可见，git merge 会在 feature 分支中新增一个新的 merge commit，然后将两个分支的历史联系在一起 使用 merge 是很好的方式，因为它是一种非破坏性的操作，对现有分支不会以任何方式被更改 另一方面，这也意味着 feature 分支每次需要合并上游更改时候，都会产生一个额外的合并提交。 如果 master 提交非常活跃，这可能会严重污染你的 feature 分支历史记录。不过这个问题可以使用高级选项 git log 来缓解 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:2:1","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git rebase 合并master到feature git checkout feature git rebase master 缩写为一句就是： git rebase feature master git rebase feature master rebase 会将整个 feature 分支移动到 master 分支的顶端，从而有效地整个了所有 master 分支上的提交。 但是，与merge 提交方式不同，rebase通过为原始分之中的每个提交创建全新的 commits 来重写项目历史记录，特点是仍然会在 feature 分支上形成线性提交。 rebase 的主要好处是可以获得更清晰的项目历史。首先，它消除了 git merge 所需的不必要的合并提交；其次，正如你在上图中所看到的，rebase 会产生完美线性的历史记录，你可以在 feature 分支上没有任何分叉的情况下一直追寻到项目的初始提交。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:2:2","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git rebase 原理 将 master 分之代码合并到 feature 上： 这边需要强调一个概念：reapply(重放)，使用 rebase 并不是简单的好像用 ctrl-x/ctrl-v 一样进行剪切复制一样，rebase会依次将你所要操作的分支的所有提交应用到目标分之上。 合并过程如下图： git rebase 合并图 从上图可以看出，在对特征分之进行 rebase 之后，其等效于创建了新的提交。并且老的提交也没有被销毁，只是简单的不能再被访问或者使用。 实际上在执行 rebase 的时候，有两个隐含的注意点： 在重放之前的提交的时候，Git会创建新的提交，也就是说即使你重放的提交与之前的一模一样Git也会将之当做新的独立的提交进行处理。 git rebase并不会删除老的提交，也就是说你在对某个分支执行了rebase操作之后，老的提交仍然会存放在.git文件夹的objects目录下。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:3:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"如何选择 git merge 和 git rebase 根据上面的对比可知： git merge 分支代码合并后不破坏原分支的代码提交记录，缺点就是会产生额外的提交记录并进行两条分支的合并 git rebase 优点是无须新增提交记录到目标分支，rebase后可以将对象分支的提交历史续上目标分支上，形成线性提交历史记录，进行review的时候更加直观 git merge 如果有多人进行开发并进行分支合并，会形成复杂的合并分支图 问题：既然rebase如此有用，那么可以使用rebase完全取代merge吗？ 答案：不能！ git rebase 黄金法则：不能在一个共享的分支上进行 git rebase 操作 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:4:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"rebase 的黄金法则 为什么不能在一个共享的分支上进行git rebase操作呢？ 所谓共享的分支，即是指那些存在于远端并且允许团队中的其他人进行Pull操作的分支，比如我们Git工作的master分支就是最常见的公共分支。 假设现在Bob和Anna在同一个项目组中工作，项目所属的仓库和分支大概是下图这样： 现在Bob为了图一时方便打破了原则(使用了git rebase)，正巧这时Anna在特征分支上进行了新的提交，此时的结构图大概是这样的： 当Bob推送自己的分支到远端的时候，现在的分支情况如下： 然后呢，当Anna也进行推送的时候，她会得到如下的提醒，Git提醒Anna她本地的版本与远程分支并不一致，需要向远端服务器拉取代码进行同步： 在Anna提交之前，分支中的Commit序列是如下这样的： A--B--C--D' origin/feature // GitHub A--B--D--E feature // Anna 在进行Pull操作之后，Git会进行自动地合并操作，结果大概是这样的： 这个第M个提交即代表着合并的提交，也就是Anna本地的分支与Github上的特征分支最终合并的点，现在Anna解决了所有的合并冲突并且可以Push她的代码，在Bob进行Pull之后，每个人的Git Commit结构为： 看到上面这个混乱的流线图，相信你对于Rebase和所谓的黄金准则也有了更形象深入的理解。 假设下还有一哥们Emma，第三个开发人员，在他进行了本地Commit并且Push到远端之后，仓库变为了： 另外，相信你也注意到，在远端的仓库中存有大量的重复的Commit信息，这会大大浪费我们的存储空间。 因此，不能在一个共享的分支上进行Git rebase操作,避免出现项目分支代码提交记录错乱和浪费存储空间的现象。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:5:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"使用 rebase 合并多次提交记录 rebase和merge不同的作用还有一个就是合并分支多次提交记录。 在分支开发的过程中，我们常常会出现为了调试程序而多次提交代码记录，但是这些记录的共同目的都是为了解决某一个需求，所以，是否可以将这些记录合并起来为一个新的记录会更方便进行代码的review呢？ ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:6:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"合并记录 尝试合并分支的最近 4 次提交纪录 git rebase -i HEAD~4 这时候，会自动进入 vi 编辑模式： 进入编辑模式，第一列为操作指令，第二列为commit号，第三列为commit信息。 - pick：保留该commit - reword：保留该commit但是修改commit信息 - edit：保留该commit但是要修改commit内容 - squash：将该commit和前一个commit合并 - fixup：将该commit和前一个commit合并，并不保留该commit的commit信息 - exec：执行shell命令 - drop：删除该commit 按照如上命令来修改你的提交记录： p 799770a add article s 72530e4 add article s 53284b1 add article s 9f6e388 add article 成功合并了四条记录为一条： 如果保存的时候，你碰到了这个错误： error: cannot 'squash' without a previous commit 说明你在合并记录的时候顺序错误了，压缩顺序应该是从下往上，而不是从上往下，否则就会触发上面的错误。也就是以新记录为准。 中途出现异常退出了 vi窗口，执行下面命令可以返回编辑窗口： git rebase --edit-todo 继续编辑合并记录的操作，修改完保存一下： git rebase --continue ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:6:1","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git pull -rebase 的应用 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:7:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"场景 同事都基于git flow工作流的话都会从develop拉出分支进行并行开发，这里的分支可能是多到数十个，然后彼此在进行自己的逻辑编写，时间可能需要几天或者几周。 在这期间你可能需要时不时的需要pull下远程develop分支上的同事的提交。这是个好的习惯，这样下去就可以避免你在一个无用的代码上进行长期的开发，回头来看这些代码不是新的代码。甚至是会面临很多冲突需要解决，而这个时候你可能还需要对冲突的部分代码进行测试和问题解决，你在有些时候pull代码的时候会有这样的一个提示： 通常习惯性的你可能会，”esc ：wq“，直接默认commit注释。然后你的commit log就多了一笔很不好看的log。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:7:1","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"如何移除多余的 merge commit 很简单，只要你在pull时候需要习惯性的加上—rebase参数，这样可以避免很多问题。 git pull --rebase可以免去分支中出现大量的merge commit，基本原理就像上面rebase一样，合并过程会直接融合到目标分支的顶端，形成线性历史提交。 注意： 在公共的分支上，例如master仍然要遵守rebase黄金原则，不用使用git pull –rabase进行代码的拉取，更改代码的历史提交记录。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:7:2","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"最后 很好的git学习网站：git 命令学习 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:8:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"简单概括 git fetch 是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。 git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull \u003c==\u003e git fetch + git merge，这样可能会产生冲突，需要手动解决。 ","date":"2022-05-31","objectID":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/:1:0","tags":["git","git fetch","git pull"],"title":"git fetch与pull区别","uri":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git fetch 用法 # 将某个远程主机的更新全部取回本地 git fetch \u003c远程主机名\u003e # 只去会特定分之的更新，可以增加分支名 git fetch \u003c远程主机名\u003e \u003c分支名\u003e # 取回更新后，会返回一个 `FETCH_HEAD`，指向的是某个 branch 在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息 git log -p FETCH_HEAD ","date":"2022-05-31","objectID":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/:2:0","tags":["git","git fetch","git pull"],"title":"git fetch与pull区别","uri":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git pull 用法 git pull \u003c远程主机名\u003e \u003c远程分支名\u003e:\u003c本地分支名\u003e # 如果远程分支是与当前分支合并，则冒号后面的部分可以省略 git pull origin xxx ","date":"2022-05-31","objectID":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/:3:0","tags":["git","git fetch","git pull"],"title":"git fetch与pull区别","uri":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/"},{"categories":["kernel"],"content":"ldmappings 大多数文件系统开发人员都遇到过idmapping。当从磁盘读取或写入权限、向用户空间报告所有权或用于权限检查时使用它们。本文的目标读者是想知道idmappings如何工作的文件系统开发人员。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:1:0","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"formal notes idmapping本质上是将一个id范围转换为另一个或相同范围的id。在用户空间中广泛使用的idmappings表示法惯例是: u:k:r u 表示上层idmapset u的第一个元素 k 表示下层idmapset k的第一个元素 r 参数表示idmapping的范围，即映射了多少个id。 从现在开始，我们总是在id前加上u或k，以明确我们谈论的是上idmapset中的id还是下idmapset中的id。 为了看看实际情况，让我们看看下面的idmapping: u22:k10000:r3 并写下它将生成的映射: u22 -\u003e k10000 u23 -\u003e k10001 u24 -\u003e k10002 从数学的观点来看，U 和 K 是有序集，而idmapping是 U 到 K 的有序同构，所以 U 和 K 是有序同构的。事实上，U 和 K 总是一个给定系统中所有可用id集合的有序子集。 简单地从数学角度分析这个问题有助于我们突出一些属性，这些属性使我们更容易理解如何在idmapping之间进行转换。例如，我们知道逆idmapping也是一个有序同构: k10000 -\u003e u22 k10001 -\u003e u23 k10002 -\u003e u24 考虑到我们处理的是有序同构，加上我们处理的是子集，我们可以相互嵌入idmapping，也就是说，我们可以在不同的idmapping之间进行合理的转换。例如，假设我们已经得到了三个idmappings: 1. u0:k10000:r10000 2. u0:k20000:r10000 3. u0:k30000:r10000 以及第一次idmapping产生的id k11000，它将上idmapset中的u1000映射到下idmapset中的k11000。 因为我们处理的是有序同构子集，所以询问第二个或第三个idmapping中id k11000对应的是什么是有意义的。使用的简单算法是应用第一个idmapping的逆，将k11000映射到u1000。然后，我们可以使用第二个idmapping映射或第三个idmapping映射来映射u1000。第二个idmapping将u1000映射到21000。第三个idmapping将u1000映射到u31000。 如果我们给以下三个idmappings相同的任务: 1. u0:k10000:r10000 2. u0:k20000:r200 3. u0:k30000:r300 我们将无法进行转换，因为这些集合不再是第一个idmapping的整个范围内的有序同构(然而，它们是第二个idmapping的整个范围内的有序同构。)第二个或第三个idmapping在上层idmapset u中都不包含u1000。这相当于没有id映射。我们可以简单地说u1000在第二个和第三个idmapping中是未映射的。内核将向用户空间报告未映射的id为overflowuid (uid_t)-1或overflowgid (gid_t)-1。 计算给定id映射到什么位置的算法非常简单。首先，我们需要验证范围是否可以包含目标id。为了简单起见，我们将跳过这一步。之后，如果我们想知道id映射到什么，我们可以做一些简单的计算: 如果我们想要从左到右映射: u:k:r id - u + k = n 如果我们想要从右到左映射: u:k:r id - k + u = n 除了“从左到右”，我们还可以说“向下”，除了“从右到左”，我们还可以说“向上”。很明显，向下和向上的映射是相反的。 要查看上面的简单公式是否有效，请考虑以下两个idmappings: 1. u0:k20000:r10000 2. u500:k30000:r10000 假设我们在第一个idmapping的下idmapset中给定k21000。我们想知道这是从第一个idmapping的上层idmapset中的哪个id映射过来的。我们在第一个idmapping中向上映射: id - k + u = n k21000 - k20000 + u0 = u1000 现在假设我们在第二个idmapping的上层idmapset中有一个id u1100，我们想知道这个id在第二个idmapping的下层idmapset中映射到什么。这意味着我们在第二个idmapping中向下映射: id - u + k = n u1100 - u500 + k30000 = k30600 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:1:1","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"General note 在内核环境中，idmapping可以被解释为将一系列用户空间id映射到一系列内核id: userspace-id:kernel-id:range 用户空间id总是uid_t或gid_t类型的idmap的上层idmapset中的一个元素，而内核id总是kuid_t或kgid_t类型的idmapset的下层idmapset中的一个元素。从现在开始，“用户空间id”将用于表示众所周知的uid_t和gid_t类型，而“内核id”将用于表示kuid_t和kgid_t。 内核主要关心内核id。它们在执行权限检查时使用，并存储在inode的i_uid和i_gid字段中。另一方面，用户空间id是一个由内核报告给用户空间的id，或者由用户空间传递给内核的id，或者从磁盘写入或读取的原始设备id。 注意，我们只关心内核存储idmappings的方式，而不关心用户空间如何指定它们。 在本文档的其余部分中，我们将在所有用户空间id前加上u，在所有内核id前加上k。idmappings范围将以r为前缀。因此，idmapping将被写成u0:k10000:r10000。 例如，id u1000是idmapset上层或以u1000开头的“userspace idmapset”中的id。它被映射到k11000，这是一个内核id，位于较低的idmapset或“内核idmapset”中，以k10000开头。 内核id总是由一个idmapping创建的。这样的id映射与用户名称空间相关联。因为我们主要关心idmappings是如何工作的，所以我们不需要关心idmappings是如何创建的，也不需要关心在文件系统上下文之外如何使用它们。这最好留给用户名称空间来解释。 初始用户命名空间是特殊的。它总是有一个如下形式的idmapping: u0:k0:r4294967295 它是在这个系统上所有可用id范围上的身份映射。 其他用户名称空间通常有非标识的id映射，例如: u0:k10000:r10000 当进程创建或想要更改文件的所有权时，或者当文件系统从磁盘读取文件的所有权时，根据与相关用户名称空间相关联的idmapping，用户空间id立即被转换为内核id。 例如，考虑由文件系统存储在磁盘上的文件被u1000所拥有: 如果一个文件系统要挂载在初始用户名称空间中(就像大多数文件系统那样)，那么将使用初始idmapping。正如我们看到的，这是简单的身份映射。这意味着从磁盘读取的id u1000将被映射到id k1000。因此，inode的i_uid和i_gid字段将包含k1000。 如果要以u0:k10000:r10000的id映射挂载文件系统，那么从磁盘读取的u1000将被映射到k11000。所以一个inode的i_uid和i_gid将包含k11000。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:1:2","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"转换算法 我们已经简要地看到，可以在不同的idmapping之间进行转换。现在我们将进一步了解它是如何工作的。 交叉映射 内核在很多地方都使用这种转换算法。例如，当通过stat()系统调用系列向用户空间报告文件的所有权时，使用它。 如果我们从一个idmapping中得到k11000我们可以把这个id映射到另一个idmapping中。为了使它工作，两个idmapping需要在它们的内核idmapset中包含相同的内核id。例如，考虑以下idmappings: 1. u0:k10000:r10000 2. u20000:k10000:r10000 我们在第一个idmapping中将u1000映射到k11000。然后，我们可以使用第二个idmapping的内核idmapset将k11000转换为第二个idmapping中的用户空间id: /* Map the kernel id up into a userspace id in the second idmapping. */ from_kuid(u20000:k10000:r10000, k11000) = u21000 注意，我们如何通过颠倒算法在第一个idmapping中返回内核id: /* Map the userspace id down into a kernel id in the second idmapping. */ make_kuid(u20000:k10000:r10000, u21000) = k11000 /* Map the kernel id up into a userspace id in the first idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 这个算法允许我们回答这样一个问题:给定的内核id对应于给定的idmapping中的哪个用户空间id。为了能够回答这个问题，两个idmapping都需要在各自的内核idmapset中包含相同的内核id。 例如，当内核从磁盘读取一个原始用户空间id时，它会根据与文件系统相关联的idmapping将其映射到内核id。让我们假设文件系统的id映射为u0:k20000:r10000，它从磁盘读取u1000拥有的文件。这意味着u1000将映射到k21000, k21000将存储在inode的i_uid和i_gid字段中。 当用户空间中的某人调用stat()或相关函数来获取文件的所有权信息时，内核不能简单地根据文件系统的idmapping来映射id，因为如果调用者使用idmapping，这会给出错误的所有者。 因此，内核将把id映射回调用者的idmapping中。让我们假设调用者有一个稍微不寻常的idmapping u3000:k20000:r10000，那么k21000将映射回u4000。因此，用户会看到这个文件属于u4000。 重新映射 通过两个idmapping的用户空间idmapset，可以将一个内核id从一个idmapping转换为另一个idmapping。这相当于重新映射内核id。 让我们来看一个例子。我们给出了以下两个idmappings: 1. u0:k10000:r10000 2. u0:k20000:r10000 我们在第一个idmapping中得到k11000。为了将第一个idmapping中的内核id转换为第二个idmapping中的内核id，我们需要执行两个步骤: 在第一个idmapping中将内核id映射到用户空间id: /* Map the kernel id up into a userspace id in the first idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 在第二个idmapping中将用户空间id映射到内核id: /* Map the userspace id down into a kernel id in the second idmapping. */ make_kuid(u0:k20000:r10000, u1000) = k21000 如您所见，我们在两个idmapping中都使用了用户空间idmapset来将一个idmapping中的内核id转换为另一个idmapping中的内核id。 这允许我们回答这样一个问题:我们需要使用哪个内核id才能在另一个idmapping中获得相同的用户空间id。为了回答这个问题，两个idmapping都需要在各自的用户空间idmapset中包含相同的用户空间id。 注意，在第一个idmapping中，我们可以通过颠倒算法轻松地返回内核id: 在第二个idmapping中将内核id映射到用户空间id: /* Map the kernel id up into a userspace id in the second idmapping. */ from_kuid(u0:k20000:r10000, k21000) = u1000 在第一个idmapping中将用户空间id映射到内核id: /* Map the userspace id down into a kernel id in the first idmapping. */ make_kuid(u0:k10000:r10000, u1000) = k11000 观察这种转换的另一种方法是，如果两个idmapping都有相关的用户空间id映射，则将其视为一个idmapping的倒置和另一个idmapping的应用。在使用idmapped挂载时，这将会派上用场。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:1:3","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"非法转换 在一个idmapping的内核idmapset中使用一个id作为另一个或相同idmapping的用户空间idmapset中的id永远是无效的。内核idmapset总是表示内核id空间中的一个idmapset，而用户空间idmapset表示用户空间id。所以下面的翻译是被禁止的: /* Map the userspace id down into a kernel id in the first idmapping. */ make_kuid(u0:k10000:r10000, u1000) = k11000 /* INVALID: Map the kernel id down into a kernel id in the second idmapping. */ make_kuid(u10000:k20000:r10000, k110000) = k21000 ~~~~~~~ 和同样是错误的: /* Map the kernel id up into a userspace id in the first idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 /* INVALID: Map the userspace id up into a userspace id in the second idmapping. */ from_kuid(u20000:k0:r10000, u1000) = k21000 ~~~~~ ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:1:4","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"创建文件系统对象时的Idmappings id向下映射或向上映射的概念在文件系统开发人员非常熟悉的两个内核函数中表达，我们已经在本文档中使用了它们: /* Map the userspace id down into a kernel id. */ make_kuid(idmapping, uid) /* Map the kernel id up into a userspace id. */ from_kuid(idmapping, kuid) 我们将简要介绍idmappings如何创建文件系统对象。为了简单起见，我们将只研究当VFS在调用文件系统本身之前已经完成路径查找时发生的情况。因此，我们关心的是调用vfs_mkdir()时会发生什么。我们还将假设创建文件系统对象的目录对每个人都是可读可写的。 当创建一个文件系统对象时，调用者将查看调用者的文件系统id。这些只是普通的uid_t和gid_t用户空间id，但它们在确定文件所有权时被专门使用，这就是为什么它们被称为“文件系统id”。它们通常与调用者的uid和gid相同，但也可以不同。我们将只假设它们总是相同的，以避免迷失在太多的细节中。 当调用者进入内核时，会发生两件事: 在调用者的idmapping中将调用者的用户空间id向下映射到内核id。(准确地说，内核只会查看隐藏在当前任务凭证中的内核id，但对于我们的教育，我们将假设这个转换是及时发生的。) 验证调用者的内核id可以映射到文件系统idmapping中的用户空间id。 第二步很重要，因为常规文件系统在写入磁盘时最终需要将内核id映射回用户空间id。因此，在第二步中，内核保证可以将有效的用户空间id写入磁盘。如果不能，内核将拒绝创建请求，甚至不冒远程文件系统损坏的风险。 精明的读者应该已经意识到这只是我们在上一节中提到的交叉映射算法的一个变种。首先，内核根据调用者的idmapping将调用者的用户空间id映射到内核id，然后根据文件系统的idmapping将内核id映射到内核id。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:0","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例1 caller id: u1000 caller idmapping: u0:k0:r4294967295 filesystem idmapping: u0:k0:r4294967295 调用者和文件系统都使用标识idmapping: 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k0:r4294967295, u1000) = k1000 验证调用者的内核id可以映射到文件系统idmapping中的用户空间id。 对于第二步，内核将调用fsuidgid_has_mapping()函数，最终归结为调用from_kuid(): from_kuid(u0:k0:r4294967295, k1000) = u1000 在本例中，两个idmappings是相同的，所以没有什么令人兴奋的事情发生。最终，放置在磁盘上的用户空间id将是u1000。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:1","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例2 caller id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k20000:r10000 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k10000:r10000, u1000) = k11000 验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k20000:r10000, k11000) = u-1 很明显，虽然调用者的用户空间id可以在调用者的idmapping中成功映射到内核id，但内核id不能根据文件系统的idmapping进行映射。因此，内核将拒绝这个创建请求。 请注意，虽然这个示例不太常见，但由于大多数文件系统不能使用非初始idmappings挂载，这是一个常见的问题，我们可以在下一个示例中看到。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:2","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例3 caller id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k0:r4294967295 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k10000:r10000, u1000) = k11000 验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k0:r4294967295, k11000) = u11000 我们可以看到，翻译总是成功的。文件系统最终放入磁盘的用户空间id将始终与调用者的idmapping中创建的内核id的值相同。这主要有两个后果。 首先，我们不能允许调用者最终使用另一个用户空间id写入磁盘。只有在使用调用者的或另一个idmapping挂载整个fileystem时才能这样做。但是该解决方案仅限于少数文件系统，而且不太灵活。但这是一个在容器化工作负载中非常重要的用例。 其次，调用者通常无法创建任何具有严格权限的文件或访问目录，因为在调用者的idmapping中，没有一个文件系统的内核id映射到有效的用户空间id 在文件系统的idmapping中将原始用户空间id映射到内核id: make_kuid(u0:k0:r4294967295, u1000) = k1000 在调用者的idmapping中映射内核id到用户空间id: from_kuid(u0:k10000:r10000, k1000) = u-1 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:3","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例4 file id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k0:r4294967295 为了向用户空间报告所有权，内核使用了上一节介绍的交叉映射算法: 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k0:r4294967295, u1000) = k1000 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k10000:r10000, k1000) = u-1 在这种情况下，交叉映射算法失败，因为文件系统idmapping中的内核id不能映射到调用者idmapping中的用户空间id。因此，内核将报告该文件的所有权为溢出。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:4","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例5 file id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k20000:r10000 为了向用户空间报告所有权，内核使用了上一节介绍的交叉映射算法: 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k20000:r10000, u1000) = k21000 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k10000:r10000, k21000) = u-1 在这种情况下，交叉映射算法同样失败，因为文件系统idmapping中的内核id不能映射到调用者idmapping中的用户空间id。因此，内核将报告该文件的所有权为溢出。 注意，如果调用者使用初始idmapping，那么在最后两个示例中，事情将变得多么简单。对于使用初始idmapping安装的文件系统来说，这很简单。所以我们只考虑一个id映射为u0:k20000:r10000的文件系统: 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k20000:r10000, u1000) = k21000 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k0:r4294967295, k21000) = u21000 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:5","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"idmapped挂载上的Idmappings 在上一节中我们看到的调用者的idmapping和文件系统的idmapping不兼容的例子会导致工作负载的各种问题。对于一个更复杂但常见的示例，考虑在主机上启动两个容器。为了完全防止这两个容器相互影响，管理员通常可以为这两个容器使用不同的不重叠的idmapping: container1 idmapping: u0:k10000:r10000 container2 idmapping: u0:k20000:r10000 filesystem idmapping: u0:k30000:r10000 管理员希望对以下文件集提供简单的读写访问: dir id: u0 dir/file1 id: u1000 dir/file2 id: u2000 到两个容器目前都不能。 当然，管理员可以选择通过chown()递归地更改所有权。例如，他们可以改变所有权，以便dir和它下面的所有文件可以从文件系统的交叉映射到容器的idmapping。让我们假设它们改变了所有权，以便与第一个容器的idmapping兼容: dir id: u10000 dir/file1 id: u11000 dir/file2 id: u12000 这仍然会使dir对第二个容器毫无用处。事实上，dir和它下面的所有文件将继续显示为第二个容器的溢出所有。 再来看看另一个越来越受欢迎的例子。一些服务管理器，比如systemd，实现了一个叫做“可移植主目录”的概念。用户可能希望在分配了不同登录用户空间id的不同机器上使用自己的主目录。大多数用户在家里的机器上将u1000作为登录id，并且他们主目录中的所有文件通常都属于u1000。在大学或工作单位，他们可能有另一个登录id，如u1125。这使得在他们的工作机器上与他们的主目录交互变得相当困难。 在这两种情况下，递归地改变所有权都有严重的影响。最明显的一个是所有权是全球性和永久性的变化。在主目录的情况下，所有权甚至需要在每次用户从他们的主目录切换到他们的工作机器时发生这种变化。对于非常大的文件集，这将变得越来越昂贵。 如果用户幸运的话，他们处理的文件系统是在用户名称空间内安装的。但是这也会全局地改变所有权，所有权的改变与文件系统挂载的生命周期有关，也就是超级块。更改所有权的惟一方法是完全卸载文件系统，然后在另一个用户名称空间中再次挂载它。这通常是不可能的，因为这意味着当前访问文件系统的所有用户都不能再访问了。这意味着dir仍然不能在具有不同idmapping的两个容器之间共享。但通常用户甚至没有这个选项，因为大多数文件系统在容器内是不可安装的。并且不要安装它们可能是可取的，因为它不需要文件系统处理恶意的文件系统映像。 但是上面提到的用例以及更多的情况都可以通过idmapped挂载来处理。它们允许在不同的坐骑上暴露同一套拥有不同所有权的dentry。这是通过通过mount_setattr()系统调用用用户名称空间标记挂载来实现的。然后使用与它相关联的idmapping从调用者的idmapping转换到文件系统的idmapping，然后使用我们前面介绍的重新映射算法进行反向转换。 Idmapped挂载使得以一种临时和本地化的方式改变所有权成为可能。所有权的变更仅限于一个特定的坐骑，并且与坐骑的生命周期相关。暴露文件系统的所有其他用户和位置都不受影响。 支持idmapped挂载的文件系统没有任何真正的理由来支持在用户名称空间内被挂载。可以在idmapped挂载下完全公开文件系统，以获得相同的效果。这样做的好处是，文件系统可以将超级块的创建留给初始用户名称空间中的特权用户。 但是，完全可以将idmapped挂载与用户名称空间内可挂载的文件系统结合起来。我们将在下面进一步讨论这个问题。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:0","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"重新映射 helpers 添加了Idmapping函数，在Idmapping之间进行转换。它们使用了我们前面介绍过的重新映射算法。我们来看看两个例子: i_uid_into_mnt() 和 i_gid_into_mnt() i_*id_into_mnt()函数将文件系统的内核id转换为挂载的idmapping中的内核id: /* Map the filesystem's kernel id up into a userspace id in the filesystem's idmapping. */ from_kuid(filesystem, kid) = uid /* Map the filesystem's userspace id down ito a kernel id in the mount's idmapping. */ make_kuid(mount, uid) = kuid mapped_fsuid() 和 mapped_fsgid() mapped_fs*id()函数将调用者的内核id转换为文件系统idmapping中的内核id。这个转换是通过使用挂载的idmapping重新映射调用者的内核id来实现的: /* Map the caller's kernel id up into a userspace id in the mount's idmapping. */ from_kuid(mount, kid) = uid /* Map the mount's userspace id down into a kernel id in the filesystem's idmapping. */ make_kuid(filesystem, uid) = kuid 注意，这两个函数是相反的。考虑以下idmappings: caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k20000:r10000 mount idmapping: u0:k10000:r10000 假设从磁盘读取属于u1000的文件。文件系统根据它的idmapping将这个id映射到k21000。这是存储在inode的i_uid和i_gid字段中的内容。 当调用者通过stat()查询这个文件的所有权时，内核通常会简单地使用交叉映射算法，并将文件系统的内核id映射到调用者的idmapping中的用户空间id。 但是当调用者访问idmapped挂载上的文件时，内核会首先调用i_uid_into_mnt()，从而将文件系统的内核id转换成挂载的idmapping中的内核id: i_uid_into_mnt(k21000): /* Map the filesystem's kernel id up into a userspace id. */ from_kuid(u0:k20000:r10000, k21000) = u1000 /* Map the filesystem's userspace id down ito a kernel id in the mount's idmapping. */ make_kuid(u0:k10000:r10000, u1000) = k11000 最后，当内核向调用者报告所有者时，它将把挂载的idmapping中的内核id转换为调用者idmapping中的用户空间id: from_kuid(u0:k10000:r10000, k11000) = u1000 我们可以通过验证在创建新文件时发生了什么来测试这个算法是否真的有效。假设用户正在创建一个u1000的文件。 内核将其映射到调用者的idmapping中的k11000。通常，内核现在会应用交叉映射，验证k11000可以映射到文件系统idmapping中的用户空间id。由于k11000不能直接映射到文件系统的idmapping中，所以创建请求失败。 但是当调用者访问idmapped挂载上的文件时，内核会首先调用mapped_fs*id()，从而根据挂载的idmapping将调用者的内核id转换成一个内核id: mapped_fsuid(k11000): /* Map the caller's kernel id up into a userspace id in the mount's idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 /* Map the mount's userspace id down into a kernel id in the filesystem's idmapping. */ make_kuid(u0:k20000:r10000, u1000) = k21000 当最后写入磁盘时，内核会将k21000映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k20000:r10000, k21000) = u1000 正如我们所看到的，我们最终得到了一个可逆的，因此信息保持的算法。在idmapped挂载上从u1000创建的文件也会被报告为u1000所拥有，反之亦然。 现在，让我们在idmapped挂载上下文中简要地重新考虑前面失败的例子。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:1","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例2 reconsider caller id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k20000:r10000 mount idmapping: u0:k10000:r10000 当调用者使用非初始idmapping时，通常的情况是将相同的idmapping附加到挂载上。现在我们执行三个步骤: 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k10000:r10000, u1000) = k11000 将调用者的内核id转换为文件系统idmapping中的内核id: mapped_fsuid(k11000): /* Map the kernel id up into a userspace id in the mount's idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 /* Map the userspace id down into a kernel id in the filesystem's idmapping. */ make_kuid(u0:k20000:r10000, u1000) = k21000 验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k20000:r10000, k21000) = u1000 所以磁盘上的所有权是u1000。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:2","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例3 reconsidered caller id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k0:r4294967295 mount idmapping: u0:k10000:r10000 同样的转换算法也适用于第三个例子。 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k10000:r10000, u1000) = k11000 将调用者的内核id转换为文件系统idmapping中的内核id: mapped_fsuid(k11000): /* Map the kernel id up into a userspace id in the mount's idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 /* Map the userspace id down into a kernel id in the filesystem's idmapping. */ make_kuid(u0:k0:r4294967295, u1000) = k1000 验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k0:r4294967295, k21000) = u1000 所以磁盘上的所有权是u1000。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:3","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例4 reconsidered file id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k0:r4294967295 mount idmapping: u0:k10000:r10000 为了向用户空间报告所有权，内核现在使用我们前面介绍的转换算法执行三个步骤: 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k0:r4294967295, u1000) = k1000 将内核id转换为挂载的idmapping中的内核id: i_uid_into_mnt(k1000): /* Map the kernel id up into a userspace id in the filesystem's idmapping. */ from_kuid(u0:k0:r4294967295, k1000) = u1000 /* Map the userspace id down into a kernel id in the mounts's idmapping. */ make_kuid(u0:k10000:r10000, u1000) = k11000 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k10000:r10000, k11000) = u1000 之前，调用者的内核id不能在文件系统的idmapping中交叉映射。有了idmapped挂载之后，现在可以通过挂载的idmapping将它交叉映射到文件系统的idmapping中。现在将根据挂载的idmapping使用u1000创建文件。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:4","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例5 reconsidered file id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k20000:r10000 mount idmapping: u0:k10000:r10000 同样，为了向用户空间报告所有权，内核现在使用我们前面介绍的转换算法执行三个步骤: 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k20000:r10000, u1000) = k21000 将内核id转换为挂载的idmapping中的内核id: i_uid_into_mnt(k21000): /* Map the kernel id up into a userspace id in the filesystem's idmapping. */ from_kuid(u0:k20000:r10000, k21000) = u1000 /* Map the userspace id down into a kernel id in the mounts's idmapping. */ make_kuid(u0:k10000:r10000, u1000) = k11000 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k10000:r10000, k11000) = u1000 以前，文件的内核id不能在文件系统的idmapping中交叉映射。有了idmapped挂载之后，现在可以通过挂载的idmapping将它交叉映射到文件系统的idmapping中。根据挂载的idmapping，该文件现在属于u1000。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:5","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"更改主目录的所有权 我们在上面已经看到了当调用者、文件系统或两者都使用非初始idmapping时，如何使用idmapped挂载在idmapping之间进行转换。当调用者使用非初始idmapping时，存在各种各样的用例。这通常发生在容器化工作负载的上下文中。结果就像我们看到的那样，对于使用初始idmapping挂载的文件系统和使用非初始idmapping挂载的文件系统，对文件系统的访问无法工作，因为内核id不能在调用者的和文件系统的idmapping之间交叉映射。 正如我们在上面看到的，idmapped挂载提供了一种解决方案，它根据挂载的idmapping重新映射调用者或文件系统的idmapping。 除了容器化的工作负载之外，idmapped挂载还有一个优点:当调用者和文件系统都使用初始idmapping时，它们也可以工作，这意味着主机上的用户可以在每次挂载的基础上改变目录和文件的所有权。 考虑我们前面的示例，其中用户的主目录位于可移植存储上。在家里，他们的id是u1000，在他们的主目录中的所有文件都属于u1000，而在uni或work，他们的登录id是u1125。 带着他们的主目录会有问题。它们不能轻松地访问它们的文件，如果不应用宽松的权限或acl，它们可能无法写入磁盘，而且即使它们可以这样做，它们也将以u1000和u1125拥有的文件和目录混合而结束。 Idmapped挂载允许解决这个问题。用户可以在他们的工作计算机或家里的计算机上为他们的主目录创建idmapped挂载，这取决于他们希望最终在便携存储本身上拥有什么所有权。 假设他们希望磁盘上的所有文件都属于u1000。当用户在他们的工作岗位插入便携存储时，他们可以设置一个作业，该作业创建一个idmapped挂载，其中的idmapping最小值为u1000:k1125:r1。所以现在当他们创建一个文件时，内核执行以下步骤，我们已经从上面知道:: caller id: u1125 caller idmapping: u0:k0:r4294967295 filesystem idmapping: u0:k0:r4294967295 mount idmapping: u1000:k1125:r1 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k0:r4294967295, u1125) = k1125 将调用者的内核id转换为文件系统idmapping中的内核id: mapped_fsuid(k1125): /* Map the kernel id up into a userspace id in the mount's idmapping. */ from_kuid(u1000:k1125:r1, k1125) = u1000 /* Map the userspace id down into a kernel id in the filesystem's idmapping. */ make_kuid(u0:k0:r4294967295, u1000) = k1000 验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k0:r4294967295, k1000) = u1000 因此，最终将在磁盘上创建u1000文件。 现在让我们简单地看看id为u1125的调用者将在他们的工作计算机上看到什么所有权: file id: u1000 caller idmapping: u0:k0:r4294967295 filesystem idmapping: u0:k0:r4294967295 mount idmapping: u1000:k1125:r1 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k0:r4294967295, u1000) = k1000 将内核id转换为挂载的idmapping中的内核id: i_uid_into_mnt(k1000): /* Map the kernel id up into a userspace id in the filesystem's idmapping. */ from_kuid(u0:k0:r4294967295, k1000) = u1000 /* Map the userspace id down into a kernel id in the mounts's idmapping. */ make_kuid(u1000:k1125:r1, u1000) = k1125 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k0:r4294967295, k1125) = u1125 因此，最终将报告调用者文件属于u1125，在我们的示例中，u1125是调用者工作站上的用户空间id。 放置在磁盘上的原始用户空间id是u1000，因此当用户将他们的主目录返回到他们的主计算机时，他们使用初始idmapping分配了u1000，并使用初始idmapping挂载文件系统，他们将看到u1000拥有的所有文件。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:4:0","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"自动挂载支持 希望实现自动挂载支持的文件系统也可以获得支持(例如可以在 fs/afs/ 中找到kAFS，在 fs/nfs/ 中找到NFS)。这个功能包括允许执行核内挂载以及请求降级挂载点。降级后的挂载点用户空间也可以访问。 ","date":"2022-05-30","objectID":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/:1:0","tags":["linux","kernel","automount","自动挂载","filesystem","文件系统"],"title":"自动挂载支持","uri":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/"},{"categories":["kernel"],"content":"核内自动挂载 参见: autofs的“挂载陷阱”部分-它是如何工作的 在用户空间中，你可以这样做: [root@andromeda root]# mount -t \u003c文件系统\u003e \u003c挂载设备\u003e \u003c挂载点\u003e [root@andromeda root]# ls /afs asd cambridge cambridge.redhat.com grand.central.org [root@andromeda root]# ls /afs/cambridge afsdoc [root@andromeda root]# ls /afs/cambridge/afsdoc/ ChangeLog html LICENSE pdf RELNOTES-1.2.2 然后如果你看一下挂载点目录，你会看到这样的东西: [root@andromeda root]# cat /proc/mounts ... #root.afs. /afs afs rw 0 0 #root.cell. /afs/cambridge.redhat.com afs rw 0 0 #afsdoc. /afs/cambridge.redhat.com/afsdoc afs rw 0 0 ","date":"2022-05-30","objectID":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/:1:1","tags":["linux","kernel","automount","自动挂载","filesystem","文件系统"],"title":"自动挂载支持","uri":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/"},{"categories":["kernel"],"content":"自动挂载点过期 挂载点的自动过期是很容易的，前提是您已经在单独列出的自动挂载过程中挂载了将要过期的挂载点。 要想过期，你需要遵循以下步骤: 创建至少一个列表，以便将过期的vfmount挂起。 当在-\u003ed_automount方法中创建一个新的挂载点时，使用mnt_set_expiry()将mnt添加到列表中: mnt_set_expiry(newmnt, \u0026afs_vfsmounts); 当您希望挂载点过期时，使用指向该列表的指针调用mark_mounts_for_expiry()。这将处理列表，将其上的每个vfmount标记为下一次调用的潜在到期。 如果一个vfmount已经被标记为过期，并且它的使用计数为1(它只被它的父vfmount引用)，那么它将从命名空间中删除并丢弃(实际上是卸载)。 最简单的方法可能是定期调用它，使用某种定时事件来驱动它。 通过调用mntput来清除过期标志。这意味着只有在上次访问挂载点之后的第二次过期请求时才会发生过期。 如果一个挂载点被移动，它将从过期列表中删除。如果绑定挂载是在一个可过期挂载上进行的，那么新的vfmount将不在过期列表中，也不会过期。 如果复制了一个名称空间，那么其中包含的所有挂载点都将被复制，过期列表中挂载点的副本将被添加到相同的过期列表中。 ","date":"2022-05-30","objectID":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/:1:2","tags":["linux","kernel","automount","自动挂载","filesystem","文件系统"],"title":"自动挂载支持","uri":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/"},{"categories":["kernel"],"content":"用户空间驱动到期 作为一种替代方案，用户空间可以请求任何挂载点的过期(尽管有些挂载点会被拒绝——例如卸载rootfs)。它通过将MNT_EXPIRE标志传递给umount()来实现这一点。该标志被认为与MNT_FORCE和MNT_DETACH不兼容。 如果有问题的挂载点不是由umount()或它的父挂载点引用的，那么将返回一个EBUSY错误，并且该挂载点不会被标记为过期或卸载。 如果挂载点在那时还没有被标记为过期，将会给出一个EAGAIN错误，它不会被卸载。 否则，如果它已经被标记并且没有被引用，卸载将照常进行。 同样，每当umount()以外的任何程序查看挂载点时，过期标志将被清除。 ","date":"2022-05-30","objectID":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/:1:3","tags":["linux","kernel","automount","自动挂载","filesystem","文件系统"],"title":"自动挂载支持","uri":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/"},{"categories":["kernel"],"content":"路径名查询说明 路径名查找几乎没有可以取巧的方法，因此反而比较复杂。有许多规则、特殊情况和实现替代方案，所有这些都使读者感到困惑。 然而，计算机科学早就熟悉这种复杂性，这就是我们广泛使用的一种方法——“分而治之”。对于分析的早期部分，我们将划分符号链接 - 将它们留到最后部分。在我们讨论符号链接之前，我们有另一个基于 VFS 锁定方法的主要部分，这将允许我们分别回顾“REF-walk”和“RCU-walk”。但我们正在超越自己。我们需要首先澄清一些重要的低级区别。 用于标识文件系统中的对象的路径名(有时是“文件名”)对大多数读者来说都很熟悉。它们包含两种类型的元素:“斜杠”是一个或多个“/”字符的序列，以及“文件夹/文件元素”是一个或多个非“/”字符的序列。 共有两种路径：那些以斜杠开始的是“绝对的”，并且从文件系统根目录开始；其他是“相对的”，从当前目录开始，或者从*at()系统调用(如openat())所给出的文件描述符指定的其他位置开始。 将相对路径描述为从当前目录开始是可以的，但这并不总是准确的:路径名可以既没有斜杠又没有文件/文件夹名，换句话说，它可以是空的。这在POSIX中通常是被禁止的，但是Linux中的一些*at()系统调用在给出AT_EMPTY_PATH标志时允许这样做。例如，如果在可执行文件上有一个打开的文件描述符，那么可以通过传递文件描述符、空路径和AT_EMPTY_PATH标志，调用execveat()来执行它。 这些路径可以分为两个部分:最终元素和其他内容。“其他一切”是容易的部分。在所有情况下，它必须识别一个已经存在的目录，否则将报告一个错误，如ENOENT或ENOTDIR。 最后一个组成部分就没那么简单了。不仅不同的系统调用对它的解释非常不同(例如，一些创建了它，一些没有)，而且它甚至可能不存在:空的路径名或只是斜杠的路径名都没有最终元素。如果它确实存在，它可能是\".“或”..\"，处理方式与其他组件截然不同。 如果一个路径名以斜杠结尾，例如“/tmp/foo/”，它可能会考虑有一个空的最终组件。在很多方面，这会导致正确的结果，但并不总是如此。特别是，mkdir()和rmdir()都会创建或删除一个由最终组件命名的目录，它们需要处理以“/”结尾的路径名。根据POSIX: 包含至少一个非切割字符的路径（pathname），以一个或多个切割字符结尾，是不合法的，除非最后一个切割符之前的的元素是一个已存在的文件夹，或者是一个将要创建的文件夹，这样的路径才是合法的。 Linux路径名遍历代码(主要在fs/name.c中)处理所有这些问题:将路径分解为组件，与最终组件完全分开处理“其他所有内容”，并检查在不允许的地方是否使用末尾的斜杠。它还解决了并发访问的重要问题。 当一个进程查找路径名时，另一个进程可能会做出影响该查找的更改。一个相当极端的情况是，如果“a/b”被重命名为“a/c/b”，而另一个进程正在查找“a/b/..”，该过程可能导致查询结果为“a/c”。大多数竞争要微妙得多，路径名查找的主要任务是防止它们产生破坏性影响。许多可能的竞争在“dcache”上下文中表现得最为清晰，理解dcache对于理解路径名查找至关重要。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:1:0","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"不止是一个缓冲 “dcache”在每个文件系统中缓存关于名称的信息，以便快速查找。每个条目(被称为“dentry”)包含三个重要的字段:一个组件名称，一个指向父dentry的指针，以及一个指向“inode”的指针，该inode包含给定名称的父节点中对象的进一步信息。inode指针可以是NULL，表示该名称在父节点中不存在。虽然在目录的dentry中可以链接到子目录的dentry，但该链接不用于路径名查找，因此这里不考虑。 除了加速查找之外，dcache还有许多用途。特别重要的一点是，它与记录文件系统安装位置的挂载表紧密集成。挂载表实际存储的是哪个dentry挂载在哪个dentry上。 在考虑dcache时，我们还有另一个“两种类型”的区别:有两种类型的文件系统。 有些文件系统确保dcache中的信息总是完全准确的(尽管不一定是完整的)。这允许VFS在不检查文件系统的情况下确定某个特定文件是否存在，这意味着VFS可以保护文件系统免受某些竞争和其他问题的影响。这些是典型的“本地”文件系统，如ext3、XFS和Btrfs。 其他文件系统不提供这种保证，因为它们不能。这些通常是跨网络共享的文件系统，无论是像NFS和9P这样的远程文件系统，还是像ocfs2或cephfs这样的集群文件系统。这些文件系统允许VFS重新验证缓存的信息，并且必须提供自己的保护来防止尴尬的竞争。VFS可以通过dentry中设置的DCACHE_OP_REVALIDATE标志来检测这些文件系统。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:2:0","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"REF-walk:包含refcount和自旋锁的简单并发管理 仔细分类后，我们现在可以开始观察沿着路径行走的实际过程。特别地，我们将从处理路径名的“其他一切”部分开始，并重点关注并发管理的“ref-walk”方法。这段代码可以在link_path_walk()函数中找到，如果你忽略所有只有在设置了LOOKUP_RCU(表示使用了RCU-walk)时才运行的地方。 REF-walk对锁和引用计数的处理相当繁琐。不像以前的“big kernel lock”时代那样笨拙，但肯定不用担心在需要锁的时候使用锁。它使用各种不同的并发控制。对各种原语的背景理解是假设的，或者可以从其他地方收集，如Meet the locker。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:3:0","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"REF-walk使用的锁定机制包括: dentry-\u003ed_lockref 这使用了lockref原语来提供自旋锁和引用计数。这个原语的特殊之处在于概念序列的“lock; inc_ref; unlock 通常可以通过单个原子内存操作来执行。在dentry上持有引用可以确保dentry不会突然被释放并用于其他内容，因此各个字段中的值将按照预期的方式运行。它还在一定程度上保护了对inode的-\u003ed_inode引用。dentry与其inode之间的关联是相当持久的。例如，当重命名一个文件时，dentry和inode会一起移动到新位置。当一个文件被创建时，dentry最初是负的(例如，d_inode是NULL)，并在创建过程中被赋值给新的inode。当一个文件被删除时，可以通过将d_inode设置为NULL或从用于在父目录中查找名称的哈希表中删除它来反映在缓存中。如果dentry仍在使用，则使用第二种选择，因为在删除文件后继续使用打开的文件是完全合法的，而且有dentry在身边会有所帮助。如果dentry没有被使用(例如，如果d_lockref中的引用计数是一个)，只有这时d_inode才会被设置为NULL。对于一个非常常见的情况，这样做更有效。因此，只要统计的引用保存在dentry中，-\u003ed_inode值如果为非空，则值永远不会被改变。 dentry-\u003ed_lock d_lock是上面d_lockref中的自旋锁的同义词。持有此锁可以防止dentry被重命名或取消链接。特别是，它的父节点(d_parent)和它的名称(d_name)不能更改，也不能从dentry哈希表中删除它。当在目录中查找名称时，REF-walk对它在散列表中找到的每个候选dentry使用d_lock，然后检查父节点和名称是否正确。所以它在缓存中搜索时不会锁定父节点;它只锁孩子。当查找给定名称的父类(以处理\" .. “)时，REF-walk可以使用d_lock来获得对d_parent的稳定引用，但它首先尝试一种更轻量级的方法。正如在dget_parent()中看到的，如果可以对父对象声明引用，并且随后可以看到d_parent没有更改，那么就不需要对子对象实际使用锁。 rename_lock 在给定目录中查找给定的名称涉及到从两个值(目录的名称和dentry)计算哈希值，访问哈希表中的槽，并搜索在那里找到的链表。当dentry被重命名时，名称和父dentry都可能改变，所以哈希值几乎肯定也会改变。这将把dentry移动到哈希表中的另一个链上。如果文件名搜索碰巧在查找以这种方式移动的dentry，它可能最终会沿着错误的链继续搜索，从而错过正确链的一部分。名称查找进程(d_lookup())不会试图阻止这种情况的发生，而只是检测它何时发生。rename_lock是一个sequlock，每当重命名任何dentry时都会更新它。如果d_lookup在未成功扫描哈希表中的链时发现发生了重命名，它会简单地再次尝试。当解析“..”时，rename_lock还用于检测和防御针对LOOKUP_BENEATH和LOOKUP_IN_ROOT的潜在攻击。(父目录被移到根目录之外，绕过了path_equal()检查)。如果在查找过程中更新了rename_lock，并且路径遇到了一个 ..，一个潜在的攻击发生了，handle_dots()将跳出并报错-EAGAIN。 inode-\u003ei_rwsem i_rwsem是一个读/写信号量，它序列化对特定目录的所有更改。例如，这确保了unlink()和rename()不能同时发生。当要求文件系统查找当前不在dcache中的名称时，或者使用readdir()检索目录中的条目列表时，它还可以保持目录的稳定。 这与目录上的d_lock: i_rwsem具有补充作用，保护该目录中的所有名称，而名称上的d_lock只保护目录中的一个名称。对dcache的大多数更改在相关目录inode上保持i_rwsem，并在发生更改时在一个或多个dentry上短暂地使用d_lock。一个例外是由于内存压力而从dcache中删除空闲的dentry。这使用了d_lock，但是i_rwsem不扮演任何角色。 信号量以两种不同的方式影响路径名查找。首先，它可以防止在查找目录中的名称时发生更改。Walk_component()首先使用lookup_fast()，然后它检查名称是否在缓存中，只使用d_lock锁定。如果没有找到这个名称，那么walk_component()会退回到lookup_slow()，它在i_rwsem上接受一个共享锁，再次检查名称是否不在缓存中，然后调用文件系统以获得确定的答案。无论结果如何，都会向缓存中添加一个新的dentry。 其次，当路径名查找到达最后一个组件时，有时需要在执行最后一个查找之前在i_rwsem上获得一个排他锁，以便能够实现所需的排除。路径查找如何选择使用或不使用i_rwsem是下一节要讨论的问题之一。 如果两个线程试图同时查找相同的名称(这个名称还没有出现在dcache中)，i_rwsem上的共享锁将不会阻止它们同时添加具有相同名称的新dentry。由于这将导致混乱，因此使用了额外的联锁级别，这是基于二级哈希表(in_lookup_hashtable)和每个dentry标志位(DCACHE_PAR_LOOKUP)。 要在缓存中添加一个新的dentry，同时只持有i_rwsem上的共享锁，线程必须调用d_alloc_parallel()。它分配一个dentry，在其中存储所需的名称和父元素，检查主哈希表或辅助哈希表中是否已经存在匹配的dentry，如果没有，则使用DCACHE_PAR_LOOKUP集在辅助哈希表中存储新分配的dentry。 如果在主哈希表中找到匹配的dentry，则返回该dentry，调用者可以知道它在与添加条目的其他线程的竞争中失败了。如果在两个缓存中都没有找到匹配的dentry，则返回新分配的dentry，调用者可以从DCACHE_PAR_LOOKUP中检测到这一点。在本例中，它知道它已经赢得了比赛，现在负责请求文件系统执行查找并找到匹配的索引节点。当查找完成时，它必须调用d_lookup_done()，它会清除标记，并进行一些其他的内部维护，包括从二级哈希表中删除dentry——它通常已经被添加到主哈希表中。注意，waitqueue_head结构体被传递给d_alloc_parallel()，并且当这个waitqueue_head仍然在作用域中时，必须调用d_lookup_done()。 如果在二级散列表中找到匹配的dentry, d_alloc_parallel()需要做更多的工作。它首先等待DCACHE_PAR_LOOKUP被清除，使用一个wait_queue被传递给赢得竞争的d_alloc_parallel()实例，该实例将通过调用d_lookup_done()被唤醒。然后检查dentry现在是否已添加到主散列表中。如果有，则返回dentry，调用者只会看到它输掉了所有竞赛。如果没有将它添加到主哈希表中，最可能的解释是使用d_splice_alias()添加了其他dentry。在任何情况下，d_alloc_parallel()都会从一开始重复所有的查找，并且通常会从主哈希表返回一些内容。 mnt-\u003emnt_count mnt_count是“mount”结构上每个cpu的引用计数器。这里的Per-CPU意味着增加计数很便宜，因为它只使用CPU本地内存，但检查计数是否为零则很昂贵，因为它需要检查每个CPU。接受mnt_count引用可以防止挂载结构作为常规卸载操作的结果消失，但不能防止“惰性”卸载。因此，持有mnt_count不能确保挂载保持在名称空间中，特别是不能稳定到挂载的dentry的链接。但是，它可以确保挂载数据结构保持一致，并且提供了对挂载文件系统根目录的引用。因此，通过-\u003emnt_count的引用提供了对挂载的dentry的稳定引用，而不是挂载的dentry。 mount_lock mount_lock是一个全局序列锁，有点像rename_lock。它可以用来检查是否对任何挂载点进行了更改。 当沿着树向下走(离开根节点)时，在通过挂载点时使用此锁检查挂载点是否安全。也就是说，读取seqlock中的值，然后代码查找挂载在当前目录上的挂载(如果有挂载的话)，并增加mnt_count。最后，根据旧值检查mount_lock中的值。如果没有变化，那么穿越是安全的。如果发生了更改，则减少mnt_count，并重试整个进程。 当向根目录遍历(遍历当前目录..)链接时，需要多加注意。在这种情况下，seqlock(包含一个计数器和一个自旋锁)被完全锁定，以防止在升级时对任何挂载点进行任何更改。需要使用此锁定来稳定到挂载dentry的链接，而挂载上的引用本身不能确保这一点。 mount_lock还用于在解析..时检测和防御针对LOOKUP_BENEATH和LOOKUP_IN_ROOT的潜在攻击。(父目录被移到根目录之外，绕过了path_equal()检查)。如果mount_lock在查找过程中更新，并且路径遇到一个..，一个潜在的攻击发生了，handle_dots()将跳出-EAGAIN。 RCU 最后，全局的(但非常轻量级的)RCU读锁会被时不时地持有，以确保某些数据结构不会意外被释放。 特别是在扫描dcache散列表和挂载点散列表中的链时使用。 struct nameidata 在整个路径遍历的过程中，当前状态被存储在结构nameidata中，“na","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:3:1","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"处理最后一个组件(路径中最后一个文件/文件夹部分) link_path_walk()只遍历设置nd-\u003elast和nd-\u003elast_type以引用路径的最后一个组件。上次它没有调用walk_component()。处理最后的组件还需要调用者来解决。这些调用程序是path_lookupat()、path_parentat()和path_openat()，它们分别处理不同系统调用的不同需求。 path_parentat()显然是最简单的—它只是对link_path_walk()进行了一些整理，并将父目录和最终组件返回给调用者。调用者将旨在创建一个名称(通过filename_create())或删除或重命名一个名称(在这种情况下使用user_path_parent())。它们将在验证并执行操作时使用i_rwsem来排除其他更改。 path_lookupat()几乎同样简单——当需要现有对象时使用它，比如stat()或chmod()。它实际上只是通过调用lookup_last()在最后一个组件上调用walk_component()。path_lookupat()只返回最终dentry。值得注意的是，当设置了标志LOOKUP_MOUNTPOINT时，path_lookupat()将在nameidata中取消设置LOOKUP_JUMPED，这样在后续的路径遍历d_weak_revalidate()将不会被调用。在卸载无法访问的文件系统时，这一点非常重要，比如卸载一个失效的NFS服务器提供的文件系统。 最后path_openat()用于open()系统调用;它包含了以open_last_lookup()开始的支持函数，处理O_CREAT(带或不带O_EXCL)、最后的/字符和末尾的符号链接所需的所有复杂性。我们将在本系列的最后一部分中重新讨论这个问题，重点讨论这些符号链接。open_last_lookup()有时会(但并非总是)接受i_rwsem，这取决于它找到了什么。 每一个组件，或者调用它们的函数，都需要警惕最终组件不是LAST_NORM的可能性。如果查找的目标是创建某个值，那么last_type的任何值(LAST_NORM除外)都将导致错误。例如，如果path_parentat()报告LAST_DOTDOT，那么调用者不会尝试创建该名称。它们还通过测试last.name[last.len]来检查末尾的斜杠。如果在最后一个组件之外有任何字符，则必须是末尾的斜杠。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:3:2","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"检验与加载 除了符号链接之外，REF-walk过程中只有两个部分还没有涉及到。一种是对过期缓存条目的处理，另一种是自动加载。 在需要它的文件系统上，查找例程将调用-\u003ed_revalidate() dentry方法，以确保缓存的信息是当前的。这通常会确认有效性或从服务器更新一些细节。在某些情况下，它可能会发现，在向前遍历的过程中上已经发生了变化，以前被认为是有效的东西实际上是无效的。当发生这种情况时，整个路径的查找将被中止，并设置LOOKUP_REVAL标志重新尝试。这迫使重新验证更加彻底。我们将在下一篇文章中看到这个重试过程的更多细节。 自动挂载点是文件系统中的一些位置，在这些位置上，如果试图查找一个名称，可能会触发对该查找的处理方式的更改，特别是在那里挂载一个文件系统。autofs在Linux文档树中详细介绍了这些内容，但这里有一些与路径查找相关的注意事项。 Linux VFS有一个托管 dentry的概念。这些dentry有三个潜在的有趣的地方，它们对应着在dentry-\u003ed_flags中可能设置的三个不同的标志: DCACHE_MANAGE_TRANSIT 如果设置了这个标志，那么文件系统请求在处理任何可能的挂载点之前调用d_manage() dentry操作。它可以执行两种特定的服务: 它可以阻止以避免比赛。如果正在卸载一个自动挂载点，d_manage()函数通常会等待该进程完成，然后才让新的查找继续进行，并可能触发新的自动挂载。 它可以有选择地只允许一些进程通过一个挂载点。当一个服务器进程正在管理自动挂载时，它可能需要访问一个目录，而不触发正常的自动挂载处理。该服务器进程可以将自己标识给autofs文件系统，然后通过返回-EISDIR给它一个通过d_manage()的特殊传递。 DCACHE_MOUNTED 这个标志设置在每个挂载的dentry上。由于Linux支持多个文件系统名称空间，因此dentry可能不是挂载在这个名称空间上，而是挂载在其他名称空间上。因此，这面旗帜被视为一种暗示，而不是承诺。 如果设置了这个标志，而d_manage()没有返回-EISDIR，那么就会调用lookup_mnt()来检查挂载散列表(使用前面描述的mount_lock)，并可能返回一个新的vfmount和一个新的dentry(都带有计数的引用)。 DCACHE_NEED_AUTOMOUNT 如果d_manage()允许我们走到这一步，而lookup_mnt()没有找到挂载点，那么这个标志将导致调用d_automount() dentry操作。 d_automount()操作可以是任意复杂的，可以与服务器进程等通信，但它最终应该报告有一个错误，没有什么可以挂载，或应该提供一个更新的struct path与新的dentry和vfmount。 在后一种情况下，将调用finish_automount()来安全地将新的挂载点安装到挂载表中。 这里没有导入的新锁，而且在这个处理过程中不要持有锁(只有计算过的引用)，这一点很重要，因为很可能会出现扩展延迟。当我们下次研究rcu walk时，这将变得更加重要，它对延迟特别敏感。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:3:3","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"RCU-walk – Linux中更快的路径名查找 RCU-walk是Linux中执行路径名查找的另一种算法。它在许多方面与REF-walk相似，并且两者共享相当多的代码。rcu遍历的显著区别在于它允许并发访问的可能性。 我们注意到REF-walk很复杂，因为有很多细节和特殊情况。RCU-walk通过简单地拒绝处理一些情况来降低复杂性，它退回到REF-walk。rcu-walk的困难来自于另一个方向:不熟悉。依赖于RCU的锁规则与传统的锁有很大的不同，所以我们将在这些规则上多花一些时间。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:0","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"明确的角色划分 管理并发性的最简单方法是强制阻止任何其他线程更改给定线程正在查看的数据结构。如果没有其他线程考虑更改数据，而许多不同的线程想要同时读取数据，那么这将是非常可贵的。即使使用允许多个并发读取器的锁，更新当前读取器数量的简单操作也会带来不必要的成本。因此，当读取一个没有其他进程改变的共享数据结构时，目标是完全避免向内存写入任何内容。不加锁，不加计数，不留下痕迹。 前面描述的REF-walk机制当然不遵循这一原则，但它实际上是为其他线程修改数据时设计的。相反，RCU-walk是为有很多频繁的读取和只有偶尔的写数据的常见情况而设计的。在文件系统树的所有部分中，这可能并不常见，但在许多部分中，这将是常见的。对于其他部分来说，重要的是RCU-walk可以快速回落到使用REF-walk。 路径名查找总是以RCU-walk模式开始，但只有当它所查找的内容在缓存中并且是稳定的时候才会继续存在。它轻快地沿着缓存的文件系统映像向下查找，不留下任何足迹，并仔细地观察它在哪里，以确保它不会出错。如果它注意到某些内容已经更改或正在更改，或者某些内容不在缓存中，那么它会尝试优雅地停止，并切换到REF-walk。 这个停止需要获取当前vfmount和dentry上的一个已统计的引用，并确保这些仍然有效—使用REF-walk的路径遍历将找到相同的条目。这是RCU-walk必须保证的不变量。它只能做出决定，比如选择下一步，如果同时在树上走，REF-walk也可以做出这样的决定。如果优雅停止成功，路径的其余部分将以可靠的REF-walk(如果速度稍慢)处理。如果RCU-walk发现它不能优雅地停止，它就会放弃，然后用REF-walk从头开始。 在filename_lookup()、filename_parentat()、do_filp_open()和do_file_open_root()等函数中可以清楚地看到这种“尝试RCU-walk，如果失败则尝试REF-walk”的模式。这四个函数大致对应于我们前面遇到的三个path_*()函数，每个函数都调用link_path_walk()。path_*()函数使用不同的模式标志调用，直到找到一个有效的模式。它们首先在LOOKUP_RCU设置请求”RCU-walk“时被调用。如果失败并报错为ECHILD，它们将被再次调用，没有特殊标志来请求REF-walk。如果其中任何一个报错，就会使用LOOKUP_REVAL设置(而不是LOOKUP_RCU设置)进行最后一次尝试，以确保在缓存中找到的条目被强制重新验证——通常情况下，只有当文件系统认为条目太老而不能信任时，才会重新验证条目。 LOOKUP_RCU可能会在内部删除这个标志，然后切换到REF-walk，但是不会尝试切换回RCU-walk。RCU-walk无法继续遍历的地方更有可能靠近树叶，所以没必要再切回 RCU-walk。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:1","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"RCU和seqlocks: 快速和轻量 毫无疑问，RCU对于RCU walk模式是至关重要的。rcu_read_lock()在RCU-walk遍历路径的整个过程中保持。它提供的特殊保证是，在锁被持有时，关键数据结构——dentry、inodes、super_blocks和mount——不会被释放。它们可能以这样或那样的方式被取消链接或失效，但内存不会被重新使用，因此各个字段中的值仍然是有意义的。这是RCU提供的唯一保证;其他所有事情都是使用seqlock完成的。 正如我们上面看到的，REF-walk持有对当前dentry和当前vfmount的已统计的引用，并且在引用“next”dentry或vfmount之前不会释放这些引用。它有时也使用d_lock自旋锁。使用这些引用和锁是为了防止发生某些更改。RCU-walk不能接受这些引用或锁，因此不能阻止这样的更改。相反，它检查是否进行了更改，如果进行了更改，则终止或重试。 为了保持上面提到的不变量(RCU-walk可能只做出REF-walk可能做出的决定)，它必须在REF-walk保存引用的相同位置或附近进行检查。因此，当REF-walk增加引用计数或接受自旋锁时，RCU-walk会使用read_seqcount_begin()或类似的函数对seqlock的状态进行采样。当REF-walk减少计数或丢弃锁时，RCU-walk使用read_seqcount_retry()或类似方法检查采样状态是否仍然有效。 然而，seqlock还有更多的功能。如果RCU-walk访问了一个seqlock保护结构中的两个不同的字段，或者访问同一个字段两次，那么这两次访问的一致性是无法保证的。当需要一致性时(通常是这样)，RCU-walk必须获取一个副本，然后使用read_seqcount_retry()来验证该副本。 read_seqcount_retry()不仅检查序列号，而且施加了一个内存屏障，这样CPU或编译器在调用之前的内存读取指令都不会被延迟到调用之后。在slow_dentry_cmp()中可以看到这样一个简单的例子，对于不使用简单的字节级名称相等的文件系统，它调用文件系统来比较名称与dentry。长度和名称指针被复制到本地变量中，然后调用read_seqcount_retry()来确认两者是一致的，然后才调用-\u003ed_compare()。当使用标准文件名比较时，将调用dentry_cmp()。值得注意的是，它没有使用read_seqcount_retry()，而是用大量注释解释为什么一致性保证不是必要的。后续的read_seqcount_retry()将足以捕获此时可能发生的任何问题。 通过对seqlock的小复习，我们可以看到RCU-walk是如何使用seqlock的。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:2","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"mount_lock和nd-\u003em_seq 当REF-walk使用mount_lock seqlock来确保安全地执行穿越挂载点时，我们已经遇到过它了。RCU-walk也使用它来完成这个任务，但远不止这些。 RCU-walk不是在每个vfmount下行时对它进行计数，而是在遍历开始时对mount_lock的状态进行采样，并将这个初始序列号存储在m_seq字段的struct nameidata中。这一个锁和一个序列号用于验证对所有vfmount的所有访问，以及所有挂载点交叉。由于对挂载表的更改相对较少，所以在发生任何“挂载”或“卸载”时，采用REF-walk是合理的。 m_seq在rcu遍历序列的末尾被检查(使用read_seqretry())，无论在路径的其余部分切换到REF-walk还是到达路径的末尾。它也会在挂载点向下遍历(在__follow_mount_rcu()中)或向上遍历(在follow_dotdot_rcu()中)时被检查。如果发现路径发生了变化，整个RCU-walk序列将被终止，并通过REF-walk再次处理该路径。 如果RCU-walk发现mount_lock没有改变，那么可以确定，如果REF-walk对每个vfmount进行引用计数，结果将是相同的。这确保了不变量保持不变，至少对于vfmount结构是这样。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:3","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"dentry-\u003ed_seq和nd-\u003eseq RCU-walk没有对d_reflock进行计数或锁定，而是对每个dentry的d_seq seqlock进行采样，并将序列号存储在nameidata结构的seq字段中，因此nd-\u003eseq应该始终是nd-\u003edentry的当前序列号。在复制之后和使用dentry的名称、父节点或inode之前，需要重新验证这个数字。 对于名字的处理我们已经看过了，父函数只在follow_dotdot_rcu()中被访问，它非常简单地遵循了所需的模式，尽管它有三种不同的情况。 如果不在挂载点，则会跟随d_parent，并收集它的d_seq。当我们在挂载点时，我们使用mnt-\u003emnt_mountpoint链接来获得一个新的dentry并收集它的d_seq。然后，在最终找到要跟踪的d_parent之后，我们必须检查是否落在了一个挂载点上，如果是，则必须找到该挂载点并遵循mnt-\u003emnt_root链接。这可能意味着一种不常见但肯定可能的情况，即路径查找的起点位于安装的文件系统的一部分，因此从根目录不可见。 存储在-\u003ed_inode中的inode指针更有趣一些。总是需要访问inode至少两次，一次是为了确定它是否为NULL，一次是为了验证访问权限。符号链接处理也需要一个经过验证的inode指针。不是在每次访问时重新验证，而是在第一次访问时进行复制，并将其存储在nameidata的inode字段中，从那里可以安全地访问它，而无需进一步验证。 lookup_fast()是rcu模式中唯一使用的查找例程，因为lookup_slow()太慢了，需要锁。正是在lookup_fast()中，我们找到了当前dentry的重要的“hand over hand”跟踪。 当前dentry和当前seq号被传递给__d_lookup_rcu()，如果成功，返回一个新的dentry和一个新的seq号。然后，lookup_fast()复制inode指针并重新验证新的seq号。然后，它最后一次使用旧seq编号1验证旧dentry，然后才继续。这个获取新dentry的seq号，然后检查旧dentry的seq号的过程与我们在REF-walk中看到的在删除旧dentry之前获取新dentry的计数引用的过程完全相同。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:4","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"No inode-\u003ei_rwsem or even rename_lock 信号量是一个相当重量级的锁，只能在允许它休眠时使用。由于rcu_read_lock()禁止休眠，inode-\u003ei_rwsem在RCU-walk中不起作用。如果其他线程确实接受了i_rwsem并以RCU-walk需要注意的方式修改了目录，结果要么是RCU-walk无法找到它正在寻找的dentry，要么是它会找到一个read_seqretry()无法验证的dentry。在任何一种情况下，它都会下降到REF-walk模式，可以使用任何需要的锁。 虽然rename_lock可以被RCU-walk使用，因为它不需要任何睡眠，但RCU-walk不需要。REF-walk使用rename_lock来防止dcache中的哈希链在搜索时发生变化。这可能会导致找不到实际存在的东西。当RCU-walk在dentry缓存中找不到数据时，不管数据是否真的存在，它都已经下到REF-walk中，并再次尝试使用适当的锁。这可以很好地处理所有情况，所以在rename_lock上添加额外的检查不会带来显著的值。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:5","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"unlazy walk() and complete_walk() “下拉到REF-walk”通常涉及到unlazy_walk()的调用，之所以这样命名是因为“RCU-walk”有时也被称为“lazy walk”。当沿着当前vfmount/dentry对的路径向下走似乎已经成功，但是下一步有问题时，调用unlazy_walk()。如果在dcache中找不到下一个名称，如果在rcu_read_lock()被持有(这禁止sleep)时无法进行权限检查或名称重新验证，如果找到自动挂载点，或者在一些涉及符号链接的情况下，就会发生这种情况。当查找到达最后一个组件或路径的末尾时，也会从complete_walk()调用它，这取决于使用的是哪种查找风格。 退出RCU-walk而不触发unlazy_walk()调用的其他原因是当发现一些不能立即处理的不一致时，例如mount_lock或报告更改的d_seq seqlock之一。在这些情况下，相关函数将返回-ECHILD，该函数将一直渗透到使用REF-walk从顶部触发新的尝试为止。 对于unlazy_walk()是一个选项的情况，它本质上接受它持有的每个指针(vfmount、dentry，可能还有一些符号链接)的引用，然后验证相关的seqlock是否没有被更改。如果发生了更改，它也会使用-ECHILD终止，否则转换为REF-walk是成功的，查找过程会继续。 对这些指针进行引用并不像递增计数器那么简单。如果您已经有了一个引用(通常是通过另一个对象间接地)，那么这样做可以获取第二个引用，但如果您根本没有经过计数的引用，那么这样做是不够的。对于dentry-\u003ed_lockref，增加引用计数器以获得引用是安全的，除非它被显式地标记为“死亡”，包括将计数器设置为-128。lockref_get_not_dead()对这些指针进行引用并不像递增计数器那么简单。如果您已经有了一个引用(通常是通过另一个对象间接地)，那么这样做可以获取第二个引用，但如果您根本没有经过计数的引用，那么这样做是不够的。对于dentry-\u003ed_lockref，增加引用计数器以获得引用是安全的，除非它被显式地标记为“死亡”，包括将计数器设置为-128。lockref_get_not_dead()实现这些。 对于mnt-\u003emnt_count，只要使用mount_lock来验证引用，那么接受引用是安全的。如果验证失败，那么以调用mnt_put()的标准方式删除该引用可能不安全——卸载可能进行得太过了。因此，当它发现它得到的引用可能不安全时，会检查MNT_SYNC_UMOUNT标志，以确定简单的mnt_put()是否正确，或者它是否应该减少计数并假装这些都没有发生。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:6","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"注意文件系统 RCU-walk几乎完全依赖于缓存的信息，通常根本不会调用文件系统。但是，除了前面提到的组件名称比较之外，还有两个地方可能包含文件系统，RCU-walk必须小心。 如果文件系统有非标准的权限检查要求—例如网络文件系统可能需要向服务器进行检查—在rcu walk期间可能会调用i_op-\u003epermission(权限接口)。在这种情况下，一个额外的”MAY_NOT_BLOCK“标志被传递，以便它知道不sleep，但如果它不能及时完成返回-ECHILD。I_op -\u003epermission被赋予了inode指针，而不是dentry，因此它不需要担心进一步的一致性检查。但是，如果它访问任何其他文件系统数据结构，必须确保它们在只持有rcu_read_lock()的情况下是安全的。这通常意味着它们必须使用kfree_rcu()或类似的方法来释放。 如果文件系统可能需要重新验证dcache条目，那么在RCU-walk中也可以调用d_op-\u003ed_revalidate。该接口被传递dentry，但不能访问inode或nameidata中的seq号，因此在访问dentry中的字段时需要格外小心。这种“额外注意”通常包括使用READ_ONCE()访问字段，并在使用它之前验证结果是否为NULL。这个模式可以在nfs_lookup_revalidate()中看到。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:7","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"A pair of patterns 在REF-walk和RCU-walk的各个细节中，以及在大的图片中，有几个相关的模式值得注意。 第一种是“快速尝试并检查，如果失败，慢慢尝试”。我们可以在高级方法中看到，首先尝试RCU-walk，然后尝试REF-walk，在使用unlazy_walk()切换到REF-walk的路径的其他部分。我们在前面的dget_parent()中也看到了它，当跟随一个”..”的链接。它尝试一种快速获取引用的方法，然后在需要时返回获取锁。 第二种模式是“快速尝试并检查，如果失败了，再试一次——重复”。这可以通过在REF-walk中使用rename_lock和mount_lock看到。RCU-walk不使用此模式—如果出现任何错误，则直接中止并尝试更稳定的方法要安全得多。 这里的重点是“快速检查”。应该是“快速仔细尝试，然后检查”。需要检查的事实提醒我们，系统是动态的，只有有限数量的东西是安全的。在整个过程中，最可能导致错误的原因是假设某些东西是安全的，而实际上并非如此。有时需要仔细考虑如何确保每次访问的安全性。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:8","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"在符号链接之间遍历 为了理解符号链接的处理，我们将研究几个基本问题:符号链接堆栈和缓存生存期将帮助我们理解符号链接的整体递归处理，并导致对最终组件的特殊注意。然后考虑访问时更新和控制查找的各种标志的摘要，就可以完成整个过程了。 符号链接堆栈 只有两种文件系统对象可以有效地出现在最后一个组件之前的路径中:目录和符号链接。处理目录非常简单:新目录仅仅成为解释路径上下一个组件的起点。处理符号链接需要更多的工作。 从概念上讲，可以通过编辑路径来处理符号链接。如果一个组件名引用了一个符号链接，那么该组件将被链接体替换，如果链接体以’/‘开头，那么前面所有的路径部分将被丢弃。这就是“readlink -f”命令所做的，尽管它也会编辑掉.和..组件。 在查找路径时，没有必要直接编辑路径字符串，丢弃早期组件也没有意义，因为它们不会被查看。跟踪所有剩余的组件很重要，但它们当然可以分开保存;不需要将它们连接起来。由于一个符号链接可以很容易地引用另一个符号链接，而另一个符号链接又可以引用第三个符号链接，因此我们可能需要保留几个路径的其余组件，每个组件在前一个完成时处理。这些路径残余物被保存在一个有限大小的堆栈中。 对单个路径查找中出现的符号链接数量进行限制有两个原因。最明显的方法就是避免循环。如果符号链接直接或通过中介引用自己，那么跟随符号链接永远不能成功完成——必须返回错误ELOOP。我们可以在不施加限制的情况下检测循环，但限制是最简单的解决方案，考虑到限制的第二个原因，这已经足够了。 第二个原因是Linus最近概括的: 因为这也是一个延迟和DoS问题。我们不仅需要对真正的循环做出反应，也需要对“非常深入”的非循环做出反应。这不是关于内存使用，而是关于用户触发不合理的CPU资源。 Linux对任何路径名的长度都有限制:PATH_MAX，即4096。造成这种限制的原因有很多;其中之一就是不让内核在一条路径上花费太多时间。使用符号链接，您可以有效地生成更长的路径，因此出于同样的原因，需要某种限制。Linux在任何一个路径查找中限制最多40个(MAXSYMLINKS)符号链接。以前，它对递归的最大深度施加了8的限制，但是当实现单独的堆栈时，这个限制提高到了40，所以现在只有一个限制。 我们在前一篇文章中遇到的nameidata结构包含一个小堆栈，可用于存储最多两个符号链接的剩余部分。在许多情况下，这就足够了。如果不是，则分配一个单独的堆栈，并为40个符号链接分配空间。路径名查找永远不会超过这个堆栈，因为一旦检测到第40个符号链接，就会返回一个错误。 看起来这个堆栈中只需要存储名字的残余部分，但是我们还需要更多。为了了解这一点，我们需要继续研究缓存生存期。 缓存符号链接的存储和生存期 与其他文件系统资源(如inode和目录条目)一样，符号链接由Linux缓存，以避免对外部存储的重复昂贵访问。对于RCU-walk来说，能够找到并临时保存这些缓存条目是特别重要的，这样它就不需要下拉到REF-walk中。 虽然每个文件系统都可以自由地做出自己的选择，但符号链接通常存储在两个地方之一。短符号链接通常直接存储在inode中。当一个文件系统分配一个结构节点时，它通常会分配额外的空间来存储私有数据(这是内核中常见的面向对象设计模式)。这有时会包括符号链接的空间。另一个常见的位置是在页面缓存中，它通常存储文件的内容。符号链接中的路径名可以被视为该符号链接的内容，并且可以像文件内容一样容易地存储在页面缓存中。 当这两种方法都不合适时，下一个最有可能的场景是文件系统将分配一些临时内存，并在需要时将符号链接内容复制或构造到该内存中。 当符号链接存储在inode中时，它的生命周期与被RCU保护的inode相同，或者被dentry上的计数引用所保护。这意味着，路径名查找用于安全访问dcache和icache (inode缓存)的机制对于安全访问一些缓存的符号链接已经足够了。在这些情况下，inode中的i_link指针被设置为指向存储符号链接的任何地方，并且在需要时可以直接访问符号链接。 当符号链接存储在页面缓存或其他地方时，情况就不那么简单了。对dentry甚至是inode的引用并不意味着对该inode的缓存页面的引用，即使使用rcu_read_lock()也不足以确保页面不会消失。因此，对于这些符号链接，路径名查找代码需要要求文件系统提供一个稳定的引用，而且，重要的是，需要在使用完该引用后释放该引用。 即使在rcu遍历模式下，也经常可以获取对缓存页的引用。它确实需要改变内存，这是最好避免的，但这并不一定是一个大的成本，它比完全放弃RCU-walk模式要好。即使分配空间来复制符号链接的文件系统也可以使用GFP_ATOMIC来成功地分配内存，而不需要退出RCU-walk。如果一个文件系统不能在RCU-walk模式下成功获得一个引用，它必须返回-ECHILD，并且调用unlazy_walk()返回到允许文件系统休眠的REF-walk模式。 这一切发生的地方是i_op-\u003eget_link() inode方法。这在RCU-walk和REF-walk中都被称为。在RCU-walk中dentry*参数是NULL， -\u003eget_link()可以返回-echild来退出RCU-walk。就像我们之前看到的i_op-\u003epermission()方法一样，-\u003eget_link()需要注意的是，它引用的所有数据结构在没有被计数的引用(只有RCU锁)的情况下都是安全的。一个回调结构体delayed_called将被传递给-\u003eget_link():文件系统可以通过set_delayed_call()设置自己的put_link函数和参数。稍后，当VFS想要放置link时，它将调用do_delayed_call()来调用带有参数的回调函数。 为了在遍历完成时删除对每个符号链接的引用，无论是在RCU-walk还是REF-walk中，符号链接堆栈需要包含路径剩余部分: 提供对前一个路径的引用的结构路径 const char* 用于提供对前一个名称的引用 使路径从RCU-walk安全切换到REF-walk 用于以后调用的结构体delayed_call。 这意味着符号链接堆栈中的每个条目需要保存五个指针和一个整数，而不是只有一个指针(路径剩余部分)。在64位系统上，每个条目大约是40字节;40个条目加起来总共是1600字节，这还不到半页。所以这看起来很多，但绝不是过度。 注意，在给定的堆栈帧中，路径剩余(name)不是其他字段引用的符号链接的一部分。它是符号链接完全解析后要遵循的剩余部分。 符号链接 link_path_walk()中的主循环无缝地遍历路径中的所有组件和所有非结尾符号链接。在处理符号链接时，名称指针被调整为指向一个新的符号链接，或者从堆栈中恢复，这样大部分循环就不需要注意了。在堆栈上和下获取这个name变量非常简单;推入和取出引用稍微复杂一些。 当找到符号链接时，walk_component()通过从文件系统返回链接的step_into()调用pick_link()。如果操作成功，旧的路径名称将被放置在堆栈上，而新值将暂时用作名称。当找到路径的结束(即*name为’\\0’)，旧的名称将从堆栈中恢复，并继续遍历路径。 推入和弹出引用指针(inode、cookie等)更加复杂，部分原因是需要处理尾部递归。当符号链接的最后一个组件本身指向一个符号链接时，我们希望在推入刚刚发现的符号链接之前将刚刚完成的符号链接从堆栈中取出，以避免留下空的路径残余物，否则会挡住去路。 当找到符号链接时，最方便的做法是立即将新的符号链接推入walk_component()中的堆栈;walk_component()也是在遍历最后一个组件时需要查看旧符号链接的最后一段代码。因此，walk_component()可以很方便地释放旧的符号链接，并在为新符号链接推送引用信息之前弹出引用。它由个 flag 引导:WALK_NOFOLLOW，它禁止它在发现符号链接时跟随，WALK_MORE表示现在释放当前符号链接还为时过早，WALK_TRAILING表示它在查找的最后一个组件上，因此，我们将检查用户空间标志LOOKUP_FOLLOW，以确定当它是符号链接时是否跟随它，并调用may_follow_link()来检查我们是否有权限跟随它。 没有最终组件的符号链接 一对特殊情况的符号链接值得进一步解释。这两种方法都会在nameidata中设置一个新的结构路径(包含mount和dentry)，并导致pick_link()返回NULL。 更明显的情况是指向/的符号链接。所有以/开头的符号链接都会在pick_link()中检测到，它会将nameidata重置为指向有效的文件系统根。如果符号链接只包含/，那么就没有更多的事情要做，根本没有组件，所以返回NULL表示可以释放符号链接，并丢弃堆栈帧。 另一种情况是/proc中看起来像符号链接但实际上不是(因此通常被称为“magic-link”): $ ls -l /proc/self/fd/1 lrwx------ 1 neilb neilb 64 Jun 13 10:19 /proc/self/fd/1 -\u003e /dev/pts/4 在/proc中，任何进程中打开的文件描述符都用类似符号链接的东西表示。它实际上是对目标文件的引用，而不仅仅是它的名称。当您读取链接这些对象时，您得到的名称可能指向同一个文件——除非它已被解除链接或挂载。当walk_component()遵循其中之一时，“procfs”中的-\u003eget_link()方法不返回","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:9","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"最后 尽管它很复杂，但所有这些路径名查找代码看起来都很好——现在的各个部分肯定比几个版本之前更容易理解了。但这并不意味着它“结束了”。正如前面提到的，RCU-walk目前只跟随存储在索引节点中的符号链接，因此，虽然它处理许多ext4符号链接，但它对NFS、XFS或Btrfs没有帮助。这种支持不太可能拖延太久。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:5:0","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["面试题"],"content":"LRU 缓存机制实现 ","date":"2022-05-25","objectID":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/:1:0","tags":["linux","算法"],"title":"面试题","uri":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["面试题"],"content":"要求 实现一个 LRU(最近最少使用)缓存机制 获取/写入数据时间复杂度是O(1) 获取数据 – 如果数据存在缓存中，则获取到数据的值，否则返回 -1 写入数据 – 如果密钥不存在则写入数据值，当缓存容量达到上限时候，它应该在写入之前删除最近最少使用的数据值，从而为新的数据值留出空间。 ","date":"2022-05-25","objectID":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/:1:1","tags":["linux","算法"],"title":"面试题","uri":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["面试题"],"content":"实现思路 要想O(1)一定要用hash了 有容量大小限制，构造函数需要传入容量限制值 构造函数: 1. 传入容量大小限制的值 2. 再定义属性 size 表示当前使用的容量 3. 定义一个hashmap + 一个双向链表; hashmap存放键+双向链表节点、 双向链表保存键对应的值 + 引用次数 get函数: 判断“键”是否存在于 hashmap，存在则获取对应的值，根据值获取到 hashmap 对应的值，然后更新引用计数，更新后与后一个节点比较，看看是否调整链表位置。 set函数: 判断\"键\"是否存在于 hashmap，存在则直接退出，不存在则创建新节点，插入 hashmap，并把节点放入 双向链表头部 ","date":"2022-05-25","objectID":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/:1:2","tags":["linux","算法"],"title":"面试题","uri":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["linux"],"content":"cpu 相关术语 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"工作频率（外频和倍频） 早期的 CPU 架构主要通过北桥来链接系统最重要的 CPU、内存与显卡设备。因为所有的设 备都得通过北桥来链接，因此每个设备的工作频率应该要相同。 于是就有所谓的前端总线 (FSB) 这个东西的产生。但因为 CPU 的运算速度比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。 外频 外频指的是CPU与外部元件进行数据传输时的速度 倍频 倍频则是 CPU 内部用来加速工作性能的一个倍数， 两者相乘才是CPU的频率速度。 如 Intel Core 2 E8400 的内频为 3.0GHz，而外频是333MHz，因此倍频就是9倍啰! (3.0G=333Mx9, 其中1G=1000M) ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"超频 所谓的超频指的是: 将CPU的倍频或者是外频通过主板的设置功能更改成较高频率的一种方式。但因为CPU的倍频通常在出厂时已经被锁定而无法修改，因此较常被超频的为外频。 举例来说，像上述3.0GHz的CPU如果想要超频，可以将他的外频333MHz调整成为400MHz，但如此一来整个主板的各个元件的运行频率可能都会被增加成原本的1.333倍(4/3)，虽然CPU可能可以到达3.6GHz，但却因为频率并非正常速度，故可能会造成死机等问题。 现在 Intel 的 CPU 会主动帮你超频喔!例如 i7-4790 这颗 CPU 的规格 [10] 中，基本频 率为 3.6GHz，但是最高可自动超频到 4GHz 喔! 通过的是 Intel 的 turbo 技术。同时，如果 你没有大量的运算需求，该 CPU 频率会降到 1.xGHz 而已，借此达到节能省电的目的!所 以，各位好朋友， 不需要自己手动超频了!Intel 已经自动帮你进行超频了…所以，如果你用 cpu-z 观察 CPU 频率，发现该频率会一直自动变动。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"北桥 早期的 CPU 架构主要通过北桥来链接系统最重要的 CPU、内存与显卡设备。因为所有的设备都得通过北桥来链接，因此每个设备的工作频率应该要相同。于是就有所谓的前端总线(FSB)这个东西的产生。但如此一来所有的数据都被北桥卡死了，北桥又不可能比 CPU 更快，因此这家伙常常是系统性能的瓶颈。 为了解决这个问题，新的 CPU 设计中， 已经将内存控制器整合到 CPU 内部， 而链接 CPU 与内存、显卡的控制器的设计，在Intel部份使用 QPI (Quick Path Interconnect) 与 DMI 技术，而 AMD 部份则使用 Hyper Transport 了，这些技术都可以让 CPU 直接与内存、显卡等设备分别进行沟通，而不需要通过外部的链接芯片了。 因为现在没有所谓的北桥了(整合到CPU内)，因此，CPU 的频率设计就无须考虑得要同步的外频，只需要考虑整体的频率即可。所以，如果你经常有查阅自己 CPU 频率的习惯， 当使用 cpu-z 这个软件时，应该会很惊讶的发现到，怎么外频变成 100MHz 而倍频可以到达 30 以上!相当有趣呢! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:3","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"cpu 等级 由于x86架构的CPU在Intel的Pentium系列(1993年)后就有不统一的脚位与设计，为了将不 同种类的CPU规范等级， 所以就有i386,i586,i686等名词出现了。 基本上，在Intel Pentium MMX与AMD K6年代的CPU称为i586等级， 而Intel Celeron与AMD Athlon(K7)年代之后的32位CPU就称为i686等级。 至于目前的64位CPU则统称为x86_64等级。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:4","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"超线程(hyper-Threading, HT) 现在的 CPU 至少都是两个核心以上的多核心 CPU 了，但是 Intel 还有个很怪的东 西，叫做 CPU 的超线程 (Hyper-Threading) 功能! 那个是啥鬼东西?我们知道现在的 CPU 运算速度都太快了，因此运算核心经常处于闲置状态下。而我们也知道现在的系统大多 都是多任务的系统， 同时间有很多的程序会让 CPU 来执行。因此，若 CPU 可以假象的同时 执行两个程序，不就可以让系统性能增加了吗?反正 CPU 的运算能力还是没有用完啊! 在每一个 CPU 内部将重要的寄存器 (register) 分成两群， 而让程序分别使用这两群寄存器。也就是 说，可以有两个程序“同时竞争 CPU 的运算单元”，而非通过操作系统的多任务切换! 这一过 程就会让 CPU 好像“同时有两个核心”的模样!因此，虽然大部分 i7 等级的 CPU 其实只有四 个实体核心，但通过 HT 的机制， 则操作系统可以抓到八个核心!并且让每个核心逻辑上分 离，就可以同时运行八个程序了。 虽然很多研究与测试中，大多发现 HT 虽然可以提升性能，不过，有些情况下却可能导致性能 降低喔!因为，实际上明明就仅有一个运算单元嘛! 但是大多数使用场景下是可以提升性能(30%-50%)的。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:5","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"内存相关术语 CPU所使用的数据都是来自于内存(main memory)，不论是软件程序还是数据， 都必须要读入内存后CPU才能利用。 个人电脑的内存主要元件为动态随机存取内存 (Dynamic Random Access Memory, DRAM),随机存取内存只有在通电时才能记录与使 用，断电后数据就消失了。因此我们也称这种RAM为挥发性内存。 DRAM根据技术的更新又分好几代，而使用上较广泛的有所谓的SDRAM与DDR SDRAM 两种。这两种内存的差别除了在于脚位与工作电压上的不同之外，DDR是所谓的双倍数据传送 速度(Double Data Rate)， 他可以在一次工作周期中进行两次数据的传送，感觉上就好像是CPU的倍频啦! 所以传输频率方面比SDRAM还要好。 DDR SDRAM又依据技术的发展，有DDR, DDR2, DDR3, DDR4等等，其中，DDR2 的频率倍数则是 4 倍, 而DDR3 则是 8 倍喔! 内存的规格内提到 DDR3/DDR3L 同时支持，我们知道 DDR3 了，那 DDR3L 是啥鬼? 为了节省更多的电力，新的制程中降低了内存的操作电压，因此 DDR3 标 准电压为 1.5V，但 DDR3L 则仅须 1.35V 喔!通常可以用在耗电量需求更低的笔记本中! 但 并非所有的系统都同步支持!这就得要看主板的支持规格啰!否则你买了 DDR3L 安插在不支 持的主板上，DDR3L 内存是可能会烧毁的喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:2:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"工作频率 与 CPU 的频率类似的，内存也是有其工作的频率，这个频率限制还是来自于 CPU 内的内存 控制器所决定的。 CPU 内置的内存控制芯片对内存的工作频率最高可达到 1600MHz。这只是工作频率(每秒几次)。一般来说，每次频率能够传输的数据量，大多为 64 位，这个 64 位就是所谓的“宽度”了! 因此，这个系统中，CPU可以从内存中取 得的最快带宽就是 1600MHz 64bit = 1600MHz 8 Bytes = 12.8GByte/s。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:2:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"字组大小(带宽) 与总线宽度相似的，CPU每次能够处理的数据量称为字组大小(word size)，字组大小依据 CPU 的设计而有32位与64位。 我们现在所称的电脑是32或64位主要是依据这个 CPU 解析的字组大小而来的!早期的32位CPU中，因为CPU每次能够解析的数据量有限，因此由内存传来的数据量就有所限制了。这也导致32位的CPU最多只能支持最大到4GBytes的内存。 得利于北桥整合到 CPU 内部的设计，CPU 得以“个别”跟各个元件进行沟通!因此，每种元件与 CPU 的沟通具有很多不同的方式!例如内存使用系统总线带宽来与 CPU 沟通。而显卡则通过PCI-E的序列信道设计来与CPU沟通喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:2:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"容量大小 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:2:3","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"多通道设计 由于所有的数据都必须要存放在内存，所以内存的数据宽度当然是越大越好。 但传统的总线 宽度一般大约仅达64位，为了要加大这个宽度，因此芯片组厂商就将两个内存汇整在一起， 如果一支内存可达64位，两支内存就可以达到128位了，这就是双通道的设计理念。 要启用双通道的功能你必须要安插两支(或四支)内存，这两支内存最好连型号 都一模一样比较好， 这是因为启动双通道内存功能时，数据是同步写入/读出这一对内存中， 如此才能够提升整体的带宽啊! 所以当然除了容量大小要一致之外，型号也最好相同啦! 服务器所需要的速度更快!因此，除了双通道之外，中阶服务器也经常提供三信道，甚 至四信道的内存环境! 例如 2014 年推出的服务器用 E5-2650 v3 的 Intel CPU 中，它可以接 受的最大信道数就是四信道且为 DDR4 喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:2:4","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"存储分类 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:3:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"DRAM 和 SRAM 除了内存条之外，事实上整部个人电脑当中还有许许多多的内存存在喔!最为我们所知的就 是CPU内的第二层高速缓存内存。 我们现在知道CPU的数据都是由内存提供，但CPU到内存 之间还是得要通过内存控制器啊! 如果某些很常用的程序或数据可以放置到CPU内部的话， 那么CPU数据的读取就不需要跑到内存重新读取了! 这对于性能来说不就可以大大的提升 了?这就是第二层高速缓存的设计概念。 因为第二层高速缓存(L2 cache)整合到CPU内部，因此这个L2内存的速度必须要CPU频率 相同。 使用DRAM是无法达到这个频率速度的，此时就需要静态随机存取内存(Static Random Access Memory, SRAM)的帮忙了。 SRAM在设计上使用的电晶体数量较多，价格 较高，且不易做成大容量，不过由于其速度快， 因此整合到CPU内成为高速缓存内存以加快 数据的存取是个不错的方式喔!新一代的CPU都有内置容量不等的L2高速缓存在CPU内部， 以加快CPU的运行性能。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:3:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"ROM 主板上面的元件是非常多的，而每个元件的参数又具有可调整性。举例来说，CPU与内存的 频率是可调整的; 而主板上面如果有内置的网卡或者是显卡时，该功能是否要启动与该功能 的各项参数， 是被记录到主板上头的一个称为CMOS的芯片上，这个芯片需要借着额外的电源来发挥记录功能， 这也是为什么你的主板上面会有一颗电池的缘故。 那CMOS内的数据如何读取与更新呢?还记得你的电脑在开机的时候可以按下[Del]按键来进 入一个名为BIOS的画面吧? BIOS(Basic Input Output System)是一套程序，这套程序是写 死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就 是只读存储器(Read Only Memory, ROM)。 ROM是一种非挥发性的内存。另外，BIOS对 于个人电脑来说是非常重要的， 因为他是系统在开机的时候首先会去读取的一个小程序喔! 另外，固件(firmware)很多也是使用ROM来进行软件的写入的。 固件像软件一样也是 一个被电脑所执行的程序，然而他是对于硬件内部而言更加重要的部分。例如BIOS就是一个 固件， BIOS虽然对于我们日常操作电脑系统没有什么太大的关系，但是他却控制着开机时各 项硬件参数的取得! 所以我们会知道很多的硬件上头都会有ROM来写入固件这个软件。 BIOS 对电脑系统来讲是非常重要的，因为他掌握了系统硬件的详细信息与开机设备的选择等 等。但是电脑发展的速度太快了， 因此 BIOS 程序码也可能需要作适度的修改才行，所以你 才会在很多主板官网找到 BIOS 的更新程序啊!但是 BIOS 原本使用的是无法改写的 ROM ， 因此根本无法修正 BIOS 程序码!为此，现在的 BIOS 通常是写入类似闪存 (flash) 或 EEPROM中。 很多硬件上面都会有固件喔!例如常用的磁盘阵列卡、10G 的网卡、交换器设备等等!你可以简单的这么想!固件就是绑在硬件上面的控制软件! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:3:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"显卡 显卡又称为VGA(Video Graphics Array)，他对于图形影像的显示扮演相当关键的角色。 一 般对于图形影像的显示重点在于分辨率与色彩深度，因为每个图像显示的颜色会占用掉内 存， 因此显卡上面会有一个内存的容量，这个显存容量将会影响到你的屏幕分辨率与色彩深 度的喔! 除了显存之外，现在由于三度空间游戏(3D game)与一些3D动画的流行，因此显卡的“运算 能力”越来越重要。 一些3D的运算早期是交给CPU去运行的，但是CPU并非完全针对这些3D 来进行设计的，而且CPU平时已经非常忙碌了呢! 所以后来显卡厂商直接在显卡上面嵌入一 个3D加速的芯片，这就是所谓的GPU称谓的由来。 显卡主要也是通过CPU的控制芯片来与CPU、内存等沟通。如前面提到的，对于图形影像 (尤其是3D游戏)来说， 显卡也是需要高速运算的一个元件，所以数据的传输也是越快越 好!因此显卡的规格由早期的PCI导向AGP， 近期AGP又被PCI-Express规格所取代了。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:4:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"磁盘 硬盘依据台式机与笔记本电脑而有分为3.5英寸及2.5英寸的大小。我 们以3.5英寸的台式机使用硬盘来说明。 在硬盘盒里面其实是由许许多多的圆形盘片、机械手 臂、 磁头与主轴马达所组成的 实际的数据都是写在具有磁性物质的盘片上头，而读写主要是通过在机械手臂上的磁头 (head)来达成。 实际运行时， 主轴马达让盘片转动，然后机械手臂可伸展让磁头在盘片上 头进行读写的动作。 另外，由于单一盘片的容量有限，因此有的硬盘内部会有两个以上的盘 片喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"扇区 磁盘设计就是在类似盘片同心 圆上面切出一个一个的小区块，这些小区块整合成一个圆形，让机器手臂上的磁头去存取。这个小区块就是磁盘的最小物理储存单位，称之为扇区 (sector) ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"磁道 同一个同心圆的扇区 组合成的圆就是所谓的磁道(track)。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"柱面 由于磁盘里面可能会有多个盘片，因此在所有盘片上 面的同一个磁道可以组合成所谓的柱面 (cylinder)。 我们知道同心圆外圈的圆比较大，占用的面积比内圈多啊!所以，为了善用这些空间，因此 外围的圆会具有更多的扇区[16]! 就如同图 0.2.5 的示意一般。此外，当盘片转一圈时，外圈 的扇区数量比较多，因此如果数据写入在外圈，转一圈能够读写的数据量当然比内圈还要 多! 因此通常数据的读写会由外圈开始往内写的喔!这是默认值啊! 另外，原本硬盘的扇区都是设计成 512Byte 的容量，但因为近期以来硬盘的容量越来越大， 为了减少数据量的拆解，所以新的大容量硬盘已经有 4KByte 的扇区设计!要注意一下。也因为这个扇区的设计不同了，因此在磁盘的分区方面，目前有旧式的 MSDOS 相容模式，以及较新的 GPT 模式喔! 在较新的 GPT 模式下，磁盘的分区通常使用 扇区号码来设计，跟过去旧的 MSDOS 是通过柱面号码来分区的情况不同喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:3","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"传输接口 为了要提升磁盘的传输速度，磁盘与主板的连接接口也经过多次的改版，传统磁盘接口包括有 SATA, SAS, IDE 与 SCSI 等等。 若考虑外接式磁盘，那就还 包括了 USB, eSATA 等等接口喔!不过目前 IDE 已经被 SATA 取代，而 SCSI 则被 SAS 取 代，因此我们下面将仅介绍 SATA, USB 与 SAS 接口而已。 SATA接口 这种插槽所使用的排线比较窄 小， 而且每个设备需要使用掉一条SATA线。因为SATA线比较窄小之故，所以对于安装与机 箱内的通风都比较好!因此原本的IDE粗排线接口就被SATA取代了! 由于SATA一条排线仅接一颗硬盘，所以你不需要调整跳针。不过一张主板上面SATA插槽的数 量并不是固定的， 且每个插槽都有编号，在连接SATA硬盘与主板的时候，还是需要留意一 下。此外，目前的 SATA 版本已经到了第三代 [17]， 每一代之间的传输速度如下所示，而且 重点是，每一代都可以向下相容喔!只是速度上会差很多就是了。目前主流都是使用 SATA3 这个接口速度可达 600MByte/s 的接口! 版本 带宽(Gbit/s) 速度(MByte/s) SATA 1.0 1.5 150 SATA 2.0 3 300 SATA 3.0 6 600 因为 SATA 传输接口传输时，通过的数据演算法的关系，当传输 10 位编码时，仅有 8 位为数 据，其余 2 位为检验之用。因此带宽的计算上面， 使用的换算 (bit 转 Byte) 为 1:10 而不 是 1Byte=8bits 喔!上表的对应要稍微注意一下。另外，虽然这个 SATA3 接口理论上可达 600MBytes/s 的传输速度， 不过目前传统的硬盘由于其物理组成的限制，一般极限速度大约 在 150~200MByte/s 而已啦!所以厂商们才要发展固态硬盘啊! SAS 接口 早期工作站或大型大脑上面，为了读写速度与稳定性，因此在这样的机器上面，大多使用的 是 SCSI 这种高阶的连接接口。 不过这种接口的速度后来被 SATA 打败了!但是 SCSI 有其 值得开发的功能，因此后来就有串行式 SCSI (Serial Attached SCSI, SAS) 的发展。这种 接口的速度比 SATA 来的快，而且连接的 SAS 硬盘的盘片转速与传输的速度也都比 SATA 硬 盘好! 只是…好贵喔!而且一般个人电脑的主板上面通常没有内置 SAS 连接接口，得要通过 外接卡才能够支持。因此一般个人电脑主机还是以 SATA 接口为主要的磁盘连接接口啰。 版本 带宽(Gbit/s) 速度(MByte/s) SAS 1 3 300 SAS 2 6 600 SAS 3 12 1200 因为这种接口的速度确实比较快喔!而且还支持例如热拔插等功能，因此，许多的设备连接 会以这种接口来链接! 例如我们经常会听到的磁盘阵列卡的连接插槽，就是利用这种 SAS 接 口开发出来的支持的 SFF-8087 设备等等。 USB接口 如果你的磁盘是外接式的接口，那么很可能跟主板链接的就是 USB 这种接口了!这也是目前 (2015) 最常见到的外接式磁盘接口了。 不过传统的 USB 速度挺慢的，即使是比较慢的传 统硬盘，其传输率大概兜还有 80~120MBytes/s ，但传统的 USB 2.0 仅有大约 60MBytes/s 的理论传输率， 通常实做在主板上面的连接口，竟然都仅有 30~40 MByte/s 而已呢!实在发 挥不出磁盘的性能啊! 为了改善 USB 的传输率，因此新一代的 USB 3.0 速度就快很多了!据说还有更新的 USB 3.1 正在发展中!这几代版本的带宽与速度制表如下： 版本 带宽(Mbit/s) 速度(MByte/s) USB 1.0 12 1.5 USB 2.0 480 60 USB 3.0 5G 500 USB 3.1 10G 1000 跟 SATA 接口一样，不是理论速度到达该数值，实际上就可以跑到这么高!USB 3.0 虽然速 度很快，但如果你去市面上面买 USB 的传统磁盘或闪存盘， 其实他的读写速度还是差不多在 100MBytes/s 而已啦!不过这样就超级快了!因为一般 USB2.0 的闪存盘读写速度大约是 40MBytes/10MBytes 左右而已说。 在购买这方面的外接式磁盘时，要特别考虑喔! 固态硬盘(solid State Disk, SSD) 传统硬盘有个很致命的问题，就是需要驱动马达去转动盘片~这会造成很严重的磁盘读取延 迟!想想看，你得要知道数据在哪个扇区上面，然后再命令马达开始转， 之后再让磁头去读 取正确的数据。另外，如果数据放置的比较离散(扇区分佈比较广又不连续)，那么读写的 速度就会延迟更明显!速度快不起来。因此， 后来就有厂商拿闪存去制作成大容量的设备， 这些设备的连接接口也是通过 SATA 或 SAS，而且外型还做的跟传统磁盘一样!所以， 虽然 这类的设备已经不能称为是磁盘 (因为没有磁头与盘片啊!都是内存!)。但是为了方便大 家称呼，所以还是称为磁盘!只是跟传统磁盘 (Hard Disk Drive, HDD) 不同， 就称为固态 硬盘 (Solid State Disk 或 Solid State Driver, SSD)。 固态硬盘最大的好处是，它没有马达不需要转动，而是通过内存直接读写的特性，因此除了 没数据延迟且快速之外，还很省电! 不过早期的 SSD 有个很重要的致命伤，就是这些闪存 有“写入次数的限制”，因此通常 SSD 的寿命大概两年就顶天了!所以数据存放时， 需要考虑 到备份或者是可能要使用 RAID 的机制来防止 SSD 的损毁 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:4","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"扩展卡与接口 你的服务器可能因为某些特殊的需求，因此需要使用主板之外的其他适配卡。所以主板上面 通常会预留多个扩充接口的插槽， 这些插槽依据历史沿革，包括 PCI/AGP/PCI-X/PCIe 等 等，但是由于 PCIe 速度快到太好用了，因此几乎所有的卡都以 PCIe 来设计了! 但是有些比 较老旧的卡可能还需要使用啊，因此一般主板大多还是会保留一两个 PCI 插槽，其他的则是 以 PCIe 来设计。 多信号卡 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:5","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"主板 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:6:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"设备I/O位址与IRQ中断信道 主板是负责各个电脑元件之间的沟通，但是电脑元件实在太多了，有输出/输入/不同的储存设 备等等， 主板芯片组怎么知道如何负责沟通呐?这个时候就需要用到所谓的I/O位址与IRQ 啰! I/O位址有点类似每个设备的门牌号码，每个设备都有他自己的位址，一般来说，不能有两个 设备使用同一个I/O位址， 否则系统就会不晓得该如何运行这两个设备了。而除了I/O位址之 外，还有个IRQ中断(Interrupt)这个咚咚。 如果I/O位址想成是各设备的门牌号码的话，那么IRQ就可以想成是各个门牌连接到邮件中心 (CPU)的专门路径啰! 各设备可以通过IRQ中断信道来告知CPU该设备的工作情况，以方 便CPU进行工作分配的任务。 老式的主板芯片组IRQ只有15个，如果你的周边接口太多时可 能就会不够用， 这个时候你可以选择将一些没有用到的周边接口关掉，以空出一些IRQ来给 真正需要使用的接口喔! 当然，也有所谓的sharing IRQ的技术就是了! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:6:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"CMOS与BIOS CMOS主要的 功能为记录主板上面的重要参数， 包括系统时间、CPU电压与频率、各项设备的I/O位址与 IRQ等，由于这些数据的记录要花费电力，因此主板上面才有电池。 BIOS为写入到主板上某 一块 flash 或 EEPROM 的程序，他可以在开机的时候执行，以载入CMOS当中的参数， 并尝 试调用储存设备中的开机程序，进一步进入操作系统当中。BIOS程序也可以修改CMOS中的 数据， 每种主板调用BIOS设置程序的按键都不同，一般台式机常见的是使用[del]按键进入 BIOS设置画面。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:6:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"连接周边设备的接口 主板与各项输出/输入设备的链接主要都是在主机机箱的后方，主要有: PS/2接口:这原本是常见的键盘与鼠标的接口，不过目前渐渐被USB接口取代，甚至较 新的主板可能就不再提供 PS/2 接口了; USB接口:通常只剩下 USB 2.0 与 USB 3.0，为了方便区分，USB 3.0 为蓝色的插槽颜 色喔! 声音输出、输入与麦克风:这个是一些圆形的插孔，而必须你的主板上面有内置音效芯 片时，才会有这三个东西; RJ-45网络头:如果有内置网络芯片的话，那么就会有这种接头出现。 这种接头有点类 似电话接头，不过内部有八蕊线喔!接上网络线后在这个接头上会有灯号亮起才对! HDMI:如果有内置显示芯片的话，可能就会提供这个与屏幕连接的接口了!这种接口可 以同时传输声音与影像， 目前也是电视机屏幕的主流连接接口喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:6:3","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"电源供应器 除了上面这些元件之外，其实还有一个很重要的元件也要来谈一谈，那就是电源供应器 (Power)。 在你的机箱内，有个大大的铁盒子，上头有很多电源线会跑出来，那就是电源 供应器了。 我们的CPU/RAM/主板/硬盘等等都需要用电，而近来的电脑元件耗电量越来越高，以前很古早的230W电源已经不够用了， 有的系统甚至得要有500W以上的电源才能够运 行~真可怕~ 电源供应器的价差非常大!贵一点的300W可以到4000 NT，便宜一点的300W只要500 NT不 到! 怎么差这么多?没错~因为Power的用料不同，电源供应的稳定性也会差很多。如前所 述，电源供应器相当于你的心脏， 心脏差的话，活动力就会不足了!所以， 稳定性差的电源 供应器甚至是造成电脑不稳定的元凶呢!所以，尽量不要使用太差的电源供应器喔! 能源转换率 电源供应器本身也会吃掉一部份的电力的!如果你的主机系统需要 300W 的电力时，因为电 源供应器本身也会消耗掉一部份的电力， 因此你最好要挑选400W以上的电源供应器。电源供 应器出厂前会有一些测试数据，最好挑选高转换率的电源供应器。 所谓的高转换率指的是“输 出的功率/输入的功率”。意思是说，假如你的主板用电量为250W， 但是电源供应器其实已经 使用掉320W的电力，则转换率为:250/320=0.78的意思。 这个数值越高表示被电源供应 器“玩掉”的电力越少，那就符合能源效益了! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:6:4","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"数据表示方式 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:7:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"数字系统(进制) ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:7:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"文字编码系统 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:7:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"linux 历史回顾 操作系统(Operation System)主要在管理与驱动硬件，因此必须要能够管理内存、管 理设备、 负责行程管理以及系统调用等等。因此，只要能够让硬件准备妥当(Ready) 的情况， 就是一个阳春的操作系统了。 Unix的前身是由贝尔实验室(Bell lab.)的Ken Thompson利用组合语言写成的， 后来在 1971-1973年间由Dennis Ritchie以C程序语言进行改写，才称为Unix。 1977年由Bill Joy释出BSD (Berkeley Software Distribution)，这些称为Unix-like的操作 系统。 1984年由Andrew Tanenbaum开始制作Minix操作系统，该系统可以提供源代码以及软 件; 1984年由Richard Stallman提倡GNU计划，倡导自由软件(Free software)， 强调其软 件可以“自由的取得、复制、修改与再发行”，并规范出GPL授权模式， 任何 GPL(General Public License)软件均不可单纯仅贩卖其软件，也不可修改软件授权。 1991年由芬兰人Linus Torvalds开发出Linux操作系统。简而言之，Linux成功的地方主要 在于: Minix(Unix), GNU, Internet, POSIX 及虚拟团队的产生。 符合 Open source 理念的授权相当多，比较知名的如 Apache / BSD / GPL / MIT 等。 Linux本身就是个最阳春的操作系统，其开发网站设立在http://www.kernel.org，我们亦称 Linux操作系统最底层的数据为“核心(Kernel)”。 从 Linux kernel 3.0 开始，已经舍弃奇数、偶数的核心版本规划，新的规划使用主线版本 (MainLine) 为依据， 并提供长期支持版本 (longterm) 来加强某些功能的持续维 护。 Linux distributions的组成含有:“Linux Kernel + Free Software + Documentations(Tools) + 可完整安装的程序”所制成的一套完整的系统。 常见的 Linux distributions 分类有“商业、社群”分类法，或“RPM、DPKG”分类法 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:8:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"linux 初探 你在你的主机上面安装了一张网卡，但是开机之后，系统却无法使用，你确定网卡是好 的，那么可能的问题出在哪里?该如何解决?因为所有的硬件都没有问题，所以，可能 出问题的地方在于系统的核心(kernel) 不支持这张网卡。解决的方法，(1)到网卡的 开发商网站，(2)下载支持你主机操作系统的驱动程序， (3)安装网卡驱动程序后， 就可以使用了。 一个操作系统至少要能够完整的控制整个硬件，请问，操作系统应该要控制硬件的哪些 单元?根据硬件的运行，以及数据在主机上面的运算情况与写入/读取情况，我们知道至 少要能够控制: (1)input/output control, (2)device control, (3)process management, (4)file management. 等等! 我在Windows上面玩的游戏，可不可以拿到Linux去玩?当然不行!因为游戏也是一个应 用程序 (application)，他必须要使用到核心所提供的工具来开发他的游戏， 所以这个 游戏是不可在不同的平台间运行的。除非这个游戏已经进行了移植。 Linux本身仅是一个核心与相关的核心工具而已，不过，他已经可以驱动所有的硬件， 所 以，可以算是一个很阳春的操作系统了。经过其他应用程序的开发之后，被整合成为 Linux distribitions。请问众多的distributions之间，有何异同?相同:(1)同样使用 http://www.kernel.org 所释出的核心; (2)支持同样的标准，如 FHS、LSB 等; (3) 使用几乎相同的自由软件 (例如 GNU 里面的 gcc/glibc/vi/apache/bind/sendmail… ); (4)几乎相同的操作接口 (例如均使用 bash/KDE/GNOME 等等)。 不同:使用的 kernel 与各软件的版本可能会不同;各开发商加入的应用工具不同，使用的套件管理模 式不同(dpkg 与 RPM) Unix 是谁写出来的? GNU 计划是谁发起的?Unix 是 Ken Thompson 写的，1973 年再 由 Dennis Ritchie 以 C 语言改写成功。 至于 GNU 与 FSF 则是 Richard Stallman 发起 的。 GNU 的全名为何?他主要由那个基金会支持?GNU 是 GNU is Not Unix 的简写，是个无 穷循环! 另外，这个计划是由自由软件基金会 (Free Software Foundation, FSF) 所支持的! 两者都是由 Stallman 先生所发起的! 何谓多用户 ( Multi-user ) 多任务 ( Multitask )?Multiuser 指的是 Linux 允许多人同 时连上主机之外，每个使用者皆有其各人的使用环境，并且可以同时使用系统的资源! Multitask 指的是多任务环境，在 Linux 系统下， CPU 与其他例如网络资源可以同时进行 多项工作， Linux 最大的特色之一即在于其多任务时，资源分配较为平均! 简单说明 GNU General Public License ( GPL ) 与 Open Source 的精神:1. GPL 的授 权之软件，乃为自由软件(Free software)，任何人皆可拥有他; 2. 开发 GPL 的团体 (或商业企业)可以经由该软件的服务来取得服务的费用; 3. 经过 GPL 授权的软件，其 属于 Open source 的情况，所以应该公布其源代码; 4. 任何人皆可修改经由 GPL 授权 过的软件，使符合自己的需求; 5. 经过修改过后 Open source 应该回馈给 Linux 社群。 什么是 POSIX ?为何说 Linux 使用 POSIX 对于发展有很好的影响?POSIX 是一种标准 规范，主要针对在 Unix 操作系统上面跑的程序来进行规范。 若你的操作系统符合 POSIX ，则符合 POSIX 的程序就可以在你的操作系统上面运行。 Linux 由于支持 POSIX ，因此很多 Unix 上的程序可以直接在 Linux 上运行， 因此程序的移植相当简 易!也让大家容易转换平台，提升 Linux 的使用率。 简单说明 Linux 成功的因素?1. 借由 Minix 操作系统开发的 Unix like ，没有版权的纠 纷; 2. 借助于 GNU 计划所提供的各项工具软件， gcc/bash 等; 3. 借由 Internet 广为 流传; 4. 借由支持 POSIX 标准，让核心能够适合所有软件的开发; 5. 托瓦兹强调务 实，虚拟团队的自然形成! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:8:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["kernel"],"content":"概述 虚拟文件系统(也称为虚拟文件系统交换机)是内核中的软件层，它为用户空间程序提供文件系统接口。它还在内核中提供了一个抽象，允许不同的文件系统实现共存。 VFS系统调用open(2)、stat(2)、read(2)、write(2)、chmod(2)等等都是从进程上下文中调用的。 文件系统锁在文档\"锁\"中进行了介绍。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:1:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"目录条目缓存(dcache) VFS实现了open(2)、stat(2)、chmod(2)和类似的系统调用。传递给它们的pathname参数由VFS用于搜索目录条目缓存(也称为dentry缓存或dcache)。这提供了一种非常快速的查找机制，可以将路径名(filename)转换为特定的dentry。dentry存储在RAM中，从不保存到磁盘:它们的存在只是为了性能。 dentry缓存是整个文件空间的视图。由于大多数计算机不能同时将所有dentry放入RAM中，所以缓存的一些位元会丢失。为了将路径名解析为dentry, VFS可能不得不在过程中创建dentry，然后加载inode。这是通过查找inode来完成的。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:2:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"inode 对象 单个dentry通常有一个指向inode的指针。inode是文件系统对象，比如普通文件、目录、fifo 和其他东西。它们要么存在于磁盘(对于块设备文件系统)，要么存在于内存(对于伪文件系统)。当需要时，将磁盘上的inode复制到内存中，并将对inode的更改写回磁盘。一个inode可以被多个dentry指向(例如，硬链接就是这样做的)。 要查找一个inode, VFS需要调用父目录inode的lookup()方法。该方法由inode所在的特定文件系统实现安装。一旦VFS拥有了所需的dentry(以及inode)，我们就可以执行所有无聊的操作，比如打开(2)文件或stat(2)文件以查看inode数据。stat(2)操作相当简单:一旦VFS有了dentry，它就会查看inode数据，并将其中一些数据传递回用户空间。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:3:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"File 对象 打开文件需要另一项操作:分配文件结构(这是文件描述符的内核端实现)。使用指向dentry的指针和一组文件操作成员函数初始化新分配的文件结构。这些数据来自inode数据。然后调用open()文件方法，这样特定的文件系统实现就可以完成它的工作。您可以看到，这是由VFS执行的另一个开关。文件结构被放置到进程的文件描述符表中。 读取、写入和关闭文件(以及其他各种VFS操作)是通过使用用户空间文件描述符来获取适当的文件结构，然后调用所需的文件结构方法来完成所需的操作。只要文件处于打开状态，它就保持使用dentry，这又意味着VFS inode仍在使用。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:4:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"注册和挂载文件系统 注册和注销文件系统，使用以下API函数: #include \u003clinux/fs.h\u003e extern int register_filesystem(struct file_system_type *); extern int unregister_filesystem(struct file_system_type *); 传递的struct file_system_type描述了文件系统。当需要将文件系统挂载到名称空间中的目录时，VFS将为特定的文件系统调用适当的mount()方法。新vfmount将把 -\u003emount() 返回的树形结构附加到挂载点，这样当路径名解析到达挂载点时，它将跳转到该vfmount的根目录。 您可以在文件/proc/filesystems中看到注册到内核的所有文件系统。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:5:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct file_system_type 这描述了文件系统。在2.6.39内核中，定义了以下成员: struct file_system_type { const char *name; int fs_flags; struct dentry *(*mount) (struct file_system_type *, int, const char *, void *); void (*kill_sb) (struct super_block *); struct module *owner; struct file_system_type * next; struct list_head fs_supers; struct lock_class_key s_lock_key; struct lock_class_key s_umount_key; }; name 文件系统类型的名称，例如“ext2”、“iso9660”、“msdos”等。 fs_flags 各种标志(例如:FS_REQUIRES_DEV, FS_NO_DCACHE等)。 mount 当应该安装该文件系统的新实例时调用的方法。mount()方法必须返回调用者请求的树的根dentry。对其超级块的激活引用必须被抓取，并且超级块必须被锁定。失败时，它应该返回ERR_PTR(错误)。 参数1(struct file_system_type *):描述由特定文件系统代码部分初始化的文件系统 参数2(int):挂载flag; 参数3(const char *): 要挂载的设备名； 参数4(void*)：任意的挂载选项，通常是ASCII字符串(参见“Mount Options”一节) kill_sb 当该文件系统的实例应该关闭时要调用的方法 owner 对于内部VFS使用:你应该在大多数情况下初始化THIS_MODULE。 next 对于内部VFS使用:你应该将其初始化为NULL s_lock_key, s_umount_key lockdep-specific… ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:5:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"superblock 对象 超级块对象表示一个挂载的文件系统。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct super_operations 这描述了VFS如何操作文件系统的超级块。在2.6.22内核中，定义了以下成员: struct super_operations { struct inode *(*alloc_inode)(struct super_block *sb); void (*destroy_inode)(struct inode *); void (*dirty_inode) (struct inode *, int flags); int (*write_inode) (struct inode *, int); void (*drop_inode) (struct inode *); void (*delete_inode) (struct inode *); void (*put_super) (struct super_block *); int (*sync_fs)(struct super_block *sb, int wait); int (*freeze_fs) (struct super_block *); int (*unfreeze_fs) (struct super_block *); int (*statfs) (struct dentry *, struct kstatfs *); int (*remount_fs) (struct super_block *, int *, char *); void (*clear_inode) (struct inode *); void (*umount_begin) (struct super_block *); int (*show_options)(struct seq_file *, struct dentry *); ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t); ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t); int (*nr_cached_objects)(struct super_block *); void (*free_cached_objects)(struct super_block *, int); }; 除非另有说明，否则所有方法都是在不持有任何锁的情况下调用的。这意味着大多数方法都可以安全地阻塞。所有方法只能从进程上下文中调用(即不能从中断处理程序或下半部调用)。 alloc_inode 该方法由alloc_inode()调用，为结构inode分配内存并对其进行初始化。如果未定义此函数，则分配一个简单的struct inode。通常，alloc_inode 会被用来分配一个更大的结构，其中包含一个struct inode嵌入其中。 destroy_inode destroy_inode()调用这个方法来释放分配给结构inode的资源。只有在定义了-\u003ealloc_inode时才需要它，它只是简单地撤销-\u003ealloc_inode所做的任何事情。 dirty_inode 当一个inode被标记为dirty时，VFS会调用这个方法。这是专门针对被标记为dirty的inode本身，而不是它的数据。如果fdatasync()需要持久化更新，则I_DIRTY_DATASYNC将在flags参数中设置。 write_inode 当VFS需要将一个inode写入磁盘时，调用此方法。第二个参数表示写是否应该是同步的，并不是所有的文件系统都检查这个标志。 drop_inode 在删除对inode的最后一次访问时调用，并保持inode-\u003ei_lock自旋锁。 此方法应该是NULL(普通UNIX文件系统语义)或generic_delete_inode(对于不希望缓存inode的文件系统-导致无论i_nlink的值如何，总是调用delete_inode) generic_delete_inode()行为相当于在put_inode()情况下使用force_delete的旧实践，但不具有force_delete()方法所具有的竞争。 delete_inode 当VFS想要删除一个inode时调用 put_super 当VFS希望释放超级块(即卸载)时调用。在超级块锁被持有时调用 sync_fs 当VFS写入与超级块关联的所有脏数据时调用。第二个参数指示方法是否应该等待直到写操作完成。可选的。 freeze_fs 当VFS锁定文件系统并强制其进入一致状态时调用。该方法目前由逻辑卷管理器(LVM)使用。 unfreeze_fs 当VFS解锁文件系统并使其重新可写时调用。 statfs 当VFS需要获取文件系统统计信息时调用。 remount_fs 当重新装载文件系统时调用。这是在内核锁被持有时调用的 clear_inode 调用，则VFS清除该inode。可选 umount_begin 当VFS卸载文件系统时调用。 show_options 由VFS调用，以显示/proc//mounts。(参见“安装选项”一节) quota_read 调用VFS来读取文件系统配额文件。 quota_write 调用VFS来写入文件系统的配额文件。 nr_cached_objects 由sb缓存收缩函数为文件系统调用，以返回它所包含的可释放缓存对象的数量。可选的。 free_cache_objects 由sb缓存收缩函数为文件系统调用，以扫描指定的尝试释放对象的数量。可选，但任何实现此方法的文件系统还需要实现-\u003enr_cached_objects才能正确调用它。 我们无法处理文件系统可能遇到的任何错误，因此返回类型为void。如果VM尝试在GFP_NOFS条件下回收，则永远不会调用该方法，该方法本身不需要处理这种情况。 实现必须包括已完成的任何扫描循环内的条件重调度调用。这使得VFS可以确定适当的扫描批处理大小，而不必担心实现是否会由于大的扫描批处理大小而导致延迟问题。 设置inode的人负责填充i_op字段。这是一个指向struct inode_operations的指针，该指针描述了可以在单个inode上执行的方法。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct xattr_handlers 在支持扩展属性(xattrs)的文件系统上，s_xattr超级块字段指向一个以null结尾的xattr处理程序数组。扩展属性是 key:value 对。 name 指示处理程序匹配具有指定名称的属性(例如system.posix_acl_access);prefix字段必须为NULL。 prefix 指示处理程序匹配所有具有指定名称前缀的属性(如“user.”);名称字段必须为NULL。 list 确定是否应该为特定dentry列出与这个xattr处理程序匹配的属性。用于一些listxattr实现，如generic_listxattr。 get 由VFS调用以获取特定扩展属性的值。该方法由getxattr(2)系统调用调用。 set 由VFS调用，以设置特定扩展属性的值。当新值为NULL时，调用该函数以删除特定的扩展属性。该方法由setxattr(2)和removexattr(2)系统调用调用。 当文件系统的xattr处理程序与指定的属性名不匹配或者文件系统不支持扩展属性时，所有*xattr(2)系统调用将返回-EOPNOTSUPP。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:2","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"inode 对象 inode对象表示文件系统中的一个对象 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct inode_operations 这描述了VFS如何操作文件系统中的inode。在2.6.22内核中，定义了以下成员: struct inode_operations { int (*create) (struct user_namespace *, struct inode *,struct dentry *, umode_t, bool); struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int); int (*link) (struct dentry *,struct inode *,struct dentry *); int (*unlink) (struct inode *,struct dentry *); int (*symlink) (struct user_namespace *, struct inode *,struct dentry *,const char *); int (*mkdir) (struct user_namespace *, struct inode *,struct dentry *,umode_t); int (*rmdir) (struct inode *,struct dentry *); int (*mknod) (struct user_namespace *, struct inode *,struct dentry *,umode_t,dev_t); int (*rename) (struct user_namespace *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int); int (*readlink) (struct dentry *, char __user *,int); const char *(*get_link) (struct dentry *, struct inode *, struct delayed_call *); int (*permission) (struct user_namespace *, struct inode *, int); struct posix_acl * (*get_acl)(struct inode *, int, bool); int (*setattr) (struct user_namespace *, struct dentry *, struct iattr *); int (*getattr) (struct user_namespace *, const struct path *, struct kstat *, u32, unsigned int); ssize_t (*listxattr) (struct dentry *, char *, size_t); void (*update_time)(struct inode *, struct timespec *, int); int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned open_flag, umode_t create_mode); int (*tmpfile) (struct user_namespace *, struct inode *, struct dentry *, umode_t); int (*set_acl)(struct user_namespace *, struct inode *, struct posix_acl *, int); int (*fileattr_set)(struct user_namespace *mnt_userns, struct dentry *dentry, struct fileattr *fa); int (*fileattr_get)(struct dentry *dentry, struct fileattr *fa); }; 同样，调用所有方法时不会持有任何锁，除非另有说明。 create 由open(2)和create(2)系统调用调用。只有在支持常规文件时才需要。你得到的dentry不应该有一个inode(即，它应该是一个负dentry)。在这里，您可能会使用dentry和新创建的inode调用d_instantiate() lookup 当VFS需要在父目录中查找一个inode时调用。要查找的名字在dentry中找到。这个方法必须调用d_add()来将找到的inode插入dentry。inode结构中的“i_count”字段应该递增。如果指定的inode不存在，则应该在dentry中插入一个NULL inode(这称为负dentry)。从这个例程返回错误代码必须只在真正发生错误时才可以，否则使用create(2)、mknod(2)、mkdir(2)等系统调用创建索引节点将会失败。如果你希望重载dentry方法，那么你应该初始化dentry中的“d_dop”字段;这是一个指向结构体“dentry_operations”的指针。在保存目录inode信号量的情况下调用此方法 link 由link(2)系统调用调用。只有在支持硬链接时才需要。您可能需要调用d_instantiate()，就像在create()方法中那样 unlink symlink 由symlink(2)系统调用调用。只有在希望支持符号链接时才需要。您可能需要调用d_instantiate()，就像在create()方法中那样 mkdir rmdir mknod 由mknod(2)系统调用来创建一个设备(char, block) inode或一个命名管道(FIFO)或套接字。只有在希望支持创建这些类型的索引节点时才需要。您可能需要调用d_instantiate()，就像在create()方法中那样 rename 由rename(2)系统调用调用，重命名对象，使其具有由第二个inode和dentry提供的父节点和名称。对于任何不支持或未知的标志，文件系统必须返回-EINVAL。目前实现了以下标志: (1) RENAME_NOREPLACE:该标志表示如果重命名目标存在，重命名将失败，使用-EEXIST代替目标。VFS已经检查是否存在，因此对于本地文件系统，RENAME_NOREPLACE实现等价于普通重命名。 (2) RENAME_EXCHANGE: exchange源和目标。必须存在;这由VFS检查。与普通重命名不同，源和目标可能具有不同的类型。 get_link 由VFS调用，以跟随到它所指向的inode的符号链接。只有在希望支持符号链接时才需要。这个方法返回要遍历的符号链接体(并可能使用nd_jump_link()重置当前位置)。如果在inode消失之前，主体不会消失，那么其他东西就不需要了;如果需要以其他方式固定它，通过让get_link(…，…，done)执行set_delayed_call(done, destructor, argument)来安排它的释放。在这种情况下，一旦VFS处理完您返回的函数体，就会调用estructor(argument)。可以在RCU模式下调用;由NULL dentry参数表示。如果请求不离开RCU模式就不能被处理，让它返回ERR_PTR(-ECHILD)。如果文件系统将符号链接目标存储在-\u003ei_link中，VFS可以直接使用它而不调用-\u003eget_link();但是，-\u003eget_link()仍然必须提供。—\u003ei_link必须在RCU宽限期后才能释放。 readlink 这现在只是readlink(2)在-\u003eget_link使用nd_jump_link()或object实际上不是符号链接的情况下使用的重载。通常文件系统应该只实现-\u003eget_link用于符号链接，readlink(2)将自动使用它。 permission 由VFS调用，以检查类posix文件系统上的访问权限。可以在rcu-walk模式下调用(mask \u0026 MAY_NOT_BLOCK)。如果在rcu-walk模式下，文件系统必须检查权限，而不能阻塞或存储到inode。如果遇到rcu-walk不能处理的情况，返回-ECHILD，它将在refwalk模式中再次被调用。 setattr getattr listxattr update_time atomic_open 对一个open的最后一个组件调用。使用这个可选的方法，文件系统可以在一个原子操作中查找、创建和打开文件。如果它想把实际打开留给调用者(例如，如果文件是一个符号链接、设备，或者只是文件系统不会原子打开的东西)，它可能通过返回finish_no_open(file, dentry)来发出信号。仅当最后一个组件为负数或需要查找时，才调用此方法。缓存的正向dentry仍然由f_op-\u003eopen()处理。如果文件已经创建，FMODE_CREATED标志应该设置在file-\u003ef_mode中。在O_EXCL的情况下，只有在文件不存在的情况下，该方法才会成功，因此FMODE_CREATED总是在成功时设置。 tmpfile 在O_TMPFILE open()的末尾调用。可选，相当于在给定目录中自动创建、打开和解链接文件。 fileattr_get 调用ioctl(FS_IO","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"地址空间对象(The Address Space Object) 地址空间对象用于对页缓存中的页进行分组和管理。它可以用来跟踪文件(或其他文件)中的页面，还可以跟踪文件各部分到进程地址空间的映射。 地址空间可以提供许多不同但相关的服务。这些方法包括通信内存压力、按地址查找页面以及跟踪标记为Dirty或Writeback的页面。 第一个可以单独用于其他的。VM可以尝试写入脏页以清除它们，也可以释放干净页以重用它们。为此，它可以在脏页面上调用-\u003ewritepage方法，在干净页面上调用-\u003ereleasepage方法，并设置pagprivate。没有PagePrivate和没有外部引用的干净页面将在不通知address_space的情况下被释放。 为了实现此功能，需要将页面放置在LRU上，并在使用页面时调用lru_cache_add和mark_page_active。 页面通常通过-\u003eindex保存在基数树索引中。该树维护每个页面的PG_Dirty和PG_Writeback状态信息，以便快速找到带有这两个标志的页面。 Dirty标记主要由mpage_writpages(默认的-\u003ewritpages方法)使用。它使用标记查找脏页并调用-\u003ewritepage。如果没有使用mpage_writepages(即地址提供了自己的-\u003ewritepages)，那么PAGECACHE_TAG_DIRTY标签几乎没有被使用。Write_inode_now和sync_inode使用它(通过__sync_single_inode)来检查-\u003ewritepages是否成功地写出了整个地址空间。 Writeback标记由filemap* wait*和sync_page*函数使用，通过filemap_fdatawait_range函数等待所有的Writeback完成。 address_space处理程序可以附加额外的信息到一个页面，通常使用’struct page‘中的’private‘字段。如果附加了这些信息，则应该设置PG_Private标志。这将导致各种VM例程对address_space处理程序进行额外调用来处理该数据。 地址空间充当存储和应用程序之间的中介。每次将整个页的数据读入地址空间，并通过复制页或对页进行内存映射的方式提供给应用程序。应用程序将数据写入地址空间，然后通常以整个页面的形式将数据写回存储，但是address_space可以更好地控制写大小。 read进程实际上只需要’readpage’。写过程更为复杂，使用write_begin/write_end或dirty_folio将数据写入address_space，使用writepage和writepage将数据回写到存储。 在地址空间中添加和删除页面由inode的i_mutex保护。 当数据写入一个页面时，应该设置PG_Dirty标志。它通常保持设置状态，直到writepage要求写入它。这应该清除PG_Dirty并设置PG_Writeback。它实际上可以在PG_Dirty被清除后的任何时候被写入。一旦知道它是安全的，就清除PG_Writeback。 Writeback利用writeback_control结构来指导操作。这为writepage和writpages操作提供了一些关于回写请求的性质和原因，以及在哪些约束条件下执行的信息。它还用于向调用者返回关于写页面或写页面请求结果的信息。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:8:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"处理回写期间的错误 大多数进行缓冲I/O的应用程序将定期调用文件同步调用(fsync、fdatasync、msync或sync_file_range)，以确保写入的数据已经到达后备存储。当回写过程中出现错误时，他们希望在文件同步请求时报告错误。在报告了一个请求的错误之后，对同一文件描述符的后续请求应该返回0，除非在上一次文件同步之后发生了进一步的回写错误。 理想情况下，内核只会在文件描述中报告错误，而这些文件描述的写操作后来又没有被写回。但是，通用的页面缓存基础设施不会跟踪已经污染每个单独页面的文件描述，因此不可能确定哪个文件描述符应该返回错误。 相反，内核中的通用回写错误跟踪基础设施解决了在错误发生时向fsync报告所有打开的文件描述的错误。在有多个写入器的情况下，所有写入器都会在后续的fsync中返回一个错误，即使通过特定文件描述符完成的所有写入都成功了(或者即使对该文件描述符根本没有写入)。 希望使用此基础结构的文件系统应该调用mapping_set_error，以便在发生错误时在address_space中记录错误。然后，在他们的-\u003efsync操作中从页面缓存写回数据后，他们应该调用file_check_and_advance_wb_err来确保struct file的错误游标已经前进到由备份设备发出的错误流中的正确点。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:9:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct address_space_operations 这描述了VFS如何操作文件到文件系统中页面缓存的映射。定义了以下成员: struct address_space_operations { int (*writepage)(struct page *page, struct writeback_control *wbc); int (*readpage)(struct file *, struct page *); int (*writepages)(struct address_space *, struct writeback_control *); bool (*dirty_folio)(struct address_space *, struct folio *); void (*readahead)(struct readahead_control *); int (*write_begin)(struct file *, struct address_space *mapping, loff_t pos, unsigned len, unsigned flags, struct page **pagep, void **fsdata); int (*write_end)(struct file *, struct address_space *mapping, loff_t pos, unsigned len, unsigned copied, struct page *page, void *fsdata); sector_t (*bmap)(struct address_space *, sector_t); void (*invalidate_folio) (struct folio *, size_t start, size_t len); int (*releasepage) (struct page *, int); void (*freepage)(struct page *); ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter); /* isolate a page for migration */ bool (*isolate_page) (struct page *, isolate_mode_t); /* migrate the contents of a page to the specified target */ int (*migratepage) (struct page *, struct page *); /* put migration-failed page back to right list */ void (*putback_page) (struct page *); int (*launder_folio) (struct folio *); bool (*is_partially_uptodate) (struct folio *, size_t from, size_t count); void (*is_dirty_writeback) (struct page *, bool *, bool *); int (*error_remove_page) (struct mapping *mapping, struct page *page); int (*swap_activate)(struct file *); int (*swap_deactivate)(struct file *); }; writepage 由VM调用，将脏页写入后备存储。这可能是由于数据完整性原因(即“同步”)，或为了释放内存(刷新)。这种差异可以从wbc-\u003esync_mode中看出。PG_Dirty标志已经清除，pagellocked为true。writepage应该启动writeout，应该设置PG_Writeback，并且应该确保在写操作完成时，页面是同步或异步解锁的。如果wbc-\u003esync_mode为WB_SYNC_NONE，如果出现问题，-\u003ewritepage处理起来不会太费劲；如果更容易的话，可以选择从映射中写出其他页面(例如由于内部依赖关系)。如果它选择不启动writeout，它应该返回AOP_WRITEPAGE_ACTIVATE，这样VM就不会一直调用该页上的-\u003ewritepage。 有关更多细节，请参阅文件“Locking”。 readpage 调用VM从后台存储读取页面。当readpage被调用时，该页面将被锁定，并且应该在读取完成后被解锁并标记为最新。如果-\u003ereadpage发现由于某些原因需要解锁页面，它可以这样做，然后返回AOP_TRUNCATED_PAGE。在这种情况下，页面将被重新定位并重新锁定，如果所有操作都成功，则将再次调用-\u003ereadpage。 writepages 由VM调用，以写出与address_space对象关联的页面。如果wbc-\u003esync_mode为WB_SYNC_ALL，则writeback_control将指定必须写入的页面范围。如果它是WB_SYNC_NONE，则给出一个nr_to_write，并且如果可能的话应该写入许多页。如果没有给出-\u003ewritpages，则使用mpage_writpages。这将从标记为DIRTY的地址空间中选择页面，并将它们传递给-\u003ewritepage。 dirty_folio VM调用，将对开本标记为dirty。如果地址空间将私有数据附加到一个 fifo，并且当 fifo 被污染时需要更新该数据，则特别需要这样做。例如，当内存映射页被修改时，就会调用这个函数。如果定义了，它应该在i_pages中设置folio dirty标志和PAGECACHE_TAG_DIRTY搜索标记。 readahead 由VM调用，以读取与address_space对象关联的页。在页缓存中，页是连续的，并且被锁定。实现应该在启动每个页面的I/O后减少页面引用计数。通常，该页面将由I/O完成处理程序解锁。页面集被分为一些同步页面和一些异步页面，rac-\u003era-\u003easync_size给出了异步页面的数量。文件系统应该尝试读取所有同步页面，但可能在到达异步页面时决定停止。如果它决定停止尝试I/O，它可以简单地返回。调用者将从地址空间中删除剩余的页，解锁它们并减小页引用计数。如果I/O成功完成，设置PageUptodate。在任何页面上设置PageError都将被忽略;如果发生I/O错误，只需解锁页面。 write_begin write_end bmap invalidate_folio releasepage freepage direct_IO isolate_page migrate_page putback_page launder_folio is_partially_uptodate is_dirty_writeback error_remove_page swap_activate swap_deactivate ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:9:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"File 对象 文件对象表示进程打开的文件。在POSIX术语中，这也称为“打开文件描述”。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:10:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct file_operations 这描述了VFS如何操作打开的文件。在4.18内核中，定义了以下成员: struct file_operations { struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iopoll)(struct kiocb *kiocb, bool spin); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); __poll_t (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f); #ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *); #endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, loff_t len, unsigned int remap_flags); int (*fadvise)(struct file *, loff_t, loff_t, int); }; 同样，调用所有方法时不会持有任何锁，除非另有说明。 llseek read read_iter write write_iter iopoll iterate iterate_shared poll unlocked_ioctl compat_ioctl mmap open flush release fsync fasync lock get_unmapped_area check_flags flock splice_write splice_read setlease fallocate copy_file_range remap_file_range fadvise 注意，文件操作是由inode所在的特定文件系统实现的。当打开一个设备节点(特殊字符或块)时，大多数文件系统将调用VFS中的特殊支持例程，它将定位所需的设备驱动程序信息。这些支持例程将文件系统文件操作替换为设备驱动程序的操作，然后继续为文件调用新的open()方法。这就是在文件系统中打开设备文件最终如何调用设备驱动程序open()方法的。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:10:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"目录条目缓存(dcache) ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct dentry_operations 这描述了文件系统如何重载标准dentry操作。dentry和dcache是VFS和各个文件系统实现的域。设备驱动程序在这里没有什么用。这些方法可以设置为NULL，因为它们要么是可选的，要么VFS使用默认值。在2.6.22内核中，定义了以下成员: struct dentry_operations { int (*d_revalidate)(struct dentry *, unsigned int); int (*d_weak_revalidate)(struct dentry *, unsigned int); int (*d_hash)(const struct dentry *, struct qstr *); int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *); int (*d_delete)(const struct dentry *); int (*d_init)(struct dentry *); void (*d_release)(struct dentry *); void (*d_iput)(struct dentry *, struct inode *); char *(*d_dname)(struct dentry *, char *, int); struct vfsmount *(*d_automount)(struct path *); int (*d_manage)(const struct path *, bool); struct dentry *(*d_real)(struct dentry *, const struct inode *); }; d_revalidate _weak_revalidate d_hash d_compare d_delete d_init d_release d_iput d_dname d_automount d_manage d_real 每个dentry都有一个指向其父dentry的指针，以及子dentry的散列列表。子dentry基本上就像目录中的文件。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"目录条目缓存API(Directory Entry Cache API) 定义了许多允许文件系统操作dentry的函数: dget 为现有的dentry打开一个新的句柄(这只是增加了使用计数) dput 关闭dentry的句柄(减少使用计数)。如果使用计数下降到0, dentry仍然在其父散列中，则调用\"d_delete“方法来检查是否应该缓存它。如果它不应该被缓存，或者dentry没有被散列，它就会被删除。否则，缓存的dentry将被放入LRU列表中，在内存不足时回收。 d_drop 这将从其父哈希列表中解算dentry。如果dentry的使用计数下降到0，则对dput()的后续调用将释放该dentry d_delete 删除一个dentry。如果没有对dentry的其他开放引用，则dentry被转换为负dentry(调用d_iput()方法)。如果有其他引用，则调用d_drop() d_add 添加一个dentry到它的父哈希列表，然后调用d_instantiate() d_instantiate 将dentry添加到inode的别名散列列表中，并更新“d_inode”成员。inode结构中的“i_count”成员应该设置/增加。如果inode指针为NULL, dentry称为“负dentry”。当为现有的负dentry创建一个inode时，通常会调用这个函数 d_lookup 它从dcache哈希表中查找指定名称的子元素。如果找到，引用计数将增加并返回dentry。调用者在使用完dentry后必须使用dput()来释放它。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:2","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"挂载操作(Mount Options) ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"解析挂载配置(Parsing options) 在挂载和重新挂载时，将向文件系统传递一个字符串，其中包含以逗号分隔的挂载选项列表。选项可以有以下两种形式:option 和 option=value \u003clinux/parser.h\u003e头文件定义了一个API来帮助解析这些选项。有很多关于如何在现有文件系统中使用它的示例。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"显示挂载配置(Showing options) 如果文件系统接受挂载选项，它必须定义show_options()来显示所有当前活动的选项。规则是: 选项必须显示哪些不是默认值，或者它们的值与默认值不同 选项可以显示为默认启用或具有默认值 仅在装入帮助程序和内核之间内部使用的选项(如文件描述符)，或者仅在装入过程中起作用的选项(如控制日志创建的选项)不受上述规则的约束。 使用上述规则的根本原因是确保可以根据在/proc/mounts.conf. 中找到的信息准确地复制一个挂载(例如，卸载和重新挂载) 5.x 内核没找到 /proc/mounts.conf ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:2","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"linux虚拟文件系统概述 linux虚拟文件系统概述 ","date":"2022-05-18","objectID":"/2022/05/0000-linux%E5%86%85%E6%A0%B8/:1:0","tags":["linux","kernel","文件系统","filesystem"],"title":"Linux内核","uri":"/2022/05/0000-linux%E5%86%85%E6%A0%B8/"},{"categories":["C"],"content":"C语言 C是一种通用的、命令式的计算机编程语言，支持结构化编程、词法变量作用域和递归，而静态类型系统可以防止许多意想不到的操作。通过设计，C提供了有效地映射到典型机器指令的构造，因此它在以前用汇编语言编写的应用程序中得到了持久的使用，包括操作系统，以及从超级计算机到嵌入式系统的各种应用程序软件。 尽管具有低级功能，但该语言的设计初衷是鼓励跨平台编程。一个符合标准的、可移植编写的C程序可以用于各种各样的计算机平台和操作系统，只需对其源代码进行很少的更改。从嵌入式微控制器到超级计算机，该语言已经在非常广泛的平台上可用。 C语言最初是由Dennis Ritchie于1969年至1973年在贝尔实验室开发的，用于重新实现Unix操作系统。它已经成为有史以来使用最广泛的编程语言之一，来自不同供应商的C编译器可用于大多数现有的计算机架构和操作系统。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"C编译器 GCC, GNU 编译器 clang, 是为LLVM项目提供了C语言家族(C, c++, Objective C/c++, OpenCL, CUDA和RenderScript)的编译器 MSCV, 微软C/C++编译器 gcc 编译器 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"编译器C版本支持 编译器不一定完全支持 C 所有特性，同时编译器也可能通过参数支持一些 C 标准没有的特性，使用时候具体参看 C编译器和对应版本说明。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"代码风格 GNU代码风格 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"C版本 版本 标准 发行时间 K\u0026E 无 1978-02-22 C89 ANSI X3.159-1989 1989-12-14 C90 ISO/IEC 9899:1990 1990-12-20 C95 ISO/IEC 9899/AMD1:1995 1995-03-30 C99 ISO/IEC 9899:1999 1999-12-16 C11 ISO/IEC 9899:2011 2011-12-15 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:4","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"hello world #include \u003cstdio.h\u003e int main(void) { puts(\"Hello, World\"); return 0; } 编译 gcc hello.c -o hello // 我们还可以使用警告选项-Wall -Wextra -Werror，这有助于识别可能导致程序失败或产生意外结果的问题 gcc -Wall -Wextra -Werror -o hello hello.c 对比 K\u0026R C 的Hello world #include \u003cstdio.h\u003e main() { printf(\"hello, world\\n\"); } 注意，在编写《The C programming language》的第一版(1978年)时，C编程语言还没有标准化，而且这个程序可能无法在大多数现代编译器上编译，除非它们被指示接受C90代码。 K\u0026R书中的第一个示例现在被认为质量很差，部分原因是它缺少main()的显式返回类型，部分原因是它缺少返回语句。 在C89中，main的类型默认为int，但K\u0026R示例不向环境返回定义的值。在C99和以后的标准中，返回类型是必需的，但是省略main的返回语句(而且只有main)是安全的，因为C99 5.1.2.2.3引入了一个特殊情况—它相当于返回0，表示成功。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:5","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"字符类型和转换 从流中读取字符类型 #include \u003cctype.h\u003e #include \u003cstdio.h\u003e typedef struct { size_t space; size_t alnum; size_t punct; } chartypes; chartypes classify(FILE *f) { chartypes types = { 0, 0, 0 }; int ch; while ((ch = fgetc(f)) != EOF) { types.space += !!isspace(ch); types.alnum += !!isalnum(ch); types.punct += !!ispunct(ch); } return types; } classify函数从流中读取字符并统计空格、字母数字和标点符号的数量。它需要注意以下几个问题： 当从流中读取一个字符时，结果被保存为int，因为读取EOF(文件结束标记)和具有相同位模式的字符之间会有歧义。 classify函数希望它们的参数可以表示为unsigned char，或者EOF宏的值。因为这正是fgetc返回的，所以这里不需要转换。 字符分类函数的返回值只区分零(false)和非零(true)。为了计算字符分类出现的次数，需要将该值转换为1或0，这可以通过双重否定实现 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:2:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"C标准库 – ctype.h int c = 'A'; isalpha(c); /* Checks if c is alphabetic (A-Z, a-z), returns non-zero here. */ isalnum(c); /* Checks if c is alphanumeric (A-Z, a-z, 0-9), returns non-zero here. */ iscntrl(c); /* Checks is c is a control character (0x00-0x1F, 0x7F), returns zero here. */ isdigit(c); /* Checks if c is a digit (0-9), returns zero here. */ isgraph(c); /* Checks if c has a graphical representation (any printing character except space), returns non-zero here. */ islower(c); /* Checks if c is a lower-case letter (a-z), returns zero here. */ isprint(c); /* Checks if c is any printable character (including space), returns non-zero here. */ ispunct(c); /* Checks if c is a punctuation character, returns zero here. */ isspace(c); /* Checks if c is a white-space character, returns zero here. */ isupper(c); /* Checks if c is an upper-case letter (A-Z), returns non-zero here. */ isxdigit(c); /* Checks if c is a hexadecimal digit (A-F, a-f, 0-9), returns non-zero here.*/ // C99 isblank(c); /* Checks if c is a blank character (space or tab), returns non-zero here. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:2:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"别名和有效类型 这里的别名是英文直译，可以理解为我们常见的类型转换 别名是指向同一个对象的两个指针a和b的属性，即a == b。 C使用数据对象的有效类型来确定可以对该对象执行哪些操作。具体来说，有效类型用于确定两个指针是否可以相互别名。 C语言的严格别名规则是指编译器可能假定哪些对象会(或不会)别名。对于数据指针，你应该记住两条经验法则: 除非另有说明，具有相同基类型的两个指针可以别名。 两个具有不同基类型的指针不能别名，除非两个类型中至少有一个是字符类型。 这里的基本类型指的是抛开类型限制，比如const，比如：double* a 和 const double* b，编译器通常必须假设对*a的修改可能会改变*b。 违反第二条规则会有灾难性后果，所以为了减少问题发生概率，除非源或目标类型为void，否则具有不同基类型的指针之间的所有指针转换都必须是显式的。 这里必须做的类型转换不包括添加限定符 const ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:3:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 不能通过非字符类型访问字符类型 int main(void) { char a[100]; int* b = ( int* )\u0026a; *b = 1; static char c[100]; b = ( int* )\u0026c; *b = 2; _Thread_local char d[100]; b = ( int* )\u0026d; *b = 3; } 在例子中，一个char数组被重新解释为int类型，并且每次对int指针b解引用时，该行为都是未定义的。因为它违反了“有效类型”规则，具有有效类型的数据对象不能通过非字符类型的其他类型访问。因为这里的另一个类型是int，所以这是不允许的。 即使内存对齐和指针大小是已知的，这也不能免除此规则，行为仍然是未定义的。 这特别意味着，在标准C语言中不可能保留可以通过不同类型的指针使用的字符类型的缓冲区对象，因为您将使用由malloc或类似函数接收的缓冲区。 实现上述目标的正确方法是使用 union typedef union bufType bufType; union bufType { char c[sizeof(int[25])]; int i[25]; }; int main( void ) { bufType a = { .c = { 0 } }; // reserve a buffer and initialize int* b = a.i; // no cast necessary *b = 1; static bufType a = { .c = { 0 } }; int* b = a.i; *b = 2; _Thread_local bufType a = { .c = { 0 } }; int* b = a.i; *b = 3; } 这里，union确保编译器从一开始就知道缓冲区可以通过不同的方式访问。这样做的另一个好处是，现在缓冲区有一个a.i，它已经是int类型，不需要进行指针转换。 有效类型 数据对象的有效类型是与之关联的最后一个类型信息(如果有的话)。 // 有效类型是 uint32_t uint32_t a = 0.0; // *pa的有效类型是 uint32_t uint32_t* pa = \u0026a; // 目前 *q 并不是一个有效类型 void* q = malloc(sizeof uint32_t); // 这里的 q 仍然不是一个有效类型，因为还没有数据写入 uint32_t* qb = q; // *qb 目前是一个有效类型 uint32_t，因为一个 uint32_t 值被写入了 *qb = 37; // r 指向的对象尽管已经初始化了，但还不是有效类型 void* r = calloc(1, sizeof uint32_t); // 不是有效类型 uint32_t* rc = r; // *rc 已经是一个有效类型 uint32_t 因为一个值从它那读取了 // 因为使用 calloc 初始化了，所以读操作是合理的 // 此时尽管我们没有写它的值，但是 *rc 已经是一个有效类型了 uint32_t c = *rc; void* s = malloc(sizeof uint32_t); // 因为有 uint32_t 类型复制到指定对象里，所以 *s 已经是有效类型了 memcpy(s, r, sizeof uint32_t); 严重违反类型转换规则 在下面的代码中，让我们假设float和uint32_t有相同的内存大小 void fun(uint32_t* u, float* f) { float a = *f, *u = 22; float b = *f; print(\"%g should equal %g\\n\", a, b); } u 和 f 具有不同的基类型，因此编译器可以假定它们指向不同的对象。 在a和b的两次初始化之间*f不可能发生变化，因此编译器可能会优化代码，使其等价于: void fun(uint32_t* u, float* f) { float a = *f, *u = 22; print(\"%g should equal %g\\n\", a, a); } 即*f的二次加载操作可以完全优化出来。 如果这样调用: float fval = 4; uint32_t uval = 77; fun(\u0026uval, \u0026fval); // 输出: 4 should equal 4 但是如果这样调用： float fval = 4; uint32_t* up = (uint32_t*)\u0026fval; fun(up, \u0026fval); 我们违反了严格的混叠规则。然后这种行为就变得没有定义了。如果编译器优化了第二次访问，输出可能与上面一样，或者完全不同，从而使程序最终处于完全不可靠的状态。 限制条件 如果有两个相同类型的指针实参，编译器就不能做任何假设，必须总是假设对*e的修改可能会改变*f: void fun(float* e, float* f) { float a = *f *e = 22; float b = *f; print(\"is %g equal to %g?\\n\", a, b); } float fval = 4; float eval = 77; fun(\u0026eval, \u0026fval); 正常输出是 is 4 equal to 4? 如果我们通过一些外部信息知道e和f永远不会指向相同的数据对象，那么这可能是低效的。我们可以通过给指针形参添加限制限定符来反映这一点: void fan(float*restrict e, float*restrict f) { float a = *f *e = 22; float b = *f; print(\"is %g equal to %g?\\n\", a, b); } 那么编译器可能总是假设e和f指向不同的对象。 改变字节 一旦对象具有有效类型，就不应该试图通过其他类型的指针修改它，除非其他类型是字符类型、char、signed char或 unsigned char。 #include \u003cinttypes.h\u003e #include \u003cstdio.h\u003e int main(void) { uint32_t a = 57; // conversion from incompatible types needs a cast ! unsigned char* ap = (unsigned char*)\u0026a; for (size_t i = 0; i \u003c sizeof a; ++i) { /* set each byte of a to 42 */ ap[i] = 42; } printf(\"a now has value %\" PRIu32 \"\\n\", a); } 打印结果: a now has value 707406378 正常是因为： 使用unsigned char类型访问单个字节，因此每次修改都有很好的定义。 对象的两个视图，通过别名a和*ap，但由于ap是指向字符类型的指针，因此不适用严格的别名规则。因此，编译器必须假设a的值可能在for循环中被更改了。a的修改值必须从已更改的字节构造。 a的类型的uint32_t没有填充位。其表示的所有位都为值计数，这里是707406378，并且不能有陷阱表示。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:3:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数组 数组是派生数据类型，表示另一种类型的值(“元素”)的有序集合。C语言中的大多数数组都有固定数量的任意一种类型的元素，其表示形式是连续地将元素存储在内存中，没有间隔或填充。C允许多维数组，它的元素是其他数组，也可以是指针数组。 C支持动态分配数组，其大小在运行时确定。C99及以后版本支持可变长度数组或VLAs。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 type name[length]; int arr[10] = {0}; // 初始化所有元素为0 int arr[10] = {42}; // 初始化第一个元素为42，其它为0 int arr[] = {4, 2, 3, 1}; arr[n] = value; value = arr[n]; ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"为什么需要数组 数组提供了一种将对象组织成具有自身意义的聚合的方法。例如，C字符串是字符数组(chars)，而像“Hello, World!”这样的字符串具有聚合的意义，它不是单个字符固有的。类似地，数组通常用于表示数学向量和矩阵，以及多种类型的列表。此外，如果没有对元素进行分组的方法，就需要单独处理每个元素，比如通过单独的变量。它不仅笨重，而且不能方便地容纳不同长度的集合。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"大多数上下文数组隐式转为指针 除了 sizeof 操作，使用 _Alignof 操作、\u0026操作、迭代字符串，它都会转换为第一个元素首地址。 这个隐式转换与数组下标操作符([])的定义紧密耦合:表达式arr[idx]被定义为等价于*(arr + idx)。此外，由于指针算法是可交换的，*(arr + idx)也等价于*(idx + arr)，而*(idx + arr)又等价于idx[arr]。如果idx或arr是指针(或数组，可衰变为指针)，另一个是整数，且整数是指针所指向数组的有效索引，则所有这些表达式都是有效的，计算结果相同。 作为一个特例，观察\u0026(arr[0])等价于\u0026*(arr + 0)，简化为arr。所有的这些表达式都是可互换的(attr最衰减到指针)。这只是再次表示数组衰变为指向其第一个元素的指针。 相反，如果地址操作符应用于类型为T[N]的数组(即\u0026arr)，则结果类型为T (*)[N]并指向整个数组。这与指向数组第一个元素的指针不同，至少在指针算术方面是不同的，指针是根据指向类型的大小定义的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"函数参数不是数组 void foo(int a[], int n); void foo(int *a, int n); 尽管foo的第一个声明对参数a使用了类似数组的语法，但这种语法用于声明一个函数参数，将该参数声明为指向数组元素类型的指针。因此，foo()的第二个签名在语义上与第一个签名相同。这对应于数组值的衰减指针出现作为一个函数调用的参数,这样,如果一个变量和一个函数参数声明相同的数组类型,变量的值是适用于一个函数调用的参数与参数有关。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:4","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"特殊例子 特殊的初始化： int array[5] = { [2] = 5, [1] = 2, [4] = 9 }; /* array is {0, 2, 5, 0, 9} */ int array[] = { [3] = 8, [0] = 9 }; /* size is 4 */ 不允许声明零长度的数组 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:5","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"变长数组(C99/C11) 可变长度数组(简称VLA)是在C99中添加的，在C11中是可选的。它们与普通数组相同，但有一个重要的区别:在编译时不必知道长度。VLA具有自动存储期限。 size_t m = calc_length(); /* calculate array length at runtime */ int vla[m]; /* create array with calculated length */ 重要: VLA有潜在的危险。如果上面示例中的数组vla需要的堆栈空间大于可用空间，则堆栈将溢出。因此不建议使用VLA ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:6","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"清除数组内容 有时需要在初始化完成后将数组设置为零。 #include \u003cstdlib.h\u003e /* for EXIT_SUCCESS */ #define ARRLEN (10) int main(void) { int array[ARRLEN]; /* Allocated but not initialised, as not defined static or global. */ size_t i; for(i = 0; i \u003c ARRLEN; ++i) { array[i] = 0; } return EXIT_SUCCESS; } 或者使用 memset ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:7","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数组长度 sizeof(array) / sizeof(array[0]) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:8","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"设置数组值 array[4] = 5; 4[array] = 5; *(4 + array) = 5; // 获取值 val = 4[array]; ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:9","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"定义数组并访问元素 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:10","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"堆上动态分配空间并初始化数组 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:11","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"迭代数组 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:12","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"多维数组 type name[size1][size2]...[sizeN]; int arr[5][10][4]; // 初始化 3 维数组 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:13","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"断言 在软件遇到断言时，提出的条件必须为真。最常见的是在执行时进行验证的简单断言。静态断言是在编译时检查的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 assert(expression); static_assert(expression, message); _Static_assert(expression, message); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"参数 参数 描述 expression 表达式，判断条件是否满足 message 诊断消息中包含的字符串字面值 assert 和 static_assert 都在 assert.h 中定义。 assert的定义依赖于宏NDEBUG，该宏没有被标准库定义。如果定义了NDEBUG，则assert为无操作: #ifdef NDEBUG # define assert(condition) ((void) 0) #else # define assert(condition) /* implementation defined */ #endif 使用 assert 会导致程序退出，生产环境中不要用 assert，最好使用条件判断 static_assert扩展为_Static_assert，这是一个关键字。condition 在编译时被检查，因此condition必须是一个常量表达式。没有必要在开发和生产之间以不同的方式处理这个问题 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 前置条件和后置条件 断言的一个用例是前置条件和后置条件。这对于保持不变和契约式设计非常有用。例如，长度总是0或正的，因此该函数必须返回0或正的值。 int length2 (int *a, int count) { int i, result = 0; /* Precondition: */ /* NULL is an invalid vector */ assert (a != NULL); /* Number of dimensions can not be negative.*/ assert (count \u003e= 0); /* Calculation */ for (i = 0; i \u003c count; ++i) { result = result + (a[i] * a[i]); } /* Postcondition: */ /* Resulting length can not be negative. */ assert (result \u003e= 0); return result; } 简单断言 #include \u003cstdio.h\u003e /* Uncomment to disable `assert()` */ /* #define NDEBUG */ #include \u003cassert.h\u003e int main(void) { int x = -1; assert(x \u003e= 0); printf(\"x = %d\\n\", x); return 0; } 运行输出: a.out: main.c:9: main: Assertion `x \u003e= 0' failed. 静态断言(C11) 静态断言用于在编译代码时检查条件是否为真。如果不是，则需要编译器发出错误消息并停止编译过程。 #include \u003cassert.h\u003e enum {N = 5}; _Static_assert(N == 5, \"N does not equal 5\"); static_assert(N \u003e 10, \"N is not greater than 10\"); /* compiler error */ 静态断言(c99) 在C11之前，没有对静态断言的直接支持。但是，在C99中，可以使用宏模拟静态断言，如果编译时条件为假，则会触发编译失败。与_Static_assert不同，第二个参数需要是适当名称，以便可以使用它创建变量名称。如果断言失败，则在编译器错误中可以看到变量名，因为该变量是在语法不正确的数组声明中使用的 #define STATIC_MSG(msg, l) STATIC_MSG2(msg, l) #define STATIC_MSG2(msg,l) on_line_##l##__##msg #define STATIC_ASSERT(x, msg) extern char STATIC_MSG(msg, __LINE__) [(x)?1:-1] enum { N = 5 }; STATIC_ASSERT(N == 5, N_must_equal_5); STATIC_ASSERT(N \u003e 5, N_must_be_greater_than_5); /* compile error */ 在C99之前，不能在块中的任意位置声明变量，因此在使用这个宏时必须非常谨慎，确保它只出现在变量声明有效的地方 断言不可能到达的位置(switch-case语法) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"原子(Atomics) Atomics作为C语言的一部分是自C11以来可用的可选特性。它们的目的是确保对在不同线程之间共享的变量的无竞争访问。如果没有原子限定，如果两个线程并发访问一个共享变量，那么它的状态将是未定义的。例如，一个自增操作(++)可以被拆分为几个汇编指令、一个读取指令、加法本身和一个存储指令。如果另一个线程要执行相同的操作，它们的两个指令序列可能会交织在一起，导致不一致的结果。 Types: 除数组类型外，所有对象类型都可以限定为 _Atomic Operators: 它们上的所有读-修改-写操作符都保证是原子的 Operations: 还有其他一些被指定为类型泛型函数的操作，例如atomic_compare_exchange。 Threads: 当它们被不同的线程访问时，对它们的访问保证不会产生数据竞争。 Signal handlers: 如果对原子类型的所有操作都是无状态的，则称为无锁类型。在这种情况下，它们还可以用于处理正常控制流和信号处理程序之间的状态变化。 只有一种数据类型保证是无锁的:atomic_flag。这是一种最小类型，其操作旨在映射到有效的测试和设置硬件指令。 在C11的线程接口中还有其他避免竞争条件的方法，特别是一个互斥类型mtx_t，它可以相互排除线程访问关键数据或代码的关键部分。如果原子不可用，则必须使用它们来防止竞争。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:6:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #ifdef __STDC_NO_ATOMICS__ # error this implementation needs atomics• #endif• #include \u003cstdatomic.h\u003e unsigned _Atomic counter = ATOMIC_VAR_INIT(0); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:6:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 原子和操作 可以在不同的线程之间并发地访问原子变量，而不需要创建竞争条件。 static unsigned _Atomic active = ATOMIC_VAR_INIT(0); int myThread(void* a) { ++active; // increment active race free // do something --active; // decrement active race free return 0; } 基类型允许的所有左值操作(修改对象的操作)都是允许的，不会导致访问它们的不同线程之间的竞争条件。 对原子对象的操作通常比普通的算术操作慢几个数量级。这也包括简单的加载或存储操作。所以你应该只在关键的任务中使用它们。 通常的算术运算和赋值，如a = a+1;实际上在a上有三个操作:首先是加载，然后是加法，最后是存储。只有操作a += 1;和++;是这样的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:6:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"位域 C语言中大多数变量的大小都是字节的整数。位域是结构的一部分，不一定占用整数字节;它们可以使用任意数量的比特。多个位域可以被打包到一个存储单元中。它们是标准C的一部分，但有许多方面是实现定义的。它们是C语言中最不可移植的部分之一。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 type-specifier identifier : size; ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"参数 参数 描述 type-specifier signed、unsigned、int 或 _Bool identifier 名字 size 字段中使用的位数 位字段的可移植类型只有signed、unsigned或_Bool。也可以使用纯int类型，但标准规定对于位域，说明符int是否指定与signed int相同的类型或与unsigned int相同的类型由实现定义。特定的实现可能允许其他整数类型，但使用它们是不可移植的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 位域 一个简单的位域可以用来描述可能包含特定位数的事物。 struct encoderPosition { unsigned int encoderCounts : 23; unsigned int encoderTurns : 4; unsigned int _reserved : 5; }; 在这个例子中，我们考虑一个编码器，它有23位单精度，4位描述多匝。当与输出与特定位数相关联的数据的硬件连接时，经常使用位域。另一个例子可能是与FPGA通信，FPGA以32位段的形式将数据写入内存，允许硬件读取: struct FPGAInfo { union { struct bits { unsigned int bulb1On : 1; unsigned int bulb2On : 1; unsigned int bulb1Off : 1; unsigned int bulb2Off : 1; unsigned int jetOn : 1; }; unsigned int data; }; }; 对于这个示例，我们展示了一个常用的构造，它能够访问单个位的数据，或者将数据包作为一个整体写入(模拟FPGA可能做的事情)。然后我们可以像这样访问比特: FPGAInfo fInfo; fInfo.data = 0xFF34F; if (fInfo.bits.bulb1On) { printf(\"Bulb 1 is on\\n\"); } 这是有效的，但根据C99标准6.7.2.1，第10项:单位内位域的分配顺序(高阶到低阶或低阶到高阶)是由实现定义的 在以这种方式定义位域时，需要注意字节序。因此，可能需要使用一个预处理器指令来检查机器的字节顺序。下面是一个例子: typedef union { struct bits { #if defined(WIN32) || defined(LITTLE_ENDIAN) uint8_t commFailure :1; uint8_t hardwareFailure :1; uint8_t _reserved :6; #else uint8_t _reserved :6; uint8_t hardwareFailure :1; uint8_t commFailure :1; #endif }; uint8_t data; } hardwareStatus; 使用位域作为小整数 #include \u003cstdio.h\u003e int main(void) { /* define a small bit-field that can hold values from 0 .. 7 */ struct { unsigned int uint3: 3; } small; /* extract the right 3 bits from a value */ unsigned int value = 255 - 2; /* Binary 11111101 */ small.uint3 = value; /* Binary 101 */ printf(\"%d\", small.uint3); /* This is in effect an infinite loop */ for (small.uint3 = 0; small.uint3 \u003c 8; small.uint3++) { printf(\"%d\\n\", small.uint3); } return 0; } 位域对齐 位域提供了声明小于字符宽度的结构域的能力。位域通过字节级或字级掩码实现。下面的示例产生一个8字节的结构。 struct C { short s; /* 2 bytes */ char c; /* 1 byte */ int bit1 : 1; /* 1 bit */ int nib : 4; /* 4 bits padded up to boundary of 8 bits. Thus 3 bits are padded */ int sept : 7; /* 7 Bits septet, padded up to boundary of 32 bits. */ }; 注释描述了一种可能的布局，但由于标准说可寻址存储单元的对齐方式未指定，所以也可能有其他布局。 未命名位域可以是任何大小，但不能初始化或引用它们。 不能给零宽度位域指定名称并将下一个字段与位域的数据类型定义的边界对齐。这是通过在位域之间填充位来实现的。 struct A的大小是1字节。 struct A { unsigned char c1 : 3; unsigned char c2 : 4; unsigned char c3 : 1; }; 在struct B中，第一个未命名位域跳过2位;c2之后的零宽度位域导致c3从字符边界开始(因此在c2和c3之间跳过3位。c4之后有3个填充位。因此，该结构的大小为2字节。 struct B { unsigned char c1 : 1; unsigned char : 2; /* Skips 2 bits in the layout */ unsigned char c2 : 2; unsigned char : 0; /* Causes padding up to next container boundary */ unsigned char c3 : 4; unsigned char c4 : 1; }; 什么时候使用位域 位域用于将多个变量组合成一个对象，类似于结构。这允许减少内存使用，在嵌入式环境中尤其有用 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"Boolean 要使用预定义的类型_Bool和头文件\u003cstdbool.h\u003e，必须使用C99/C11版本的C语言。为了避免编译器警告和可能的错误，只有在使用C89和该语言以前的版本时，才应该使用typedef/define示例。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:8:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:8:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"命令行参数 int main(int argc, char *argv[]) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:9:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:9:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"注释 /* ... */ // c99 及其之后 // ... ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:10:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"常见的C编程习惯用法和开发人员实践 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:11:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"比较 // 不好 if ( i == 2) //Bad-way { doSomething; } // 好 if( 2 == i) //Good-way { doSomething; } ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:11:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"常见陷阱 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:12:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"编译 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:13:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"复合类型 像字符串字面量一样，const限定的复合字面量可以放在只读内存中，甚至可以共享。例如, (const char []) { \"abc\" } == \"abc\" ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:14:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 (type) { initializer-list } ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:14:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"头文件包含 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:15:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数据类型 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:16:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"声明与定义 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:17:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"错误处理 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:18:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #include \u003cerrno.h\u003e• int errno; /* implementation defined */• #include \u003cstring.h\u003e• char *strerror(int errnum);• #include \u003cstdio.h\u003e• void perror(const char *s); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:18:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"文件和 I/O 流 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:19:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #include \u003cstdio.h\u003e /* Include this to use any of the following sections */• FILE *fopen(const char *path, const char *mode); /* Open a stream on the file at path with the specified mode */ FILE *freopen(const char *path, const char *mode, FILE *stream); /* Re-open an existing stream on the file at path with the specified mode */ int fclose(FILE *stream); /* Close an opened stream */• size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); /* Read at most nmemb elements of size bytes each from the stream and write them in ptr. Returns the number of read elements. */ size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); /* Write nmemb elements of size bytes each from ptr to the stream. Returns the number of written elements. */ int fseek(FILE *stream, long offset, int whence); /* Set the cursor of the stream to offset, relative to the offset told by whence, and returns 0 if it succeeded. */ long ftell(FILE *stream); /* Return the offset of the current cursor position from the beginning of the stream. */ void rewind(FILE *stream); /* Set the cursor position to the beginning of the file. */• int fprintf(FILE *fout, const char *fmt, ...); /* Writes printf format string on fout */• FILE *stdin; /* Standard input stream */• FILE *stdout; /* Standard output stream */• FILE *stderr; /* Standard error stream */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:19:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"格式化输入/输出 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:20:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"函数参数 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:21:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"函数指针 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:22:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 - `returnType (*name)(parameters);` - `typedef returnType (*name)(parameters);` - `typedef returnType Name(parameters);` Name *name; - `typedef returnType Name(parameters);` `typedef Name *NamePtr;` ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:22:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"使用 typedef ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:23:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"上下文指针 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:24:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"标识符作用域 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:25:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"实现定义的行为 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:26:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"隐式转换和显示转换 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:27:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"初始化 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:28:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"内联汇编 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:29:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"内联 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:30:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"进程间通信(IPC) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:31:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"迭代语句/循环 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:32:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 /* all versions */• for ([expression]; [expression]; [expression]) one_statement• for ([expression]; [expression]; [expression]) { zero or several statements }• while (expression) one_statement• while (expression) { zero or several statements }• do one_statement while (expression);• do { one or more statements } while (expression);• // since C99 in addition to the form above• for (declaration; [expression]; [expression]) one_statement;• for (declaration; [expression]; [expression]) { zero or several statements } ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:32:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"跳转 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:33:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 return val; /* Returns from the current function. val can be a value of any type that is converts to the function's return type. */ return; /* Returns from the current void-function. */• break; /* Unconditionally jumps beyond the end (\"breaks out\") of an Iteration Statement (loop) or out of the innermost switch statement. */ continue; /* Unconditionally jumps to the beginning of an Iteration Statement (loop). */• goto LBL; /* Jumps to label LBL. */• LBL: statement /* any statement in the same function. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:33:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"链表 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:34:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数字、字符和字符串的字面值 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:35:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"内存管理 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:36:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 void *aligned_alloc(size_t alignment, size_t size); /* Only since C11 */• void *calloc(size_t nelements, size_t size);• void free(void *ptr);• void *malloc(size_t size);• void *realloc(void *ptr, size_t size);• void *alloca(size_t size); /* from alloca.h, not standard, not portable, dangerous. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:36:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"多字字符序列 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:37:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"多线程 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:38:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 thrd_t // Implementation-defined complete object type identifying a thread• int thrd_create( thrd_t *thr, thrd_start_t func, void *arg ); // Creates a thread• int thrd_equal( thrd_t thr0, thrd_t thr1 ); // Check if arguments refer to the same thread• thr_t thrd_current(void); // Returns identifier of the thread that calls it• int thrd_sleep( const struct timespec *duration, struct timespec *remaining ); // Suspend call thread execution for at least a given time void thrd_yield(void); // Permit other threads to run instead of the thread that calls it• _Noreturn void thrd_exit( int res ); // Terminates the thread the thread that calls it• int thrd_detatch( thrd_t thr; // Detaches a given thread from the current environment• int thrd_join( thrd_t thr, int *res ); // Blocks the current thread until the given thread finishes ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:38:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"操作符 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:39:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 expr1 operator• operator expr2• expr1 operator expr2• expr1 ? expr2 : expr3 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:39:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"将 2 维数组传给函数 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:40:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"指针 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:41:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 \u003cData type\u003e *\u003cVariable name\u003e;• int *ptrToInt;• void *ptrToVoid; /* C89+ */• struct someStruct *ptrToStruct;• int **ptrToPtrToInt;• int arr[length]; int *ptrToFirstElem = arr; /* For \u003cC99 'length' needs to be a compile time constant, for \u003e=C11 it might need to be one. */ int *arrayOfPtrsToInt[length]; /* For \u003cC99 'length' needs to be a compile time constant, for \u003e=C11 it might need to be one. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:41:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"预处理器和宏 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:42:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"随机数生成 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:43:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 arc4random() (available on OS X and BSD)• random() (available on Linux)• drand48() (available on POSIX) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:43:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"条件 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:44:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"信号处理 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:45:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"标准数学 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:46:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"字符串 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:47:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"结构体 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:48:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"Structure Padding and Packing ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:49:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"测试框架 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:50:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"CppUTest #include \u003cCppUTest/CommandLineTestRunner.h\u003e #include \u003cCppUTest/TestHarness.h\u003e TEST_GROUP(Foo_Group) {} TEST(Foo_Group, Foo_TestOne) {} /* Test runner may be provided options, such ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:50:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"线程(原生) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:51:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #ifndef __STDC_NO_THREADS__• # include \u003cthreads.h\u003e• #endif• void call_once(once_flag *flag, void (*func)(void));• int cnd_broadcast(cnd_t *cond);• void cnd_destroy(cnd_t *cond);• int cnd_init(cnd_t *cond);• int cnd_signal(cnd_t *cond);• int cnd_timedwait(cnd_t *restrict cond, mtx_t *restrict mtx, const struct timespec *restrict ts); int cnd_wait(cnd_t *cond, mtx_t *mtx);• void mtx_destroy(mtx_t *mtx);• int mtx_init(mtx_t *mtx, int type);• int mtx_lock(mtx_t *mtx);• int mtx_timedlock(mtx_t *restrict mtx, const struct timespec *restrict ts);• int mtx_trylock(mtx_t *mtx);• int mtx_unlock(mtx_t *mtx);• int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);• thrd_t thrd_current(void);• int thrd_detach(thrd_t thr);• int thrd_equal(thrd_t thr0, thrd_t thr1);• _Noreturn void thrd_exit(int res);• int thrd_join(thrd_t thr, int *res);• int thrd_sleep(const struct timespec *duration, struct timespec* remaining);• void thrd_yield(void);• int tss_create(tss_t *key, tss_dtor_t dtor);• void tss_delete(tss_t key);• void *tss_get(tss_t key);• int tss_set(tss_t key, void *val); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:51:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"类型限定符 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:52:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"typedef ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:53:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"未定义类型 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:54:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"联合体 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:55:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"Valgrind Valgrind是一个调试工具，可用于诊断C程序中有关内存管理的错误。Valgrind可用于检测诸如无效指针使用等错误，包括超出已分配空间的写入或读取，或对free()进行无效调用。它还可以通过执行内存分析的函数来改进应用程序。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:56:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"变量参数 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:57:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"X-macros x -宏是一种基于预处理程序的技术，用于最小化重复代码和维护数据/代码的对应关系。基于一组公共数据的多个不同的宏展开可以通过单个主宏来表示整个组展开，该宏的替换文本由内部宏展开的序列组成，每个数据对应一个。内部宏通常被命名为X()，这就是该技术的名称。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:58:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["linux"],"content":"C 各个版本说明 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:0","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C 语言早期 最早由丹尼斯·里奇（Dennis Ritchie）为了在PDP-11电脑上运行的Unix系统所设计出来的编程语言 第一次发展在1969年到1973年之间。 在PDP-11出现后，丹尼斯·里奇与肯·汤普逊着手将Unix移植到PDP-11上 1973年，Unix操作系统的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上。 1975年C语言开始移植到其他机器上使用。史蒂芬·强生实现了一套“可移植编译器” ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:1","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"K\u0026R c 1978年，丹尼斯·里奇和布莱恩·柯林汉合作出版了《C程序设计语言》的第一版。 “K\u0026R C”（柯里C）。 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:2","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C89/C90 1989年，C语言被美国国家标准协会（ANSI）标准化，这个版本又称为C89 标准化的一个目的是扩展 K\u0026R C，增加了一些新特性。 1990年，国际标准化组织（ISO）规定国际标准的C语言 通过对 ANSI 标准的少量修改，最终制定了 ISO 9899:1990，又称为C90。 随后，ANSI亦接受国际标准C，并不再发展新的C标准。 注意: C89和C90是一回事，C89是由ANSI(American National Standards Institute)美国国家标准协会制定，C90 是由国际标准协会根据ANSI C89 制定。 C89/C90对K\u0026R C改进点 增加了真正的标准库 新的预处理命令与特性 函数原型允许在函数申明中指定参数类型 一些新的关键字，包括 const、volatile 与 signed 宽字符、宽字符串与多字节字符 对约定规则、声明和类型检查的许多小改动与澄清 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:3","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C99 1994年为C语言创建了一个新标准，但是只修正了一些C89标准中的细节和增加更多更广的国际字符集支持。 不过，这个标准引出了1999年ISO 9899:1999的发表。它通常被称为C99。 C99被ANSI于2000年3月采用。 C99新特性(部分) 支持不定长的数组，声明时使用 int a[var] 的形式。 变量声明不必放在语句块的开头，for 语句提倡写成 for(int i=0;i\u003c100;++i) 的形式 允许采用（type_name）{xx,xx,xx} 类似于 C++ 的构造函数的形式构造匿名的结构体。 除了已有的 __line__ __file__ 以外，增加了 __func__ 得到当前的函数名。 取消了函数返回类型默认为 int 的规定。 增加和修改了一些标准头文件(定义bool的、定义复数的、里增加了 struct tmx，对 struct tm 做了扩展。) ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:4","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C11 2011年12月8日，ISO正式发布了新的C语言的新标准C11，之前被称为C1X 官方名称为ISO/IEC 9899:2011 新的标准提高了对C++的兼容性，并增加了一些新的特性。 这些新特性包括泛型宏、多线程、带边界检查的函数、匿名结构等。 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:5","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C18 C18没有引入新的语言特性，只对C11进行了补充和修正 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:6","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++ 各个版本说明 1998年是C++标准委员会成立的第一年，以后每5年视实际需要更新一次标准。 2009年，C++标准有了一次更新，一般称该草案为C++0x。 C++0x是C++11标准成为正式标准之前的草案临时名字。 后来，2011年，C++新标准标准正式通过，更名为ISO/IEC 14882:2011，简称C++11。 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:0","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++11 C++11，先前被称作C++0x，即ISO/IEC 14882:2011，是C++编程语言的一个标准。 它取代第二版标准ISO/IEC 14882:2003 （第一版ISO/IEC 14882:1998公开于1998年， 第二版于2003年更新，分别通称C++98以及C++03，两者差异很小），且已被C++14取代 C++11 新特性(部分) auto 关键字及用法 C++11 之前，auto 具有存储期说明符的语义。auto在C++98中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两个标准的auto，完全是两个概念。 nullptr 关键字及用法 引入nullptr，是因为重载函数处理 NULL 的时候会出问题，二义性 void foo(int); //(1) void foo(void*); //(2) foo(NULL); // 重载决议选择 (1)，但调用者希望是 (2) foo(nullptr); // 调用(2) for循环语法 for ( 范围声明 : 范围表达式 ) 循环语句 STL – std::array std::array 提供了静态数组，编译时确定大小、更轻量、更效率，当然也比 std::vector 有更多局限性。 STL – std::forward_list 单向链表 STL – unordered_map STL – unordered_set 多线程 – std::thread 在 C++11 以前，C++ 的多线程编程均需依赖系统或第三方接口实现，一定程度上影响了代码的移植性。C++11 中，引入了 boost 库中多线程的部分内容，形成标准后的接口与 boost 库基本没有变化，这样方便了使用者切换使用 C++ 标准接口。 多线程 – std::atomic 从实现上，可以理解为这些原子类型内部自己加了锁。 多线程 – std::condition_variable 智能指针 – std::shared_ptr 智能指针 – std::weak_ptr 其它 – std::function 其它 – std::bind lambda ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:1","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++14 C++14 旨在作为C++11的一个小扩展，主要提供漏洞修复和小的改进。2014年8月18日，经过C++标准委员投票，C++14标准获得一致通过。ISO/IEC 14882:2014 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:2","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++17 C++17 又称C++1z，是继 C++14 之后，C++ 编程语言 ISO/IEC 标准的下一次修订的非正式名称。官方名称 ISO/IEC 14882:2017 基于 C++ 11，C++ 17 旨在简化该语言的日常使用，使开发者可以更简单地编写和维护代码。 C++ 17是对 C++ 语言的重大更新 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:3","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["samba"],"content":"配置文件 配置文件 说明 /etc/samba/smb.conf samba的主要配置文件，可设置全局参数和共享目录的参数 /etc/samba/lmhosts 通过hostname来访问samba /etc/samba/smbusers 由于windows和linux里的管理员和访客账号名称不一致，可使用此配置文件来设置一个映射，比如administrator映射成root /etc/sysconfig/samba 配置smbd，nmbd启动时带的参数 /var/lib/samba/private/{passdb.tdb, secrets.tdb} 管理samba的用户账号/密码时，会用到的数据库档案 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:1:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"可用命令 命令 说明 smbd smbd提供文件和打印共享服务器 nmbd nmbd提供NetBIOS名称服务和浏览支持，帮助客户端定位服务器，处理所有基于UDP的协议 tdbdump,tdbtool samba使用了tdb数据库，可以使用tdb工具来查看数据库内容 smbstatus 查看samba的状态 smbpasswd, pdbedit 服务器功能，用于管理samba的用户账号和密码，早期是使用smbpasswd命令，后来因为使用了tdb数据库，所以推荐使用pdbedit命令来管理用户数据 mount.cifs 用来挂载分享目录 smbclient samba客户端命令 nmblookup 查找NetBIOS name smbtree 未知，可能是用来查找网络邻居的吧 testparm 验证smb.conf文件的内容是否合法 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:2:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"工作模式 samba 共有5种工作模式，分别为： share，用户对samba服务器的访问不需要身份验证，允许匿名访问，用户的访问权限仅由相应用户对共享文件的访问权限决定 user，使用用户名和密码访问samba服务器 server，使用另外一台服务器专门用来做身份验证，samba服务只提供文件和打印机共享服务 domain，域模式\u003c待补充\u003e ads，\u003c待补充\u003e 通过设置security选项即可设置samba的工作模式：security = share ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:3:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"配置项 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:4:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"全局配置 [global] workgroup = WORKGROUP dns proxy = no log file = /var/log/samba/%m.log max log size = 1000 client min protocol = SMB2 server role = standalone server passdb backend = tdbsam obey pam restrictions = yes unix password sync = yes passwd program = /usr/bin/passwd %u passwd chat = *New*UNIX*password* %n\\n *ReType*new*UNIX*password* %n\\n *passwd:*all*authentication*tokens*updated*successfully* pam password change = yes map to guest = Bad Password usershare allow guests = yes name resolve order = lmhosts bcast host wins security = user guest account = nobody usershare path = /var/lib/samba/usershare usershare max shares = 100 usershare owner only = yes force create mode = 0070 force directory mode = 0070 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:4:1","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"共享目录配置 不需要密码的共享 需要将全局参数中的security设置成share(暂不清楚，在user工作模式下通过设置guest ok好像也可以，需要验证) 最小化配置： [test] comment = test path = /tmp read only = no guest ok = yes create mask = 644 其中： read only默认为yes，表示只允许读，不允许写，所以需要修改 guest ok默认是no，表示不允许匿名访问 create mask默认是744，导致客户端创建的文件都是可执行文件，所以需要修改 注意： writable和writeable是同义词 writeable和read only是反义同义词 writeable默认为no read only默认为yes 完整配置需要配置available和browseable，不过这两个默认都是yes 用户名/密码方式的共享 需要将全局参数中的security设置成user [win] comment = win path = /home/win read only = yes create mask = 644 valid users = win 这种方式首先需要使用root权限添加一个账户，然后使用smbpasswd -a xxx在samba数据库添加此用户的samba密码 输入smbpasswd -a xxx 时会直接让用户设置这个账户的samba密码 这个用户信息保存在tdb数据库里 修改密码：root权限下输入smbpasswd user_name即可修改user_name的samba密码 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:4:2","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"配置文件验证 使用testparm可以验证smb.conf文件的内容是否合法 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:5:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"Samab密码设置对象 Samab密码设置对象(Password Settings Objects，简称PSOs)，开始于 Samba Version:4.9 密码设置对象(PSO)是一种 AD 功能，也称为细粒度密码策略(FGPP)。在 AD 中，密码设置控制以下几个方面： 用户更改密码时的最小密码长度和复杂性要求 密码历史时长：放置用户再次使用以前的密码 密码使用的最小和最大期限：用户必须更改密码的频率 账户锁定：在将用户锁定其账户之前登录尝试失败的阈值，以及他们被锁定的持续时间。 在支持 PSO 之前，Samba 管理员只能为域中的所有用户配置密码设置。例如。如果您想强制系统管理员拥有更长、更安全的密码，那么每个用户都必须遵守相同的密码要求。 PSO 允许 AD 管理员覆盖域的密码策略设置，并为特定用户或用户组配置更精细的密码设置。例如，PSO 可以强制某些用户使用更长的密码长度，或者放宽对其他用户的复杂性限制，等等。 PSO 可以应用于组或单个用户。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:1:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"如何配置 PSO 可以使用 samba-tool domain passwordsettings pso 命令设置。参看 samba-tool domain passwordsettings pso --help 获取更多使用细节。PSO 命令的功能： 自行管理 PSO，即使用 create 或 set 子命令配置密码设置。还有 delete、list 和 show 命令。 控制适用于特定用户的 PSO。使用 apply 和 unapply 将 PSO 链接到特定组或用户 许多不同的 PSO 可以应用于同一用户（直接或通过组）。当多个 PSO 应用于同一用户时，本质上是具有最低优先级的 PSO 生效。但是，直接应用于用户的 PSO 总是胜过通过组成员身份继承的 PSO。要查看对给定用户生效的 PSO，使用 samba-tool domain passwordsettings pso show-user。 如果没有 PSO 应用于用户，则应用域密码设置。您可以使用samba-tool domain passwordsettings show|set查看/修改这些配置。 注意： 请使用 samba-tool 创建密码设置对象，而不是使用手动 LDIF。 PSO 需要驻留在“密码设置容器”中，samba-tool 将自动对其进行排序。任何在别处创建的 PSO 都将被忽略。 内置组不包括在 PSO 计算中。任何应用于内置组的 PSO 都不会生效。 要使用 Windows GUI 创建 PSO，请打开 Active Directory 管理中心，然后导航到系统 -\u003e 密码设置容器，然后单击“新建”按钮将弹出一个向导。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:2:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"已知问题 当前 (v4.9) 配置 PSO 并将其应用于用户会导致性能下降。这是我们希望在未来解决的问题。 计算 PSO 涉及计算用户的组成员资格，这是一个相当昂贵的计算。更糟糕的是，我们可能需要多次查找 msDS-ResultantPSO，因此它可能会尝试多次计算组，仅针对一次用户身份验证操作。注意： 如果根本没有 PSO 对象，则不会影响性能。 我们尝试缓存 msDS-ResultantPSO 结果，因此每次用户身份验证操作只计算一次。但是，如果没有 msDS-ResultantPSO（即域默认值适用于用户），我们不会缓存结果。所以这将是最坏的情况：域中存在一些 PSO，但它们对大多数用户不起作用。 如果 PSO 直接应用于用户（而不是组），则跳过昂贵的组计算。但是，与将 PSO 应用于组相比，将 PSO 直接应用于用户会使 PSO 更难管理。 如果密码历史长度从零变为非零值，Windows 和 Samba 行为之间还有一个非常微不足道的错误 (#13431)。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:3:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"代码位置 主要 PSO 行为是使用构造属性控制的：msDS-ResultantPSO。这是为用户对象生成的，其值是适用于该用户的 PSO 的 DN。因此，确定适用于用户的正确 PSO 的逻辑存在于 operation.c 中，在那里生成构造的属性。 如果你 grep 'msDS-ResultantPSO' 的代码库，你应该找到所有尝试使用它的地方。基本上，无论代码检查密码设置属性（例如 lockOutObservationWindow），我们都必须检查 PSO 是否适用于该用户，如果是，则使用 PSO 属性（具有不同的名称，即 msDS-LockoutObservationWindow）。 samdb_result_effective_badPwdCount() 就是一个很好的例子。 get_pso_data_callback() 也值得注意，因为它用 PSO 的值覆盖了 dsdb_user_pwd_settings 结构的值（即域密码设置）。在密码哈希模块中使用此结构（作为结构 dsdb_control_password_change_status 的一部分）来检查密码更改操作。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:4:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"参考文档 MS-ADTS 记录了如何确定 msDS-ResultantPSO（第 3.1.1.4.5.36 节）。 MS-SAMR 记录了 msDS-ResultantPSO 如何用于确定应用于用户的有效密码设置，即 Effective-LockoutThreshold、Effective-MinimumPasswordLength 等。这在第 3.1.1.5 节用于发起更新约束的密码设置属性中记录，但这些 Effective-XYZ 值在整个文档的其他几个地方都被引用，例如在计算 userAccountControl 时。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:5:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["linux"],"content":"rfkill rfkill 是一个小型的用户空间工具，用于查询 rfkill 开关、按钮和子系统接口的状态。 Linux 内核通过 /dev/rfkill 设备文件公开了 rfkill 子系统一些控制功能，允许用户空间模拟/监听/控制硬件 rfkill 设备。 ","date":"2022-04-20","objectID":"/2022/04/0005-rfkill/:1:0","tags":["linux","rfkill","wlan","bluetooth"],"title":"rfkill —— 用户空间控制无线通讯命令","uri":"/2022/04/0005-rfkill/"},{"categories":["linux"],"content":"具体使用 rfkill --help ","date":"2022-04-20","objectID":"/2022/04/0005-rfkill/:2:0","tags":["linux","rfkill","wlan","bluetooth"],"title":"rfkill —— 用户空间控制无线通讯命令","uri":"/2022/04/0005-rfkill/"},{"categories":["linux"],"content":"参看 https://wireless.wiki.kernel.org/en/users/Documentation/rfkill ","date":"2022-04-20","objectID":"/2022/04/0005-rfkill/:3:0","tags":["linux","rfkill","wlan","bluetooth"],"title":"rfkill —— 用户空间控制无线通讯命令","uri":"/2022/04/0005-rfkill/"},{"categories":["字符编码"],"content":"字符编码基本概念 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:0","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符 字符（Character）：在计算机和电信技术中，一个字符是一个单位的字形、类字形单位或符号的基本信息。说的简单点字符是各种文字和符号的总称。一个字符可以是一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号、一个图形符号或者控制符号等。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:1","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符集 字符集（Character Set）：是指多个字符的集合。不同的字符集包含的字符个数不一样、包含的字符不一样、对字符的编码方式也不一样。例如GB2312是中国国家标准的简体中文字符集，GB2312收录简化汉字（6763个）及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。而ASCII字符集只包含了128字符，这个字符集收录的主要字符是英文字母、阿拉伯字母和一些简单的控制字符。 另外，还有其他常用的字符集有 GBK字符集、GB18030字符集、Big5字符集、Unicode字符集等。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:2","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符编码 字符编码（Character Encoding）：字符编码是指一种映射规则，根据这个映射规则可以将某个字符映射成其他形式的数据以便在计算机中存储和传输。例如ASCII字符编码规定使用单字节中低位的7个比特去编码所有的字符，在这个编码规则下字母A的编号是65（ASCII码），用单字节表示就是0x41，因此写入存储设备的时候就是二进制的 01000001。每种字符集都有自己的字符编码规则，常用的字符集编码规则还有 UTF-8编码、GBK编码、Big5编码等。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:3","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"码点 码点（Code Point）：有些地方翻译为码值或内码。是指在某个字符集中，根据某种编码规则将字符编码后得到的值。比如在ASCII字符集中，字母A经过ASCII编码得到的值是65，那么65就是字符A在ASCII字符集中的码点。 总结：通俗解释字符集就是把字符放到一起的一个集合。而这个集合的每一个字符都对应一个数字，叫做码点。那么，这样就建立起来数字和字符之间的索引关系。那么，某个字符在计算机中怎么表示，具体占用几个字节等等，这些就需要编码规则来解决了。这个就是字符编码，他来解决根据某个规则来将字符映射到相应的码点上面。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:4","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符编码 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:0","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"ASCII 码 ASCII 编码于 1967 年第一次发布，最后一次更新是在 1986 年，迄今为止共收录了 128 个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是 1234567890）、标点符号（,.!等）、特殊符号（@#$%^\u0026等）以及一些具有控制功能的字符（往往不会显示出来）。 ASCII 编码是美国人给自己设计的，他们并没有考虑欧洲那些扩展的拉丁字母，也没有考虑韩语和日语，我大中华几万个汉字更是不可能被重视。计算机也是美国人发明的，起初使用的就是 ASCII 码，只能显示英文字符。各个国家为了让本国公民也能正常使用计算机，开始效仿 ASCII 开发自己的字符编码，例如 ISO/IEC 8859（欧洲字符集）、shift_Jis（日语字符集）、GBK（中文字符集）等。 二进制 十进制 十六进制 字符/缩写 解释 00000000 0 00 NUL (NULL) 空字符 00000001 1 01 SOH (Start Of Headling) 标题开始 00000010 2 02 STX (Start Of Text) 正文开始 00000011 3 03 ETX (End Of Text) 正文结束 00000100 4 04 EOT (End Of Transmission) 传输结束 00000101 5 05 ENQ (Enquiry) 请求 00000110 6 06 ACK (Acknowledge) 回应/响应/收到通知 00000111 7 07 BEL (Bell) 响铃 00001000 8 08 BS (Backspace) 退格 00001001 9 09 HT (Horizontal Tab) 水平制表符 00001010 10 0A LF/NL(Line Feed/New Line) 换行键 00001011 11 0B VT (Vertical Tab) 垂直制表符 00001100 12 0C FF/NP (Form Feed/New Page) 换页键 00001101 13 0D CR (Carriage Return) 回车键 00001110 14 0E SO (Shift Out) 不用切换 00001111 15 0F SI (Shift In) 启用切换 00010000 16 10 DLE (Data Link Escape) 数据链路转义 00010001 17 11 DC1/XON (Device Control 1/Transmission On) 设备控制1/传输开始 00010010 18 12 DC2 (Device Control 2) 设备控制2 00010011 19 13 DC3/XOFF (Device Control 3/Transmission Off) 设备控制3/传输中断 00010100 20 14 DC4 (Device Control 4) 设备控制4 00010101 21 15 NAK (Negative Acknowledge) 无响应/非正常响应/拒绝接收 00010110 22 16 SYN (Synchronous Idle) 同步空闲 00010111 23 17 ETB (End of Transmission Block) 传输块结束/块传输终止 00011000 24 18 CAN (Cancel) 取消 00011001 25 19 EM (End of Medium) 已到介质末端/介质存储已满/介质中断 00011010 26 1A SUB (Substitute) 替补/替换 00011011 27 1B ESC (Escape) 逃离/取消 00011100 28 1C FS (File Separator) 文件分割符 00011101 29 1D GS (Group Separator) 组分隔符/分组符 00011110 30 1E RS (Record Separator) 记录分离符 00011111 31 1F US (Unit Separator) 单元分隔符 00100000 32 20 (Space) 空格 00100001 33 21 ! 00100010 34 22 \" 00100011 35 23 # 00100100 36 24 $ 00100101 37 25 % 00100110 38 26 \u0026 00100111 39 27 ' 00101000 40 28 ( 00101001 41 29 ) 00101010 42 2A * 00101011 43 2B + 00101100 44 2C , 00101101 45 2D - 00101110 46 2E . 00101111 47 2F / 00110000 48 30 0 00110001 49 31 1 00110010 50 32 2 00110011 51 33 3 00110100 52 34 4 00110101 53 35 5 00110110 54 36 6 00110111 55 37 7 00111000 56 38 8 00111001 57 39 9 00111010 58 3A : 00111011 59 3B ; 00111100 60 3C \u003c 00111101 61 3D = 00111110 62 3E \u003e 00111111 63 3F ? 01000000 64 40 @ 01000001 65 41 A 01000010 66 42 B 01000011 67 43 C 01000100 68 44 D 01000101 69 45 E 01000110 70 46 F 01000111 71 47 G 01001000 72 48 H 01001001 73 49 I 01001010 74 4A J 01001011 75 4B K 01001100 76 4C L 01001101 77 4D M 01001110 78 4E N 01001111 79 4F O 01010000 80 50 P 01010001 81 51 Q 01010010 82 52 R 01010011 83 53 S 01010100 84 54 T 01010101 85 55 U 01010110 86 56 V 01010111 87 57 W 01011000 88 58 X 01011001 89 59 Y 01011010 90 5A Z 01011011 91 5B [ 01011100 92 5C \\ 01011101 93 5D ] 01011110 94 5E ^ 01011111 95 5F _ 01100000 96 60 ` 01100001 97 61 a 01100010 98 62 b 01100011 99 63 c 01100100 100 64 d 01100101 101 65 e 01100110 102 66 f 01100111 103 67 g 01101000 104 68 h 01101001 105 69 i 01101010 106 6A j 01101011 107 6B k 01101100 108 6C l 01101101 109 6D m 01101110 110 6E n 01101111 111 6F o 01110000 112 70 p 01110001 113 71 q 01110010 114 72 r 01110011 115 73 s 01110100 116 74 t 01110101 117 75 u 01110110 118 76 v 01110111 119 77 w 01111000 120 78 x 01111001 121 79 y 01111010 122 7A z 01111011 123 7B { 01111100 124 7C | 01111101 125 7D } 01111110 126 7E ~ 01111111 127 7F DEL (Delete) 删除 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:1","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"GB2312(别名:EUC-CN) 《信息交换用汉字编码字符集》是由中国国家标准总局1980年发布，1981年5月1日开始实施的一套国家标准，标准号是GB 2312—1980。 GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。 GB2312(1980年)共收录 7445 个字符 –\u003e GBK1.0(1995年)共收录 21886 个字符 –\u003e GB18030(2000年)取代GBK1.0共收录 27484 个汉字包含了少数民族语言。 从 ASCII -\u003e GB2312 -\u003e GBK -\u003e GB18030，这些编码都是向下兼容的。区分中文编码的方法是最高字节的最高位不为 0。这些都属于双字节字符集。 GB2312 编码规则 GB2312 规定每个英文字符占1字节(只有这一个特例，为了兼容 ASCII)，中文字符采用两个字节表示 GB2312 整体分为 94 个区，每个区 94 位，01-09 特殊符号区；16-55一级汉字，按拼音排序；56-87二级汉字，部首/笔划排序；10-15与88-94未定义 GB2312 是区位编码，编码范围是 0XA1A1-0XFEFE，其中汉字编码范围是 0XB0A1-0XF7FE。 GB2312 01-09 符号和数字区，16-87是汉字区 GB2312 编码计算：[区号+0xA0][位号+0xA0] GB2312 编码识别 保存为demo-gb2312.c // // Created by dingjing on 3/28/22. // #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdint.h\u003e #include \u003cstdbool.h\u003e /** * 总共 94 个区 94 个位 */ bool is_gb2312 (const char* code) { int len = strlen (code); if (len != 2 \u0026\u0026 len != 1) { return false; } uint8_t codeH = code[0]; uint8_t codeL = code[1]; uint8_t area = codeH - 0xA0; uint8_t pos = codeL - 0xA0; if ((len == 1) \u0026\u0026 (0 == (codeL \u0026 0x80))) { printf (\"ascii code: '%-3c' hex code: 0x%-2X\\n\", *code, *code); return true; } if (area \u003e= 1 \u0026\u0026 area \u003c= 94 \u0026\u0026 pos \u003e= 1 \u0026\u0026 pos \u003c= 94) { printf (\"gb2312 code: '%-3s' -- area: %-2u, pos: %-2u hex code: 0x%-2X 0x%-2X\\n\", code, area, pos, codeH, codeL); return true; } } int main (int argc, char* argv[]) { /** * https://uic.io/en/charset/show_raw/gb2312 * http://tools.jb51.net/table/gb2312 * 1. '残' 十六进制: B2D0 * 2. '怖' 十六进制: B2C0 * 3. '惭' 十六进制: B2D1 * * 4. ascii 里显示的特殊符号 32(space) - 47(/) * 5. ascii 里数字 30(0) - 39(9) * 6. ascii 里显示的特殊符号 58(:) - 64(@) * 7. ascii 里显示的大写字母 65(A) - 90(Z) * 8. ascii 里显示的标号字符 91([) - 96(`) * 9. ascii 里显示的大写字母 97(a) - 122(z) * 10. ascii 其它可显示字符 123({) - 126(~) * * uint16_t 就足够了 */ const char* arr[] = { \"、\", \"∩\", \"〓\", /* 第一区 */ \"残\", \"怖\", \"惭\", \"庄\", \"丽\", \"君\", \"齄\", \" \", \"/\", \"0\", \"9\", \":\", \"@\", \"A\", \"Z\", \"[\", \"`\", \"a\", \"z\", \"{\", \"~\" }; printf (\"array: %lu/%lu\\n\\n\", sizeof arr[0], sizeof arr); int len = sizeof arr / sizeof arr[0]; for (int i = 0; i \u003c len; ++i) { const char* code = arr[i]; if (!is_gb2312 (code)) { printf (\"index: %d -- code '%-3s' is not gb2312\\n\", i, code); } } return 0; } 编译命令: gcc -O0 -finput-charset=utf8 -fexec-charset=gb2312 demo-gb2312.run demo-gb2312.c GB2312识别思路(后续补充) ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:2","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"Unicode 编码 Unicode 的使命就是为了统一世界上所有语言的编码，它包含了世界上所有字符的编码，规定了每个字符对应的码点值。 这里需要注意：Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 问题1: 如何才能区别unicode和ascii 问题2: 我们已经知道，英文字母只用一个字节表示就够了，如果 unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0， 这对于存储来说是极大的浪费，文本文件的大小会因此大出 2-3 倍，这是无法接受的。 另附unicode中汉字编码 字符集 字数 unicode 编码 基本汉字 20902字 4E00(一) - 9FA5(龥) 基本汉字扩充 90字 9FA6(龦) - 9FFF(\u003c无法显示\u003e) 这些看着不像汉字，先不管 扩展A 6592字 3400 - 4DBF，看着不像汉字 扩展B 42720字 20000-2A6DF 扩展C 4153字 2A700-2B738 扩展D 222字 2B740-2B81D 扩展E 5762字 2B820-2CEA1 扩展F 7473字 2CEB0-2EBE0 扩展G 4939字 30000-3134A 康熙部首 214字 2F00-2FD5 部首扩展 115字 2E80-2EF3 兼容汉字 477字 F900-FAD9 兼容扩展 542字 2F800-2FA1D PUA(GBK)部件 81字 E815-E86F 部件扩展 452字 E400-E5E8 PUA增补 207字 E600-E6CF 汉字笔画 36字 31C0-31E3 汉字结构 12字 2FF0-2FFB 汉语注音 43字 3105-312F 注音扩展 22字 31A0-31BA 〇 1字 3007 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:3","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"utf8 编码(unicode编码的一种实现) UTF-8 是一种变长字节编码方式，是 Unicode 的一种实现方式，使用 1-4 个字节表示一个符号， 对于某一个字符的 UTF-8 编码，如果只有一个字节则其最高二进制位为 0； 如果是多字节，其第一个字节从最高位开始，连续的二进制位值为 1 的个数决定了其编码的位数，其余各字节均以 10 开头。UTF-8 最多可用到 6 个字节。 注意：这里是utf8编码的核心，它规定了utf8最多可以使用多少字节编码 思考：为什么utf8最多只能使用6字节参与编码？ 实际上 utf-8 编码没用到 6 字节那么多，只用到了 4 字节 另外补充：另外补充 utf16，介于 utf8 与 utf32 之间，部分编码定长、部分编码不定长(只有两种) utf32 是定长的，用 4 字节表示一个字符 utf8中文汉字占3字节(这种结论不是一直不变的) 以下展示 utf8 分别为 1、2、3、4、5、6字节时候，理论上其它位的编码范围。 1字节 0xxxxxxx 2字节 110xxxxx 10xxxxxx 3字节 1110xxxx 10xxxxxx 10xxxxxx 4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 与上述等价 1字节, utf8-1 0x00-0x7F 2字节, utf8-2 0xC2-0XDF 0X80-0XBF 3字节, utf8-3 0xE0 0xA0-0XBF 0x80-0xBF 0xE1-0XEC 0x80-0XBF 0x80-0xBF 0xED 0x80-0x9F 0x80-0xBF 0xEE-0xEF 0x80-0xBF 0x80-0xBF 4字节, utf8-4 0xF0 0x90-0xBF 0x80-0xBF 0x80-0xBF 0xF1-0xF3 0x80-0xBF 0x80-0xBF 0x80-0xBF 0xF4 0x80-0x8F 0x80-0xBF 0x80-0xBF utf8 编码识别 保存为demo-utf8.c // // Created by dingjing on 3/28/22. // #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e #include \u003cstring.h\u003e #include \u003cstdbool.h\u003e bool is_utf8_1 (const char* code) { int len = strlen(code); if (len \u003c 1) { return false; } const uint8_t code1 = code[0]; if (!(0x80 \u0026 code1)) { return true; } return false; } bool is_utf8_2 (const char* code) { int len = strlen(code); if (len \u003c 2) { return false; } const uint8_t code1 = code[0]; const uint8_t code2 = code[1]; // printf (\"debug2: 0x%-4X\\n\", code); if (!is_utf8_1 (code) \u0026\u0026 (0xC0 == (0xE0 \u0026 code1)) \u0026\u0026 (0x80 == (0xE0 \u0026 code2))) { // printf (\"debug: is utf8-2\\n\"); if (code1 \u003e= 0xC0 \u0026\u0026 code1 \u003c= 0xDF \u0026\u0026 code2 \u003e= 0x80 \u0026\u0026 code2 \u003c= 0xBF) { return true; } } return false; } bool is_utf8_3 (const char* code) { /** * 0xE0 0xA0-0XBF 0x80-0xBF * 0xE1-0XEC 0x80-0XBF 0x80-0xBF * 0xED 0x80-0x9F 0x80-0xBF * 0xEE-0xEF 0x80-0xBF 0x80-0xBF */ int len = strlen(code); if (len \u003c 3) { return false; } const uint8_t code1 = code[0]; const uint8_t code2 = code[1]; const uint8_t code3 = code[2]; if ((0xE0 == code1) \u0026\u0026 ((code2 \u003e= 0xA0) \u0026\u0026 (code2 \u003c= 0XBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } else if (((code1 \u003e= 0xE1) \u0026\u0026 (code1 \u003c= 0xEC)) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } else if ((0xED == code1) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0x9F)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } else if (((code1 \u003e= 0xEE) \u0026\u0026 (code1 \u003c= 0xEF)) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } return false; } bool is_utf8_4 (const char* code) { /** * 0xF0 0x90-0xBF 0x80-0xBF 0x80-0xBF * 0xF1-0xF3 0x80-0xBF 0x80-0xBF 0x80-0xBF * 0xF4 0x80-0x8F 0x80-0xBF 0x80-0xBF */ int len = strlen(code); if (len \u003c 4) { return false; } const uint8_t code1 = code[0]; const uint8_t code2 = code[1]; const uint8_t code3 = code[2]; const uint8_t code4 = code[3]; // printf (\"debug4: 0x%-4X %-4X\\n\", code1H, code1L); if (!is_utf8_1 (code) \u0026\u0026 !is_utf8_2 (code) \u0026\u0026 !is_utf8_3 (code)) { if ((0xF0 == code1) \u0026\u0026 ((code2 \u003e= 0x90) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF)) \u0026\u0026 ((code4 \u003e= 0x80) \u0026\u0026 (code4 \u003c= 0xBF))) { return true; } else if (((code1 \u003e= 0xF1) \u0026\u0026 (code1 \u003c= 0xF3)) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF)) \u0026\u0026 ((code4 \u003e= 0x80) \u0026\u0026 (code4 \u003c= 0xBF))) { return true; } else if ((0xF4 == code1) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0x8F)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF)) \u0026\u0026 ((code4 \u003e= 0x80) \u0026\u0026 (code4 \u003c= 0xBF))) { return true; } } return false; } int main (int argc, char* argv[]) { // utf-8 1 - 4 字节 const char* arr[] = { \" \", \"/\", \"0\", \"9\", \":\", \"@\", \"A\", \"Z\", \"[\", \"`\", \"a\", \"z\", \"{\", \"~\", /* 以下都是 ASCII */ \"§\", \"©\", \"®\", \"Ą\", \"Ď\", \"Đ\", \"Ő\", /* 2 字节 utf8 编码 */ \"ᥕ\", \"一\", \"龥\", \"庄\", \"丽\", \"君\", /* 3 字节 */ \"契\", \"い\", \"龜\" }; printf (\"array: %lu/%lu\\n\\n\", sizeof arr[0], sizeof arr); char buf[128] = {0}; int len = sizeof arr / sizeof arr[0]; for (int i = 0; i \u003c len; ++i) { const char* code = arr[i]; if (is_utf8_1 (code)) { ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:4","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"utf16 编码(unicode编码的一种实现) 没用到，后续补充。 部分编码定长、部分编码不定长(只有两种) ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:5","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"utf32 编码(unicode编码的一种实现) utf32 是定长的，用 4 字节表示一个字符 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:6","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["linux"],"content":"说明 fstransform 命令可以将文件系统从一种类型转换为另一种类型而不丢失数据(即非破坏性的)。更重要的是它可以直接执行，而无需格式化或者复制数据。 tune2fs 命令可以把 ext2 转为 ext3 或 ext4；也可以把 ext3 转为 ext4 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:1:0","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"fstransform文件系统格式转换 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:2:0","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"需要注意的事 1. Linux内核必须支持转换前和转换后的文件系统 2. ext2升级到ext3、ext4无需 fstransform，要使用 tune2fs 3. 源文件系统的设备至少有5%的可用空间 4. 开始执行转换前卸载文件系统 5. 源文件系统存储的数据越多，转换时间越长。实际取决于设备 6. 虽然fstransform被证明是稳定的，但是也要备份好数据 7. 无法转换Linux根文件系统格式 8. 设备上的文件系统限制 必须支持 SPARSE 文件(即:带有孔的文件) 至少有两个系统调用\"ioctl\"(FS_IOC_FIEMAP和FIBMAP)中的一个 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:2:1","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"操作 fstransform /dev/xxx \u003c目标系统\u003e 亲测速度太慢，而且还有很高的失败率。建议如果是ext系列的文件系统使用tune2fs转换。 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:2:2","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"tune2fs 转换ext系列文件系统格式 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:0","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"ext2 转 ext3 tune2fs -j /dev/sda ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:1","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"ext2 转 ext4 tune2fs -O extents,uninit_bg,dir_index,has_journal /dev/sda1 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:2","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"ext3 转 ext4 tune2fs -O extents,uninit_bg,dir_index,has_journal /dev/sda1 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:3","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"wireshark 是什么 Wireshark(前称Ethereal)是一个网络封包分析软件。网络封包软件的功能主要是截取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用 WinPCAP 作为接口，直接与网卡进行数据报文交换。 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:1:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 使用 首先进入 wireshark，启动时候需要使用命令行以 root 启动 非root用户无法抓取网卡上所有的包 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"1. 选择网卡 选择菜单栏上 Capture -\u003e Option，选中使用的网卡，点击 start 开始抓包 选择网卡 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"2. 添加过滤条件 比如仅需要查看 www.baidu.com 的数据包，通过 ping 命令获取对应的 ip，在 wireshark 中设置 ip 过滤条件就可以看到。 ip.addr == 119.75.217.26 and icmp 表示只显示ICPM协议且源主机IP或者目的主机IP为119.75.217.26的数据包 添加过滤条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 界面说明 wireshark界面说明 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:3:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"数据详细区说明 Frame: 物理层的数据帧概况 Ethernet II: 数据链路层以太网帧头部信息 Internet Protocol Version 4: 互联网层IP包头部信息 Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP 之后的都属于应用层 wireshark界面说明 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:3:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 设置过滤条件 需要注意的是，wireshark 既可以设置抓包过滤条件，也可以设置显示过滤条件，前者限制大，用于减少捕获数据包的数量；后者用于在报文中隐藏某些报文。 抓包过滤器只能在抓包前设置，无法动态修改，显示过滤器则没有此限制 设置抓包过滤条件，(如果已经开始抓包，需要先停止…)菜单栏 Capture -\u003e Options -\u003e Input -\u003e Capture filter for selected interfaces 设置配置条件，同时选中要抓取的网卡，点击此页面右下角的 Start 即可开始抓包 设置显示过滤条件，在菜单栏下边有个文本输入框(Apply a display filter ... \u003cCtrl-/\u003e) 在这里配置显示过滤条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"抓取过滤类型(抓包过滤) 类型 说明 host 让wireshark只抓取源于或发往由标识符host所指定的主机名或IP地址的流量 net 让wireshark只抓取源于或发往由标识符net所标识的IPv4/IPv6网络号的流量 port 让wireshark只抓取源于或发往由标识符port指定端口号的流量包 portrange 让wireshark只抓取源于或发往由标识符portrange指定端口范围的流量包 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"过滤方向(显示/抓包过滤) 方向 说明 src 发送端条件 dst 目标端条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"过滤协议(显示过滤) 协议 说明 ether fddi tr wlan ip ip6 arp rarp decnet sctp tcp udp http … ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:3","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"逻辑运算符(显示过滤) 运算符 说明 \u0026\u0026 或 and 两者等价与逻辑 || 或 or 两者等价或逻辑 ! 或 not 两者等价非逻辑 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:4","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"比较操作符(显示过滤) 运算符 说明 == 等于 != 不等于 \u003e 大于 \u003c 小于 \u003e= 大于等于 \u003c= 小于等于 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:5","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"例子 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"抓包过滤条件 抓取百度的包 host www.baidu.com 或者使用 ping www.baidu.com 得到百度网站的ip (220.181.38.150)再使用命令 net 220.181.38.150 抓取指定ip范围内的包 net 192.168.0.0/24 或 net 192.168.0.0 mask 255.255.255.0 抓取从指定 IP 范围发出的包 src net 192.168.0.0/24 或 src net 192.168.0.0 mask 255.255.255.0 抓取发往目标 IP 范围的包 dst net 192.168.0.0/24 或 dst net 192.168.0.0 mask 255.255.255.0 抓取指定端口53的包(DNS服务) port 53 抓取指定服务器上非 HTTP 和非 SMTP 的包 host www.example.com and not (port 80 or port 25) host www.example.com and not port 80 and not port 25 抓取除了 ARP 和 DNS 的包 port not 53 and not arp 抓取指定端口范围的包 (tcp[0:2] \u003e 1500 and tcp[0:2] \u003c 1550) or (tcp[2:2] \u003e 1500 and tcp[2:2] \u003c 1550) 或 tcp portrange 1501-1549 值抓取EAPOL类型以太网的包 ether proto 0x888e 拒绝向链路层发现协议发送的以太网帧 not ether dst 01:80:c2:00:00:0e 仅捕获IPv4流量-最短的过滤器，但有时非常有用，以摆脱较低的层协议，如ARP和STP ip 仅捕获单播流量-如果你只想看到与你的机器之间的流量，而不捕获广播和多播 not broadcast and not multicast 捕获IPv6“所有节点”(路由器和邻居通告)流量。可以用来找到流氓RAs dst host ff02::1 捕获HTTP GET请求。这将查找TCP头后面的字节’G’、‘E’、‘T’和’ ‘(十六进制值47、45、54和20)。“tcp[12:1] \u0026 0xf0) » 2\"计算出tcp报头长度 port 80 and tcp[((tcp[12:1] \u0026 0xf0) \u003e\u003e 2):4] = 0x47455420 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"显示过滤器 仅显示 SMTP(25端口)和 ICMP 数据包 tcp.port eq 25 or icmp 只显示局域网(192.168.x.x)的流量，工作站和服务器之间-没有Internet: ip.src==192.168.0.0/16 and ip.dst==192.168.0.0/16 TCP buffer full - Source指示Destination停止发送数据 tcp.window_size == 0 \u0026\u0026 tcp.flags.reset != 1 参考：https://wiki.wireshark.org/DisplayFilters 参考: https://wiki.wireshark.org/Home ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"samba 挂载 目前有一个需求，系统重启时候需要自动挂载远程 samba 文件系统，起初使用 fstab 发现并不能成功挂载，考虑应该是和启动顺序有关系，当没有网络的时候是无法执行挂载操作的，或者说挂载会出错，后来发现 systemd 也提供自动挂载的功能，于是尝试了一下，发现是可以的。 ","date":"2022-03-18","objectID":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/:1:0","tags":["linux","samba","systemd"],"title":"systemd 自动挂载samba","uri":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/"},{"categories":["linux"],"content":"具体步骤 在 /etc/samba/ 下创建 credentials 文件夹 mkdir /etc/samba/crendentials 在/etc/samba/crendentials下创建比如名为share0的文件并加入如下配置 # vim /etc/samba/crendentials/share0 username=\u003csamba登录用户名\u003e password=\u003csamba对应的密码\u003e 创建systemd unit文件，内容如下 # vim /etc/systemd/system/mnt-share.mount Description= mount a samba share Requires=network-online.target After=network-online.target systemd-resolved.service Wants=network-online.target systemd-resolved.service [Mount] Name=mnt-share What=//\u003c远程samba-ip\u003e/\u003c远程samba路径\u003e Where=/mnt/share # \u003c本机挂载路径\u003e Type=cifs Options=x-systemd.automount,_netdev,credentials=/etc/samba/credentials/share,sec=ntlmssp,vers=1.0,rw,uid=1000,gid=1000,dir_mode=0777,file_mode=0777,iocharset=utf8 TimeoutSec=30 [Install] WantedBy=multi-user.target 测试是否可以挂载 systemctl start mnt-share.mount 如果有报错就需要尝试修改 5. 开机自动挂载 systemctl enable mnt-share.mount 注意：挂载路径(Where)必须和文件名(mnt-share0)对应，比如挂载到 /mnt/share，那么文件名必须是mnt-share0.mount 参考：arch linux samba https://wiki.archlinux.org/index.php/samba#As_systemd_unit ","date":"2022-03-18","objectID":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/:2:0","tags":["linux","samba","systemd"],"title":"systemd 自动挂载samba","uri":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/"},{"categories":["linux"],"content":"说明 dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:1:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"块大小可以使用的计量表 单元大小 表示 字节(1B) c 字节(2B) w 块(512B) b 千字节(1024B) k 兆字节(1024KB) M 吉字节(1024MB) G ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:2:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"参数解释 参数 说明 if=\u003c文件名\u003e 输入文件名，默认为stdin标准输入，用来指定读取的源文件 of=\u003c文件名\u003e 输出文件名，默认为stdout标准输出，用来指定输出的目的文件 ibs=\u003c字节\u003e 一次读入bytes个字节，即指定一个块大小为bytes个字节 obs=\u003c字节\u003e 一次输出bytes个字节，即指定一个块大小为bytes个字节 bs=\u003c字节\u003e 同事设置读入/读出的块大小为 bytes 个字节 cbs=\u003c字节\u003e 一次转换bytes个字节，即指定转换缓存区大小 skip=\u003c字节\u003e 从输入文件开头跳过blocks个块后再开始复制 seek=\u003c字节\u003e 从输出文件开头跳过blocks个块后再开始复制 count=\u003c字节\u003e 仅拷贝blocks个块，块大小等于ibs指定的字节数 conv=\u003c转换参数\u003e 用指定的参数转换文件。ascii:转换ebcdic为asciiebcdic:转换ascii为ebcdicibm:转换ascii为alternate ebcdicblock:把每一行转换为长度为cbs，不足部分用空格填充unblock:使没一行的长度都为cbs，不足部分用空格填充lcase:把大写字符转换为小写字符ucase:把小写字符转换为大写字符swab:交换输入的每对字节noerror:出错时不停止notrunc:不截断输出文件sync:将每个输入块填充到ibs个字节，不足部分也能够(NUL)字符补齐 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:3:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"dd应用实例 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"将本地 /dev/hdb 盘备份到 /dev/hdd dd if=/dev/hdb of=/dev/hdd ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:1","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"备份/dev/hdb全盘数据，并利用gzip工具进行压缩，保存到指定路径 dd if=/dev/hdb | gzip \u003e /root/image.gz ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:2","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"将压缩的备份文件恢复到指定盘 gzip -dc /root/image.gz | dd of=/dev/hdb ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:3","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"备份与恢复MBR 备份磁盘开始的512个字节大小的MBR信息到指定文件： dd if=/dev/hda of=/root/image count=1 bs=512 count=1指仅拷贝一个块；bs=512指块大小为512个字节 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:4","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"增加swap分区文件大小 第一步：创建一个大小为256M的文件： dd if=/dev/zero of=/swapfile bs=1024 count=262144 第二步：把这个文件变成swap文件： mkswap /swapfile 第三步：启用这个swap文件： swapon /swapfile 第四步：编辑/etc/fstab文件，使在每次开机时自动加载swap文件： /swapfile swap swap default 0 0 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:5","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"销毁磁盘数据 dd if=/dev/urandom of=/dev/hda1 注意：利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:6","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"测试硬盘的读写速度 dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file dd if=/root/1Gb.file bs=64k | dd of=/dev/null 通过以上两个命令输出的命令执行时间，可以计算出硬盘的读、写速度 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:7","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"确定硬盘的最佳块大小 dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file 通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:8","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"修复硬盘 dd if=/dev/sda of=/dev/sda # 或 dd if=/dev/hda of=/dev/hda 当硬盘较长时间(一年以上)放置不使用后，磁盘上会产生magnetic flux point，当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数 据起死回生。并且这个过程是安全、高效的 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:9","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"利用netcat远程备份 dd if=/dev/hda bs=16065b | netcat \u003c targethost-IP \u003e 1234 在源主机上执行此命令备份/dev/hda netcat -l -p 1234 | dd of=/dev/hdc bs=16065b 在目的主机上执行此命令来接收数据并写入/dev/hdc netcat -l -p 1234 | bzip2 \u003e partition.img netcat -l -p 1234 | gzip \u003e partition.img 以上两条指令是目的主机指令的变化分别采用bzip2、gzip对数据进行压缩，并将备份文件保存在当前目录 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:10","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"另附 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"/dev/null 和/dev/zero的区别 /dev/null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着。它是空设备，也称为位桶（bit bucket）。任何写入它的输出都会被抛弃。如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶 /dev/zero，是一个输入设备，你可你用它来初始化文件。该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:1","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"使用/dev/null 把/dev/null看作\"黑洞\"， 它等价于一个只写文件，所有写入它的内容都会永远丢失.，而尝试从它那儿读取内容则什么也读不到。然而， /dev/null对命令行和脚本都非常的有用 禁止标准输出 cat $filename \u003e/dev/null 禁止标准错误 #rm $badname 2\u003e/dev/null 禁止标准输出和标准错误的输出 cat $filename 2\u003e/dev/null \u003e/dev/null cat $filename \u0026\u003e/dev/null 自动清空日志文件的内容 cat /dev/null \u003e /var/log/messages # : \u003e /var/log/messages 有同样的效果， 但不会产生新的进程.（因为:是内建的） 隐藏cookie而不再使用 if [ -f ~/.netscape/cookies ] # 如果存在则删除. then rm -f ~/.netscape/cookies fi ln -s /dev/null ~/.netscape/cookies 现在所有的cookies都会丢入黑洞而不会保存在磁盘上了 使用/dev/zero 像/dev/null一样， /dev/zero也是一个伪文件， 但它实际上产生连续不断的null的流（二进制的零流，而不是ASCII型的）。 写入它的输出会丢失不见， 而从/dev/zero读出一连串的null也比较困难， 虽然这也能通过od或一个十六进制编辑器来做到。 /dev/zero主要的用处是用来创建一个指定长度用于初始化的空文件，就像临时交换文件。 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:2","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["system"],"content":"https://blog.csdn.net/qq_38264240/article/details/121442084 ","date":"2022-03-17","objectID":"/2022/03/0002-kvm%E5%AE%89%E8%A3%85win11%E8%A7%A3%E5%86%B3%E6%97%A0tpm%E9%97%AE%E9%A2%98/:0:0","tags":["system","win11"],"title":"KVM安装Win11解决无TPM问题","uri":"/2022/03/0002-kvm%E5%AE%89%E8%A3%85win11%E8%A7%A3%E5%86%B3%E6%97%A0tpm%E9%97%AE%E9%A2%98/"},{"categories":["system"],"content":"前言 致力于传统操作系统基本概念、基本技术、基本方法的阐述 把操作系统成熟的基本原理与当代具有代表性的具体实例紧密地结合起来 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:1:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"涉及内容 操作系统概论 介绍操作系统的基本概念、多道程序设计技术、操作系统的形成和发展，操作系统的分类；操作系统的服务、操作系统的功能、操作系统的接口；操作系统的结构 处理机管理 从处理器和中断技术开始，介绍了中断的概念、分类、处理、优先级和多重中断。接着，引入进程和线程的概念，介绍进程管理的实现模型、线程不同级别的实现方法，介绍处理机调度的三个层次，着重讨论了各种单处理机调度算法，也涉及到多处理机调度算法和实时调度算法 并发进程 介绍进程的顺序性和并发性，进程的协作和竞争，以进程交互、进程控制、进程通信和进程死锁问题为重点，讨论并发程序设计有关技术和各种进程互斥、同步、通信机制和工具 存储管理 讨论存储管理的基本功能、各种传统存储管理技术、虚拟存储管理技术和最新的存储管理技术，如多级页表、反置页表等 设备管理 讨论 I/O 硬件原理、I/O 控制方式、I/O 软件原理、I/O 缓冲技术，着重介绍磁盘驱动调度技术、RAID 技术以及设备分配/去配和虚拟设备技术。也介绍了具有通道的I/O系统管理 文件管理 讨论文件概念、文件目录、文件逻辑结构、文件物理结构、文件的保护和保密、文件存储空间管理以及文件的操作和使用原理。也讨论了文件系统的新概念：内存映射文件和虚拟文件系统。 操作系统安全性 讨论操作系统安全威胁和类型；操作系统保护的层次及保护的基本机制、策略和模型，其中着重讨论了身份认证机制、授权机制、加密机制和审计机制 网络和分布式操作系统 简要介绍网络和分布式操作系统的基本概念和技术，包括网络和数据通信基础、网络体系结构、网络操作系统；分布式进程通信、分布式资源管理、分布式进程同步、分布式文件系统和进程迁移等 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:1:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统概论 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统定义 操作系统是管理系统资源、控制程序执行、改善人机界面、提供各种服务，合理组织计算机工作流程和为用户有效使用计算机提供良好运行环境的一种系统软件。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"配置操作系统的主要目标 方便用户使用 OS 通过提供用户与计算机之间的友善接口来方便用户使用 扩大机器功能 OS 通过扩充改造硬件设施和提供新的服务来扩大机器功能 管理系统资源 OS 有效管理好系统中所有硬件软件资源，使之得到充分利用 提高系统效率 OS 合理组织好计算机的工作流程，以改进系统性能和提高系统效率 构筑开放环境 OS 遵循有关国际标准来设计和构造，以构筑出一个开放环境。含义主要是指：遵循有关国际标准（如开放的通信标准、开放的用户接口标准、开放的线程库标准等）；支持体系结构的可伸缩性和可扩展性；支持应用程序在不同平台上的可移植性和可互操作性 计算机系统包括硬件和软件两个组成部分。硬件是所有软件运行的物质基础，软件能充分发挥硬件潜能和扩充硬件功能，完成各种系统及应用任务，两者互相促进、相辅相成、缺一不可。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统的作用和功能 操作系统是用户与计算机硬件之间的接口 操作系统是计算机系统的资源管理者 处理器管理 处理器管理的第一项工作是处理中断事件。硬件只能发现中断事件，捕捉它并产生中断信号，但不能进行处理，配置了操作系统，就能对中断事件进行处理 处理器管理的第二项工作是处理器调度。处理器是计算机系统中一种稀有和宝贵的资源，应该最大限度地提高处理器的利用率。为了提高处理器的利用率，操作系统采用了多道程序设计技术。在多道程序或多用户的情况下，组织多个作业或任务执行时，就要解决处理器的调度、分配和回收等问题。为了实现处理器管理的功能，描述多道程序的并发执行，操作系统引入了进程的概念，处理器的分配和执行都是以进程为基本单位；随着并行处理技术的发展，为了进一步提高系统并行性，使并发执行单位的粒度变细，并发执行的代价降低，操作系统又引入了线程的概念。对处理器的管理和调度最终归结为对进程和线程的管理和调度，包括：（1）进程控制和管理；（2）进程同步和互斥；（3）进程通信；（4）进程死锁；（5）线程控制和管理；（6）处理器调度，又分高级调度，中级调度和低级调度。 正是由于操作系统对处理器的管理策略不同，其提供的作业处理方式也就不同，例如，批处理方式、分时处理方式、实时处理方式等等。从而，呈现在用户面前，成为具有不同处理方式和不同特点的操作系统。 存储管理 存储管理的主要任务是管理存储器资源，为多道程序运行提供有力的支撑，便于用户使用存储资源，提高存储空间的利用率。存储管理的主要功能包括： 存储分配。存储管理将根据用户程序的需要分配给它存储器资源，这是多道程序能并发执行的首要条件，当然程序运行结束时，还需回收存储资源。 存储共享。存储管理能让内存储器（又叫主存储器）中的多个用户程序实现存储资源的共享，以提高存储器的利用率。 地址转换与存储保护。存储管理负责把用户的逻辑地址转换成物理地址，同时要保证各个用户程序相互隔离起来互不干扰，更不允许用户程序访问操作系统的程序和数据，从而，保护系统和用户程序存放在存储器中的信息不被破坏。 存储扩充。由于受到处理器寻址能力的限制，一台计算机的物理内存容量总是有限的，难以满足用户大型程序的需求，而外存储器容量大且价格便宜。存储管理还应该能从逻辑上来扩充内存储器，把内存和外存混合起来使用，为用户提供一个比内存实际容量大得多的逻辑编程空间，方便用户的编程和使用。 设备管理 设备管理的主要任务是管理各类外围设备，完成用户提出的I/O请求，加快I/O信息的传送速度，发挥I/O设备的并行性，提高I/O设备的利用率，以及提供每种设备的设备驱动程序和中断处理程序，为用户隐蔽硬件细节，提供方便简单的设备使用方法。为实现这些任务，设备管理应该具有以下功能： 提供外围设备的控制与处理 提供缓冲区的管理 提供设备独立性 外围设备的分配和去配 实现共享型外围设备的驱动调度 实现虚拟设备 文件管理 文件管理则是针对系统中的信息资源的。在现代计算机中，通常把程序和数据以文件形式存储在外存储器（又叫辅存储器）上，供用户使用，这样，外存储器上保存了大量文件。 文件管理，它的主要任务是对用户文件和系统文件进行有效管理，实现按名存取；实现文件的共享、保护和保密，保证文件的安全性；并提供给用户一整套能方便使用文件的操作和命令。 具体来说，文件管理要完成以下任务： 提供文件的逻辑组织方法 提供文件的物理组织方法 提供文件的存取方法 提供文件的使用方法 实现文件的目录管理 实现文件的共享和存取控制 实现文件的存储空间管理 网络与通信管理 计算机网络源于计算机与通信技术的结合，联网操作系统至少应具有以下管理功能： 网上资源管理功能。计算机网络的主要目的之一是共享资源，网络操作系统应实现网上资源的共享，管理用户应用程序对资源的访问，保证信息资源的安全性和完整性。 数据通信管理功能。计算机联网后，结点之间可以互相传送数据，进行通信，通过通信软件，按照通信协议的规定，完成网络上计算机之间的信息传送。 网络管理功能。包括故障管理、安全管理、性能管理、记帐管理和配置管理等。 用户接口 为了使用户能灵活、方便地使用计算机和系统功能，操作系统还提供了一组友好的使用其功能的手段称用户接口，它包括两大类：程序接口和操作接口。用户通过这些接口能方便地调用操作系统功能，有效地组织作业及其工作和处理流程，并使整个系统能高效地运行。 操作系统的主要特性 并发性 并发性是指两个或两个以上的事件或活动在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在若干个运行着的程序，因此，它应该具有处理和调度多个程序同时执行的能力。 发挥并发性能够消除计算机系统中部件和部件之间的相互等待，有效地改善系统资源的利用率，改进系统的吞吐率，提高系统效率。 并发性虽然能有效改善系统资源的利用率，但却会引发一系列的问题，使操作系统的设计和实现变得复杂化。如：进程切换、进程调度、进程隔离保护、进程协作 在多处理器系统中，程序的并发性不仅体现在宏观上，而且体现在微观上，这称为并行的。并行性是指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同 CPU 上同时执行。而在分布式系统中，多台计算机的并存使程序的并发性得到了更充分的发挥，因为，同一时刻每台计算机上都可以有程序在执行。可见并行的事件或活动一定是并发的，但反之并发的事件或活动未必是并行的，并行性是并发性的特例，而并发性是并行性的扩展。由于并发技术的本质思想是：当一个程序发生事件（如等待 I/O）时出让其占用的 CPU 而由另一个程序运行，据此不难看出，实现并发技术的关键之一是如何对系统内的多个运行程序（进程）进行切换的技术。 共享性 共享指计算机系统中的资源（包括硬件资源和信息资源）可被多个并发执行的用户程序和系统程序共同使用，而不是被其中某一个程序所独占。 资源共享的方式可以分成两种： 互斥访问 系统中的某些资源如打印机、磁带机、卡片机，虽然它们可提供给多个程序使用，但在同一时间段内却只允许一个程序访问这些资源，即要求互相排斥地使用这些资源 同时访问 允许同一时间内多个程序对它们进行访问，这里“同时”是宏观上的说法，从微观上看多个程序访问资源仍然是交错的，只是这种交错访问的顺序对访问的结果没有影响罢了。典型的可供多个程序同时访问的资源是磁盘，各种可重入程序也可被同时访问 与共享性有关的问题是资源分配、信息保护、存取控制等，必须要妥善解决好这些问题。 共享性和并发性是操作系统两个最基本的特性，它们互为依存。一方面，资源的共享是因为程序的并发执行而引起的，若系统不允许程序并发执行，自然也就不存在资源共享问题。另一方面，若系统不能对资源共享实施有效管理，必然会影响到程序的并发执行，甚至程序无法并发执行，操作系统也就失去了并发性，导致整个系统效率低下。 异步性 在多道程序环境中，允许多个进程并发执行，由于资源有限而进程众多，多数情况下，进程的执行不是一贯到底，而是“走走停停”。 虚拟性 虚拟性是指操作系统中的一种管理技术，它是把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。显然，前者是实际存在的而后者是虚构假想的，采用虚拟技术的目的是为用户提供易于使用、方便高效的操作环境。比如：1个 CPU 被虚拟成两个、1台机器可以虚拟出多台的硬件 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统的形成和发展 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"人工操作阶段 初始操作系统尚未出现，由程序员采用手工方式直接控制和使用计算机硬件，程序员使用机器语言编程，并将事先准备好的程序和数据穿孔在纸带或卡片上，从纸带或卡片输入机将程序和数据输入计算机。然后，启动计算机运行程序，程序员可以通过控制台上的按钮、开关和氖灯来操纵和控制程序，运行完毕，取走计算输出的结果，才轮到下一个用户上机。 后来，汇编语言产生了，在汇编系统中，数字操作码被记忆码代替，程序按固定格式的汇编语言书写。系统程序员预先编制一个汇编程序，它把用汇编语言书写的“源程序”解释成计算机能直接执行的机器语言格式的目标程序。随后，一些高级程序设计语言相继出现进一步方便了编程。 执行时需要把汇编程序或编译系统以及源程序和数据，都穿在卡片或纸带上，然后，再装入和执行。 其大致过程为： 人工把源程序用穿孔机穿在卡片或纸带上 将准备好的汇编程序或编译系统装入计算机 汇编程序或编译系统读入人工装在输入机上的穿孔卡片或穿孔带上的源程序 执行汇编过程或编译过程，产生目标程序，并输出到目标卡片迭或纸带 通过引导程序把装在输入机上的目标程序读入计算机 执行目标程序，从输入机上读入人工装好的数据卡片或数据带上的数据 产生计算结果，把执行结果从打印机上或卡片机上输出 上述方式比直接用机器语言前进了一步，程序易于编制和读取，汇编程序或编译系统可执行存储、分配等辅助工作，从而，在一定程度上减轻了用户的负担。 人工操作方式存在严重缺点： 用户独占资源 人工干预较多 计算时间拉长 这种人工操作方式在慢速的计算机上还能容忍，但是随着计算机速度的提高，其缺点就更加暴露出来了。 此外，随着 CPU 速度迅速提高而 I/O 设备速度却提高不多，导致 CPU 与 I/O 设备之间的速度不匹配，矛盾越来越突出，需要妥善解决这些问题 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"管理程序阶段 早期批处理系统借助于作业控制语言变革了计算机的手工操作方式。用户不再通过开关和按钮来控制计算机的执行，而是通过脱机方式使用计算机，通过作业控制卡来描述对作业的加工和控制步骤，并把作业控制卡连同程序、数据一起提交给计算机的操作员，操作员收集到一批作业后一起把它们放到卡片机上输入计算机。计算机上则运行一个驻留在内存中的执行程序，以对作业进行自动控制和成批处理，自动进行作业转换以减少系统空闲和手工操作时间。其工作流程如下：执行程序将一批作业从纸带或卡片机输入到磁带上，每当一批作业输入完成后，执行程序自动把磁带上的第一个作业装入内存，并把控制权交给作业。当该作业执行完成后，执行程序收回控制权并再调入磁带上的第二个作业到内存执行。计算机在执行程序的控制下就这样连续地一个作业一个作业地执行，直至磁带上的作业全部做完。这种系统能实现作业到作业的自动转换，缩短作业的准备和建立时间，减少人工操作和干预，让计算机尽可能地连续运转。 早期的批处理系统中，一开始作业的输入和输出均是联机的，联机 I/O 的缺点是速度慢， I/O 设备和 CPU 仍然串行工作，CPU 时间浪费很大，为此，在批处理中引进了脱机 I/O 技术。除主机外，另设一台辅机，该机仅与 I/O 设备打交道，不与主机连接。输入设备上的作业通过辅机输到磁带上，这叫脱机输入；主机负责从磁带上把作业读入内存执行，作业完成后，主机负责把结果输出到磁带上，这叫脱机输出；然后，由辅机把磁带上的结果信息在打印机上打印输出。这称作脱机 I/O 技术。 为了发挥批处理系统的性能，缩短作业的准备和建立时间，驻留在内存工作的执行程序的功能得到了很大的扩充，进化到管理程序。FMS 和 IBSYS ）是这类系统的典型实例。 管理程序的内存组织如图所示，它的主要功能小结如下： 管理程序的内存组织 - 自动控制和处理作业流。管理程序把控制权传送给一个作业，当作业运行结束时，它又收回控制权，继续调度下一个作业执行，自动控制和处理作业流，减少了作业的准备和建立时间。作业流的自动控制和处理依靠作业控制语言，因而，促进了作业控制语言的发展。作业控制语言是由一些描述作业控制过程的语句组成的，每个语句附有一行作业或作业步信息编码，并以穿孔卡的形式提供。例如，$\\$JOB$ 卡表示启动一个新作业; $\\$FIN$ 卡表示调用 FORTRAN 编译系统; $\\$ASM$ 卡表示调用汇编程序；$\\$LOAD$ 卡表示调用装配程序；$\\$DATA$ 卡指定数据；$\\$RUN$ 卡执行用户程序；$\\$END$ 卡表示一个作业结束。管理程序通过输入、解释并执行嵌入用户作业的作业控制卡规定的功能，就能自动地处理用户作业流。每个作业完成后，管理程序又自动地从输入机上读取下一个作业运行，直到整批作业处理结束。 - 提供一套操作命令。操作员通过打字机输入命令，管理程序识别并执行命令，这样不仅速度快，操作员还可进行一些复杂的控制。输出信息也可由打字机输出，代替了早期的氖灯显示，易于理解。这种交互方式不仅提高了效率，也便于使用 - 提供设备驱动和 I/O 控制功能。系统提供标准 I/O 程序，用户通过管理程序获得和使用 I/O 设备，减轻了用户驱动物理设备的负担。管理程序还能处理某些特殊设备和设备故障，改进了设备的可靠性和可用性。 - 提供库程序和程序装配功能。库程序包括：汇编程序、FORTRAN 语言编译程序、标准 I/O 程序、标准子程序等。通常，用户程序必须调用库程序才能执行下去，装配工作由管理程序完成。所有程序都按相对地址编址，管理程序把相应库程序和用户程序进行装配，并转换成绝对地址形式的目标程序，以便执行。 - 提供简单的文件管理功能。用户通过输入设备输入程序和数据，为了反复使用，用户希望能把这些信息保存起来，以便随时使用，这就产生了文件系统。从此，用户可按文件名字，而不是信息的物理地址进行存取，方便灵活，安全可靠。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"多道程序设计与操作系统的形成 多道程序设计 在早期的单道批处理系统中，内存中仅有单个作业在运行，致使系统中仍有许多资源空闲，设备利用率低，系统性能较差。 单道算题运行时处理器的使用效率 当 CPU 工作时，外部设备不能工作；而外部设备工作时，CPU 必须等待。 20 世纪 60 年代初，有两项技术取得了突破：中断和通道，这两种技术结合起来为实现 CPU 和 I/O 设备的并行工作提供了基础，这时，多道程序的概念才变成了现实。 多道程序设计是指允许多个程序(作业)同时进入一个计算机系统的内存储器并启动进行交替计算的方法。也就是说，计算机内存中同时存放了多道（二个以上相互独立的）程序，它们均处于开始和结束点之间。从宏观上看是并行的，多道程序都处于运行过程中，但都未运行结束；从微观上看是串行的，各道程序轮流占用 CPU，交替地执行。引入多道程序设计技术的根本目的是提高 CPU 的利用率，充分发挥计算机系统部件的并行性，现代计算机系统都采用了多道程序设计技术。 操作系统的形成 第三代计算机的性能有了更大提高，机器速度更快，内外存容量增大，I/O 设备数量和种类增多，为软件的发展提供了有力支持。如何更好地发挥硬件功效，如何更好地满足各种应用的需要，这些都迫切要求扩充管理程序的功能。 中断技术 和 通道技术 的出现使得硬部件具有了较强的并行工作能力，从理论上来说，实现多道程序系统已无问题。但是，从半自动的管理程序方式过渡到能够自动控制程序执行的操作系统方式，对辅助存储器性能的要求增高。这个阶段虽然有个别的磁带操作系统出现，但操作系统的真正形成还期待着大容量高速辅助存储器的出现。 大约到 60 年代中期以后，随着磁盘的问世，相继出现了多道批处理操作系统和分时操作系统、实时操作系统，到这个时候标志着操作系统正式形成。 计算机配置操作系统后，其资源管理水平和操作自动化程度有了进一步提高，具体表现在： 操作系统实现了计算机操作过程的自动化。批处理方式更为完善和方便，作业控制语言有了进一步发展，为优化调度和管理控制提供了新手段 资源管理水平有了提高，实现了外围设备的联机同时操作, 进一步提高了计算机资源的利用率 提供虚存管理功能，由于多个用户作业同时在内存中运行，在硬件设施的支持下，操作系统为多个用户作业提供了存储分配、共享、保护和扩充的功能，导致操作系统步入实用化 支持分时操作，多个用户通过终端可以同时联机地与一个计算机系统交互 文件管理功能有改进，数据库系统开始出现 多道程序设计趋于完善，采用复杂的调度算法，充分利用各类资源，最大限度地提高计算机系统效率 操作系统的发展和分类 促使操作系统不断发展的主要动力有以下五个方面： 器件快速更新换代：CPU 性能快速提升 计算机体系结构不断发展：硬件的改进促使计算机技术的进步 提高计算机系统资源利用率的需要 让用户使用计算机越来越方便的需要 满足用户的新要求，提供给用户新服务 从操作系统形成以来，按照功能、特点和使用方式的不同，可把操作系统区分为三种基本类型： 批处理操作系统，特征如下： 用户脱机工作 成批处理作业 单/多个程序运行 分时操作系统，特征如下： 同时性。若干个终端用户同时联机使用计算机，分时就是指多个用户分享使用同一台计算机的 CPU 时间 独立性。终端用户彼此独立，互不干扰，每个终端用户感觉上好像他独占了这台计算机 及时性。终端用户的立即型请求（即不要求大量 CPU 时间处理的请求）能在足够快的时间之内得到响应（通常应该为 2 ~ 3 秒钟）。这一特性与计算机 CPU 的处理速度、分时系统中联机终端用户数目和时间片的长短密切相关 交互性。人机交互，联机工作，用户直接控制其程序的运行，便于程序的调试和排错。 分时操作系统和批处理操作系统虽然有共性，它们都基于多道程序设计技术，但存在下列不同点： 追求的目标不同。批处理系统以提高系统资源利用率和作业吞吐率为目标；分时系统则要满足多个联机用户立即型命令的快速响应。 适应的作业不同。批处理适应已经调试好的大型作业；而分时系统适应正在调试的小作业。 资源的利用率不同。批处理操作系统可合理安排不同负载的作业，使各种资源利用率较佳；分时操作系统中，多个终端作业使用相同类型编译系统、运行系统和公共子程序时，系统调用它们的开销较小。 作业控制的方式不同。批处理由用户通过 JCL 的语句书写作业控制流，预先提交，脱机工作；交互型作业，由用户从键盘输入操作命令控制，交互方式，联机工作。 实时操作系统；目前有三种典型的实时系统，过程控制系统、信息查询系统和事务处理系统。 微机操作系统；供个人使用 并行操作系统；计算机的应用经历了从数据处理到信息处理，从信息处理到知识处理，每前进一步都要求增加计算机的处理能力。 网络操作系统；计算机网络是通过通信设施将地理上分散的并具有自治功能的多个计算机系统互连起来的系统 分布式操作系统 操作系统提供的服务和用户接口 操作系统提供的基本服务 操作系统要为用户程序的执行提供一个良好的运行环境，它要为程序及其用户提供各种服务，当然不同的操作系统提供的服务不完全相同，但有许多共同点。 提供操作系统共性服务为程序员带来了方便，使编程任务变得更加容易，操作系统提供给程序和用户的共性服务大致有： 创建程序。提供各种工具和服务，程序的编辑工具和调试工具，帮助用户编程并生成高质量的源程序等服务 执行程序。将用户程序和数据装入主存，为其运行做好一切准备工作并启动和执行程序。当程序编译或运行出现异常时，应能报告发生的情况，终止程序执行或进行适当处理 数据I/O 信息存取。文件系统让用户按文件名来建立、读写、修改以及删除文件，使用方便，安全可靠。当涉及多用户访问或共享文件时，操作系统将提供信息保护机制 通信服务。在许多情况下，一个进程要与另外的进程交换信息，这种通信一般分为两种情况，一是在同一台计算机上执行的进程之间通信；二是在被网络连接在一起的不同计算机上执行的进程之间通信 错误检测和处理。操作系统能捕捉和处理各种硬件或软件造成的差错或异常，并让这些差错或异常造成的影响缩小在最小范围内，必要时及时报告给操作员或用户。 此外，操作系统除上述提供给用户的服务外，还具有另外一些功能，以保证它自身高效率、高质量地工作，从而，使得多个用户程序能够有效地共享系统资源，提高系统效率，这些功能有： 资源分配 统计 保护 操作系统提供的用户接口 操作系统可以通过程序接口和操作接口两种方式把它的服务和功能提供给用户，反过来也可以这样说，用户可以通过两个接口来调用操作系统提供的服务和功能 用户和操作系统间的两种接口 程序接口与系统调用 系统调用 系统调用的实现要点 系统调用与过程（函数）调用的区别 程序中执行系统调用或过程（函数）调用，虽然都是对某种功能或服务的需求，但两者从调用形式到具体实现都有很大区别。 调用形式不同。过程（函数）使用一般调用指令，其转向地址是固定不变的，包含在跳转语句中，但系统调用中不包含处理程序入口，而仅仅提供功能号，按功能号调用 被调用代码的位置不同。过程（函数）调用是一种静态调用，调用程序和被调用代码在同一程序内，经过连接编辑后作为目标代码的一部份。当过程（函数）升级或修改时，必须重新编译连接。而系统调用是一种动态调用，系统调用的处理代码在调用程序之外（在操作系统中），这样一来，系统调用处理代码升级或修改时，与调用程序无关。而且，调用程序的长度也大大缩短，减少了调用程序占用的存储空间。 提供方式不同。过程（函数）往往由编译系统提供，不同编译系统提供的过程（函数）可以不同；系统调用由操作系统提供，一旦操作系统设计好，系统调用的功能、种类与数量便固定不变了。 调用的实现不同。程序使用一般机器指令（跳转指令）来调用过程（函数），是在用户态运行的；程序执行系统调用，是通过中断机构来实现，需要从用户态转变到核心态，在管理状态执行。因此程序执行系统调用安全性好 Linux 的系统调用 每个系统调用由两部分组成： 核心函数：是实现系统调用功能的（内核）代码，它运行在核心态，数据也存放在内核空间，通常它不能再使用系统调用，也不能使用应用程序可用的库函数。 接口函数：是提供给应用程序的 API，以库函数形式存在，该库中存放了所有系统调用的接口函数的目标代码，用汇编语言书写。其主要功能是把系统调用号、入口参数地址传送给相应的核心函数，并使用户态下运行的应用程序陷入核心态（Linux内核陷入由 0X80 中断实现，调用流程：1. 取系统调用号，检验合法性；2. 建立调用堆栈，保护现场信息；3. 根据系统调用号定位核心函数地址；4. 根据通用寄存器内容，从用户栈中取入口参数；5. 核心函数执行，把结果返回应用程序； 6. 执行退栈操作，判别调度程序 scheduler 是否要被执行）。 操作接口与系统程序 作业控制方式 命令解释程序 系统程序 操作系统的结构设计 操作系统的构件 内核 进程 线程 管程 类程 整体式结构的操作系统 层次式结构的操作系统 虚拟机结构的操作系统 客户/服务器与微内核结构的操作系统 客户/服务器与微内核结构 微内核的设计 操作系统的运行模型 非进程内核模型 OS 功能（函数）在用户进程内执行的模型 OS 功能（函数）作为独立进程执行的模型 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"总结 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:4","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"处理器管理 处理器管理是操作系统的重要组成部分，它负责管理、调度和分派计算机系统的重要资源———处理器，并控制程序的执行。由于处理器管理是操作系统中最核心的组成部分，任何程序的执行都必须真正占有处理器，因此，处理器管理直接影响系统的性能。 操作系统的基本任务是对“进程”实施管理，操作系统必须有效控制进程的执行、给进程分配资源、允许进程之间共享和交换信息、保护每个进程在运行期间免受其他进程干扰、控制进程的互斥、同步和通信。为达到这些要求，操作系统的处理器管理必须为每一个进程维护一个数据结构，用以描述该进程的状态和分配到的资源，并允许操作系统行使对进程的控制权。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:4:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中央处理器 计算机系统的核心是中央处理器。如果一个计算机系统只包括一个运算处理器，称之为单处理器系统。如果有多个运算处理器，则称之为多处理器系统。 早期的计算机系统是基于单个处理器的顺序处理机器，每一条指令的执行也是串行的，为提高计算机处理的速度，首先发展起来的是联想存储器系统和流水线系统，前者提出了数据驱动的思想，后者解决了指令并行执行的问题，这两者都是最初计算机并行化发展的例子。 随着硬件技术的进步，并行处理技术得到了迅猛的发展，计算机系统不再局限于单处理器和单数据流，各种各样的并行结构得到了应用。 目前计算机系统可以分作以下四类： 单指令流单数据流（SISD）。一个处理器在一个存储器中的数据上执行单条指令流。 单指令流多数据流（SIMD）。单条指令流控制多个处理单元同时执行，每个处理单元包括处理器和相关的数据存储，一条指令事实上控制了不同的处理器对不同的数据进行了操作。向量机和阵列机是这类计算机系统的代表。 多指令流单数据流（MISD）。一个数据流被传送给一组处理器，通过这一组处理器上的不同指令操作最终得到处理结果 多指令流多数据流（MIMD）。多个处理器对各自不同的数据集同时执行不同的指令流。可以把 MIMD 系统划分为共享内存的紧密耦合 MIMD 系统和内存分布的松散耦合 MIMD 系统两大类。 根据处理器分配策略，紧密耦合 MIMD 系统可以分为主从式系统 MSP 和对称式系统 SMP 两类。 主从式系统的基本思想是：在一个特别的处理器上运行操作系统内核，其他处理器上则运行用户程序和操作系统例行程序，内核负责分配和调度各个处理器，并向其他程序提供各种服务（如输入输出）。这种方式实现简单，但是主处理器的崩溃会导致整个系统的崩溃，并且极可能在主处理器形成性能瓶颈。 在对称式多处理器系统中有两个或两个以上的处理器，操作系统内核可以运行在任意一个处理器上。每个处理器都可以自我调度运行的进程和线程，单个进程的多个线程可在不同处理器上同时运行，服务器进程可以使用多个线程去处理同时来自多个客户的请求，并且操作系统内核也被设计成多进程或多线程，内核的各个部分可以并行执行。 对称多处理器是迄今为止开发出的最为成功的两种并行机之一，有一种 SMP 机最多可支持 64 个处理器，多个处理器之间采用共享主存储器。SMP 机有对称性、单一地址空间、低通信延迟和一致的高速缓存等特点，具有高可靠性、可扩充性、易伸缩性。这一系统中任何处理器都可以访问任何存储单元及 I/O 设备；处理器之间通信代价很低，而并行度较高。 由于共享存储器中只要保存一个操作系统和数据库副本，既有利于动态负载平衡，又有利于保证数据的完整性和一致性。 在松散耦合 MIMD 系统中，每个处理单元都有一个独立的内存储器，各个处理单元之间通过设定的线路或网络通信，多计算机系统和集群系统都是松散耦合 MIMD 系统的例子。 集群系统是迄今为止开发出的另一种最为成功的并行机，它是一组互联的计算机系统。因此也是分布式系统的一种，集群操作系统也是分布式操作系统的一个品种。集群系统运行时构成统一的计算资源，给人以一台机器的感觉。集群系统的配置一般有两种方法，一是各个节点计算机自带磁盘，二是多个节点计算机共享 RAID 磁盘。 在集群系统中，每一台计算机都是一个完整的节点，离开集群后自己可以独立地工作，所以一个节点的失效并不意味着服务的失败，从而使集群系统具备很好的容错性。集群系统还具有很好的可伸缩性，可以用低成本的微机和以太网设备等产品构成。 寄存器 计算机系统的处理器包括一组寄存器，其个数根据机型（处理器型号）的不同而不同，它们构成了一级存储，虽然比主存储器容量要小的多，但是访问速度要快的多。这组寄存器所存储的信息与程序的执行有很大的关系，构成了处理器现场。 不同类型的处理器具有不同的寄存器组成。一般来说，这些寄存器可以分为以下几类： 通用寄存器。可由程序设计者指定许多功能，如存放操作数或用作寻址寄存器。 数据寄存器。用以存放操作数。它们作为内存数据的高速缓存，可以被系统程序和用户程序直接使用并进行计算。 地址寄存器。用于指明内存地址，如索引寄存器、段寄存器（基址/限长）、堆栈指针寄存器等。 I/O 地址寄存器。用于指定 I/O 设备 I/O 缓冲寄存器。用于处理器和 I/O 设备交换数据 控制寄存器。用于存放处理器的控制和状态信息，它至少应该包括程序计数器 PC 和指令寄存器 IR，中断寄存器以及用于存储器和 I/O 模块控制的寄存器。此外还有存放将被访问的存储单元地址的存储器地址寄存器，以及存放从存储器读出或欲写入的数据的存储器数据寄存器。 特权指令与非特权指令 计算机的基本功能是执行程序，而最终被执行的程序是存储在内存中的机器指令。处理器根据程序计数器（PC）内存中取一条指令到指令寄存器（IR）并执行它，PC 将自动地增长或改变为转移地址以指明下一条要执行的指令的入口地址。 每台计算机的机器指令的集合称指令系统，它反映了一台机器的功能和处理能力，可以分为以下五类： 数据处理类指令：用于执行算术和逻辑运算 转移类指令：如无条件转移、条件转移、计数转移等用于改变指令执行序列 数据传送类指令：用于在处理器的寄存器和寄存器、寄存器和存储器单元、存储器单元和存储器之间交换数据 移位与字符串指令，移位分算术、逻辑和循环移位。字符串处理有字符串的传送、比较、查询和转换。 I/O类指令：用于启动外围设备，让主存和外围设备之间交换数据 引入操作系统后，操作系统核心程序可以使用全部机器指令，但用户程序只能使用机器指令系统的一个子集。这是因为，用户程序执行一些有关资源管理的机器指令时很容易导致系统混乱，造成系统或用户信息的破坏。 因此，在多道程序设计环境中，从资源管理和控制程序执行的角度出发，必须把指令系统中的指令分作两类：特权指令和非特权指令。 所谓特权指令是指那些只能提供给操作系统的核心程序使用的指令，如启动输入 % 输出设备、设置时钟、控制中断屏蔽位、清内存、建立存储键，加载 PSW 等。只有操作系统才能执行全部指令（特权指令和非特权指令），如果一般用户执行特权指令，会导致非法执行而产生保护中断，转交给操作系统的“用户非法执行特权指令”的特殊处理程序处理。 处理器状态 那么，中央处理器怎么知道当前是操作系统还是一般用户在其上运行呢？这将依赖于处理器状态的标志。在执行不同程序时，根据执行程序对资源和机器指令的使用权限把处理器设置成不同状态。 处理器状态又称为处理器的运行模式，有些系统把处理器状态划分为核心状态、管理状态和用户状态，而大多数系统把处理器状态简单划分为管理状态（又称特权状态、系统模式、特态或管态）和用户状态（又称目标状态、用户模式、常态或目态）。 当处理器处于管理状态时，程序可以执行全部指令，访问所有资源，并具有改变处理器状态的能力；当处理器处于用户状态时，程序只能执行非特权指令。 Intel 奔腾处理器由四种状态，支持 4 个特权级别，0 级权限最高，3 级权限最低。 0 级为操作系统内核级。处理 I/O 、存储管理和其他关键操作。 1 级为系统调用处理程序级。用户程序可以通过调用这里的过程执行系统调用，但是只有一些特定的和受保护的过程可以被调用。 2 级为共享库过程级。它可以被很多正在运行的程序共享，用户程序可以调用这些过程，读取它们的数据，但是不能修改它们。 3 级为用户程序级。它受到的保护最少。 当然，各个操作系统在实现过程中可以根据具体策略有选择地使用硬件提供的保护级别，如运行在 奔腾 上的 windows 操作系统只使用了 0 级 和 3 级。 下面两类情况会导致从用户态向管理状态转换 程序请求操作系统服务，执行一条系统调用 程序运行时，产生了一个中断事件，运行程序被中断，让中断处理程序工作 这两类情况都是通过中断机构才发生的，可以说中断是目态到管态转换的惟一途径。当系统中断响应交换程序状态字时，这个处理中断事件的处理程序的程序状态字的处理器状态位标志一定为“管态”。怎样实现管态到目态的转换呢？每台计算机通常会提供一条特权指令称作加载程序状态字 LPSW (Load PSW)，用来实现操作系统向用户程序的转换。 程序状态字寄存器 操作系统通过引入程序状态字 PSW (Program Status Word) 来区别不同的处理器工作状态。 ，程序状态字用来指示处理器状态、控制指令的执行顺序并且保留和指示与运行程序有关的各种信息，其主要作用是方便地实现程序状态的保护和恢复。每个正在执行的程序都有一个与其执行相关的 PSW ，而每个处理器都设置一个程序状态字寄存器。 一个程序占有处理器执行，它的 PSW 将占有程序状态字寄存器。 一般来说，程序状态字寄存器包括以下几类内容： 程序基本状态。包括： 程序计数器：指明下一条执行的指令地址； 条件码：表示指令执行的结果状态； 处理器状态位：指明当前的处理器状态，如目态或管态、运行或等待。 中断码。保存程序执行时当前发生的中断事件。 中断屏蔽位。指明程序执行中发生中断事件时，是否响应出现的中断事件。 由于不同处理器中的控制寄存器组织方式不同，所以在大多数计算机的处理器现场中可能找不到一个称为程序状态字寄存器的具体寄存器，但总是有一组控制与状态寄存器实际上起到这一作用。 在 Intel 奔腾中，程序状态字由标志寄存器 EFLAGS 和指令指针寄存器 EIP 组成，均为 32 位。EFLAGS 的低 16 位称 FLAGS，可当作一个单元来处理。标志可划分为三组：状态标志、控制标志、系统标志。 状态标志：它使得一条指令的执行结果影响后面的指令。算术运算指令使用 OF","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:4:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断技术 现代计算机中都配置了硬件中断装置，中断机制是操作系统的重要组成部分之一。 每当用户程序执行系统调用以求获得系统的服务和帮助、或操作系统管理 I/O 设备和处理形形色色的内部和外部事件时，都需要通过中断机制进行处理。所以，也有人说操作系统是由 “中断驱动” 的。 中断是指程序执行过程中，当发生某个事件时，中止 CPU 上现行程序的运行，引出处理该事件的服务程序执行的过程。 在提供中断装置的计算机系统中，在每两条指令或某些特殊指令执行期间都检查是否有中断事件发生，若无则立即执行下一条或继续执行，否则响应该事件并转去处理中断事件。 中断这种处理突发事件的能力是由硬件和软件协作完成的。首先，由硬件的中断装置发现产生的中断事件，然后，中断装置中止现行程序的执行，引出处理该事件的程序来处理。 计算机系统不仅可以处理由于硬件或软件错误而产生的事件，而且可以处理某种预见要发生的事件。例如，外围设备工作结束时，也发出中断请求，向系统报告它已完成任务，系统根据具体情况做出相应处理。 引起中断的事件称为中断源。发现中断源并产生中断的硬件称中断装置。在不同的硬件结构中，通常有不同的中断源和不同的中断装置，但它们有一个共性，即当中断事件发生后，中断装置能改变处理器内操作执行的顺序，可见中断是现代操作系统实现并发性的基础之一。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:5:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断源分类 从中断事件的性质和激活的手段来说，可以分成强迫性中断事件和自愿性中断事件两大类。 强迫性中断事件不是正在运行的程序所期待的，而是由于随机发生的某种事故或外部请求信息所引起的。这类中断事件大致有以下几种： 机器故障中断事件。例如电源故障、主存储器出错等 程序性中断事件。例如定点溢出、除数为0、地址越界等。由于这类中断反映程序执行中发现的例外情况，所以又称异常 外部中断事件。例如时钟的定时中断、控制台发控制信息等 输入输出中断事件。例如设备出错、传输结束等 自愿性中断事件是正在运行的程序所期待的事件。这种事件是由于执行了一条访管指令而引起的，它表示正在运行的程序对操作系统有某种需求，一旦机器执行到一条访管指令时，便自愿停止现行程序的执行而转入访管中断处理程序处理。例如，要求操作系统协助启动外围设备工作。 两类中断事件的响应过程略有不同，详见图： 两类中断事件 还可以按照中断信号的来源，把中断分为外中断和内中断两类： 外中断。一般又称中断，是指来自处理器和主存储器之外的中断，包括电源故障中断、时钟中断、控制台中断、它机中断和 I/O 中断等。每个不同的中断具有不同的中断优先级，在处理高一级中断时，往往会屏蔽部分或全部低级中断。 内中断。是指来自处理器和主存内部的中断，一般又称异常，包括通路校验错、主存奇偶错、非法操作码、地址越界、页面失效、调试指令、访管中断、算术操作溢出等各种程序性中断。其中访管中断是由机器指令提供的特殊指令，该指令执行时将会引起内中断。异常是不能被屏蔽的，一旦出现应立即响应并加以处理。 中断和异常的区别如下： 中断：中断是由与现行指令无关的中断信号触发的，所以它是异步的，而且中断的发生与 CPU 处在用户模式或内核模式无关，通常在两条机器指令之间才可以响应中断，一般来说，中断处理程序提供的服务不是为当前进程所需要的，如时钟中断、硬盘读写服务请求中断 异常：异常则是由处理器正在执行现行指令而引起的。因而一条指令执行期间允许响应陷入。通常，异常处理程序提供的服务是为当前进程所用的。异常包括很多方面，有出错，也有陷入。出错和陷入的主要一点区别是：它们发生时保存的返回指令地址不同，出错保存指向触发异常的那条指令，而陷入保存指向触发异常的那条指令的下一条指令。因此，当从异常返回时，出错会重新执行那条指令，而陷入就不会重新执行那条指令。 上述的内中断与外中断（中断和异常）要通过硬件设施来产生中断请求，可以看作硬中断。与其相对应的不必由硬件发信号而能引发的一种中断称为软中断，软中断是利用硬件中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。它通常是由内核或进程对某个进程发出的中断信号，可以看作内核与进程或进程与进程之间用来模拟硬中断的一种信号通信方式。 软中断和硬中断两者的共同点是：当中断源产生中断请求或发出软中断信号后，CPU 或者接收进程在适当的时机自动进行中断处理或完成软中断信号所对应的功能。这里所说适当时机表示接收的硬中断会及时获得中断处理程序的处理，但接收软中断信号的进程不一定正好在接到此信号时占有处理器，而相应的软中断信号处理必需等到该接收进程获得处理器后才能进行，通常会有一定时间的延迟。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断装置 发现中断源并产生中断的硬件称中断装置，这些硬件包括中断逻辑线路和中断寄存器。 迄今为止，所有的计算机系统都采用硬件和软件（硬件中断装置和软件中断处理程序）结合的方法实现中断处理。 一般来说，硬件中断装置主要做以下三件事： 发现中断源，响应中断请求。当发现多个中断源时，它将根据规定的优先级，先后发出中断请求。 保护现场。将运行程序中断点在处理器中某些寄存器内的现场信息（又称运行程序的执行上下文）存放于内存储器。使得中断处理程序运行时，不会破坏被中断程序的有用信息，以便在中断处理结束后能够返回被中断程序继续运行。 启动处理中断事件的中断处理程序，处理器状态已从目态被切换到管态。 中断来源于正在执行的程序以及计算机系统的各个部件，甚至计算机的外部环境。当一个具体的中断事件发生时，计算机的硬件中断装置必须把它记录下来。中断寄存器是用来记录中断事件的寄存器，中断寄存器的内容称中断字，中断字的每一位对应一个中断事件。每当一条机器指令执行结束的时刻，中断控制部件扫描中断字，查看是否有中断事件发生，若是则处理器便响应这个中断请求。 当中断发生后，中断字的相应位会被置位。由于同一时刻可能有多个中断事件发生，中断装置将根据中断屏蔽要求和中断优先级选取一个，然后把中断寄存器的内容送入程序状态字寄存器的中断码字段，且把中断寄存器的相应位清“0”当处理中断事件的程序执行时就可以读出中断信息进行分析，从而知道发生了什么中断事件。 紧接着中断装置进行必要的保护现场工作。此时并不一定要将处理器中所有寄存器中的信息全部存于（写回）存储器中，但是，对程序状态字寄存器中的那些信息一定要保护起来。最后，将中断处理程序的程序状态字送入现行程序状态字寄存器，这就引出了相应的中断事件处理程序。 IBM中大型机中断响应过程 如果把被中断的程序的程序状态字称为旧程序状态字，而把中断处理程序的程序状态字称为新程序状态字的话，如何来实现新旧程序状态字的交换呢？通常，系统为每一种中断都开辟了主存的固定单元存放新的和旧的程序状态字。 下图是 IBM 中大型机中断响应过程，主存中开辟了专用的双字单元（用16进制标出），用于存放各类中断的旧的和新的 PSW（分别为旧的和新的外中断、访管中断、程序中断、机器故障中断和 I/O 中断），CPU 中还有硬件程序状态字寄存器保存运行程序的现行 PSW。 IBM PC 中断的响应过程 当响应中断时，由硬件执行 1 把中断码装配到现行 PSW 中，然后，执行 2 把现行 PSW 保存到中断类相应的旧 PSW 单元；同时，执行 3 把中断类相应的新 PSW 加载到现行 PSW ，这就引出了相应中断类的中断处理程序。中断事件处理结束后，如果执行 4 便可从断点返回继续执行被中断的程序。 在 IBM PC 机上，为了方便地找到中断处理程序，通常在计算机内存的低地址处开辟了一个称为中断向量表的区域。表中每一项称为一个中断向量，其中存放了一个中断处理程序的入口地址及相关信息，不同中断源需要用不同的中断处理程序处理，也就对应了不同的中断向量。 另外，采用堆栈方式保存被中断程序的状态信息，当发现中断源并响应中断时，中断装置将把现行 PSW 内容压进堆栈，接着再把指令指针 IP 和代码段基地址内容也压进堆栈，这就保存了原运行程序的状态。处理器根据硬件中断装置提供的中断向量号，获得被接受的中断请求的中断向量地址，再按照中断向量地址把中断处理程序的 PSW 送入现行程序状态字寄存器，加载新的程序状态字。从而，就引出了处理特定中断事件的中断处理程序。返回原程序时，只要把栈顶内容弹出送入现行 IP、CS和PSW中。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断处理程序 处理中断事件的程序称为中断处理程序。它的主要任务是处理中断事件和恢复正常操作。由于不同中断源对应不同中断处理程序，故快速找到中断处理程序的入口地址是一个关键问题。寻找入口地址可用如下办法：在主存储器(常在低地址区)设置一张向量地址表，存储单元的地址对应向量地址，存储单元的内容为入口地址。CPU 响应中断后，根据预先规定的次序找到相应向量地址，便可获得该中断事件处理程序的入口地址。 一个操作系统设计者将根据中断的不同类型和不同的应用环境，来确定不同的处理原则。 具体地讲，一个中断处理程序主要做以下四项工作： 保护未被硬件保护的一些必需的处理状态。例如，将通用寄存器的内容保存到主存储器，从而使中断处理程序在运行中可以使用通用寄存器 识别各个中断源，分析产生中断的原因。 处理发生的中断事件。中断处理程序将根据不同的中断源，进行各种处理操作。有简单的操作，如置一个特征标志；也有相当复杂的操作，如重新启动磁带机倒带并执行重读操作。 恢复正常操作。恢复正常操作一般有几种情况：恢复中断前的程序按断点执行；重新启动一个新的程序或者甚至重新启动操作系统。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断事件的具体处理方案 机器故障中断事件的处理 一般来说，这种事件是由硬件的故障产生的，排除这种故障必须进行人工干预。中断处理能做的工作一般是保护现场，防止故障蔓延，报告给操作员并提供故障信息以便维修和校正，以及对程序中所造成的破坏进行估价和恢复。下面列举一些硬件失效中断事件的处理办法。 电源故障的处理 当电源发生故障，例如断电时，硬设备能保证继续正常工作一段时间。操作系统利用这段时间可以做以下三项工作： 将处理器中有关寄存器内的信息经主存储器送到磁盘保存起来，以便在故障排除后恢复现场，继续工作。 停止外围设备工作。有些外围设备（例如磁带机）不能立即停止，中断处理程序将把这些正在交换信息又不能立即停止的设备记录下来。 停止处理器工作。一般可以让主机处于停机状态，此时，整个系统既不执行指令又不响应中断。 当故障排除后，操作员可以从一个约定点启动操作系统以恢复工作。恢复程序做的主要工作是： 恢复中断前的有关现场 启动被停止的外围设备继续工作 如果发生故障时有不能立即停止的外围设备正在工作，那么，涉及这些外围设备的程序将被停止执行而等待操作员的干预命令 完成上述各项工作后，系统将选择可以运行的程序继续运行 主存储器故障的处理 主存储器的奇偶校验或海明校验装置发现主存储器读写错误时，就产生这种中断事件。中断处理程序首先停止与出现的中断事件有关的程序的运行。然后向操作员报告出错单元的地址和错误的性质。 程序性中断事件的处理 处理程序性中断事件大体上有两种办法。 对于那些纯属程序错误而又难以克服的事件，例如非法使用特权指令，企图访问一个不允许其使用的主存储器单元等，操作系统只能将出错程序的名字、出错地点和错误性质报告给操作员并请求干预。 对于其他一些程序性中断，例如定点溢出、阶码下溢等，不同的用户往往有不同的处理要求。所以，操作系统可以将这种程序性中断事件转交给用户程序自行处理。 如果用户程序对发生的中断事件没有提出处理办法，那么操作系统将进行标准处理。 用户怎样来编制处理中断事件的程序呢？有些语言提供了称之为 on 语句的调试语句，它的形式如下： on \u003c条件\u003e \u003c中断续元入口\u003e 比如： // 每当发生定点溢出时，转向以 LA 为标号的语句 on fixed overflow go to LA; // 对于发生在不同地方的同一种程序性中断事件允许用户采用不同的处理方法。 // 例如，在执行了上述调试语句后又执行调试语句： on fixed overflow go to LB; // 就表示今后再发生溢出时将转向 LB 而不是转向 LA 去处理了 有了调试语句后，用户用程序设计语言编制程序时，也就可以编写处理程序性中断事件的程序了。编译程序为每个用户设置一张中断续元入口表，且在编译源程序产生目标程序时，把调试语句翻译成一段程序。其功能是：将中断续元入口地址送入中断续元入口表中对应该语句的中断条件的那一栏。中断续元入口表的形式如图: 中断续元入口 对应每一个用户处理的中断事件，表格中有一栏用以填写处理该中断事件的中断续元入口地址。如果用户没有给出处理其中断事件的中断续元时，相应栏的内容为0。当程序运行执行到调试语句时，就将中断续元的入口地址送入相应栏内。 显然，对于同一中断事件，当执行第二次对应该事件的调试语句时，就将第二次规定的中断续元入口地址填入表内相应栏中而冲去了第一次填写的内容。这就是上面所说的，利用对同一条件多次使用调试语句时，可以做到对发生于不同地点的同一种中断事件采用不同的处理方法。 当发生程序中断事件后，操作系统是怎样转交给用户程序去处理的呢？操作系统只要根据中断事件查看表中对应栏，如果对应栏为“0”它表示用户未定义该类中断续元，此时系统将按规定的标准办法进行处理。例如，将程序停止下来，向操作员报告出错位置和性质，或者置之不顾，就好像什么事也没有发生一样。如果对应栏不为“0”，则强迫用户程序转向中断续元去处理。 如果在中断续元的执行中又发生中断事件时，就不能这样简单地处理了。首先，中断续元的嵌套一般应规定重数，在上面的表格中规定嵌套重数为2。表格第一栏的第 0 字节记录了第一次进入中断续元的事件号；第 1 个字节记录了第二次（嵌套）进入中断续元的事件号。其次，中断续元的嵌套不能递归，例如，处理定点溢出的中断续元，在执行时不允许又发生定点溢出程序性中断事件。 下面按步骤小结一下中断续元的处理过程和原则： 编译程序编译到 on 语句时，生成填写相应中断续元入口表的目标代码段； 程序运行执行到 on 语句时，根据中断条件号，将中断续元入口填入相应栏，这是通过执行上述代码段来实现的； 执行同一中断条件号的 on 语句时，中断续元入口被填入同一栏，从而，用户可在他的程序的不同部分对同一中断条件采用不同的处理方法； 每当一个中断条件发生时，检查中断续元入口表相应栏，或转入中断续元处理，或进行操作系统标准处理； 程序性中断处理允许嵌套，应预先规定嵌套重数，但不允许递归。 外部中断事件的处理 时钟定时中断以及来自控制台的信息都属外部中断事件，它们的处理原则如下： 时钟中断事件的处理 时钟是操作系统进行调度工作的重要工具，如让分时进程作时间片轮转、让实时进程定时发出或接收控制信号、系统定时唤醒或阻塞一个进程、对用户进程进行记账。 时钟可以分成绝对时钟和间隔时钟（即闹钟）两种。利用计时器能确保操作系统必要时获得控制权，例如，陷入死循环的进程最终因时间片耗尽会被迫出让处理器。 系统设置一个绝对时钟寄存器，计算机的绝对时钟定时地（例如每 10 ms）把该寄存器的内容加 1。如果开始时这个寄存器的内容为 0，那么，只要操作员告诉系统开机时的年、月、日、时、分、秒，以后就可推算出当前的年、月、日、时、分、秒了。当绝对时钟寄存器记满溢出时，就产生一次绝对时钟中断，操作系统处理这个中断时，只要在主存的固定单元上加 1 就行了。这个固定单元记录了绝对时钟中断的次数，这样就可保证有足够的计时量。计算当前时间时，只要按绝对时钟中断的次数和绝对时钟寄存器的内容推算就可得到。 间隔时钟是定时将一个间隔时钟寄存器的内容减 1，当间隔时钟寄存器的内容为 0 时，就产生一个间隔时钟中断。所以，只要在间隔时钟寄存器中放一个预定的值，那么就可起到闹钟的作用，每当产生一个间隔时钟中断，就意味着预定的时间到了。操作系统经常利用间隔时钟作控制调度。 时钟硬件做的工作仅仅是按已知时间间隔产生中断，其余与时间有关的任务必须由软件来做，不同的操作系统有关时钟的任务不同，但一般包括以下内容： 维护绝对日期和时间 防止进程的运行时间超出其允许值，发现陷入死循环的进程 对使用 CPU 的用户进程记账 处理进程的间隔时钟（闹钟) 对系统的功能或部件提供监视定时器 在 Intel x86/奔腾 微机中，Linux利用 CMOS 中记录的时间作为系统启动时的基准时间，在系统运行时，利用时钟滴答来维护系统的时间。Linux 使用一个全局变量称 jiffies(瞬时)作为所有系统时间的测量基准，系统启动时，CMOS 中记录的时间转化为从 1970年1月1日0时0分0秒(UNIX纪元)算起的 jiffies 值(累积秒数)。操作系统中需要有定时服务的机制，以实现准时调度任务或处理与时间相关的工作，这些都是通过定时器机制来实现的。 Linux定时器机制 Linux 中存在两种类型的系统定时器，这两种定时器都具有对应的处理例程，必须在到达给定的系统时间时被进程调用，但实现方法有些不同。第一类是老的定时器机制，有一个 CA 个指针的数组定义的定时器。每个指针可指向一个 timer-struct 结构，而 timer-active 是活动定时器的掩码，数组元素是静态定义的，在系统初始化时入口被加到该数组中。第二类是新的定时器机制，突破了 32 个定时器的限制，使用一个 timer-list 数据结构的链表，按定时器到期时间的升序排列。两类定时器中 expires 给出该定时器被激活的时间，而 *fn() 指出定时器激活后的处理函数。 两类定时器都使用 jiffies 值作为到期比较时间。例如，某个定时器要在 2s 之后到期，则必须将 2s 转换成对应的 jiffies 值，加上当前的系统时间(也是以 jiffies 为单位)后，得到的便是该定时器到期的系统时间 expires。每次系统时钟滴答到来时，定时器 bottom half 处理过程被标记为活动状态，这样当调度程序下次运行时，定时器队列能获得处理。定时器 buttom half 处理过程要处理两种类型的系统定时器。对于老的系统定时器，检查 timer-active 中被置位的位掩码，以便确定活动的定时器。如果一个活动的定时器到期，便调用对应的定时器例程，timer-active 对应位被清除。对于新的系统定时器，检查链表中的 timer-list 数据结构。每个到期的定时器将被从链表中移出，对应的定时器例程被调用。新的定时器机制的优点是能传递参数 data 到定时器例程中。 有了上述定时器，Linux 就可以统计用户的记账信息，它记录进程的创建时间及进程在生命周期占用的 CPU 时间。每个时钟滴答到来时，核心都修改当前进程在内核态和用户态占用的时间，这些时间称为记账信息。对于不同的时间，Linux 运行了不同的间隔定时器，这些间隔定时器的类型有三种： real 这种间隔定时器按实际时间计时，不管进程处在何种模式下运行（包括进程被挂起时），计时总在进行，当定时到达时发送给进程一个 SIGALRM 信号 virtual 这种间隔定时器仅当进程在用户态下执行时才计时，当定时到达时发送","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["linux"],"content":"imx6ull emmc镜像制作 ","date":"2022-03-16","objectID":"/2022/03/0004-imx6ull%E7%83%A7%E5%86%99%E9%95%9C%E5%83%8F/:1:0","tags":["linux","imx6ull"],"title":"Imx6ull烧写镜像","uri":"/2022/03/0004-imx6ull%E7%83%A7%E5%86%99%E9%95%9C%E5%83%8F/"},{"categories":["linux"],"content":"什么是buildroot buildroot 是一个简单、高效、易用的工具，能够利用交叉编译生成嵌入式linux系统 ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:1:0","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"buildroot 项目 ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:2:0","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"拉取buildroot源码 https://github.com/imx6ull-pro/buildroot.git buildroot 配置编译选项 查询可用目标系统 make list-defconfigs 选定目标系统 make imx6ullevk_defconfig 打开配置菜单 make menuconfig # 或 make nconfig 查看帮助 make help ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:2:1","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"gvfs 介绍 gvfs 是 GNOME 用户空间虚拟文件系统的缩写，从 GLib 2.15.1 开始加入系统，主要是对 I/O 的一层抽象。gvfs 提供了一些模块，这些模块由使用 libgio 的 API 应用程序自动使用。也通过 fuse，允许不适用 gio 的应用程序可以访问 gvfs 文件系统。 访问虚拟文件系统的前提是挂载文件系统，gvfs 提供了一个守护进程——gvfsd来协调处理模块，每个模块都与 gvfsd 通过 gio 进行通信信。gvfs带有一些后端，这些后端实现了回收站、sftp、ftp、webdav、以及本地数据相关支持，都是作为 gvfs 功能实现的一部分。 gvfs 还包括用于 gio 实现卷监视器。 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:1:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfs守护进程说明 守护进程 功能 gvfsd 是gvfs主要守护程序。它通过org.gtk.vfs.Daemon名连接到dbus会话总线上，当gvfsd没有启动时候，可以通过gio客户端自动拉起gvfsd守护进程。gvfsd主要任务是充当模块的安装器和跟踪器。在需要的时候，它会产生新的后端，并跟踪它们的生命周期，维护已挂载的列表并创建与它们的直接连接。gvfsd还将启动gvfsd-fuse 并向其提供应在其中安装 fuse 文件系统的安装点 gvfsd-fuse gvfsd-fuse维护FUSE(用户空间的文件系统)挂载，以使gvfs后端可用于 POSIX 应用程序。fuse文件系统的挂载点由 [PATH] 参数提供。其主要由 gvfsd 启动 gvfsd-metadata gvfsd-metadata是一个守护进程，充当内部 gvfs 元数据存储的写入序列化程序。它是在 gio 客户端更改元数据时候自动启动。读取操作直接由客户端 gio 完成，并不需要运行守护程序 gvfs-goa-volume-monitor 支持 GNOME 在线账户 gvfs-gphoto2-volume-monitor 支持图片传输协议，如:gPhoto gvfs-mtp-volume-monitor 支持媒体传输协议 gvfs-udisks2-volume-monitor gvfs-udisks2-volume-monitor负责磁盘、介质、挂载和fstab桌面用户界面中显示的项目。特别的是gnome-shell以及使用 GLib API 的任何其它应用程序都在使用此过程中的信息。 请注意：不要把它与udisks软件包中的udisksd和udisksctl混淆 gvfs-afc-volume-monitor 苹果文件系统 gvfsd-afc 挂载IPhone/Ipod touch音量 gvfsd-afp 苹果文件协议卷 gvfsd-afp-browse 浏览apple归档协议卷 gvfsd-archive 挂载各种格式的归档文件 gvfsd-burn 提供刻录 CD 的位置 gvfsd-cdda 挂载音频 CD gvfsd-computer 提供计算机 computer:/// 支持 gvfsd-dav 挂载 DAV 文件系统 gvfsd-dnssd 浏览域名解析 gvfsd-ftp 挂载 FTP 文件系统 gvfsd-gphoto2 通过PTP挂载，这意味着gvfs通过libgphoto2通过 VFS 将相机上的照片显示给GNOME程序 gvfsd-http 通过 HTTP 挂载 gvfsd-localtest 测试后端 gvfsd-mtp 通过 mtp 挂载 gvfsd-network 提供 network:///支持 gvfsd-nfs 提供 nfs 协议支持 gvfsd-recent 提供最近访问支持 gvfsd-sftp 提供sftp支持 gvfsd-smb 提供samba支持 gvfsd-smb-browse 浏览windows共享文件系统的卷 gvfsd-trash 提供回收站支持 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:1:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd 代码模块功能梳理 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd 依赖文件及库分析 # 源码 daemon/main.c daemon/mount.c # 依赖库 gvfsddaemon gvfsd 代码梳理 解析命令行，是否使用 fuse、是否debug、是否仅仅打印版本信息 … 创建gvfs daemon g_vfs_daemon_new (TRUE, \u003creplace\u003e) gvfs_get_socket_dir()创建文件夹 监听 daemon 的 shutdown 信号 session dbus总线上注册，名字为：org.gtk.vfs.Daemon 如果需要 fuse 支持则启动 gvfsd-fuse 进程 session 上 dbus 注册成功就会调用 gboolean mount_init() gvfsd 结束执行 mount_finalize() g_vfs_daemon_new (TRUE, \u003creplace\u003e) g_vfs_daemon_new () 声明与定义位于daemon/gvfsdaemon.[hc]文件里 创建线程: g_thread_pool_new() 初始化互斥锁: g_mutex_init() 挂载数量初始化0、jobs初始化NULL、registered_paths(hash)、client_connections(hash)、session dbus的conn g_dbus_auth_observer_new() allow-mechanism authorize-authenticated-peer gvfs_dbus_daemon_skeleton_new() handle-get-connection handle-cancel handle-list-monitor-implementations gvfs_dbus_mountable_skeleton_new() handle-mount gboolean mount_init () gboolean mount_init ()声明与定义在daemon/mount.[hc]文件里 read_mountable_config () 获取环境变量 GVFS_MOUNTABLE_EXTENSION(默认是.mount文件)、GVFS_MOUNTABLE_DIR 读取 GVFS_MOUNTABLE_DIR 文件名需要有 .mount 后缀，文件夹是：/usr/share/gvfs/mounts/ /sys/fs/cgroup/ 解析 xxx.mount并保存到链表 mountables 全局变量 创建管道 pipe(reload_pipes) (其中 reload_pipes 是全局的static int reload_pipes[2];) 监控管道，当管道有数据读入就会重新执行第一步流程read_mountable_config () 获取SESSION bus 的实例 conn = g_bus_get_sync(SESSION, NULL, NULL) mount_tracker = gvfs_dbus_mount_tracker_skeleton_new () 并分别监听信号(这些信号分别对应相应dbus功能) handle-register-fuse handle-register-mount handle-mount-location handle-lookup-mount handle-lookup-mount-by-fuse-path handle-list-mounts handle-list-mounts2 handle-list-mountable-info handle-list-mount-types handle-unregister-mount g_dbus_interface_skeleton_export(mount_tracker,conn,G_VFS_DBUS_MOUNTTRACKER_PATH,NULL) G_VFS_DBUS_MOUNTTRACKER_PATH 是 /org/gtk/vfs/mounttracker 通过d-feet查看，此dbus提供了一系列接口，主要功能包括：支持的挂载类型、挂载信息、挂载点、通过 fuse 挂载的位置；同时也提供了挂载和卸载信号 gvfs_dbus_mount_tracker_skeleton_new() 一系列dbus对应的操作及一些接口声明 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:2","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"udisks2 gvfs-udisks2-monitor 进程负责磁盘、media、挂载点和fstab在桌面环境挂载、访问。尤其是 gnome-shell 和文件管理器程序 (nautilus)以及其它使用 GLib 的 API 程序。 通常，只会显示可挂载文件系统的测盘或媒体，这些媒体在下边统称为 “设备”。 如果设备挂载点在 /media/、$HOME、/run/media/$USER 之外的文件夹，那么设备可能不会显示在用户界面。或者如果设备挂载点在 /media/、$HOME、/run/media/$USER 这些目录之下，但是挂载点是以 . 开头的，那么也不会显示。这需要使用使用挂载选项 x-gvfs-show 来强制显示，当然 x-gvfs-hide 也可以使挂载点隐藏。 设备的名称、图标、符号图标是根据某些特征选择的，比如：设备的文件系统标签、x-gvfs-name=\u003cvalue\u003e、x-gvfs-icon=\u003cvalue\u003e 和 x-gvfs-symbolic-icon=\u003cvalue\u003e 在 /etc/fstab 添加自动挂载点时候，建议用户使用 /dev/disk 层次结构中稳定的符号连接，而不是内核名称 sda、sdb 等 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"热插拔 通过 eSATA 或 USB 连接的设备在物理机器上是可热插拔的。当物理设备连接到机器上或从机器上移除时候 linux内核 会把通知事件发送到用户空间，系统接受到此类事件并根据其配置对它们进行响应 设备驱动加载后会在 devfs (/dev) 下生成对应的设备节点，如果设备连接后 systemd-udevd 会根据配置对 /dev/ 下的设备节点进行增加 如果是块设备，systemd-udevd 通知 udisksd 和 gvfsd 以及 gvfs-udisks2-volume-monitor ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"一些 fstab 例子 强制在用户界面隐藏设备 /dev/disk/by-id/ata-HITACHI_HTS723232A7A364_E3834563KRG2HN-part1 /home/davidz/Data auto defaults,x-gvfs-hide 0 0 强制在用户界面显示设备(显示名字为 ‘My Movies’) /dev/disk/by-uuid/4CAE8E5B5AF47502 /Movies auto defaults,x-gvfs-show,x-gvfs-name=My%20Movies 0 0 自定义设备图标 /dev/disk/by-uuid/4CAE8E5B5AF47502 /Movies auto defaults,x-gvfs-show,x-gvfs-name=My%20Movies,x-gvfs-icon=folder-videos,x-gvfs-symbolic-icon=folder-videos-symbolic 0 0 强制在用户空间显示 NFS 挂载点 10.200.0.210:/tank/media /mnt/Filer nfs4 default,users,noauto,x-gvfs-show 0 0 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:2","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"一些udev例子 不自动挂载金士顿U盘 SUBSYSTEMS==\"usb\", ENV{ID_VENDOR}==\"*Kingston*\", ENV{ID_MODEL}==\"*DataTraveler*\", ENV{UDISKS_AUTO}=\"0\" 自动挂载某设备但是不要求admin权限 ENV{ID_SERIAL}==\"WDC_WD1002FAEX-00Y9A0_WD-WCAW30039835\", ENV{UDISKS_AUTO}=\"1\", ENV{UDISKS_SYSTEM}=\"0\" 给特殊设备特殊名字和图标 ENV{ID_MEDIA_PLAYER}==\"apple-ipod\", ENV{UDISKS_NAME}=\"David's iPod\", ENV{UDISKS_ICON_NAME}=\"multimedia-player-ipod\", ENV{UDISKS_SYMBOLIC_ICON_NAME}=\"multimedia-player-ipod-symbolic\" 确保此特殊设备不出现在用户界面 ENV{ID_SERIAL}==\"HITACHI_HTS723232A7A364_E3834563KRG2HN\", ENV{UDISKS_IGNORE}=\"1\" ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:3","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux","qemu"],"content":"在Linux宿主机上挂载 qemu 虚拟盘 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:0","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"下载 qemu-nbd 工具 pacman -S qemu 或 apt-get install qemu-utils 或 yum install qemu-img ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:1","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"加载nbd模块并挂载 modprobe nbd max_part=8 qemu-nbd --connect=/dev/nbd0 \u003cxxx.qcow2\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:2","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"开始挂载nbd磁盘到文件系统 mount /dev/nbd0xx \u003c挂载点\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:3","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"卸载nbd qemu-nbd --disconnect /dev/nbd0 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:4","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"将vmware的vmdk虚拟盘转为qemu支持的qcow2虚拟盘 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:0","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"合并vmware虚拟磁盘 如果vmware下虚拟机的磁盘是分块的，比如:xxx-s001.vmdk、xxx-s002.vmdk… 需要先合并为一个vmdk文件 vmware-vdiskmanager.exe -r \u003c虚拟盘的路径\u003e -t 0 \u003c合并后盘的名字\u003e vmware-vdiskmanager.exe 在vmware安装路径下 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:1","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"vmdk转qcow2 在linux下执行(确保执行前安装有qemu环境和工具包) qemu-img convert -f vmdk -O qcow2 \u003cxxx.vmdk\u003e \u003cxxx.qcow2\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:2","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux"],"content":"ARM 简史 ARM公司既不生产芯片也不销售芯片，它只出售芯片技术授权。却做到了在手持设备市场上占有90%以上的份额。 软银在2016年耗资320亿美元拿下ARM，使得本来就大红大紫的ARM公司，再一次窜到了业界人士的面前。ARM这家不生产芯片却也能数钱数到手抽筋的公司到底有着怎样的发展史？ 1978 年诞生 ARM公司既不生产芯片也不销售芯片，它只出售芯片技术授权。却做到了在手持设备市场上占有90%以上的份额。 软银在2016年耗资320亿美元拿下ARM，使得本来就大红大紫的ARM公司，再一次窜到了业界人士的面前。ARM这家不生产芯片却也能数钱数到手抽筋的公司到底有着怎样的发展史？ CPU公司的全称：Cambridge Processor Unit，字面意思是“剑桥处理器单元”。 CPU公司的创始人：奥地利籍物理学博士Hermann Hauser和他的朋友，英国工程师Chris Curry。 不过，CPU公司成立之后，主要从事电子设备设计和制造的业务。他们接到的第一份订单，是制造赌博机的微控制器系统。这个微控制器系统被开发出来后，称之为Acorn System 1。 1979 年公司改名 1979年，这家公司给自己换了个名字——Acorn Computer Ltd。 Acorn是什么意思？橡子。 Acorn Computer Ltd公司的商标里面就有一个橡子。 关于Acorn，还有一个有趣的说法，就是因为他们想在电话黄页里排在Apple（苹果）公司的前面… 在Acorn System 1之后，他们又陆续开发了System 2、3、4，还有面向消费者的盒式计算机 —— Acorn Atom。 1981 年迎来BBC订单 到了1981年，公司迎来了一个难得的机遇 —— 英国广播公司BBC打算在整个英国播放一套提高电脑普及水平的节目，他们希望Acorn能生产一款与之配套的电脑。 这个计划非常宏大，英国政府也参与其中（购机费的一半将由政府资助），电脑一旦采购，将进入英国的每一间教室。 接下这个任务之后，Acorn就开始干了起来。 结果，很快他们就发现，自己产品的硬件设计并不能满足需求。当时，中央处理器的发展潮流，正在从8位变成16位。Acorn并没有合适的芯片可以用。 起初，他们打算使用美国国家半导体和摩托罗拉公司的16位芯片。但是，经过评估后，他们发现了两个缺陷： 芯片的执行速度有点慢，中断的响应时间太长。 售价太贵，一台500英镑的电脑，处理器芯片就占到100英镑。 他们打算去找当时如日中天的英特尔（Intel），希望对方提供一些80286处理器的设计资料和样品。但是，却遭到了拒绝。 备受打击的Acorn公司，一气之下决定自己干，自己造芯片。 当时，Acorn公司的研发人员从美国加州大学伯克利分校找到了一个关于新型处理器的研究——简化指令集，恰好可以满足他们的设计要求。 在此基础上，经过多年的艰苦奋斗，来自剑桥大学的计算机科学家Sophie Wilson和Steve Furber最终完成了微处理器的设计。 对于这块芯片，Acorn给它命名为Acorn RISC Machine。 嗯，这就是大名鼎鼎的“ARM”三个字母的由来。 Acorn是公司名称，Machine是机器，那RISC是什么意思呢？ RISC的全称是\"精简指令集计算机\"（reduced instruction set computer），它支持的指令比较简单，所以功耗小、价格便宜，特别适合移动设备。早期使用ARM芯片的典型设备，就是苹果公司的牛顿PDA。 这里解释一下，到底“简化指令集”有什么意义。 它是相对于“复杂指令集（CISC，complex instruction set computer）”的一个概念。 早期的处理器都是CISC架构（包括英特尔的处理器），随著时间推移，有越来越多的指令集加入。由于当时编译器的技术并不纯熟，程序都会直接以机器码或是组合语言写成，为了减少程序的设计时间，逐渐开发出单一指令，复杂操作的程序代码。设计师只需写下简单的指令，再交给CPU去执行。 但是后来有人发现，整个指令集中，只有约20％的指令常常会被使用到，大约占了整个程序的80％；剩余80％的指令，只占了整个程序的20％。（典型的二八原则） 于是，1979年美国加州大学伯克利分校的David Patterson教授提出了RISC的想法，主张硬件应该专心加速常用的指令，较为复杂的指令则利用常用的指令去组合。 1985年10月，英特尔发布了80386。在80386面前，ARM1就只有被吊打的份了。 intel 80386 32位，27.5万个晶体管，频率为12.5MHz，后提高到33MHz 让ARM直接在性能上和x86系列硬杠，显然是不现实的。ARM有意无意地选择了与Intel不同的设计路线——Intel持续迈向x86高效能设计，ARM则专注于低成本、低功耗的研发方向。 BBC在1981年就提出需求，如果等到1985年ARM1出来，那岂不是黄花菜都凉了？ 所以，在ARM1问世之前，Acorn其实已经提供了解决方案给BBC。 当时，Acorn的电脑，临时采用了MOS 6502处理器（由MOS科技研发的8位微处理器）。 MOS 6502处理器 1982 年推出 BBC Micro计算机 1982 年Acorn计算机公司推出了BBC Micro计算机，这是欧洲第一台畅销的个人计算机。 BBC Micro 1984 BBC Micro 被大量使用 到了 1984 年，大约80%的英国学校都配有这款电脑。Acorn公司彻底在大英帝国老百姓面前刷了一把存在感。 后来，ARM处理器被研发出来之后，用在了BBC Micro的后续型号中。 BBC Micro电脑里面的ARM芯片 1985 年推出 ARM1 芯片 1985 年Acorn与合作伙伴推出了ARM1芯片，以此作为其未来个人计算机的中枢。 在ARM1之后，Acorn陆续推出了好几个系列，例如ARM2，ARM3。 1990 年得到苹果公司投资 1990 年11月27日，Acorn公司正式改组为ARM计算机公司。苹果公司出资150万英镑，芯片厂商VLSI出资25万英镑，Acorn本身则以150万英镑的知识产权和12名工程师入股。 在成立后的那几年，ARM业绩平平，工程师们人心惶惶，害怕随时失业。 在这个情况下，ARM决定改变他们的产品策略——他们不再生产芯片，转而以授权的方式，将芯片设计方案转让给其他公司，即“Partnership”开放模式。 没想到正是这种模式，开创了属于ARM的全新时代。 ARM 32位嵌入式RISC(Reduced lnstruction Set Computer)处理器扩展到世界范围，占据了低功耗、低成本和高性能的嵌入式系统应用领域的领先地位。 ARM所采取的是IP（Intellectual Property，知识产权）授权的商业模式，收取一次性技术授权费用和版税提成。 具体来说，ARM有三种授权方式：处理器、POP以及架构授权。 处理器授权是指授权合作厂商使用ARM设计好的处理器，对方不能改变原有设计，但可以根据自己的需要调整产品的频率、功耗等。 POP（processor optimization pack，处理器优化包）授权是处理器授权的高级形式， ARM出售优化后的处理器给授权合作厂商，方便其在特定工艺下设计、生产出性能有保证的处理器。 架构授权是ARM会授权合作厂商使用自己的架构，方便其根据自己的需要来设计处理器（例如后来高通的Krait架构和苹果的Swift架构，就是在取得ARM的授权后设计完成的）。 所以，授权费和版税就成了ARM的主要收入来源。除此之外，就是软件工具和技术支持服务的收入。 对于半导体公司来说，授权费和版税到底有多少呢？一次性技术授权费用在100万-1000万美元之间，版税提成比例一般在1%-2%之间。 正是ARM的这种授权模式，极大地降低了自身的研发成本和研发风险。它以风险共担、利益共享的模式，形成了一个以ARM为核心的生态圈，使得低成本创新成为可能。 苹果公司投资ARM，是为了保证其Newton手持计算机的芯片供应，这个不切实际的设备以失败而告终。 注意：这里的ARM是公司名称，不是芯片名称。这个ARM的完全拼写也不一样，是Advanced RISC Machines。 前面的芯片名称：Acorn RISC Machine 现在的公司名称：Advanced RISC Machines 1998 年诺基亚基于ARM设计并畅销 1998 年诺基亚基于ARM设计的畅销帮助它成了全世界最大的手机生产商。 1991 年ARM将产品授权给英国GEC Plessey半导体公司 1993 年ARM将产品授权给Cirrus Logic和德州仪器（Texas Instruments，TI） 与德州仪器的合作，给ARM公司带来了重要的突破。而且，也给ARM公司树立了声誉，证实了授权模式的可行性。 此后，越来越多的公司参与到这种授权模式中，与ARM建立了合作关系。其中就包括三星、夏普等公司。 在此基础上，ARM坚定了授权模式的决心，并着手设计更多性价比高的产品。 1993年，苹果公司推出了一款新型掌上电脑产品——Newton。ARM公司开发的ARM6芯片被用于该产品之中。 Apple Newton Message Pad 现在被认为是PDA和智能手机的鼻祖 但是很遗憾，因为Newton技术过于超前，加上一些用户体验上的缺陷，所以未能被市场接受，后来以失败告终。 但ARM积累了经验，继续改良技术。没过多久，ARM迎来了自己的黄金机遇——","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:1:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"硬件相关概念 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"电平 在数字电路中，分为高电平和低电平，分别用1和0表示。一个数字电路的管脚，总是存在一个电平的，要么高要么低，或者说要么1要到0(其实还有一种，高阻) ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:1","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"总线 在嵌入式系统中一定会有一块处理器芯片，此外，还有其它的芯片作为外部设备（后面简称外设），这些芯片与处理器协作实现产品的功能。复杂的产品往往是由大量的芯片组成的。那么不可避免的是我们需要将所有的外设与处理器进行相连，最为简单的是将所有的外设都采用独立（注意是独立）的信号线连接至处理器，这样的好处是容易理解，但问题是：不可行。 因为处理器芯片需要引出太多的线了，从芯片的生产和产品的生产角度来看都不实际。加之，处理器（在此我们假设处理器是单核的，而不是多核的）处理事务在微观上是串行的，也就是说在某一时刻如果要对外设进行读写操作，那只可能是对大量外设中的一个进行，即多个外设不可能在微观上被处理器同时访问。需要注意的是，这里提出了微观这一概念，这是为了区别于宏观。 从宏观上来讲，一个处理器中可以有多个任务同时运行，但这些任务在微观上却是一个一个运行的（后面会用串行来描述这里所说的“一个一个”），多任务的串行运行实现是由操作系统扮演着重要的角色来实现的。回到我们的话题，即然将每个外设采用独立的信号线连到处理器不可行，且处理器在单一时间内只会对一个外设进行访问，那我们能不能采用共享的信号线将所有的芯片连在一起呢？这就是总线概念的由来。 通俗的说，如果我们周围有十个家庭，为了让这十个家庭每两个之间都能往来，我们并不需要为每两个家庭修一条单独（注意是单独）的路（如果这样，要修45条路），而是可以修一条大路，然后，每个家都与大路相连。 对于总线，我们往往说总线是处理器的，而其它的外设是挂在总线上的。那有一个问题，我们每一时间只能访问挂在总线上的一个外设，那如何区分这些外设呢？和我们的路一样，我们需要用地址来区分每一个家庭，在总线上，也是采用地址来进行区分的。这样，总线就根据其功能分为两类了。一类是地址总线，这一总线上的数据只会是从处理器向外设“流”，是单向的。 另一类则是数据总线，用来将数据从处理器传送到外设（从处理器的角度来说是写操作）或者是将数据从外设传送到处理器（从处理器的角度来说是读操作），显然，数据总线是双向的。也就是说，在我们的嵌入式系统中同时存在地址总线和数据总线将所有需要与处理器进行通讯的芯片连在一起的。 总线是有宽度的，正如我们的路分为“三车道”或是“四车道”，我们说32位处理器，是指其数据总线宽度是32位，也就是“有32辆车能同时跑”，显然，宽度越是宽我们的处理器速度就越是快，因为我们从外设芯片存取数据的速度会更快，这就是为什么我们的计算机向64位发展的原因。同样的，地址总线也是有宽度的，对于32位处理器其最大宽度也就是32位。 总线的概念有了，那接下来的一个问题是，即使是每一个外设都有一个地址，那这一地址记在哪里呢？是放在外设芯片上吗？如果这样的话，那就有一个问题，每一类外设的地址必须是不能重叠的，而当一个产品中需要两块一样的芯片的话，两块芯片的地址就无法区分了，看来这样操作存在问题。还有，如果这样的话每一个外设也得与（比如，32根）数据总线完全相连，并监听数据线以了解处理器是不是在“叫”自己，这样很是复杂。 此外，地址也有可能因为外设种类的增多而用光。总的来说地址不能存放在外设芯片，那如何让外设知道，此时它是被处理器招换从而需要进行读写访问的呢？答案就是芯片的片选（CS， chip select）信号，或者又叫使能（ENable）信号。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:2","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"片选(CS或EN) 片选信号对于外设芯片来讲，就是一个（也是一根）通知信号，告诉芯片“嘿，请开门，我要放些东西进来，或是拿些东西走”，这里的东西只能是数据，不可能是玉米棒什么的。那有个问题，这个信号源从哪里来呢？显然，只能从处理器来。那是不是也是像总线那样，每一个芯片都共用一根线连在一起呢？如果这样，可能处理器“一叫开门”所有的芯片都将“门”打开了。如果是处理器写数据，那可能所有的芯片都被写入同样的数据。 而取数据时，每个外设芯片都向外“扔”数据，这一定会造成数据总线冲突，因为有的芯片向总线上“扔”1，有的则“扔”0，这种情况下处理器一定会“发疯”的，因为它不知道应当得到1还是0。 既然这样，显然不能将所有的片选信号连在一起了，只能是各芯片的片选信号独立。前面提到了地址总线，我们是采用一根地址线连一个外设芯片呢？还是采用其它的方法。如果采用一根地址线连一个外设芯片，那可能最多只能挂接32个芯片了，这显然不行。其实，在现实中，是采用32位的数字来表示一个外设芯片的地址的，比如1可以表示芯片A，而6534可以表示另外一个芯片B， 等等。由此看来，理论上我们可以表示2的32次方（4294967296）个设备，之所以说理论上，是因为有的设备要占用大量的地址。即然这样，那还有一个问题，如果将32位的地址总线转换成芯片的一根片选信号呢？这需要引入译码（器）的概念。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:3","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"译码器 译码器将一个数据转换成一根信号线上的信号，比如3/8译码器，可以将一个位宽是3位的数据转换成8根（2的3次方）完全独立的信号线，当向数据侧写入二进制的011时，对应的是8根线的第3根，当输入二进制的111时，对应的是8根线中的最后一根。有了译码器，处理器的地址线就简化了，只要32根地址线加上外面的译码器，就可以访问大量的外设芯片了。外部设备的选择问题，我们已经解决了，现在还得回头看一看数据总线。 3/8译码器 在嵌入式系统中，所有芯片的数据总线可以理解成是直接相连的。之所以用了“可以理解”一词，是因为为了提高总线的负载能力，其中会加入总线驱动器。为了理解，我们看一看我们生活中的自来水，比如，在北京理论上可能所有的水管是连在一起的，但中间可能为了提高水压，存在很多小的水站用来增加供水压力，而不可能全北京所有的自来水自接来自一个水厂。 既然所有的数据总线是连在一起的，那就可能会有问题。当向外部设备写数据时，处理器先向地址总线输送目标外设的地址，地址译码器将其转换成一根信号的片选信号送到了目标外设，目标外设收到这一信号后，将“门”打开。接下来处理器将要传送到外设的数据往数据总线上一放，由于只有目标外设芯片打开了“门”，所以数据只会进入到目标外设，而其它的外设什么也不会收到。 很好！处理器向外写数据应当没有问题，我们接下来看一看读。读的话，由于数据是从外设输送到处理器的，尽管我们采用和写一样的方法打开目标外设的“门”，但此时，其它的外设也在数据总线上，它们有可能处于1也可能处于0，是不是会影响处理器读取目标外设的数据呢？结果当然不会，但我们得引入另一个概念：高阻态。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:4","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"高阻态 很显然，当处理器从目标外设读数据时，我们希望其它没有被选上的芯片的数据总线不会对目标外设所要传送的数据有影响，那怎么办呢？实际上，当芯片没有被选中时，其数据总线都处于高阻态。所谓的高阻态，我们可以理解成这一管脚在外设芯片内部是断开的，如此一来，显然不会对处理器从目标外设读取数据造成任何的影响了。 我们说当一个芯片没有被选中或是没有被使能时，其数据总线一定是处于高阻态的。前面用了“门”的开和关来打比方，那“门”是指什么呢？是指外设的数据总线，片选信号的作用就是控制将外设的数据总线与处理器的数据总线相连或是断开。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:5","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"驱动 总线上的数据是谁放上去的我们就说谁是那一时刻的驱动者。也就是说，当处理器向外设写数据时，它是在驱动数据总线的，而当处理器从目标外设读取数据时，目标外设是在驱动数据总线的。对于地址总线，因为只可能从处理器向目标外设写，所以地址总线永远是由处理器驱动的。当一个芯片没有被选中时，我们说它并不驱动数据总线。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:6","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"三态门 前面我们说到外设芯片的数据总线在没有被选中时其处于高阻态，当被选中时，其电平可能是高（1）或是低（0）。如此一来，我们说外设的数据总线其芯片管脚是属于三态门的，即存在高电平、低电平和高阻态，三个状态。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:7","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"电平特效 前面我们了解了什么是片选信号，也讲到了三态门，需要指出的是片选信号通常不是三态门，其只存在两个状态，即高电平或是低电平。前面我们也说了，片选信号是用来“开门”的，而片选信号又有高和低电平，那到底是高电平表示“开门”呢？还是低电平？对于这一问题，我们称如果一个电平对于一个片选信号表示“开门”那么它就是这一信号的有效电平。 比如，对于一个片选信号，如果低电平表示“开门”，那么我们说这个片选信号是低电平有效的。虽然，在这里我们用片选信号来解释电平的有效性，但是很多信号都存在有效性的问题，比如，后面我们将要谈的读信号和写信号都存在有效性问题。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:8","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"时序 在前面我们说到当处理器要向外设芯片写数据时，需要先将所需访问的外设的地址放在地址总线上，然后，由译码器将地址总线上的数据转换成片选信号，片选信号则使能目标外设芯片，接下来处理器写数据到数据总线上，从而完成一个写操作。显然，在处理器将数据写到数据总线之前地址线上的数据必须一直保留一段时间，否则的话译码器不能长时间的使片选信号有效。 当完成了数据的写操作后，处理器就不需要保证地址总线上的地址有效了。我们可以看出，这一系列的操作都有一定严格的时间顺序的，这称之为时序。时序描述了处理器与外部设备的交互信号 “规程”，大家只有按照这一“规程”来操作，才能保证处理器与外部设备之间能正常的通讯。 这好比，我们的道路上的红绿灯，如果我们行人和车辆不按照其指示来通行的话，就会出现事故。通常，采用时序图来描述芯片之间通讯的信号“规程”。 读时序图 读时序图 从图中我们可以看出ADDRESS是表示地址总线的，DQ是表示数据总线的,CE是片选信号，且是低电平有效，其宽度要保证在进行读操作时总是有效的。学会看时序图对于做嵌入式系统开发非常有帮助，因为我们不可避免的要与芯片打交道。在时序图中，通常会标识很多的时间需求信息。 在写启动代码时需要初始化各地址空间的片选地址寄存器和读写时序，时序的配置依据就是来自于外设芯片的时间需求，这是芯片手册很重要的一部分内容。当一个地址空间中存在多个外设芯片时，我们需要考虑到其中最慢的外设芯片的时间需求，否则的话有的芯片就不能正常工作。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:9","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"读信号 当处理器需要从外设芯片读取信号时，除了需要产生片选信号外，还需要告诉外设芯片这是一个读操作，而不是一个写操作，这是通过读信号来实现的。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:10","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"写信号 前面讲了读信号，我想对于写信号也就不难理解了，这个信号用于告诉外设芯片，这是一个向外设芯片写数据的操作。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:11","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"I/O端口 前面提到了外设（芯片）)，现在是对外设进行分类的时候了。大体上外设分为两类，一类是存储器外设，而另一类是非存储器外设，后者常被称之为I/O设备，这里的I/O是Input/Output的简写，即输入、输出。可见，I/O外设是一个非常宽泛的概念。对于存储器外设，其特点是，它所占用的空间是连续的一片。比如，SDRAM内存就是属于存储器外设，如果其容量是8M字节，那么其占用的地址空间也会是8M的。 与存储器外设所不同的是，I/O外设所点用的地址一般都很少。比如一个I/O外设可能存在多个控制寄存器，这些控制寄存器从处理器来看就是多个I/O端口（地址），向这个地址写数据就是向外设所对应的寄存器写数据，反之，也可以是读。 比如，一个串口芯片可能存在多个寄存器，一个用来查询芯片的状态，一个用来设置芯片的功能，另一个用来读取芯片从串口线所收到的数据，最后，还有一个用来向芯片写数据以向串口线上发送数据。对于这一串口芯片的寄存器，从处理器的角度来看，都是独立的I/O端口。 I/O端口存在读、写性问题，有的端口是只读的，有的端口是只写的，还有的端口是即可读也可写，其读写性是由外设芯片的寄存器所决定的，在芯片的数据手册中能找到。需要指出的是，有些存储器外设也存在I/O端口，以对其进行一定的控制。从I/O端口这一名字来看，对于处理器来说，就是对从外面读入数据或是向外面输出数据的一个接口总称。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:12","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"中断 中断从硬件的角度来看就是一个能产生高、低电平的一根信号线，但理解它需要从处理器的角度出发。我们说过了，处理器从微观上看，所做的工作是按顺序进行的，其对程序的处理只能是一条指令一条指令的执行。如果存在需要对外设芯片进行访问，而有可能从处理器发出读、写命令后，由于外设通常比处理器慢很多，所以外设芯片需要一些时间来准备好所需的数据。 在这种情况下，如果处理器一直等外设芯片的返回数据再执行后续的指令的话，将耗费宝贵的时间，这些时间完全可以用来做其它的工作。别忘了，从宏观上看来处理器常常是多任务的，任务是指操作系统所提供的调度单位。当一个任务因为等待外设芯片的数据而阻塞时，我们可以切换到另外的任务，从而提高处理效率。 这就有一个问题，当处理器去处理另一个任务时，如果外设芯片的数据好了的话，如果告诉处理器呢？对了！就是通过中断信号。中断信号的高、低电平可以用来表示是否有中断需要处理器注意以处理特定的事件（比如，外设数据准备好了的事件）。 由此看来，中断的引入能大大的提高处理器的运用效率。为了使用处理器上的中断，一开始我们需要初始化好处理器的中断控制器，比如安装好所需的中断服务程序或称之为ISR（Interrupt Service Routine），然后，打开中断屏蔽位。中断服务程序中需要做如下的操作： 从外设读入或向外设写数据。读还是写通常需要读取外设的中断状态寄存器来决定。 清除外设的中断信号。我们知道，中断信号是由外设芯片驱动的，为了告诉外设芯片，处理器已经处理完了所需做的工作，那么处理器需要通过一定的方式通知外设芯片。这种方式就是向外设芯片的寄存器中的某一位写入一个数据，比如，可能是写入1表示清中断，也可能是写入0表示清中断，这通常在外设的数据手册中能查到。 当外设收到了处理器的清中断请求后，其就会驱动中断线使其无效。比如，一个外设的中断线是当其为低电平表示有中断，将其从低电平变为高电平就是驱动为无效。 清除处理器的中断信号标识。处理器中往往也会保存外部中断信号是否发生过，当我们处理完了外设芯片的中断时，我们也需要清除处理器上的标识，从而为下一次中断做准备。需要注意的是，清外设的中断必须发生在请处理器中断标识之前！ 中断还存在一个触发方式问题。有两种触发方式 ，一种是电平触发，另一种是沿触发。电平触发是指电平的高低表示外设是否有中断，而沿触发则是能过中断线上的电平的升或降来表示的，显然，存在两种沿触发方式。 一种是中断线从低电平变为高电平，我们称之为上升沿触发，另一处是中断线从高电平转换为低电平，我们称之为下降沿触发。总的来说中断的触发方式有电平触发、上升沿触发和下降沿触发。电平触发方式中处理中中断设置很重要的一个步骤。 ROM ROM(Read Only Memory)和RAM(Random Access Memory)指的都是半导体存储器，ROM在系统停止供电的时候仍然可以保持数据，而RAM通常是在掉电之后就丢失数据，典型的RAM就是计算机的内存。 ROM有很多种，PROM是可编程的ROM，它和EPROM(可擦除可编程ROM)的区别是，PROM是一次性的，也就是软件灌入后，就无法修改了，这是早期的产品，现在已经不再使用，而EPROM是通过紫外光的照射擦出原先的程序的一种通用存储器。另外一种EEPROM是通过电子擦除，价格很高，写入时间很长，写入慢。 举个例子，手机软件一般放在EEPROM中，我们打电话，有些最后拨打的号码，暂时存在SRAM中，不是马上写入通话记录(通话记录保存在EEPROM中)，因为当时有很重要工作(通话)要做，如果写入，漫长的等待用户无法忍受。 RAM RAM有两大类，一种称为静态RAM(Static RAM/SRAM)，SRAM速度非常快，是目前读写最快的存储设备了，它也非常昂贵，所以只在要求很苛刻的地方使用，譬如CPU的一级缓冲，二级缓冲。 另一种称为动态RAM(Dynamic RAM/DRAM)，DRAM保留数据的时间很短，速度也比SRAM慢，不过它还是比任何的ROM都要快，但从价格上来说DRAM相比SRAM要便宜很多，计算机内存就是DRAM的。 DRAM DRAM分为很多种，常见的主要有FPRAM/FastPage、EDORAM、SDRAM、DDR RAM、RDRAM、SGRAM以及WRAM等，这里介绍其中的一种DDR RAM。 DDR RAM DDR RAM(Date-Rate RAM)也称作DDR SDRAM，这种改进型的RAM和SDRAM是基本一样的，不同之处在于它可以在一个时钟读写两次数据，这样就使得数据传输速度加倍了。 这是目前电脑中用得最多的内存，而且它有着成本优势，击败了Intel的另外一种内存标准-Rambus DRAM。在很多高端的显卡上，也配备了高速DDR RAM来提高带宽，这可以大幅度提高3D加速卡的像素渲染能力。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:13","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"内存原理解析 内存是用来存放当前正在使用的(即执行中)的数据和程序，我们平常所提到的计算机的内存指的是动态内存(即DRAM)，动态内存中所谓的“动态”，指的是当我们将数据写入DRAM后，经过一段时间，数据会丢失，因此需要一个额外设电路进行内存刷新操作。 具体的工作过程是这样的：一个DRAM的存储单元存储的是0还是1取决于电容是否有电荷，有电荷代表1，无电荷代表0。但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，这就是数据丢失的原因; 刷新操作定期对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电; 若电量小于1/2，则认为其代表0，并把电容放电，藉此来保持数据的连续性。 NAND Flash和NOR Flash的比较 常用的Flash类型有：NOR Flash和NAND Flash两种。NOR Flash由Intel公司在1988年发明，以替代当时在市场上占据主要地位的EPROM和EEPROM。NANDFlash由Toshiba公司在1989年发明。两者的主要差别如下表所示。 NOR Flash支持XIP，即代码可以直接在NOR Flash上执行，无需拷贝到内存中。这是由于NOR Flash的接口与RAM完全相同，可以随机访问任意地址的数据。在NOR Flash上进行读操作的效率非常高，但是擦除和写操作的效率很低；另外，NOR Flash的容量一般比较小。 NAND Flash进行擦除和写操作的效率更高，并且容量更大。一般而言，NOR Flash用于存储程序，NAND Flash用于存储数据。基于NAND Flash的设备通常也要搭配NOR Flash以存储程序。 Flash存储器件由擦除单元(也称为块)组成，当要写某个块时，需要确保这个块已经被擦除。NOR Flash的块大小范围为64KB～128KB；NAND Flash的块大小范围为8KB～64KB，擦/写一个NOR Flash块需4S，而擦/写一个NAND Flash块仅需2ms。 NOR Flash的块太大，不仅增加了擦写时间，对于给定的写操作，NOR Flash也需要更多的擦除操作——特别是小文件，比如一个文件只有1KB，但是为了保存它却需要擦除大小为64KB～128KB的NOR Flash块。 NOR Flash的接口与RAM完全相同，可以随意访问任意地址的数据。而NAND Flash的接口仅仅包含几个I/O引脚，需要串行地访问。NAND Flash一般以512字节为单位进行读写。这使得NOR Flash适合于运行程序，而NAND Flash更适合于存储数据。 容量相同的情况下，NAND Flash的体积更小，对于空间有严格要求的系统，NAND Flash可以节省更多空间。市场上NOR Flash的容量通常为1~4MB(也有32MB的NOR Flash)，NANDFlash的容量为8~512MB。容量的差别也使得NOR Flash多用于存储程序，NAND Flash多用于存储数据。 对于Flash存储器件的可靠性需要考虑3点：位反转、坏块和可擦除次数。所有Flash器件都遭遇位反转的问题：由于FLASH固有的电器特性，在读写数据过程中，偶然会产生一位或几位数据错误——这种概率很低，而NAND Flash出现的概率远大于NOR Flash。当位反转发生在关键的代码、数据上时，有可能导致系统崩溃。 当仅仅是报告位反转，重新读取即可；如果确实发生了位反转，则必须有相应的错误检测/恢复措施。在NAND Flash上发生位反转的概率更高，推荐使用EDC/ECC进行错误检测和恢复。 NAND Flash上面会有坏块随机分布，在使用前需要将坏块扫描出来，确保不再使用它们，否则会使产品含有严重的故障。NAND Flash每块的可擦除次数通常在100000次左右，是NOR Flash的10倍。另外，因为NAND Flash的块大小通常是NOR Flash的1/8，所以NAND Flash的寿命远远超过NOR Flash。 linux对NOR、NAND Flash的软件支持都很成熟。在NOR Flash上常用jffs2文件系统，而在NAND Flash上常用yaffs文件系统。在更底层，有MTD驱动程序实现对它们的读、写、擦除操作，它也实现了EDC/ECC校验。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:14","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"工具 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"万用表 万用表通常是用来查看电平的高低、电阻的大小等的，是常用且必不可少的工具之一。在嵌入式系统开发中，我们常用的是数字万用表。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:1","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"示波器 在嵌入式系统开发中，我们不可避免的要与外设芯片打交道。调试驱动程序时，除了需要完全看明白芯片的数据手册，且在软件高度的过程中，还需要看我们所期望的信号电平是否发生在芯片上。比如，我们在写驱动程序时，需要通过写I/O端口来对外设芯片进行操作，当写相应的I/O端口时，我们知道所对应芯片的片选信号应当有效，有时，我们需要验证是否按预期发生了，这就需要用到示波器。 一般的示波器是能同时观测两个信号线的信号状态的。示波器都提供一定的功能，比如设置信号扑捉的方式等等。示波器很重要的一个参数据是其采集频率，根据Nyquist采集定理，如果我们想用示波器查看频率是100M赫兹的信号，那么其采样频率必须至少是其两倍，即200M赫兹。有人可能会问：为什么不用万用表来看呢？因为万用表的采集频率很底，无法采集到很快的信号变化。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:2","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"逻辑分析仪 简单的说逻辑分析器就是具有很多信号通道的示波器。通过逻辑分析仪，我们可以看到地址总线和数据总线上的数据。逻辑分析仪都提供一定的编程能力，用于编程什么时候开始对总线上的数据进行采集。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:3","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"环境搭建目标 pc 可以通过 串口 连接到 开发板，并能查看输出日志 pc 可以通过 ssh 连接到 开发板。开发板默认登录用户名: root，无密码 在 pc 上配置好 arm 交叉编译工具链 准备好常用的源码: uboot源码、linux源码、buildroot源码 我使用 manjaro 作为开发环境；使用 imx6ull pro 作为运行/学习环境，开发板下载的工具里没有linux平台的，因此需要从下载资料的 ubuntu 虚拟机里提取。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发板展示 各标号硬件含义 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发板启动方式（上图表号16对应状态） boot sw1(lcd_data5) sw2(lcd_data11) sw3(boot_mode0) sw4(boot_mode1) emmc OFF OFF ON OFF sd ON ON ON OFF usb X X OFF ON 注意：当设为 USB 启动时候，不能插上SD卡、TF卡；上电之后才可以插卡。刚出厂的板子在 emmc 上烧写了系统，开发板启动方式需要设置为 emmc 启动。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"第一次启动开发板 设置开发板的打开方式为 emmc，打开电源开关 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"接串口 下载 linux 串口驱动程序 https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers 并编译之后在源码目录执行insmod ./xxx.ko，插入编译生成的内核模块(xxx.ko文件) 连接开发板电源线并打开开关，插拔 usb 线观察 /dev/ 下设备变化，发现插入 usb 后会多出 ttyUSB0 这一设备 执行 pacman -S minicom 下载 minicom 打开串口 minicom -D /dev/ttyUSB0 然后重启开发板(直接断点和上电)，后续就可以通过 minicom 看到串口日志了（需要开发板默认打开串口输出） ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"ssh 连接到开发板 给开发板联网并重启，在系统选项里设置网络(ip、子网掩码、网关)并用 PC ssh 连接上去 接上串口，用 minicom 来观察日志输出 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:4","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"搭建环境 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"下载开相关源码及工具 百度网盘下载,提取码:root ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"配置 arm gcc 交叉编译环境(使用imx6ull资料配置) 解压缩 ubuntu 的虚拟机文件（如果压缩文件是多个，需要都选中然后解压） 查看解压后的文件有几个 *.vmdk 文件，如果是多个则需要使用 vdiskmanager 合并为一个 使用 qemu-img 把 xxx.vmdk 文件转为 qemu 支持的 qcow2 文件 我的 linux 工作机用 qemu 而不是 vmware 挂载转换后的文件系统 使用mount挂载虚拟硬盘的家目录，大概是 /dev/nb0p4 挂载后可以通过 ls 命令看到book文件夹，这就是家目录，然后把文件 100ask_imx6ull-sdk 复制出来，在这个文件夹的ToolChain目录下有需要的arm编译链，具体目录是 100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot 配置环境变量，修改 ~/.bashrc 添加如下配置: export ARCH=arm export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- PATH=\u003carm交叉编译根目录\u003e/bin:${PATH} export PATH=$(echo ${PATH} | sed 's/:/\\n/g' | sort | uniq | tr -s '\\n' ':' | sed 's/:$//g') 配置好后重新打开终端或执行source ~/.bashrc 之后打开终端，运行 arm-buildroot-linux-gnueabihf-gcc -v，查看是否有如下信息输出(如果没有，重新执行这一步): Using built-in specs. COLLECT_GCC=/data/environment/gcc-arm/bin/arm-buildroot-linux-gnueabihf-gcc.br_real COLLECT_LTO_WRAPPER=/data/environment/gcc-arm/bin/../libexec/gcc/arm-buildroot-linux-gnueabihf/7.5.0/lto-wrapper Target: arm-buildroot-linux-gnueabihf Configured with: ./configure --prefix=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --sysconfdir=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/etc --enable-static --target=arm-buildroot-linux-gnueabihf --with-sysroot=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/arm-buildroot-linux-gnueabihf/sysroot --enable-__cxa_atexit --with-gnu-ld --disable-libssp --disable-multilib --disable-decimal-float --with-gmp=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-mpc=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-mpfr=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-pkgversion='Buildroot 2020.02-gee85cab' --with-bugurl=http://bugs.buildroot.net/ --disable-libquadmath --enable-tls --enable-plugins --enable-lto --enable-threads --with-isl=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-abi=aapcs-linux --with-cpu=cortex-a7 --with-fpu=neon-vfpv4 --with-float=hard --with-mode=arm --enable-languages=c,c++,fortran --with-build-time-tools=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/arm-buildroot-linux-gnueabihf/bin --enable-shared --enable-libgomp Thread model: posix gcc version 7.5.0 (Buildroot 2020.02-gee85cab) 上述2、3、4步相关教程可以查看qcow2虚拟分区挂载 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"配置arm gcc交叉编译环境(这个留备后续使用，不需要配置) arm 交叉编译工具下载地址: arm 交叉编译工具下载地址，或者复制到浏览器下载(这个包宿主机是x86，目标代码编译成arm的): https://armkeil.blob.core.windows.net/developer/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-arm-none-linux-gnueabihf.tar.xz 下载并解压之后放置指定目录并改名为 gcc-arm，比如: /data/envrionment/gcc-arm/ 配置环境变量，编辑 ~/.bashrc，在末尾加入如下代码: export ARCH=arm export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- PATH=\u003carm交叉编译根目录\u003e/bin:${PATH} export PATH=$(echo ${PATH} | sed 's/:/\\n/g' | sort | uniq | tr -s '\\n' ':' | sed 's/:$//g') 配置好后重新打开终端或执行source ~/.bashrc 之后打开终端，运行 arm-none-linux-gnueabihf-gcc -v，查看是否有如下信息输出(如果没有，重新执行这一步): Using built-in specs. COLLECT_GCC=arm-none-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER=/data/environment/gcc-arm/bin/../libexec/gcc/arm-none-linux-gnueabihf/11.2.1/lto-wrapper Target: arm-none-linux-gnueabihf Configured with: /data/jenkins/workspace/GNU-toolchain/arm-11/src/gcc/configure --target=arm-none-linux-gnueabihf --prefix= --with-sysroot=/arm-none-linux-gnueabihf/libc --with-build-sysroot=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/install//arm-none-linux-gnueabihf/libc --with-bugurl=https://bugs.linaro.org/ --enable-gnu-indirect-function --enable-shared --disable-libssp --disable-libmudflap --enable-checking=release --enable-languages=c,c++,fortran --with-gmp=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-mpfr=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-mpc=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-isl=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-arch=armv7-a --with-fpu=neon --with-float=hard --with-mode=thumb --with-arch=armv7-a --with-pkgversion='GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)' Thread model: posix Supported LTO compression algorithms: zlib gcc version 11.2.1 20220111 (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 这里需要注意的是，如果下载的 arm 编译工具链与开发板文件系统的编译工具链 gcc 不一致，则会导致在 pc 上用跨平台编译工具链编译出来的程序无法在 arm 开发板上运行。解决办法：1. 重新编译开发板根文件系统、内核并烧写；2. 使用官方提供的交叉编译工具链 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"安装 make 项目管理命令 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:4","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"cortexA7 烧写工具 imx6ull 官方烧写工具是 mfgtools 操作简单，一键烧写整个镜像\u003c用这个就可以\u003e nxp 提供的 uuu (Universal Update Utility) 又名 mfgtools 3.0 这块具体使用后续会有介绍 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:5","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"4. mkimage 工具 这一工具来源于 u-boot，用来给一个 bin 文件添加头部信息，芯片固件需要根据头部信息把 bin 文件放到内存中去执行 执行 pacman -S u-boot 命令后，再次执行 mkimage -h 查看是否正确安装: mkimage: invalid option -- 'h' Error: Invalid option Usage: mkimage -l image -l ==\u003e list image header information mkimage [-x] -A arch -O os -T type -C comp -a addr -e ep -n name -d data_file[:data_file...] image -A ==\u003e set architecture to 'arch' -O ==\u003e set operating system to 'os' -T ==\u003e set image type to 'type' -C ==\u003e set compression type 'comp' -a ==\u003e set load address to 'addr' (hex) -e ==\u003e set entry point to 'ep' (hex) -n ==\u003e set image name to 'name' -d ==\u003e use image data from 'datafile' -x ==\u003e set XIP (execute in place) mkimage [-D dtc_options] [-f fit-image.its|-f auto|-F] [-b \u003cdtb\u003e [-b \u003cdtb\u003e]] [-E] [-B size] [-i \u003cramdisk.cpio.gz\u003e] fit-image \u003cdtb\u003e file is used with -f auto, it may occur multiple times. -D =\u003e set all options for device tree compiler -f =\u003e input filename for FIT source -i =\u003e input filename for ramdisk file -E =\u003e place data outside of the FIT structure -B =\u003e align size in hex for FIT structure and header Signing / verified boot options: [-k keydir] [-K dtb] [ -c \u003ccomment\u003e] [-p addr] [-r] [-N engine] -k =\u003e set directory containing private keys -K =\u003e write public keys to this .dtb file -G =\u003e use this signing key (in lieu of -k) -c =\u003e add comment in signature node -F =\u003e re-sign existing FIT image -p =\u003e place external data at a static position -r =\u003e mark keys used as 'required' in dtb -N =\u003e openssl engine to use for signing mkimage -V ==\u003e print version information and exit Use '-T list' to see a list of available image types ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:6","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"最后来一个例子 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"在开发机上编写一个例子 #include \u003cstdio.h\u003e int main (int argc, char* argv[]) { printf (\"Hello World!\\n\"); return 0; } ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发机上的Makefile CC = arm-buildroot-linux-gnueabihf-gcc CUR_DIR = $(shell pwd) SRC = $(strip $(subst $(CUR_DIR), ., $(wildcard $(CUR_DIR)/*.c))) TARGET = $(strip $(patsubst %.c, %.run, $(SRC))) all:${TARGET} %.run:%.c ${CC} -o $@ $\u003c clean: rm -f *.run rm -f *.o ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"编译 分别保存上述代码为 hello-world.c、makefile脚本为 Makefile，两个文件放在同级目录，执行 make 会在当前目录下生成 hello-world.run，使用 scp ./hello-world.run root@\u003c开发机ip\u003e:~ 把编译好的二进制文件传输到开发机，最后使用 ssh 登录到开发机上家目录执行 ./hello-world.run 即可看到输出结果。 至此，开发环境和开发板打通。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["c\u0026c++"],"content":"设计模式简介 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。 使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"设计模式的设计原则 对接口编程而不是对实现编程 优先使用对象组合而不是继承 ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:1:1","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"设计模式的类型 目前总共有23 种设计模式。这些模式可以分为三大类： 创建型模式（Creational Patterns） 结构型模式（Structural Patterns） 行为型模式（Behavioral Patterns） 当然，我们还会讨论另一类设计模式：J2EE 设计模式。 模式\u0026描述 包括 创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式 适配器模式(Adapter Pattern)桥接模式(Bridge Pattern)过滤器模式(Filter、Criteria Pattern)组合模式(Composite Pattern)装饰器模式(Decorator Pattern)外观模式(Facade Pattern)享元模式(Flyweight Pattern)代理模式(Proxy Pattern) 行为型模式这些设计模式特别关注对象之间的通信 责任链模式(Chain of Responsibility Pattern)命令模式(Command Pattern)解释器模式(Interpreter Pattern)迭代器模式(Iterator Pattern)中介者模式(Mediator Pattern)备忘录模式(Memento Pattern)观察者模式(Observer Pattern)状态模式(State Pattern)空对象模式(Null Object Pattern)策略模式(Strategy Pattern)模板模式(Template Pattern)访问者模式(Visitor Pattern) J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的 MVC 模式(MVC Pattern)业务代表模式(Business Delegate Pattern)组合实体模式(Composite Entity Pattern)数据访问对象模式(Data Access Object Pattern)前端控制器模式(Front Controller Pattern)拦截过滤器模式(Intercepting Filter Pattern)服务定位器模式(Service Locator Pattern)传输对象模式(Transfer Object Pattern) ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:1:2","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"设计模式六大原则 开闭原则: 对扩展开放，对修改关闭 里氏代换原则: 任何基类可以出现的地方，子类一定可以出现(LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为，里氏代换原则是对开闭原则的补充)。 依赖倒转原则: 针对接口编程，依赖于抽象而不依赖于具体(这个原则是开闭原则的基础) 接口隔离原则: 使用多个隔离的接口，比使用单个接口要好(降低类之间的依赖/耦合度) 迪米特法则，又称最少知道原则: 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立 合成复用原则: 尽量使用合成/聚合的方式，而不是使用继承 ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:1:3","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"设计模式 ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"工厂模式 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象 意图 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行 主要解决 主要解决接口选择的问题 优点 一个调用者想创建一个对象，只要知道其名称就可以了 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以 屏蔽产品的具体实现，调用者只关心产品的接口。 缺点 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方 数据库访问：当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时 设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度 实现 工厂模式 例子 创建一个接口 Shape.java public interface Shape { void draw(); } 创建实现接口的实体类 // Rectangle.java public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Inside Rectangle::draw() method.\"); } } // Square.java public class Square implements Shape { @Override public void draw() { System.out.println(\"Inside Square::draw() method.\"); } } // Circle.java public class Circle implements Shape { @Override public void draw() { System.out.println(\"Inside Circle::draw() method.\"); } } 创建一个工厂ShapeFactory.java public class ShapeFactory { //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(\"CIRCLE\")){ return new Circle(); } else if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){ return new Square(); } return null; } } 使用工厂 public class FactoryPatternDemo { public static void main(String[] args) { ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape(\"CIRCLE\"); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape(\"RECTANGLE\"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape(\"SQUARE\"); //调用 Square 的 draw 方法 shape3.draw(); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:1","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"抽象工厂模式 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 意图 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 主要解决 主要解决接口选择的问题 何时使用 系统的产品有多于一个的产品族，而系统只消费其中某一族的产品 优点 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象 缺点 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码 使用场景 QQ 换皮肤，一整套一起换 生成不同操作系统的程序 产品族难扩展，产品等级易扩展 实现 抽象工厂模式 例子 创建一个接口 // Shape.java public interface Shape { void draw(); } 创建实现接口的实体类 // Rectangle.java public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Inside Rectangle::draw() method.\"); } } // Square.java public class Square implements Shape { @Override public void draw() { System.out.println(\"Inside Square::draw() method.\"); } } // Circle.java public class Circle implements Shape { @Override public void draw() { System.out.println(\"Inside Circle::draw() method.\"); } } 创建颜色的接口 // Color.java public interface Color { void fill(); } 创建实现接口的实体类 // Red.java public class Red implements Color { @Override public void fill() { System.out.println(\"Inside Red::fill() method.\"); } } // Green.java public class Green implements Color { @Override public void fill() { System.out.println(\"Inside Green::fill() method.\"); } } // Blue.java public class Blue implements Color { @Override public void fill() { System.out.println(\"Inside Blue::fill() method.\"); } } 为 Color 和 Shape 对象创建抽象类来获取工厂 // AbstractFactory.java public abstract class AbstractFactory { public abstract Color getColor(String color); public abstract Shape getShape(String shape); } 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象 // ShapeFactory.java public class ShapeFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(\"CIRCLE\")){ return new Circle(); } else if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){ return new Square(); } return null; } @Override public Color getColor(String color) { return null; } } // ColorFactory.java public class ColorFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ return null; } @Override public Color getColor(String color) { if(color == null){ return null; } if(color.equalsIgnoreCase(\"RED\")){ return new Red(); } else if(color.equalsIgnoreCase(\"GREEN\")){ return new Green(); } else if(color.equalsIgnoreCase(\"BLUE\")){ return new Blue(); } return null; } } 创建一个工厂创建器/生成器类，通过传递形状颜色信息来获取工厂 // FactoryProducer.java public class FactoryProducer { public static AbstractFactory getFactory(String choice){ if(choice.equalsIgnoreCase(\"SHAPE\")){ return new ShapeFactory(); } else if(choice.equalsIgnoreCase(\"COLOR\")){ return new ColorFactory(); } return null; } } 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象 // AbstractFactoryPatternDemo.java public class AbstractFactoryPatternDemo { public static void main(String[] args) { //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(\"SHAPE\"); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(\"CIRCLE\"); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(\"RECTANGLE\"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(\"SQUARE\"); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(\"COLOR\"); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(\"RED\"); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(\"GREEN\"); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(\"BLUE\"); //调用 Blue 的 fill 方法 color3.fill(); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:2","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"单例模式 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象 意图 保证一个类仅有一个实例，并提供一个访问它的全局访问点 主要解决 一个全局使用的类频繁地创建与销毁 何时使用 当您想控制实例数目，节省系统资源的时候 优点 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存） 避免对资源的多重占用（比如写文件操作） 缺点 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化 使用场景 要求生产唯一序列号 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等 实现 单例模式 例子 创建一个 Singleton 类 // SingleObject.java public class SingleObject { //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject(){} //获取唯一可用的对象 public static SingleObject getInstance(){ return instance; } public void showMessage(){ System.out.println(\"Hello World!\"); } } 从 singleton 类获取唯一的对象 // SingletonPatternDemo.java public class SingletonPatternDemo { public static void main(String[] args) { //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); } } 单例的几种实现方式 懒汉式，线程不安全 public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 懒汉式，线程安全 public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉式，线程安全 public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:3","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"构造者模式 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象 意图 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示 主要解决 主要解决在软件系统中，有时候面临着\"一个复杂对象\"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定 何时使用 一些基本部件不会变，而其组合经常变化的时候 优点 建造者独立，易扩展 便于控制细节风险 缺点 产品必须有共同点，范围有限制 如内部变化复杂，会有很多的建造类 使用场景 需要生成的对象具有复杂的内部结构 需要生成的对象内部属性本身相互依赖 实现 构造者模式 例子 创建一个表示食物条目和食物包装的接口 // Item.java public interface Item { public String name(); public Packing packing(); public float price(); } // Packing.java public interface Packing { public String pack(); } 创建实现 Packing 接口的实体类 // Wrapper.java public class Wrapper implements Packing { @Override public String pack() { return \"Wrapper\"; } } // Bottle.java public class Bottle implements Packing { @Override public String pack() { return \"Bottle\"; } } 创建实现 Item 接口的抽象类，该类提供了默认的功能 // Burger.java public abstract class Burger implements Item { @Override public Packing packing() { return new Wrapper(); } @Override public abstract float price(); } // ColdDrink.java public abstract class ColdDrink implements Item { @Override public Packing packing() { return new Bottle(); } @Override public abstract float price(); } 创建扩展了 Burger 和 ColdDrink 的实体类 // VegBurger.java public class VegBurger extends Burger { @Override public float price() { return 25.0f; } @Override public String name() { return \"Veg Burger\"; } } // ChickenBurger.java public class ChickenBurger extends Burger { @Override public float price() { return 50.5f; } @Override public String name() { return \"Chicken Burger\"; } } // Coke.java public class Coke extends ColdDrink { @Override public float price() { return 30.0f; } @Override public String name() { return \"Coke\"; } } // Pepsi.java public class Pepsi extends ColdDrink { @Override public float price() { return 35.0f; } @Override public String name() { return \"Pepsi\"; } } 创建一个 Meal 类，带有上面定义的 Item 对象 import java.util.ArrayList; import java.util.List; public class Meal { private List\u003cItem\u003e items = new ArrayList\u003cItem\u003e(); public void addItem(Item item){ items.add(item); } public float getCost(){ float cost = 0.0f; for (Item item : items) { cost += item.price(); } return cost; } public void showItems(){ for (Item item : items) { System.out.print(\"Item : \"+item.name()); System.out.print(\", Packing : \"+item.packing().pack()); System.out.println(\", Price : \"+item.price()); } } } 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象 // MealBuilder.java public class MealBuilder { public Meal prepareVegMeal (){ Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; } public Meal prepareNonVegMeal (){ Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; } } BuilderPatternDemo // BuilderPatternDemo.java public class BuilderPatternDemo { public static void main(String[] args) { MealBuilder mealBuilder = new MealBuilder(); Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println(\"Veg Meal\"); vegMeal.showItems(); System.out.println(\"Total Cost: \" +vegMeal.getCost()); Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println(\"\\n\\nNon-Veg Meal\"); nonVegMeal.showItems(); System.out.println(\"Total Cost: \" +nonVegMeal.getCost()); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:4","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"原型模式 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 意图 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 主要解决 在运行期建立和删除原型 何时使用 当一个系统应该独立于它的产品创建，构成和表示时 当要实例化的类是在运行时刻指定时，例如，通过动态装载 为了避免创建一个与产品类层次平行的工厂类层次时 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 优点 性能提高 逃避构造函数的约束 缺点 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候 必须实现 Cloneable 接口 使用场景 资源优化场景 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等 性能和安全要求的场景 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式 一个对象多个修改者的场景 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 注意：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流 实现 原型模式 例子 创建一个实现了 Cloneable 接口的抽象类 // Shape.java public abstract class Shape implements Cloneable { private String id; protected String type; abstract void draw(); public String getType(){ return type; } public String getId() { return id; } public void setId(String id) { this.id = id; } public Object clone() { Object clone = null; try { clone = super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return clone; } } 创建扩展了上面抽象类的实体类 // Rectangle.java public class Rectangle extends Shape { public Rectangle(){ type = \"Rectangle\"; } @Override public void draw() { System.out.println(\"Inside Rectangle::draw() method.\"); } } // Square.java public class Square extends Shape { public Square(){ type = \"Square\"; } @Override public void draw() { System.out.println(\"Inside Square::draw() method.\"); } } // Circle.java public class Circle extends Shape { public Circle(){ type = \"Circle\"; } @Override public void draw() { System.out.println(\"Inside Circle::draw() method.\"); } } 创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中 // ShapeCache.java import java.util.Hashtable; public class ShapeCache { private static Hashtable\u003cString, Shape\u003e shapeMap = new Hashtable\u003cString, Shape\u003e(); public static Shape getShape(String shapeId) { Shape cachedShape = shapeMap.get(shapeId); return (Shape) cachedShape.clone(); } // 对每种形状都运行数据库查询，并创建该形状 // shapeMap.put(shapeKey, shape); // 例如，我们要添加三种形状 public static void loadCache() { Circle circle = new Circle(); circle.setId(\"1\"); shapeMap.put(circle.getId(),circle); Square square = new Square(); square.setId(\"2\"); shapeMap.put(square.getId(),square); Rectangle rectangle = new Rectangle(); rectangle.setId(\"3\"); shapeMap.put(rectangle.getId(),rectangle); } } PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆 // PrototypePatternDemo.java public class PrototypePatternDemo { public static void main(String[] args) { ShapeCache.loadCache(); Shape clonedShape = (Shape) ShapeCache.getShape(\"1\"); System.out.println(\"Shape : \" + clonedShape.getType()); Shape clonedShape2 = (Shape) ShapeCache.getShape(\"2\"); System.out.println(\"Shape : \" + clonedShape2.getType()); Shape clonedShape3 = (Shape) ShapeCache.getShape(\"3\"); System.out.println(\"Shape : \" + clonedShape3.getType()); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:5","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"适配器模式 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 意图 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决 主要解决在软件系统中，常常要将一些\"现存的对象\"放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用 系统需要使用现有的类，而此类的接口不符合系统的需要 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口 通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 优点 可以让任何两个没有关联的类一起运行 提高了类的复用 增加了类的透明度 灵活性好 缺点 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构 由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 使用场景 有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式 注意：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题 实现 适配器模式 例子 为媒体播放器和更高级的媒体播放器创建接口 // MediaPlayer.java public interface MediaPlayer { public void play(String audioType, String fileName); } // AdvancedMediaPlayer.java public interface AdvancedMediaPlayer { public void playVlc(String fileName); public void playMp4(String fileName); } 创建实现了 AdvancedMediaPlayer 接口的实体类 // VlcPlayer.java public class VlcPlayer implements AdvancedMediaPlayer{ @Override public void playVlc(String fileName) { System.out.println(\"Playing vlc file. Name: \"+ fileName); } @Override public void playMp4(String fileName) { //什么也不做 } } // Mp4Player.java public class Mp4Player implements AdvancedMediaPlayer{ @Override public void playVlc(String fileName) { //什么也不做 } @Override public void playMp4(String fileName) { System.out.println(\"Playing mp4 file. Name: \"+ fileName); } } 创建实现了 MediaPlayer 接口的适配器类 // MediaAdapter.java public class MediaAdapter implements MediaPlayer { AdvancedMediaPlayer advancedMusicPlayer; public MediaAdapter(String audioType){ if(audioType.equalsIgnoreCase(\"vlc\") ){ advancedMusicPlayer = new VlcPlayer(); } else if (audioType.equalsIgnoreCase(\"mp4\")){ advancedMusicPlayer = new Mp4Player(); } } @Override public void play(String audioType, String fileName) { if(audioType.equalsIgnoreCase(\"vlc\")){ advancedMusicPlayer.playVlc(fileName); }else if(audioType.equalsIgnoreCase(\"mp4\")){ advancedMusicPlayer.playMp4(fileName); } } } 创建实现了 MediaPlayer 接口的实体类 // AudioPlayer.java public class AudioPlayer implements MediaPlayer { MediaAdapter mediaAdapter; @Override public void play(String audioType, String fileName) { //播放 mp3 音乐文件的内置支持 if(audioType.equalsIgnoreCase(\"mp3\")){ System.out.println(\"Playing mp3 file. Name: \"+ fileName); } //mediaAdapter 提供了播放其他文件格式的支持 else if(audioType.equalsIgnoreCase(\"vlc\") || audioType.equalsIgnoreCase(\"mp4\")){ mediaAdapter = new MediaAdapter(audioType); mediaAdapter.play(audioType, fileName); } else{ System.out.println(\"Invalid media. \"+ audioType + \" format not supported\"); } } } 使用 AudioPlayer 来播放不同类型的音频格式 // AdapterPatternDemo.java public class AdapterPatternDemo { public static void main(String[] args) { AudioPlayer audioPlayer = new AudioPlayer(); audioPlayer.play(\"mp3\", \"beyond the horizon.mp3\"); audioPlayer.play(\"mp4\", \"alone.mp4\"); audioPlayer.play(\"vlc\", \"far far away.vlc\"); audioPlayer.play(\"avi\", \"mind me.avi\"); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:6","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"桥接模式 桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 意图 将抽象部分与实现部分分离，使它们都可以独立的变化 主要解决 在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活 何时使用 实现系统可能有多个角度分类，每一种角度都可能变化 应用实例 墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。 优点 抽象和实现的分离 优秀的扩展能力 实现细节对客户透明 缺点 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程 使用场景 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 对于两个独立变化的维度，使用桥接模式再适合不过了 实现 桥接模式 例子 创建桥接实现接口 // DrawAPI.java public interface DrawAPI { public void drawCircle(int radius, int x, int y); } 创建实现了 DrawAPI 接口的实体桥接实现类 // RedCircle.java public class RedCircle implements DrawAPI { @Override public void drawCircle(int radius, int x, int y) { System.out.println(\"Drawing Circle[ color: red, radius: \" + radius +\", x: \" +x+\", \"+ y +\"]\"); } } // GreenCircle.java public class GreenCircle implements DrawAPI { @Override public void drawCircle(int radius, int x, int y) { System.out.println(\"Drawing Circle[ color: green, radius: \" + radius +\", x: \" +x+\", \"+ y +\"]\"); } } 使用 DrawAPI 接口创建抽象类 Shape // Shape.java public abstract class Shape { protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI){ this.drawAPI = drawAPI; } public abstract void draw(); } 创建实现了 Shape 抽象类的实体类 // Circle.java public class Circle extends Shape { private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) { super(drawAPI); this.x = x; this.y = y; this.radius = radius; } public void draw() { drawAPI.drawCircle(radius,x,y); } } 使用 Shape 和 DrawAPI 类画出不同颜色的圆 // BridgePatternDemo.java public class BridgePatternDemo { public static void main(String[] args) { Shape redCircle = new Circle(100,100, 10, new RedCircle()); Shape greenCircle = new Circle(100,100, 10, new GreenCircle()); redCircle.draw(); greenCircle.draw(); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:7","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"过滤器模式 过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。 实现 过滤器模式 例子 创建一个类，在该类上应用标准 // Person.java public class Person { private String name; private String gender; private String maritalStatus; public Person(String name,String gender,String maritalStatus){ this.name = name; this.gender = gender; this.maritalStatus = maritalStatus; } public String getName() { return name; } public String getGender() { return gender; } public String getMaritalStatus() { return maritalStatus; } } 为标准（Criteria）创建一个接口 // Criteria.java import java.util.List; public interface Criteria { public List\u003cPerson\u003e meetCriteria(List\u003cPerson\u003e persons); } 创建实现了 Criteria 接口的实体类 // CriteriaMale.java import java.util.ArrayList; import java.util.List; public class CriteriaMale implements Criteria { @Override public List\u003cPerson\u003e meetCriteria(List\u003cPerson\u003e persons) { List\u003cPerson\u003e malePersons = new ArrayList\u003cPerson\u003e(); for (Person person : persons) { if(person.getGender().equalsIgnoreCase(\"MALE\")){ malePersons.add(person); } } return malePersons; } } // CriteriaFemale.java import java.util.ArrayList; import java.util.List; public class CriteriaFemale implements Criteria { @Override public List\u003cPerson\u003e meetCriteria(List\u003cPerson\u003e persons) { List\u003cPerson\u003e femalePersons = new ArrayList\u003cPerson\u003e(); for (Person person : persons) { if(person.getGender().equalsIgnoreCase(\"FEMALE\")){ femalePersons.add(person); } } return femalePersons; } } // CriteriaSingle.java import java.util.ArrayList; import java.util.List; public class CriteriaSingle implements Criteria { @Override public List\u003cPerson\u003e meetCriteria(List\u003cPerson\u003e persons) { List\u003cPerson\u003e singlePersons = new ArrayList\u003cPerson\u003e(); for (Person person : persons) { if(person.getMaritalStatus().equalsIgnoreCase(\"SINGLE\")){ singlePersons.add(person); } } return singlePersons; } } // AndCriteria.java import java.util.List; public class AndCriteria implements Criteria { private Criteria criteria; private Criteria otherCriteria; public AndCriteria(Criteria criteria, Criteria otherCriteria) { this.criteria = criteria; this.otherCriteria = otherCriteria; } @Override public List\u003cPerson\u003e meetCriteria(List\u003cPerson\u003e persons) { List\u003cPerson\u003e firstCriteriaPersons = criteria.meetCriteria(persons); return otherCriteria.meetCriteria(firstCriteriaPersons); } } // OrCriteria.java import java.util.List; public class OrCriteria implements Criteria { private Criteria criteria; private Criteria otherCriteria; public OrCriteria(Criteria criteria, Criteria otherCriteria) { this.criteria = criteria; this.otherCriteria = otherCriteria; } @Override public List\u003cPerson\u003e meetCriteria(List\u003cPerson\u003e persons) { List\u003cPerson\u003e firstCriteriaItems = criteria.meetCriteria(persons); List\u003cPerson\u003e otherCriteriaItems = otherCriteria.meetCriteria(persons); for (Person person : otherCriteriaItems) { if(!firstCriteriaItems.contains(person)){ firstCriteriaItems.add(person); } } return firstCriteriaItems; } } 使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表 // CriteriaPatternDemo.java import java.util.ArrayList; import java.util.List; public class CriteriaPatternDemo { public static void main(String[] args) { List\u003cPerson\u003e persons = new ArrayList\u003cPerson\u003e(); persons.add(new Person(\"Robert\",\"Male\", \"Single\")); persons.add(new Person(\"John\",\"Male\", \"Married\")); persons.add(new Person(\"Laura\",\"Female\", \"Married\")); persons.add(new Person(\"Diana\",\"Female\", \"Single\")); persons.add(new Person(\"Mike\",\"Male\", \"Single\")); persons.add(new Person(\"Bobby\",\"Male\", \"Single\")); Criteria male = new CriteriaMale(); Criteria female = new CriteriaFemale(); Criteria single = new CriteriaSingle(); Criteria singleMale = new AndCriteria(single, male); Criteria singleOrFemale = new OrCriteria(single, female); System.out.println(\"Males: \"); printPersons(male.meetCriteria(persons)); System.out.println(\"\\nFemales: \"); printPersons(female.meetCriteria(persons)); System.out.println(\"\\nSingle Males: \"); printPersons(singleMale.meetCriteria(persons","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:8","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"组合模式 组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 意图 将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性 主要解决 它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 如何使用 您想表示对象的部分-整体层次结构（树形结构） 您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象 如何解决 树枝和叶子实现统一接口，树枝内部组合该接口 关键代码 树枝内部组合该接口，并且含有内部属性 List，里面放 Component 应用实例 算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数 在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝 优点 高层模块调用简单 节点自由增加 缺点 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则 使用场景 部分、整体场景，如树形菜单，文件、文件夹的管理 注意事项：定义时为具体类 实现 组合模式 例子 创建 Employee 类，该类带有 Employee 对象的列表 // Employee.java import java.util.ArrayList; import java.util.List; public class Employee { private String name; private String dept; private int salary; private List\u003cEmployee\u003e subordinates; //构造函数 public Employee(String name,String dept, int sal) { this.name = name; this.dept = dept; this.salary = sal; subordinates = new ArrayList\u003cEmployee\u003e(); } public void add(Employee e) { subordinates.add(e); } public void remove(Employee e) { subordinates.remove(e); } public List\u003cEmployee\u003e getSubordinates(){ return subordinates; } public String toString(){ return (\"Employee :[ Name : \"+ name +\", dept : \"+ dept + \", salary :\" + salary+\" ]\"); } } 使用 Employee 类来创建和打印员工的层次结构 // CompositePatternDemo.java public class CompositePatternDemo { public static void main(String[] args) { Employee CEO = new Employee(\"John\",\"CEO\", 30000); Employee headSales = new Employee(\"Robert\",\"Head Sales\", 20000); Employee headMarketing = new Employee(\"Michel\",\"Head Marketing\", 20000); Employee clerk1 = new Employee(\"Laura\",\"Marketing\", 10000); Employee clerk2 = new Employee(\"Bob\",\"Marketing\", 10000); Employee salesExecutive1 = new Employee(\"Richard\",\"Sales\", 10000); Employee salesExecutive2 = new Employee(\"Rob\",\"Sales\", 10000); CEO.add(headSales); CEO.add(headMarketing); headSales.add(salesExecutive1); headSales.add(salesExecutive2); headMarketing.add(clerk1); headMarketing.add(clerk2); //打印该组织的所有员工 System.out.println(CEO); for (Employee headEmployee : CEO.getSubordinates()) { System.out.println(headEmployee); for (Employee employee : headEmployee.getSubordinates()) { System.out.println(employee); } } } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:9","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"装饰器模式 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 意图 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活 主要解决 一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀 何时使用 在不想增加很多子类的情况下扩展类 如果解决 将具体功能职责划分，同时继承装饰者模式 关键代码 Component 类充当抽象角色，不应该具体实现 修饰类引用和继承 Component 类，具体扩展类重写父类方法 应用实例 不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体 优点 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能 缺点 多层装饰比较复杂 使用场景 扩展一个类的功能 动态增加功能，动态撤销 注意事项：可替代继承 实现 装饰器模式 例子 创建一个接口 // Shape.java public interface Shape { void draw(); } 创建实现接口的实体类 // Rectangle.java public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Shape: Rectangle\"); } } // Circle.java public class Circle implements Shape { @Override public void draw() { System.out.println(\"Shape: Circle\"); } } 创建实现了 Shape 接口的抽象装饰类 // ShapeDecorator.java public abstract class ShapeDecorator implements Shape { protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape){ this.decoratedShape = decoratedShape; } public void draw(){ decoratedShape.draw(); } } 创建扩展了 ShapeDecorator 类的实体装饰类 // RedShapeDecorator.java public class RedShapeDecorator extends ShapeDecorator { public RedShapeDecorator(Shape decoratedShape) { super(decoratedShape); } @Override public void draw() { decoratedShape.draw(); setRedBorder(decoratedShape); } private void setRedBorder(Shape decoratedShape){ System.out.println(\"Border Color: Red\"); } } 使用 RedShapeDecorator 来装饰 Shape 对象 // DecoratorPatternDemo.java public class DecoratorPatternDemo { public static void main(String[] args) { Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); //Shape redCircle = new RedShapeDecorator(new Circle()); //Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(\"Circle with normal border\"); circle.draw(); System.out.println(\"\\nCircle of red border\"); redCircle.draw(); System.out.println(\"\\nRectangle of red border\"); redRectangle.draw(); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:10","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"外观模式 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 意图 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 主要解决 降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口 何时使用 客户端不需要知道系统内部的复杂联系，整个系统只需提供一个\"接待员\"即可 定义系统的入口 如何解决 客户端不与系统耦合，外观类与系统耦合 关键代码 在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好 应用实例 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便 优点 减少系统相互依赖 提高灵活性 提高了安全性。 缺点 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适 使用场景 为复杂的模块或子系统提供外界访问的模块 子系统相对独立 预防低水平人员带来的风险 注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口 实现 外观模式 例子 创建一个接口 // Shape.java public interface Shape { void draw(); } 创建实现接口的实体类 // Rectangle.java public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Rectangle::draw()\"); } } // Square.java public class Square implements Shape { @Override public void draw() { System.out.println(\"Square::draw()\"); } } // Circle.java public class Circle implements Shape { @Override public void draw() { System.out.println(\"Circle::draw()\"); } } 创建一个外观类 // ShapeMaker.java public class ShapeMaker { private Shape circle; private Shape rectangle; private Shape square; public ShapeMaker() { circle = new Circle(); rectangle = new Rectangle(); square = new Square(); } public void drawCircle(){ circle.draw(); } public void drawRectangle(){ rectangle.draw(); } public void drawSquare(){ square.draw(); } } 使用该外观类画出各种类型的形状 // FacadePatternDemo.java public class FacadePatternDemo { public static void main(String[] args) { ShapeMaker shapeMaker = new ShapeMaker(); shapeMaker.drawCircle(); shapeMaker.drawRectangle(); shapeMaker.drawSquare(); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:11","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"享元模式 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。 意图 运用共享技术有效地支持大量细粒度的对象 主要解决 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建 何时使用 系统中有大量对象 这些对象消耗大量内存 这些对象的状态大部分可以外部化 这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替 系统不依赖于这些对象身份，这些对象是不可分辨的。 如何解决 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象 关键代码 用 HashMap 存储这些对象 优点 大大减少对象的创建，降低系统的内存，使效率提高 缺点 提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱 使用场景 系统有大量相似对象 需要缓冲池的场景 注意事项： 注意划分外部状态和内部状态，否则可能会引起线程安全问题 这些类必须有一个工厂对象加以控制 实现 享元模式 例子 创建一个接口 // Shape.java public interface Shape { void draw(); } 创建实现接口的实体类 // Circle.java public class Circle implements Shape { private String color; private int x; private int y; private int radius; public Circle(String color){ this.color = color; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } public void setRadius(int radius) { this.radius = radius; } @Override public void draw() { System.out.println(\"Circle: Draw() [Color : \" + color +\", x : \" + x +\", y :\" + y +\", radius :\" + radius); } } 创建一个工厂，生成基于给定信息的实体类的对象 // ShapeFactory.java import java.util.HashMap; public class ShapeFactory { private static final HashMap\u003cString, Shape\u003e circleMap = new HashMap\u003c\u003e(); public static Shape getCircle(String color) { Circle circle = (Circle)circleMap.get(color); if(circle == null) { circle = new Circle(color); circleMap.put(color, circle); System.out.println(\"Creating circle of color : \" + color); } return circle; } } 使用该工厂，通过传递颜色信息来获取实体类的对象 // FlyweightPatternDemo.java public class FlyweightPatternDemo { private static final String colors[] = { \"Red\", \"Green\", \"Blue\", \"White\", \"Black\" }; public static void main(String[] args) { for(int i=0; i \u003c 20; ++i) { Circle circle = (Circle)ShapeFactory.getCircle(getRandomColor()); circle.setX(getRandomX()); circle.setY(getRandomY()); circle.setRadius(100); circle.draw(); } } private static String getRandomColor() { return colors[(int)(Math.random()*colors.length)]; } private static int getRandomX() { return (int)(Math.random()*100 ); } private static int getRandomY() { return (int)(Math.random()*100); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:12","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"代理模式 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式 意图 为其他对象提供一种代理以控制对这个对象的访问 主要解决 在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层 何时使用 想在访问一个类时做一些控制 如何解决 增加中间层 应用实例 买火车票不一定在火车站买，也可以去代售点 优点 职责清晰 高扩展性 智能化 缺点 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景 按职责来划分，通常有以下使用场景： 远程代理 虚拟代理 Copy-on-Write 代理 保护（Protect or Access）代理 Cache代理 防火墙（Firewall）代理 同步化（Synchronization）代理 智能引用（Smart Reference）代理 注意事项： 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制 实现 代理模式 例子 创建一个接口 // Image.java public interface Image { void display(); } 创建实现接口的实体类 // RealImage.java public class RealImage implements Image { private String fileName; public RealImage(String fileName){ this.fileName = fileName; loadFromDisk(fileName); } @Override public void display() { System.out.println(\"Displaying \" + fileName); } private void loadFromDisk(String fileName){ System.out.println(\"Loading \" + fileName); } } // ProxyImage.java public class ProxyImage implements Image{ private RealImage realImage; private String fileName; public ProxyImage(String fileName){ this.fileName = fileName; } @Override public void display() { if(realImage == null){ realImage = new RealImage(fileName); } realImage.display(); } } 当被请求时，使用 ProxyImage 来获取 RealImage 类的对象 // ProxyPatternDemo.java public class ProxyPatternDemo { public static void main(String[] args) { Image image = new ProxyImage(\"test_10mb.jpg\"); // 图像将从磁盘加载 image.display(); System.out.println(\"\"); // 图像不需要从磁盘加载 image.display(); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:13","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"责任链模式 责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 意图 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止 主要解决 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了 何时使用 在处理消息的时候以过滤很多道 如何解决 拦截的类都实现统一接口 关键代码 Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去 优点 降低耦合度。它将请求的发送者和接收者解耦 简化了对象。使得对象不需要知道链的结构 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任 增加新的请求处理类很方便 缺点 不能保证请求一定被接收 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用 可能不容易观察运行时的特征，有碍于除错 使用场景 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求 可动态指定一组对象处理请求。 实现 责任链模式 例子 创建抽象的记录器类 // AbstractLogger.java public abstract class AbstractLogger { public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; //责任链中的下一个元素 protected AbstractLogger nextLogger; public void setNextLogger(AbstractLogger nextLogger){ this.nextLogger = nextLogger; } public void logMessage(int level, String message){ if(this.level \u003c= level){ write(message); } if(nextLogger !=null){ nextLogger.logMessage(level, message); } } abstract protected void write(String message); } 创建扩展了该记录器类的实体类 // ConsoleLogger.java public class ConsoleLogger extends AbstractLogger { public ConsoleLogger(int level){ this.level = level; } @Override protected void write(String message) { System.out.println(\"Standard Console::Logger: \" + message); } } // ErrorLogger.java public class ErrorLogger extends AbstractLogger { public ErrorLogger(int level){ this.level = level; } @Override protected void write(String message) { System.out.println(\"Error Console::Logger: \" + message); } } // FileLogger.java public class FileLogger extends AbstractLogger { public FileLogger(int level){ this.level = level; } @Override protected void write(String message) { System.out.println(\"File::Logger: \" + message); } } 创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分 // ChainPatternDemo.java public class ChainPatternDemo { private static AbstractLogger getChainOfLoggers(){ AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR); AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG); AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO); errorLogger.setNextLogger(fileLogger); fileLogger.setNextLogger(consoleLogger); return errorLogger; } public static void main(String[] args) { AbstractLogger loggerChain = getChainOfLoggers(); loggerChain.logMessage(AbstractLogger.INFO, \"This is an information.\"); loggerChain.logMessage(AbstractLogger.DEBUG, \"This is a debug level information.\"); loggerChain.logMessage(AbstractLogger.ERROR, \"This is an error information.\"); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:14","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"命令模式 命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 意图 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化 主要解决 在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适 何时使用 在某些场合，比如要对行为进行\"记录、撤销/重做、事务\"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\"行为请求者\"与\"行为实现者\"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合 如何解决 通过调用者调用接受者执行命令，顺序：调用者→命令→接受者 关键代码 定义三个角色： received 真正的命令执行对象 Command invoker 使用命令对象的入口 应用实例 struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command 优点 降低了系统耦合度 新的命令可以很容易添加到系统中去 缺点 使用命令模式可能会导致某些系统有过多的具体命令类 使用场景 认为是命令的地方都可以使用命令模式，比如： GUI 中每一个按钮都是一条命令 模拟 CMD 注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展 示意图 命令模式示意图 实现 命令模式 例子 创建一个命令接口 // Order.java public interface Order { void execute(); } 创建一个请求类 // Stock.java public class Stock { private String name = \"ABC\"; private int quantity = 10; public void buy(){ System.out.println(\"Stock [ Name: \"+name+\", Quantity: \" + quantity +\" ] bought\"); } public void sell(){ System.out.println(\"Stock [ Name: \"+name+\", Quantity: \" + quantity +\" ] sold\"); } } 创建实现了 Order 接口的实体类 // BuyStock.java public class BuyStock implements Order { private Stock abcStock; public BuyStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.buy(); } } // SellStock.java public class SellStock implements Order { private Stock abcStock; public SellStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.sell(); } } 创建命令调用类 // Broker.java import java.util.ArrayList; import java.util.List; public class Broker { private List\u003cOrder\u003e orderList = new ArrayList\u003cOrder\u003e(); public void takeOrder(Order order){ orderList.add(order); } public void placeOrders(){ for (Order order : orderList) { order.execute(); } orderList.clear(); } } 使用 Broker 类来接受并执行命令 // CommandPatternDemo.java public class CommandPatternDemo { public static void main(String[] args) { Stock abcStock = new Stock(); BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); broker.placeOrders(); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:15","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"解释器模式 解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 意图 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子 主要解决 对于一些固定文法构建一个解释句子的解释器 何时使用 如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题 如何解决 构建语法树，定义终结符与非终结符 关键代码 构建环境类，包含解释器之外的一些全局信息，一般是 HashMap 应用实例 编译器、运算表达式计算 优点 可扩展性比较好，灵活 增加了新的解释表达式的方式 易于实现简单文法 缺点 可利用场景比较少 对于复杂的文法比较难维护 解释器模式会引起类膨胀 解释器模式采用递归调用方法 使用场景 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树 一些重复出现的问题可以用一种简单的语言来进行表达 一个简单语法需要解释的场景。 注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替 实现 解释器模式 例子 创建一个表达式接口 // Expression.java public interface Expression { public boolean interpret(String context); } 创建实现了上述接口的实体类 // TerminalExpression.java public class TerminalExpression implements Expression { private String data; public TerminalExpression(String data){ this.data = data; } @Override public boolean interpret(String context) { if(context.contains(data)){ return true; } return false; } } // OrExpression.java public class OrExpression implements Expression { private Expression expr1 = null; private Expression expr2 = null; public OrExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } @Override public boolean interpret(String context) { return expr1.interpret(context) || expr2.interpret(context); } } // AndExpression.java public class AndExpression implements Expression { private Expression expr1 = null; private Expression expr2 = null; public AndExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } @Override public boolean interpret(String context) { return expr1.interpret(context) \u0026\u0026 expr2.interpret(context); } } InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们 // InterpreterPatternDemo.java public class InterpreterPatternDemo { //规则：Robert 和 John 是男性 public static Expression getMaleExpression(){ Expression robert = new TerminalExpression(\"Robert\"); Expression john = new TerminalExpression(\"John\"); return new OrExpression(robert, john); } //规则：Julie 是一个已婚的女性 public static Expression getMarriedWomanExpression(){ Expression julie = new TerminalExpression(\"Julie\"); Expression married = new TerminalExpression(\"Married\"); return new AndExpression(julie, married); } public static void main(String[] args) { Expression isMale = getMaleExpression(); Expression isMarriedWoman = getMarriedWomanExpression(); System.out.println(\"John is male? \" + isMale.interpret(\"John\")); System.out.println(\"Julie is a married women? \" + isMarriedWoman.interpret(\"Married Julie\")); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:16","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"迭代器模式 这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示 迭代器模式属于行为型模式 意图 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示 主要解决 不同的方式来遍历整个整合对象 何时使用 遍历一个聚合对象 如何解决 把在元素之间游走的责任交给迭代器，而不是聚合对象 关键代码 定义接口：hasNext, next 优点 它支持以不同的方式遍历一个聚合对象 迭代器简化了聚合类 在同一个聚合上可以有多个遍历 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性 使用场景 访问一个聚合对象的内容而无须暴露它的内部表示 需要为聚合对象提供多种遍历方式 为遍历不同的聚合结构提供一个统一的接口 注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据 实现 迭代器模式 例子 创建接口 // Iterator.java public interface Iterator { public boolean hasNext(); public Object next(); } // Container.java public interface Container { public Iterator getIterator(); } 创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator // NameRepository.java public class NameRepository implements Container { public String[] names = {\"Robert\" , \"John\" ,\"Julie\" , \"Lora\"}; @Override public Iterator getIterator() { return new NameIterator(); } private class NameIterator implements Iterator { int index; @Override public boolean hasNext() { if(index \u003c names.length){ return true; } return false; } @Override public Object next() { if(this.hasNext()){ return names[index++]; } return null; } } } 使用 NameRepository 来获取迭代器，并打印名字 // IteratorPatternDemo.java public class IteratorPatternDemo { public static void main(String[] args) { NameRepository namesRepository = new NameRepository(); for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){ String name = (String)iter.next(); System.out.println(\"Name : \" + name); } } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:17","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"中介者模式 中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 意图 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 主要解决 对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理 何时使用 多个类相互耦合，形成了网状结构 如何解决 将上述网状结构分离为星型结构 应用实例 中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易 机场调度系统 MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者 优点 降低了类的复杂度，将一对多转化成了一对一 各个类之间的解耦 符合迪米特原则 缺点 中介者会庞大，变得复杂难以维护 使用场景 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类 实现 中介者模式 例子 创建中介类 // ChatRoom.java import java.util.Date; public class ChatRoom { public static void showMessage(User user, String message){ System.out.println(new Date().toString() + \" [\" + user.getName() +\"] : \" + message); } } 创建 user 类 // User.java public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public User(String name){ this.name = name; } public void sendMessage(String message){ ChatRoom.showMessage(this,message); } } 使用 User 对象来显示他们之间的通信 // MediatorPatternDemo.java public class MediatorPatternDemo { public static void main(String[] args) { User robert = new User(\"Robert\"); User john = new User(\"John\"); robert.sendMessage(\"Hi! John!\"); john.sendMessage(\"Hello! Robert!\"); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:18","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"备忘录模式 备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。 意图 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态 主要解决 所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态 何时使用 很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有\"后悔药\"可吃 如何解决 通过一个备忘录类专门存储对象状态 关键代码 客户不与备忘录类耦合，与备忘录管理类耦合 应用实例 打游戏时的存档 Windows 里的 ctrl + z IE 中的后退 数据库的事务管理 优点 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态 实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存 使用场景 需要保存/恢复数据的相关状态场景 提供一个可回滚的操作 注意事项 为了符合迪米特原则，还要增加一个管理备忘录的类 为了节约内存，可使用原型模式+备忘录模式 实现 备忘录模式 例子 创建 Memento 类 // Memento.java public class Memento { private String state; public Memento(String state){ this.state = state; } public String getState(){ return state; } } 创建 Originator 类 // Originator.java public class Originator { private String state; public void setState(String state){ this.state = state; } public String getState(){ return state; } public Memento saveStateToMemento(){ return new Memento(state); } public void getStateFromMemento(Memento Memento){ state = Memento.getState(); } } 创建 CareTaker 类 // CareTaker.java import java.util.ArrayList; import java.util.List; public class CareTaker { private List\u003cMemento\u003e mementoList = new ArrayList\u003cMemento\u003e(); public void add(Memento state){ mementoList.add(state); } public Memento get(int index){ return mementoList.get(index); } } 使用 CareTaker 和 Originator 对象 // MementoPatternDemo.java public class MementoPatternDemo { public static void main(String[] args) { Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState(\"State #1\"); originator.setState(\"State #2\"); careTaker.add(originator.saveStateToMemento()); originator.setState(\"State #3\"); careTaker.add(originator.saveStateToMemento()); originator.setState(\"State #4\"); System.out.println(\"Current State: \" + originator.getState()); originator.getStateFromMemento(careTaker.get(0)); System.out.println(\"First saved State: \" + originator.getState()); originator.getStateFromMemento(careTaker.get(1)); System.out.println(\"Second saved State: \" + originator.getState()); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:19","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"观察者模式 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式 意图 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新 主要解决 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作 何时使用 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知 如何解决 使用面向对象技术，可以将这种依赖关系弱化 关键代码 在抽象类里有一个 ArrayList 存放观察者们 应用实例 拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价 优点 观察者和被观察者是抽象耦合的 建立一套触发机制 缺点 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化 使用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 注意事项: JAVA 中已经有了对观察者模式的支持类 避免循环引用 如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式 实现 观察者模式 例子 创建 Subject 类 // Subject.java import java.util.ArrayList; import java.util.List; public class Subject { private List\u003cObserver\u003e observers = new ArrayList\u003cObserver\u003e(); private int state; public int getState() { return state; } public void setState(int state) { this.state = state; notifyAllObservers(); } public void attach(Observer observer){ observers.add(observer); } public void notifyAllObservers(){ for (Observer observer : observers) { observer.update(); } } } 创建 Observer 类 // Observer.java public abstract class Observer { protected Subject subject; public abstract void update(); } 创建实体观察者类 // BinaryObserver.java public class BinaryObserver extends Observer{ public BinaryObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \"Binary String: \" + Integer.toBinaryString( subject.getState() ) ); } } // OctalObserver.java public class OctalObserver extends Observer{ public OctalObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \"Octal String: \" + Integer.toOctalString( subject.getState() ) ); } } // HexaObserver.java public class HexaObserver extends Observer{ public HexaObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \"Hex String: \" + Integer.toHexString( subject.getState() ).toUpperCase() ); } } 使用 Subject 和实体观察者对象 // ObserverPatternDemo.java public class ObserverPatternDemo { public static void main(String[] args) { Subject subject = new Subject(); new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println(\"First state change: 15\"); subject.setState(15); System.out.println(\"Second state change: 10\"); subject.setState(10); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:20","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"状态模式 在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象 意图 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类 主要解决 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为 何时使用 代码中包含大量与对象状态有关的条件语句 如何解决 将各种具体的状态类抽象出来 关键代码 通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 应用实例 打篮球的时候运动员可以有正常状态、不正常状态和超常状态 曾侯乙编钟中，‘钟是抽象接口’,‘钟A’等是具体状态，‘曾侯乙编钟’是具体环境（Context） 优点 封装了转换规则 枚举可能的状态，在枚举状态之前需要确定状态种类 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数 缺点 状态模式的使用必然会增加系统类和对象的个数 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱 状态模式对\"开闭原则\"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景 行为随状态改变而改变的场景 条件、分支语句的代替者 注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个 实现 状态模式 例子 创建一个接口 // State.java public interface State { public void doAction(Context context); } 创建实现接口的实体类 // StartState.java public class StartState implements State { public void doAction(Context context) { System.out.println(\"Player is in start state\"); context.setState(this); } public String toString(){ return \"Start State\"; } } // StopState.java public class StopState implements State { public void doAction(Context context) { System.out.println(\"Player is in stop state\"); context.setState(this); } public String toString(){ return \"Stop State\"; } } 创建 Context 类 // Context.java public class Context { private State state; public Context(){ state = null; } public void setState(State state){ this.state = state; } public State getState(){ return state; } } 使用 Context 来查看当状态 State 改变时的行为变化 // StatePatternDemo.java public class StatePatternDemo { public static void main(String[] args) { Context context = new Context(); StartState startState = new StartState(); startState.doAction(context); System.out.println(context.getState().toString()); StopState stopState = new StopState(); stopState.doAction(context); System.out.println(context.getState().toString()); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:21","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"空对象模式 在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。 在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。 实现 空对象模式 例子 创建一个抽象类 // AbstractCustomer.java public abstract class AbstractCustomer { protected String name; public abstract boolean isNil(); public abstract String getName(); } 创建扩展了上述类的实体类 // RealCustomer.java public class RealCustomer extends AbstractCustomer { public RealCustomer(String name) { this.name = name; } @Override public String getName() { return name; } @Override public boolean isNil() { return false; } } // NullCustomer.java public class NullCustomer extends AbstractCustomer { @Override public String getName() { return \"Not Available in Customer Database\"; } @Override public boolean isNil() { return true; } } 创建 CustomerFactory 类 // CustomerFactory.java public class CustomerFactory { public static final String[] names = {\"Rob\", \"Joe\", \"Julie\"}; public static AbstractCustomer getCustomer(String name){ for (int i = 0; i \u003c names.length; i++) { if (names[i].equalsIgnoreCase(name)){ return new RealCustomer(name); } } return new NullCustomer(); } } 使用 CustomerFactory，基于客户传递的名字，来获取 RealCustomer 或 NullCustomer 对象。 // NullPatternDemo.java public class NullPatternDemo { public static void main(String[] args) { AbstractCustomer customer1 = CustomerFactory.getCustomer(\"Rob\"); AbstractCustomer customer2 = CustomerFactory.getCustomer(\"Bob\"); AbstractCustomer customer3 = CustomerFactory.getCustomer(\"Julie\"); AbstractCustomer customer4 = CustomerFactory.getCustomer(\"Laura\"); System.out.println(\"Customers\"); System.out.println(customer1.getName()); System.out.println(customer2.getName()); System.out.println(customer3.getName()); System.out.println(customer4.getName()); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:22","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"策略模式 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 意图 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换 主要解决 在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护 何时使用 一个系统有许多许多类，而区分它们的只是他们直接的行为 如何解决 将这些算法封装成一个一个的类，任意地替换 关键代码 实现同一个接口 应用实例 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略 优点 算法可以自由切换 避免使用多重条件判断 扩展性良好 缺点 策略类会增多 所有策略类都需要对外暴露 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为 一个系统需要动态地在几种算法中选择一种 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题 实现 策略模式 例子 创建一个接口 // Strategy.java public interface Strategy { public int doOperation(int num1, int num2); } 创建实现接口的实体类 // OperationAdd.java public class OperationAdd implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 + num2; } } // OperationSubtract.java public class OperationSubtract implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 - num2; } } // OperationMultiply.java public class OperationMultiply implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 * num2; } } 创建 Context 类 // Context.java public class Context { private Strategy strategy; public Context(Strategy strategy){ this.strategy = strategy; } public int executeStrategy(int num1, int num2){ return strategy.doOperation(num1, num2); } } 使用 Context 来查看当它改变策略 Strategy 时的行为变化 // StrategyPatternDemo.java public class StrategyPatternDemo { public static void main(String[] args) { Context context = new Context(new OperationAdd()); System.out.println(\"10 + 5 = \" + context.executeStrategy(10, 5)); context = new Context(new OperationSubtract()); System.out.println(\"10 - 5 = \" + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println(\"10 * 5 = \" + context.executeStrategy(10, 5)); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:23","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"模板模式 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 意图 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 主要解决 一些方法通用，却在每一个子类都重新写了这一方法 何时使用 有一些通用的方法 如何解决 将这些通用算法抽象出来 关键代码 关键步骤在抽象类实现，其他步骤在子类实现 应用实例 在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异 优点 封装不变部分，扩展可变部分 提取公共代码，便于维护 行为由父类控制，子类实现 缺点 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大 使用场景 有多个子类共有的方法，且逻辑相同 重要的、复杂的方法，可以考虑作为模板方法。 注意事项：为防止恶意操作，一般模板方法都加上 final 关键词 实现 模板模式 ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:24","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"访问者模式 在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 意图 主要将数据结构与数据操作分离 主要解决 稳定的数据结构和易变的操作耦合问题 何时使用 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，使用访问者模式将这些封装到类中 如何解决 在被访问的类里面加一个对外提供接待访问者的接口 关键代码 在数据基础类里面有一个方法接受访问者，将自身引用传入访问者 应用实例 您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式 优点 符合单一职责原则 优秀的扩展性 灵活性 缺点 具体元素对访问者公布细节，违反了迪米特原则 具体元素变更比较困难 违反了依赖倒置原则，依赖了具体类，没有依赖抽象 使用场景 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，也不希望在增加新操作时修改这些类。 注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 实现 访问者模式 例子 定义一个表示元素的接口 // ComputerPart.java public interface ComputerPart { public void accept(ComputerPartVisitor computerPartVisitor); } 创建扩展了上述类的实体类 // Keyboard.java public class Keyboard implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); } } // Monitor.java public class Monitor implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); } } // Mouse.java public class Mouse implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); } } // Computer.java public class Computer implements ComputerPart { ComputerPart[] parts; public Computer(){ parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()}; } @Override public void accept(ComputerPartVisitor computerPartVisitor) { for (int i = 0; i \u003c parts.length; i++) { parts[i].accept(computerPartVisitor); } computerPartVisitor.visit(this); } } 定义一个表示访问者的接口 // ComputerPartVisitor.java public interface ComputerPartVisitor { public void visit(Computer computer); public void visit(Mouse mouse); public void visit(Keyboard keyboard); public void visit(Monitor monitor); } 创建实现了上述类的实体访问者 // ComputerPartDisplayVisitor.java public class ComputerPartDisplayVisitor implements ComputerPartVisitor { @Override public void visit(Computer computer) { System.out.println(\"Displaying Computer.\"); } @Override public void visit(Mouse mouse) { System.out.println(\"Displaying Mouse.\"); } @Override public void visit(Keyboard keyboard) { System.out.println(\"Displaying Keyboard.\"); } @Override public void visit(Monitor monitor) { System.out.println(\"Displaying Monitor.\"); } } 使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分 // VisitorPatternDemo.java public class VisitorPatternDemo { public static void main(String[] args) { ComputerPart computer = new Computer(); computer.accept(new ComputerPartDisplayVisitor()); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:25","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"MVC模式 MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 Model(模型): 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 View(视图): 视图代表模型包含的数据的可视化。 Controller(控制器): 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 MVC 实现 MVC 例子 创建模型 // Student.java public class Student { private String rollNo; private String name; public String getRollNo() { return rollNo; } public void setRollNo(String rollNo) { this.rollNo = rollNo; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 创建视图 // StudentView.java public class StudentView { public void printStudentDetails(String studentName, String studentRollNo){ System.out.println(\"Student: \"); System.out.println(\"Name: \" + studentName); System.out.println(\"Roll No: \" + studentRollNo); } } 创建控制器 // StudentController.java public class StudentController { private Student model; private StudentView view; public StudentController(Student model, StudentView view){ this.model = model; this.view = view; } public void setStudentName(String name){ model.setName(name); } public String getStudentName(){ return model.getName(); } public void setStudentRollNo(String rollNo){ model.setRollNo(rollNo); } public String getStudentRollNo(){ return model.getRollNo(); } public void updateView(){ view.printStudentDetails(model.getName(), model.getRollNo()); } } 使用 StudentController 方法来演示 MVC 设计模式的用法 // MVCPatternDemo.java public class MVCPatternDemo { public static void main(String[] args) { //从数据库获取学生记录 Student model = retrieveStudentFromDatabase(); //创建一个视图：把学生详细信息输出到控制台 StudentView view = new StudentView(); StudentController controller = new StudentController(model, view); controller.updateView(); //更新模型数据 controller.setStudentName(\"John\"); controller.updateView(); } private static Student retrieveStudentFromDatabase(){ Student student = new Student(); student.setName(\"Robert\"); student.setRollNo(\"10\"); return student; } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:26","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"业务代表模式 业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体 客户端(Client): 表示层代码可以是 JSP、servlet 或 UI java 代码。 业务代表(Business Delegate): 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。 查询服务(LookUp Service): 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。 业务服务(Business Service): 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。 实现 业务代表模式 例子 创建 BusinessService 接口 // BusinessService.java public interface BusinessService { public void doProcessing(); } 创建实体服务类 // EJBService.java public class EJBService implements BusinessService { @Override public void doProcessing() { System.out.println(\"Processing task by invoking EJB Service\"); } } // JMSService.java public class JMSService implements BusinessService { @Override public void doProcessing() { System.out.println(\"Processing task by invoking JMS Service\"); } } 创建业务查询服务 // BusinessLookUp.java public class BusinessLookUp { public BusinessService getBusinessService(String serviceType){ if(serviceType.equalsIgnoreCase(\"EJB\")){ return new EJBService(); }else { return new JMSService(); } } } 创建业务代表 // BusinessDelegate.java public class BusinessDelegate { private BusinessLookUp lookupService = new BusinessLookUp(); private BusinessService businessService; private String serviceType; public void setServiceType(String serviceType){ this.serviceType = serviceType; } public void doTask(){ businessService = lookupService.getBusinessService(serviceType); businessService.doProcessing(); } } 创建客户端 // Client.java public class Client { BusinessDelegate businessService; public Client(BusinessDelegate businessService){ this.businessService = businessService; } public void doTask(){ businessService.doTask(); } } 使用 BusinessDelegate 和 Client 类来演示业务代表模式 // BusinessDelegatePatternDemo.java public class BusinessDelegatePatternDemo { public static void main(String[] args) { BusinessDelegate businessDelegate = new BusinessDelegate(); businessDelegate.setServiceType(\"EJB\"); Client client = new Client(businessDelegate); client.doTask(); businessDelegate.setServiceType(\"JMS\"); client.doTask(); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:27","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"组合实体模式 组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。 组合实体（Composite Entity） - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。 粗粒度对象（Coarse-Grained Object） - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。 依赖对象（Dependent Object） - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。 策略（Strategies） - 策略表示如何实现组合实体。 实现 组合实体模式 例子 创建依赖对象 // DependentObject1.java public class DependentObject1 { private String data; public void setData(String data){ this.data = data; } public String getData(){ return data; } } // DependentObject2.java public class DependentObject2 { private String data; public void setData(String data){ this.data = data; } public String getData(){ return data; } } 创建粗粒度对象 // CoarseGrainedObject.java public class CoarseGrainedObject { DependentObject1 do1 = new DependentObject1(); DependentObject2 do2 = new DependentObject2(); public void setData(String data1, String data2){ do1.setData(data1); do2.setData(data2); } public String[] getData(){ return new String[] {do1.getData(),do2.getData()}; } } 创建组合实体 // CompositeEntity.java public class CompositeEntity { private CoarseGrainedObject cgo = new CoarseGrainedObject(); public void setData(String data1, String data2){ cgo.setData(data1, data2); } public String[] getData(){ return cgo.getData(); } } 创建使用组合实体的客户端类 // Client.java public class Client { private CompositeEntity compositeEntity = new CompositeEntity(); public void printData(){ for (int i = 0; i \u003c compositeEntity.getData().length; i++) { System.out.println(\"Data: \" + compositeEntity.getData()[i]); } } public void setData(String data1, String data2){ compositeEntity.setData(data1, data2); } } 使用 Client 来演示组合实体设计模式的用法 // CompositeEntityPatternDemo.java public class CompositeEntityPatternDemo { public static void main(String[] args) { Client client = new Client(); client.setData(\"Test\", \"Data\"); client.printData(); client.setData(\"Second Test\", \"Data1\"); client.printData(); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:28","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"数据访问对象模式 数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。 数据访问对象接口（Data Access Object Interface） - 该接口定义了在一个模型对象上要执行的标准操作。 数据访问对象实体类（Data Access Object concrete class） - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。 模型对象/数值对象（Model Object/Value Object） - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。 实现 数据访问对象模式 例子 创建数值对象 // Student.java public class Student { private String name; private int rollNo; Student(String name, int rollNo){ this.name = name; this.rollNo = rollNo; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getRollNo() { return rollNo; } public void setRollNo(int rollNo) { this.rollNo = rollNo; } } 创建数据访问对象接口 // StudentDao.java import java.util.List; public interface StudentDao { public List\u003cStudent\u003e getAllStudents(); public Student getStudent(int rollNo); public void updateStudent(Student student); public void deleteStudent(Student student); } 创建实现了上述接口的实体类 // StudentDaoImpl.java import java.util.ArrayList; import java.util.List; public class StudentDaoImpl implements StudentDao { //列表是当作一个数据库 List\u003cStudent\u003e students; public StudentDaoImpl(){ students = new ArrayList\u003cStudent\u003e(); Student student1 = new Student(\"Robert\",0); Student student2 = new Student(\"John\",1); students.add(student1); students.add(student2); } @Override public void deleteStudent(Student student) { students.remove(student.getRollNo()); System.out.println(\"Student: Roll No \" + student.getRollNo() +\", deleted from database\"); } //从数据库中检索学生名单 @Override public List\u003cStudent\u003e getAllStudents() { return students; } @Override public Student getStudent(int rollNo) { return students.get(rollNo); } @Override public void updateStudent(Student student) { students.get(student.getRollNo()).setName(student.getName()); System.out.println(\"Student: Roll No \" + student.getRollNo() +\", updated in the database\"); } } 使用 StudentDao 来演示数据访问对象模式的用法 // DaoPatternDemo.java public class DaoPatternDemo { public static void main(String[] args) { StudentDao studentDao = new StudentDaoImpl(); //输出所有的学生 for (Student student : studentDao.getAllStudents()) { System.out.println(\"Student: [RollNo : \" +student.getRollNo()+\", Name : \"+student.getName()+\" ]\"); } //更新学生 Student student =studentDao.getAllStudents().get(0); student.setName(\"Michael\"); studentDao.updateStudent(student); //获取学生 studentDao.getStudent(0); System.out.println(\"Student: [RollNo : \" +student.getRollNo()+\", Name : \"+student.getName()+\" ]\"); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:29","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"前端控制器模式 前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。 前端控制器（Front Controller） - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。 调度器（Dispatcher） - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。 视图（View） - 视图是为请求而创建的对象。 实现 前端控制器模式 例子 创建视图 // HomeView.java public class HomeView { public void show(){ System.out.println(\"Displaying Home Page\"); } } // StudentView.java public class StudentView { public void show(){ System.out.println(\"Displaying Student Page\"); } } 创建调度器 Dispatcher // Dispatcher.java public class Dispatcher { private StudentView studentView; private HomeView homeView; public Dispatcher(){ studentView = new StudentView(); homeView = new HomeView(); } public void dispatch(String request){ if(request.equalsIgnoreCase(\"STUDENT\")){ studentView.show(); }else{ homeView.show(); } } } 创建前端控制器 FrontController // FrontController.java public class FrontController { private Dispatcher dispatcher; public FrontController(){ dispatcher = new Dispatcher(); } private boolean isAuthenticUser(){ System.out.println(\"User is authenticated successfully.\"); return true; } private void trackRequest(String request){ System.out.println(\"Page requested: \" + request); } public void dispatchRequest(String request){ //记录每一个请求 trackRequest(request); //对用户进行身份验证 if(isAuthenticUser()){ dispatcher.dispatch(request); } } } 使用 FrontController 来演示前端控制器设计模式 // FrontControllerPatternDemo.java public class FrontControllerPatternDemo { public static void main(String[] args) { FrontController frontController = new FrontController(); frontController.dispatchRequest(\"HOME\"); frontController.dispatchRequest(\"STUDENT\"); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:30","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"拦截过滤器模式 拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。 过滤器（Filter） - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。 过滤器链（Filter Chain） - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。 Target - Target 对象是请求处理程序。 过滤管理器（Filter Manager） - 过滤管理器管理过滤器和过滤器链。 客户端（Client） - Client 是向 Target 对象发送请求的对象 实现 拦截过滤器模式 例子 创建过滤器接口 Filter // Filter.java public interface Filter { public void execute(String request); } 创建实体过滤器 // AuthenticationFilter.java public class AuthenticationFilter implements Filter { public void execute(String request){ System.out.println(\"Authenticating request: \" + request); } } // DebugFilter.java public class DebugFilter implements Filter { public void execute(String request){ System.out.println(\"request log: \" + request); } } 创建 Target // Target.java public class Target { public void execute(String request){ System.out.println(\"Executing request: \" + request); } } 创建过滤器链 // FilterChain.java import java.util.ArrayList; import java.util.List; public class FilterChain { private List\u003cFilter\u003e filters = new ArrayList\u003cFilter\u003e(); private Target target; public void addFilter(Filter filter){ filters.add(filter); } public void execute(String request){ for (Filter filter : filters) { filter.execute(request); } target.execute(request); } public void setTarget(Target target){ this.target = target; } } 创建过滤管理器 // FilterManager.java public class FilterManager { FilterChain filterChain; public FilterManager(Target target){ filterChain = new FilterChain(); filterChain.setTarget(target); } public void setFilter(Filter filter){ filterChain.addFilter(filter); } public void filterRequest(String request){ filterChain.execute(request); } } 创建客户端 Client // Client.java public class Client { FilterManager filterManager; public void setFilterManager(FilterManager filterManager){ this.filterManager = filterManager; } public void sendRequest(String request){ filterManager.filterRequest(request); } } 使用 Client 来演示拦截过滤器设计模式 // InterceptingFilterDemo.java public class InterceptingFilterDemo { public static void main(String[] args) { FilterManager filterManager = new FilterManager(new Target()); filterManager.setFilter(new AuthenticationFilter()); filterManager.setFilter(new DebugFilter()); Client client = new Client(); client.setFilterManager(filterManager); client.sendRequest(\"HOME\"); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:31","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"服务定位器模式 服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。 服务（Service） - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。 Context / 初始的 Context - JNDI Context 带有对要查找的服务的引用。 服务定位器（Service Locator） - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。 缓存（Cache） - 缓存存储服务的引用，以便复用它们。 客户端（Client） - Client 是通过 ServiceLocator 调用服务的对象。 实现 服务定位模式 例子 创建服务接口 Service // Service.java public interface Service { public String getName(); public void execute(); } 创建实体服务 // Service1.java public class Service1 implements Service { public void execute(){ System.out.println(\"Executing Service1\"); } @Override public String getName() { return \"Service1\"; } } // Service2.java public class Service2 implements Service { public void execute(){ System.out.println(\"Executing Service2\"); } @Override public String getName() { return \"Service2\"; } } 为 JNDI 查询创建 InitialContext // InitialContext.java public class InitialContext { public Object lookup(String jndiName){ if(jndiName.equalsIgnoreCase(\"SERVICE1\")){ System.out.println(\"Looking up and creating a new Service1 object\"); return new Service1(); }else if (jndiName.equalsIgnoreCase(\"SERVICE2\")){ System.out.println(\"Looking up and creating a new Service2 object\"); return new Service2(); } return null; } } 创建缓存 Cache // Cache.java import java.util.ArrayList; import java.util.List; public class Cache { private List\u003cService\u003e services; public Cache(){ services = new ArrayList\u003cService\u003e(); } public Service getService(String serviceName){ for (Service service : services) { if(service.getName().equalsIgnoreCase(serviceName)){ System.out.println(\"Returning cached \"+serviceName+\" object\"); return service; } } return null; } public void addService(Service newService){ boolean exists = false; for (Service service : services) { if(service.getName().equalsIgnoreCase(newService.getName())){ exists = true; } } if(!exists){ services.add(newService); } } } 创建服务定位器 // ServiceLocator.java public class ServiceLocator { private static Cache cache; static { cache = new Cache(); } public static Service getService(String jndiName){ Service service = cache.getService(jndiName); if(service != null){ return service; } InitialContext context = new InitialContext(); Service service1 = (Service)context.lookup(jndiName); cache.addService(service1); return service1; } } 使用 ServiceLocator 来演示服务定位器设计模式 // ServiceLocatorPatternDemo.java public class ServiceLocatorPatternDemo { public static void main(String[] args) { Service service = ServiceLocator.getService(\"Service1\"); service.execute(); service = ServiceLocator.getService(\"Service2\"); service.execute(); service = ServiceLocator.getService(\"Service1\"); service.execute(); service = ServiceLocator.getService(\"Service2\"); service.execute(); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:32","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["c\u0026c++"],"content":"传输对象模式 传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。 业务对象（Business Object） - 为传输对象填充数据的业务服务。 传输对象（Transfer Object） - 简单的 POJO，只有设置/获取属性的方法。 客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。 实现 传输对象模式 例子 创建传输对象 // StudentVO.java public class StudentVO { private String name; private int rollNo; StudentVO(String name, int rollNo){ this.name = name; this.rollNo = rollNo; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getRollNo() { return rollNo; } public void setRollNo(int rollNo) { this.rollNo = rollNo; } } 创建业务对象 // StudentBO.java import java.util.ArrayList; import java.util.List; public class StudentBO { //列表是当作一个数据库 List\u003cStudentVO\u003e students; public StudentBO(){ students = new ArrayList\u003cStudentVO\u003e(); StudentVO student1 = new StudentVO(\"Robert\",0); StudentVO student2 = new StudentVO(\"John\",1); students.add(student1); students.add(student2); } public void deleteStudent(StudentVO student) { students.remove(student.getRollNo()); System.out.println(\"Student: Roll No \" + student.getRollNo() +\", deleted from database\"); } //从数据库中检索学生名单 public List\u003cStudentVO\u003e getAllStudents() { return students; } public StudentVO getStudent(int rollNo) { return students.get(rollNo); } public void updateStudent(StudentVO student) { students.get(student.getRollNo()).setName(student.getName()); System.out.println(\"Student: Roll No \" + student.getRollNo() +\", updated in the database\"); } } 使用 StudentBO 来演示传输对象设计模式 // TransferObjectPatternDemo.java public class TransferObjectPatternDemo { public static void main(String[] args) { StudentBO studentBusinessObject = new StudentBO(); //输出所有的学生 for (StudentVO student : studentBusinessObject.getAllStudents()) { System.out.println(\"Student: [RollNo : \" +student.getRollNo()+\", Name : \"+student.getName()+\" ]\"); } //更新学生 StudentVO student =studentBusinessObject.getAllStudents().get(0); student.setName(\"Michael\"); studentBusinessObject.updateStudent(student); //获取学生 studentBusinessObject.getStudent(0); System.out.println(\"Student: [RollNo : \" +student.getRollNo()+\", Name : \"+student.getName()+\" ]\"); } } ","date":"2021-09-19","objectID":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:33","tags":["设计模式","c++","design pattern"],"title":"设计模式","uri":"/2021/09/0010-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["C/C++"],"content":"fPIC/fpic -fPIC与-fpic都是在编译时加入的选项，用于生成位置无关的代码(Position-Independent-Code)，可以使得动态库可以被多个程序共享。 这两个选项都是可以使代码在加载到内存时使用相对地址，所有对固定地址的访问都通过全局偏移表(global offset table，GOT)来实现。 -fPIC和-fpic最大的区别在于是否对GOT的大小有限制。 -fPIC对GOT表大小无限制，所以如果在不确定的情况下，使用-fPIC是更好的选择。 如果链接的可执行文件的GOT大小超过计算机特定的最大大小，则会从链接器收到错误消息，指示-fpic不起作用;在这种情况下，请使用-fPIC重新编译。 GOT大小根据操作系统的不同而大小不一样，SPARC上为8k，在AArch64上为28k，在m68k和RS / 6000上为32k。x86没有此限制。 如果不加-fPIC,则加载.so文件的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容,这就造成每个使用这个.so文件代码段的进程在内核里都会生成这个.so文件代码段的copy，每个copy都不一样,取决于 这个.so文件代码段和数据段内存映射的位置. 不加-fPIC编译出来的so文件,是要再加载时根据加载到的位置再次重定位的.(因为它里面的代码并不是位置无关代码)。如果被多个应用程序共同使用,那么它们必须每个程序维护一份so的代码副本了.(因为so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享)。 当设置编译参数是：fPIC 时候 pic 和 PIC 设置为2； 当设置编译参数是：fpic 时候 pic 和 PIC 设置为1； 什么情况下不用 fPIC 该库可能时长更新 该库需要非常高的效率(尤其有很多全局变量使用时候) 该库并不大 该库基本不需要多个应用程序共享 ","date":"2021-02-16","objectID":"/2021/02/0013-fpic%E4%B8%8Efpie/:1:0","tags":["linux","c","c++","gcc"],"title":"fpic与fpie","uri":"/2021/02/0013-fpic%E4%B8%8Efpie/"},{"categories":["C/C++"],"content":"fPIE/fpie -fPIE 与 -fpie 都是在编译时候加入的选项，用于生成位置无关的可执行文件。 -fpie and -fPIE both define the macros pie and PIE. The macros have the value 1 for -fpie and 2 for -fPIE. ","date":"2021-02-16","objectID":"/2021/02/0013-fpic%E4%B8%8Efpie/:2:0","tags":["linux","c","c++","gcc"],"title":"fpic与fpie","uri":"/2021/02/0013-fpic%E4%B8%8Efpie/"},{"categories":["database"],"content":"数据库 实现数据持久化 使用完整的管理系统统一管理，易于查询 补充一句: 使用数据库并不比把数据保存到文件性能好，数据库的优点在于其结构化的数据存储和管理查询引擎，解决数据增、删、改、查中的同步问题以及为表的权限管理等问题。 数据库概念： DB(数据库)：存储数据的仓库，保存一系列有组织的数据 DBMS(数据库管理系统)：数据库通过 DBMS 创建和操作的容器 SQL(结构化查询语言)：专门用来与数据库通信的语言 常见数据库：MySQL、Oracle、DB2、SqlServer 等 ","date":"2017-06-28","objectID":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/:1:0","tags":["db","sql","mysql","数据库"],"title":"Sql语句整理","uri":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/"},{"categories":["database"],"content":"SQL SQL (Structural query language) —— 结构查询语言，其具有以下优点： 不是某个特定数据库供应商专用语言，几乎所有 DBMS 都支持 SQL 简单易学、语言灵活 SQL 语句可以分为以下三种类型： DML(Data Manipulation Language) 数据操纵语言 DDL (Data Definition Language) 数据定义语言 dcl (Data Control Language) 数据控制语言 ","date":"2017-06-28","objectID":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/:2:0","tags":["db","sql","mysql","数据库"],"title":"Sql语句整理","uri":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/"},{"categories":["database"],"content":"DML 用于查询与修改数据记录，包括如下 SQL 语句： INSERT: 添加数据到数据库中 UPDATE: 修改数据库中的数据 DELETE: 删除数据库中的数据 SELECT: 选择数据库中的数据 ","date":"2017-06-28","objectID":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/:2:1","tags":["db","sql","mysql","数据库"],"title":"Sql语句整理","uri":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/"},{"categories":["database"],"content":"DDL DDL 用于定义数据库的结构，比如创建、修改、删除数据库对象，包括以下SQL语句 CREATE TABLE: 创建数据库表 ALTER TABLE: 更改表结构、添加、删除、修改列长度 DROP TABLE: 删除表 CREATE INDEX: 在表上建立索引 DROP INDEX: 删除索引 ","date":"2017-06-28","objectID":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/:2:2","tags":["db","sql","mysql","数据库"],"title":"Sql语句整理","uri":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/"},{"categories":["database"],"content":"DCL DCL 用来控制数据库的访问，包括如下 SQL 语句： GRANT: 授予访问权限 REVOKE: 撤销访问权限 COMMIT: 提交事务处理 ROLLBACK: 事务处理回退 SAVEPOINT: 设置保存点 LOCK: 对数据库的特定部分进行锁定 ","date":"2017-06-28","objectID":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/:2:3","tags":["db","sql","mysql","数据库"],"title":"Sql语句整理","uri":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/"},{"categories":null,"content":"01：001-010 当编译发现大量错误的时候，从第一个看起，一个一个的解决，不要急着去看下一个错误，往往后面的错误都是由于前面的错误引起的，第一个解决后很可能都解决了。比如我们可能就写错了一行代码，编译提示几百个错误，你只要把这一行纠正了，其他错误也就没了。 定时器是个好东西，学会好使用它，有时候用QTimer::singleShot单次定时器和QMetaObject::invokeMethod可以解决意想不到的问题。比如在窗体初始化的时候加载一个耗时的操作，很容易卡主界面的显示，要在加载完以后才会显示界面，这就导致了体验很卡不友好的感觉，此时你可以将耗时的加载（有时候这些加载又必须在主线程，比如用QStackWidget堆栈窗体加载一些子窗体），延时或者异步进行加载，这样就会在界面显示后去执行，而不是卡住主界面。 //异步执行load函数 QMetaObject::invokeMethod(this, \"load\", Qt::QueuedConnection); //延时10毫秒执行load函数 QTimer::singleShot(10, this, SLOT(load())); 默认QtCreator是单线程编译，可能设计之初考虑到尽量不过多占用系统资源，而现在的电脑都是多核心的，默认msvc编译器是多线程编译的不需要手动设置，而对于其他编译器，需要手动设置才行。 方法一：在每个项目的构建设置中（可以勾选一个 shadow build 的页面地方）的build步骤，make arguments增加一行 -j16 即可，此设置会保存在pro.user文件中，一旦删除就需要重新设置，不建议此方法； 方法二：在构建套件的环境中增加，工具-\u003e选项-\u003e构建套件(kits)-\u003e选中一个构建套件-\u003eenvironment-\u003e右侧change按钮-\u003e打开的输入框中填入 MAKEFLAGS=-j4 ， 这样就可以不用每次设置多线程编译，只要是应用该构件套件的项目都会加上这个编译参数； 注意：-j后面接的是电脑的核心数，写多了不会有效果，要自己看下电脑的参数，或者填个-j4就行，毕竟现在电脑4核心应该是最基本的； 大概从2019年开始的新版本的QtCreator默认已经会根据电脑的核心自动设置多线程编译，比如识别到你的电脑是16核心的就会默认设置-j16参数进行编译； 如果你想顺利用QtCreator部署安卓程序，首先你要在 Android Studio 里面配置成功，编译一个程序能够在手机上或者模拟器中跑起来，把坑全部趟平。 很多时候找到Qt对应封装的方法后，记得多看看该函数的重载，多个参数的，你会发现不一样的世界，有时候会恍然大悟，原来Qt已经帮我们封装好了，比如QString、QColor的重载参数极其丰富，很多你做梦都想要的功能就在里面。 可以在pro文件中写上版本号、程序图标、产品名称、版权所有、文件说明等信息（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件。对于早期的Qt4版本你可以手动写rc文件实现。 #程序版本 VERSION = 2025.10.01 #程序图标 RC_ICONS = main.ico #产品名称 QMAKE_TARGET_PRODUCT = quc #版权所有 QMAKE_TARGET_COPYRIGHT = feiyangqingyun #文件说明 QMAKE_TARGET_DESCRIPTION = QQ: 517216493 WX: feiyangqingyun 管理员运行程序，限定在MSVC编译器，在项目pro文件中增加如下代码。 QMAKE_LFLAGS += /MANIFESTUAC:\"level='requireAdministrator' uiAccess='false'\" #以管理员运行 QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,\"5.01\" #VS2013 在XP运行 运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上一行CONFIG += console，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，一般没法正常运行的程序都会打印一些提示信息缺啥之类的。 TEMPLATE = app MOC_DIR = temp/moc RCC_DIR = temp/rcc UI_DIR = temp/ui OBJECTS_DIR = temp/obj #就是下面这行用来设置运行文件附带调试输出窗口 CONFIG += console 绘制平铺背景QPainter::drawTiledPixmap，绘制圆角矩形QPainter::drawRoundedRect()，而不是QPainter::drawRoundRect()，这两个函数非常容易搞混。 指定控件移除旧的样式。 //移除原有样式 style()-\u003eunpolish(ui-\u003ebtn); //必须要有下面这行不然还是不会卸载 ui-\u003ebtn-\u003esetStyleSheet(\"\"); //重新设置新的该控件的样式。 style()-\u003epolish(ui-\u003ebtn); ","date":"0001-01-01","objectID":"/1/01/qt/:0:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"02：011-020 获取类的属性和方法 //拿到控件元对象 const QMetaObject *metaObject = widget-\u003emetaObject(); //所有属性的数量 int propertyCount = metaObject-\u003epropertyCount(); //propertyOffset是自定义的属性开始的位置 int propertyOffset = metaObject-\u003epropertyOffset(); //循环取出控件的自定义属性, int i = 0 表示所有属性 for (int i = propertyOffset; i \u003c propertyCount; ++i) { QMetaProperty metaProperty = metaObject-\u003eproperty(i); const char *name = metaProperty.name(); const char *type = metaProperty.typeName(); QVariant value = widget-\u003eproperty(name); qDebug() \u003c\u003c name \u003c\u003c type \u003c\u003c value; } //所有方法的数量 int methodCount = metaObject-\u003emethodCount(); //methodOffset是自定义的方法开始的位置 int methodOffset = metaObject-\u003emethodOffset(); //循环取出控件的自定义方法, int i = 0 表示所有方法 for (int i = methodOffset; i \u003c methodCount; ++i) { QMetaMethod metaMethod = metaObject-\u003emethod(i); const char *name = metaMethod.name(); const char *type = metaMethod.typeName(); qDebug() \u003c\u003c name \u003c\u003c type; } Qt内置图标封装在QStyle中，大概七十多个图标，可以直接拿来用。 SP_TitleBarMenuButton, SP_TitleBarMinButton, SP_TitleBarMaxButton, SP_TitleBarCloseButton, SP_MessageBoxInformation, SP_MessageBoxWarning, SP_MessageBoxCritical, SP_MessageBoxQuestion, ... //下面这样取出来使用就行 QPixmap pixmap = this-\u003estyle()-\u003estandardPixmap(QStyle::SP_TitleBarMenuButton); ui-\u003elabel-\u003esetPixmap(pixmap); 根据操作系统位数判断加载 win32 { contains(DEFINES, WIN64) { DESTDIR = $$PWD/../bin64 } else { DESTDIR = $$PWD/../bin32 } } Qt5增强了很多安全性验证，如果出现setGeometry: Unable to set geometry，请将该控件的可见移到加入布局之后。 可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可。 QPushButton *btn = new QPushButton; btn-\u003eresize(30, ui-\u003elineEdit-\u003eheight()); QHBoxLayout *layout = new QHBoxLayout(ui-\u003elineEdit); layout-\u003esetMargin(0); layout-\u003eaddStretch(); layout-\u003eaddWidget(btn); 对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果。 巧妙的使用 findChildren 可以查找该控件下的所有子控件。 findChild 为查找单个。 //查找指定类名objectName的控件 QList\u003cQWidget *\u003e widgets = fatherWidget.findChildren\u003cQWidget *\u003e(\"widgetname\"); //查找所有QPushButton QList\u003cQPushButton *\u003e allPButtons = fatherWidget.findChildren\u003cQPushButton *\u003e(); //查找一级子控件,不然会一直遍历所有子控件 QList\u003cQPushButton *\u003e childButtons = fatherWidget.findChildren\u003cQPushButton *\u003e(QString(), Qt::FindDirectChildrenOnly); 巧妙的使用inherits判断是否属于某种类。 QTimer *timer = new QTimer; // QTimer inherits QObject timer-\u003einherits(\"QTimer\"); // returns true timer-\u003einherits(\"QObject\"); // returns true timer-\u003einherits(\"QAbstractButton\"); // returns false 使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-\u003edynamicPropertyNames()列出所有弱属性名称，然后通过widget-\u003eproperty(“name”)取出对应的弱属性的值。 在开发时, 无论是出于维护的便捷性, 还是节省内存资源的考虑, 都应该有一个 qss 文件来存放所有的样式表, 而不应该将 setStyleSheet 写的到处都是。如果是初学阶段或者测试阶段可以直接UI上右键设置样式表，正式项目还是建议统一到一个qss样式表文件比较好，统一管理。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"03：021-030 如果出现Z-order assignment: is not a valid widget.错误提示，用记事本打开对应的ui文件，找到为空的地方，删除即可。 善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来。特别注意的是第二个参数是QVariant类型，这就不要太灵活了，意味着可以附带万能的数据比如结构体，这样就可以带一堆数据了，而不是一个数据。比如下拉框选择学号，对应元素可以附带该学生的姓名、班级、成绩等。很多人以为只能附带QString、int之类的数据，因为通常的用法也是那两种。 QStringList listVideoOpenInterval, listVideoOpenIntervalx; listVideoOpenInterval \u003c\u003c \"0.0 秒\" \u003c\u003c \"0.1 秒\" \u003c\u003c \"0.3 秒\" \u003c\u003c \"0.5 秒\" \u003c\u003c \"1.0 秒\" \u003c\u003c \"2.0 秒\"; listVideoOpenIntervalx \u003c\u003c \"0\" \u003c\u003c \"100\" \u003c\u003c \"300\" \u003c\u003c \"500\" \u003c\u003c \"1000\" \u003c\u003c \"2000\"; for (int i = 0; i \u003c listVideoOpenInterval.count(); ++i) { ui-\u003ecboxVideoOpenInterval-\u003eaddItem(listVideoOpenInterval.at(i), listVideoOpenIntervalx.at(i)); } //取出对应的值 int indexVideoOpenInterval = ui-\u003ecboxVideoOpenInterval-\u003ecurrentIndex(); indexVideoOpenInterval = ui-\u003ecboxVideoOpenInterval-\u003eitemData(indexVideoOpenInterval).toInt(); 如果用了webengine模块，发布程序的时候带上QtWebEngineProcess.exe、translations文件夹、resources文件夹，不然无法正常运行。 在MFC程序或者VB/C#等窗体程序中，每个控件都有一个句柄，而且用句柄工具移过去会自动识别，但是在Qt程序中默认Qt是一个窗体一个句柄，如果要让每个控件都拥有独立的句柄，在main函数中要做如下设置。 int main(int argc, char *argv[]) { QApplication a(argc, argv); a.setAttribute(Qt::AA_NativeWindows); } Qt编写的Android程序防止程序被关闭。 #if defined(Q_OS_ANDROID) QAndroidService a(argc, argv); return a.exec() #else QApplication a(argc, argv); return a.exec(); #endif 可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置， *::down-arrow{} *::menu-indicator{} *::up-arrow:disabled{} *::up-arrow:off{} 可以指定位置设置背景图片。 QMainWindow \u003e .QWidget { background-color: gainsboro; background-image: url(:/images/xxoo.png); background-position: top right; background-repeat: no-repeat } 嵌入式linux运行Qt程序 //Qt4写法 ./HelloQt -qws \u0026 //Qt5写法 xcb 可以改成 linuxfb eglfs vnc wayland 等,有哪个就用哪个挨个测试 ./HelloQt --platform xcb ./HelloQt --platform linuxfb ./HelloQt --platform wayland 如果发现QtCreator中的构建套件不正常了或者坏了（比如不能正确识别环境中的qmake或者编译器、打开项目不能正常生成影子构建目录），请找到两个目录（C:\\Users\\Administrator\\AppData\\Local\\QtProject、C:\\Users\\Administrator\\AppData\\Roaming\\QtProject）删除即可，删除后重新打开QtCreator进行构建套件的配置就行。 QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV Filters安装即可（k-lite或者LAV Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer，并未完整验证，报错提示 Your GStreamer installation is missing a plug-in，需要命令安装 sudo apt-get install ubuntu-restricted-extras）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:3","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"04：031-040 判断编译器类型、编译器版本、操作系统。 //GCC编译器 #ifdef __GNUC__ #if __GNUC__ \u003e= 3 // GCC3.0 以上 //MSVC编译器 #ifdef _MSC_VER #if _MSC_VER \u003e=1000 // VC++4.0 以上 #if _MSC_VER \u003e=1100 // VC++5.0 以上 #if _MSC_VER \u003e=1200 // VC++6.0 以上 #if _MSC_VER \u003e=1300 // VC2003 以上 #if _MSC_VER \u003e=1400 // VC2005 以上 #if _MSC_VER \u003e=1500 // VC2008 以上 #if _MSC_VER \u003e=1600 // VC2010 以上 #if _MSC_VER \u003e=1700 // VC2012 以上 #if _MSC_VER \u003e=1800 // VC2013 以上 #if _MSC_VER \u003e=1900 // VC2015 以上 //Visual Studio版本与MSVC版本号的对应关系 MSC 1.0 _MSC_VER == 100 MSC 2.0 _MSC_VER == 200 MSC 3.0 _MSC_VER == 300 MSC 4.0 _MSC_VER == 400 MSC 5.0 _MSC_VER == 500 MSC 6.0 _MSC_VER == 600 MSC 7.0 _MSC_VER == 700 MSVC++ 1.0 _MSC_VER == 800 MSVC++ 2.0 _MSC_VER == 900 MSVC++ 4.0 _MSC_VER == 1000 (Developer Studio 4.0) MSVC++ 4.2 _MSC_VER == 1020 (Developer Studio 4.2) MSVC++ 5.0 _MSC_VER == 1100 (Visual Studio 97 version 5.0) MSVC++ 6.0 _MSC_VER == 1200 (Visual Studio 6.0 version 6.0) MSVC++ 7.0 _MSC_VER == 1300 (Visual Studio .NET 2002 version 7.0) MSVC++ 7.1 _MSC_VER == 1310 (Visual Studio .NET 2003 version 7.1) MSVC++ 8.0 _MSC_VER == 1400 (Visual Studio 2005 version 8.0) MSVC++ 9.0 _MSC_VER == 1500 (Visual Studio 2008 version 9.0) MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010 version 10.0) MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012 version 11.0) MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013 version 12.0) MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015 version 14.0) MSVC++ 14.1 _MSC_VER == 1910 (Visual Studio 2017 version 15.0) MSVC++ 14.11 _MSC_VER == 1911 (Visual Studio 2017 version 15.3) MSVC++ 14.12 _MSC_VER == 1912 (Visual Studio 2017 version 15.5) MSVC++ 14.13 _MSC_VER == 1913 (Visual Studio 2017 version 15.6) MSVC++ 14.14 _MSC_VER == 1914 (Visual Studio 2017 version 15.7) MSVC++ 14.15 _MSC_VER == 1915 (Visual Studio 2017 version 15.8) MSVC++ 14.16 _MSC_VER == 1916 (Visual Studio 2017 version 15.9) MSVC++ 14.2 _MSC_VER == 1920 (Visual Studio 2019 Version 16.0) MSVC++ 14.21 _MSC_VER == 1921 (Visual Studio 2019 Version 16.1) MSVC++ 14.22 _MSC_VER == 1922 (Visual Studio 2019 Version 16.2) //Borland C++ #ifdef __BORLANDC__ //Cygwin #ifdef __CYGWIN__ #ifdef __CYGWIN32__ //mingw #ifdef __MINGW32__ //windows #ifdef _WIN32 //32bit #ifdef _WIN64 //64bit #ifdef _WINDOWS //图形界面程序 #ifdef _CONSOLE //控制台程序 //Windows（95/98/Me/NT/2000/XP/Vista）和Windows CE都定义了 #if (WINVER \u003e= 0x030a) // Windows 3.1以上 #if (WINVER \u003e= 0x0400) // Windows 95/NT4.0以上 #if (WINVER \u003e= 0x0410) // Windows 98以上 #if (WINVER \u003e= 0x0500) // Windows Me/2000以上 #if (WINVER \u003e= 0x0501) // Windows XP以上 #if (WINVER \u003e= 0x0600) // Windows Vista以上 //_WIN32_WINNT 内核版本 #if (_WIN32_WINNT \u003e= 0x0500) // Windows 2000以上 #if (_WIN32_WINNT \u003e= 0x0501) // Windows XP以上 #if (_WIN32_WINNT \u003e= 0x0600) // Windows Vista以上 在pro中判断Qt版本及构建套件位数 #打印版本信息 message(qt version: $$QT_VERSION) #判断当前qt版本号 QT_VERSION = $$[QT_VERSION] QT_VERSION = $$split(QT_VERSION, \".\") QT_VER_MAJ = $$member(QT_VERSION, 0) QT_VER_MIN = $$member(QT_VERSION, 1) #下面是表示 Qt5.5及以上版本 greaterThan(QT_VER_MAJ, 4) { greaterThan(QT_VER_MIN, 4) { #自己根据需要做一些处理 }} #QT_ARCH是Qt5新增的,在Qt4上没效果 #打印当前Qt构建套件的信息 message($$QT_ARCH) #表示arm平台构建套件 contains(QT_ARCH, arm) {} #表示32位的构建套件 contains(QT_ARCH, i386) {} #表示64位的构建套件 contains(QT_ARCH, x86_64) {} #其实Qt内置了主版本号和子版本号变量 #判断当前qt版本号 message($$QT_ARCH : $$QT_VERSION -\u003e $$QT_MAJOR_VERSION . $$QT_MINOR_VERSION) #下面的含义是如果版本 \u003c 4.8 lessThan(QT_MAJOR_VERSION, 5) { lessThan(QT_MINOR_VERSION, 8) { #这里放要做的处理 }} #下面的含义是如果版本 \u003c 5.12.0 REQ_QT_MAJOR = 5 REQ_QT_MINOR = 12 REQ_QT_PATCH = 0 lessThan(QT_MAJOR_VERSION, $$REQ_QT_MAJOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_MINOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_PATCH) { #这里放要做的处理 } #下面的含义是如果版本 \u003e= 5.5 greaterThan(QT_MAJOR_VERSION, 4) { greaterThan(QT_MINOR_VERSION, 4) { #这里放要做的处理 }} //代码中判断版本不要太简单 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) //这里放要做的处理 #endif //下面表示 \u003e= 5.0.0 #if QT_VERSION \u003e= 0x050000 ... #endif //下面表示 \u003c 5.12.10 #if QT_VERSION \u003c 0x050C0A ... #endif Qt最小化后恢复界面可能会出现假死冻结现象，加上代码 void showEvent(QShowEvent *e) { setAttribute(Qt::","date":"0001-01-01","objectID":"/1/01/qt/:0:4","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"05：041-050 如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库。 QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\"); db.setDatabaseName(\":memory:\"); 清空数据表并重置自增ID，sql = truncate table table_name。 QtChart模块从Qt5.7开始自带，最低编译要求Qt5.4。在安装的时候记得勾选，默认不勾选。使用该模块需要引入命名空间。 #include \u003cQChartView\u003e QT_CHARTS_USE_NAMESPACE class CustomChart : public QChartView QPushButton左对齐文字，需要设置样式表QPushButton{text-align:left;} QLabel有三种设置文本的方法，掌握好Qt的属性系统，举一反三，可以做出很多效果。 //常规办法 ui-\u003elabel-\u003esetText(\"hello\"); //取巧办法 ui-\u003elabel-\u003esetProperty(\"text\", \"hello\"); //属性大法 ui-\u003elabel-\u003esetStyleSheet(\"qproperty-text:hello;\"); 巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行。 QEventLoop loop; connect(reply, SIGNAL(finished()), \u0026loop, SLOT(quit())); loop.exec(); 多种预定义变量 #if (defined webkit) || (defined webengine)，去掉生成空的debug和release目录，在pro文件中加一行 CONFIG -= debug_and_release。 新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About Plugins。也可以设置代码检查级别，Tools》Options 》C++ 》Code Model。 QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据。 如果数据量很小，也可以采用如下方法： //主动加载所有数据,不然获取到的行数\u003c=256 while(model-\u003ecanFetchMore()) { model-\u003efetchMore(); } 如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，比如自由拉伸边框，可以使用 setWindowFlags(Qt::CustomizeWindowHint)，这样会保留一个系统白边框。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:5","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"06：051-060 在某些http post数据的时候，如果采用的是\u0026字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码。 QString content = \"测试中文\"; QString note = content.toUtf8().toPercentEncoding(); Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启。 CONFIG += resources_big Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一。 方法一：设置属性 this-\u003esetAttribute(Qt::WA_StyledBackground, true); 方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。 方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。 void Widget::paintEvent(QPaintEvent *) { QStyleOption option; option.initFrom(this); QPainter painter(this); style()-\u003edrawPrimitive(QStyle::PE_Widget, \u0026option, \u0026painter, this); } 有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的。 在使用QFile的过程中，不建议频繁的打开文件写入然后再关闭文件，比如间隔5ms输出日志，IO性能瓶颈很大，这种情况建议先打开文件不要关闭，等待合适的时机比如析构函数中或者日期变了需要重新变换日志文件的时候关闭文件。不然短时间内大量的打开关闭文件会很卡，文件越大越卡。 在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接。 int fd = tcpSocket-\u003esocketDescriptor(); int keepAlive = 1; //开启keepalive属性,缺省值:0(关闭) int keepIdle = 5; //如果在5秒内没有任何数据交互,则进行探测,缺省值:7200(s) int keepInterval = 2; //探测时发探测包的时间间隔为2秒,缺省值:75(s) int keepCount = 2; //探测重试的次数,全部超时则认定连接失效,缺省值:9(次) setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)\u0026keepAlive, sizeof(keepAlive)); setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, (void *)\u0026keepIdle, sizeof(keepIdle)); setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, (void *)\u0026keepInterval, sizeof(keepInterval)); setsockopt(fd, SOL_TCP, TCP_KEEPCNT, (void *)\u0026keepCount, sizeof(keepCount)); 如果程序打包好以后弹出提示 This application failed to start because it could not find or load the Qt platform plugin 一般都是因为platforms插件目录未打包或者打包错了的原因导致的。 非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的（后面发现我在刚学Qt的时候也发布了一些demo到网上也是tr包含中文的，当时就狠狠的打了自己一巴掌），tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理。 很多人Qt和Qt Creator傻傻分不清楚，经常问Qt什么版本结果发一个Qt Creator的版本过来，Qt Creator是使用Qt编写的集成开发环境IDE，和宇宙第一的Visual Studio一样，他可以是msvc编译器的（WIN对应的Qt集成安装环境中自带的Qt Cerator是msvc的），也可以是mingw编译的，还可以是gcc的。如果是自定义控件插件，需要集成到Qt Creator中，必须保证该插件的动态库文件（dll或者so等文件）对应的编译器和Qt版本以及位数和Qt Creator的版本完全一致才行，否则基本不大可能集成进去。特别注意的是Qt集成环境安装包中的Qt版本和Qt Creator版本未必完全一致，必须擦亮眼睛看清楚，有些是完全一致的。 超过两处相同处理的代码，建议单独写成函数。代码尽量规范精简，比如 if(a == 123) 要写成 if (123 == a)，值在前面，再比如 if (ok == true) 要写成 if (ok)，if (ok == false) 要写成 if (!ok)等。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:6","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"07：061-070 很多人问Qt嵌入式平台用哪个好，这里统一回答（当前时间节点2018年）：imx6+335x比较稳定，性能高就用RK3288 RK3399，便宜的话就用全志H3，玩一玩可以用树莓派香橙派。 对于大段的注释代码，建议用 #if 0 #endif 将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是 #if 0则只要把0改成1即可，开发效率提升很多。 Qt打包发布，有很多办法，Qt5以后提供了打包工具windeployqt（linux上为linuxdeployqt，mac上为macdeployqt）可以很方便的将应用程序打包，使用下来发现也不是万能的，有时候会多打包一些没有依赖的文件，有时候又会忘记打包一些插件尤其是用了qml的情况下，而且不能识别第三方库，比如程序依赖ffmpeg，则对应的库需要自行拷贝，终极大法就是将你的可执行文件复制到Qt安装目录下的bin目录，然后整个一起打包，挨个删除不大可能依赖的组件，直到删到正常运行为止。 Qt中的动画，底层用的是QElapsedTimer定时器来完成处理，比如产生一些指定规则算法的数据，然后对属性进行处理。 在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致。 QRect rect(-radius, -radius, radius * 2, radius * 2); //以下两种方法二选一,其实绘制360度的圆弧=绘制无背景的圆形 painter-\u003edrawArc(rect, 0, 360 * 16); painter-\u003edrawEllipse(rect); 不要把d指针看的很玄乎，其实就是在类的实现文件定义了一个私有类，用来存放局部变量，个人建议在做一些小项目时，没有太大必要引入这种机制，会降低代码可读性，增加复杂性，新手接受项目后会看的很懵逼。 很多人在绘制的时候，设置画笔以为就只可以设置个单调的颜色，其实QPen还可以设置brush，这样灵活性就提高不知道多少倍，比如设置QPen的brush以后，可以使用各种渐变，比如绘制渐变颜色的进度条和文字等，而不再是单调的一种颜色。 很多控件都带有viewport，比如QTextEdit/QTableWidget/QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport()设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-\u003eviewport()-\u003esetStyleSheet(“background-color:transparent;”);而不是scrollArea-\u003esetStyleSheet(“QScrollArea{background-color:transparent;}”); 有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置 setAttribute(Qt::WA_Hover, true); Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等。 QDateTime dateTime; QString dateTime_str = dateTime.currentDateTime().toString(\"yyyy-MM-dd hh:mm:ss\"); //从字符串转换为毫秒（需完整的年月日时分秒） datetime.fromString(\"2011-09-10 12:07:50:541\", \"yyyy-MM-dd hh:mm:ss:zzz\").toMSecsSinceEpoch(); //从字符串转换为秒（需完整的年月日时分秒） datetime.fromString(\"2011-09-10 12:07:50:541\", \"yyyy-MM-dd hh:mm:ss:zzz\").toTime_t(); //从毫秒转换到年月日时分秒 datetime.fromMSecsSinceEpoch(1315193829218).toString(\"yyyy-MM-dd hh:mm:ss:zzz\"); //从秒转换到年月日时分秒（若有zzz，则为000） datetime.fromTime_t(1315193829).toString(\"yyyy-MM-dd hh:mm:ss[:zzz]\"); ","date":"0001-01-01","objectID":"/1/01/qt/:0:7","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"08：071-080 在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用 at() 取值而不是 [] 操作符，在官方书籍《C++ GUI Qt 4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用 at() 与使用 [] 操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用 at() 函数而不用 [] 操作符，因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而 at() 函数则不被允许出现在一个赋值的左边。 如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息。 QDialog dialog; dialog.setWindowModality(Qt::WindowModal); dialog.exec(); 安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns); 在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制。 将 QApplication::style() 对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication::style()-\u003edrawControl 的第4个参数如果不设置，则绘制出来的控件不会应用样式表。 心中有坐标，万物皆painter，强烈建议在学习自定义控件绘制的时候，将qpainter.h头文件中的函数全部看一遍、试一遍、理解一遍，这里边包含了所有Qt内置的绘制的接口，对应的参数都试一遍，你会发现很多新大陆，会一定程度上激发你的绘制的兴趣，犹如神笔马良一般，策马崩腾遨游代码绘制的世界。 在使用setItemWidget或者setCellWidget的过程中，有时候会发现设置的控件没有居中显示而是默认的左对齐，而且不会自动拉伸填充，对于追求完美的程序员来说，这个可不大好看，有个终极通用办法就是，将这个控件放到一个widget的布局中，然后将widget添加到item中，这样就完美解决了，而且这样可以组合多个控件产生复杂的控件。 //实例化进度条控件 QProgressBar *progress = new QProgressBar; //增加widget+布局巧妙实现居中 QWidget *widget = new QWidget; QHBoxLayout *layout = new QHBoxLayout; layout-\u003esetSpacing(0); layout-\u003esetMargin(0); layout-\u003eaddWidget(progress); widget-\u003esetLayout(layout); ui-\u003etableWidget-\u003esetCellWidget(0, 0, widget); 很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色。 //根据背景色自动计算合适的前景色 double gray = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255; QColor textColor = gray \u003e 0.5 ? Qt::black : Qt::white; 对QTableView、QTableWidget、QTreeView、QTreeWidget禁用列拖动。 #if (QT_VERSION \u003c QT_VERSION_CHECK(5,0,0)) ui-\u003etableView-\u003ehorizontalHeader()-\u003esetResizeMode(0, QHeaderView::Fixed); ui-\u003etreeView-\u003eheader()-\u003esetResizeMode(0, QHeaderView::Fixed); #else ui-\u003etableView-\u003ehorizontalHeader()-\u003esetSectionResizeMode(0, QHeaderView::Fixed); ui-\u003etreeView-\u003eheader()-\u003esetSectionResizeMode(0, QHeaderView::Fixed); #endif 从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0 ","date":"0001-01-01","objectID":"/1/01/qt/:0:8","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"09：081-090 Qt中的QColor对颜色封装的很完美，支持各种转换，比如rgb、hsb、cmy、hsl，对应的是toRgb、toHsv、toCmyk、toHsl，还支持透明度设置，颜色值还能转成16进制格式显示。 QColor color(255, 0, 0, 100); qDebug() \u003c\u003c color.name() \u003c\u003c color.name(QColor::HexArgb); //输出 #ff0000 #64ff0000 QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法。 if (variant.typeName() == \"QColor\") { QColor color = variant.value\u003cQColor\u003e(); QFont font = variant.value\u003cQFont\u003e(); QString nodeValue = color.name(QColor::HexArgb); } Qt中的QString和const char *之间转换，最好用toStdString().c_str()而不是toLocal8Bit().constData()，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常。 Qt的信号槽机制非常牛逼，也是Qt的独特的核心功能之一，有时候我们在很多窗体中传递信号来实现更新或者处理，如果窗体层级比较多，比如窗体A的父类是窗体B，窗体B的父类是窗体C，窗体C有个子窗体D，如果窗体A一个信号要传递给窗体D，问题来了，必须先经过窗体B中转到窗体C再到窗体D才行，这样的话各种信号关联信号的connect会非常多而且管理起来比较乱，可以考虑增加一个全局的单例类AppEvent，公共的信号放这里，然后窗体A对应信号绑定到AppEvent，窗体D绑定AppEvent的信号到对应的槽函数即可，干净清爽整洁。 QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets.qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突。 Qt中有个全局的焦点切换信号focusChanged，可以用它做自定义的输入法。Qt4中默认会安装输入法上下文，比如在main函数打印a.inputContext会显示值，这个默认安装的输入法上下文，会拦截两个牛逼的信号QEvent::RequestSoftwareInputPanel和QEvent::CloseSoftwareInputPanel，以至于就算你安装了全局的事件过滤器依然识别不到这两个信号，你只需要在main函数执行a.setInputContext(0)即可，意思是安装输入法上下文为空。Qt5.7以后提供了内置的输入法，可以通过在main函数最前面加上 qputenv(“QT_IM_MODULE”, QByteArray(“qtvirtualkeyboard”)); 来启用。 在Qt5.10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-\u003etableView-\u003ehorizontalHeader()-\u003esetMinimumSectionSize(0); Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT += gui-private才能使用。 #include \"QtGui/private/qzipreader_p.h\" #include \"QtGui/private/qzipwriter_p.h\" QZipReader reader(dirPath); QString path(\"\"); //解压文件夹到当前目录 reader.extractAll(path); //文件夹名称 QZipReader::FileInfo fileInfo = reader.entryInfoAt(0); //解压文件 QFile file(filePath); file.open(QIODevice::WriteOnly); file.write(reader.fileData(QString::fromLocal8Bit(\"%1\").arg(filePath))); file.close(); reader.close(); QZipWriter *writer = new QZipWriter(dirPath); //添加文件夹 writer-\u003eaddDirectory(unCompress); //添加文件 QFile file(filePath); file.open(QIODevice::ReadOnly); writer-\u003eaddFile(data, file.readAll()); file.close(); writer-\u003eclose(); 理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理。 在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:9","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"10：091-100 数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题。 新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写。 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,0,0)) void incomingConnection(qintptr handle); #else void incomingConnection(int handle); #endif Qt支持所有的界面控件比如QPushButton、QLineEdit自动关联 on_控件名_信号(参数) 信号槽，比如按钮的单击信号 on_pushButton_clicked()，然后直接实现槽函数即可。 QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染。 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,4,0)) //下面两种方法都可以,Qt默认采用的是AA_UseDesktopOpenGL QCoreApplication::setAttribute(Qt::AA_UseOpenGLES); //QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL); #endif QApplication a(argc, argv); 另外一个方法解决 全屏+QWebEngineView控件一起会产生右键菜单无法弹出的bug,需要上移一个像素 QRect rect = qApp-\u003edesktop()-\u003egeometry(); rect.setY(-1); rect.setHeight(rect.height()); this-\u003esetGeometry(rect); QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值。 QStyle::sliderValueFromPosition(minimum(), maximum(), event-\u003ex(), width()); 用QFile读写文件的时候，推荐用QTextStream文件流的方式来读写文件，速度快很多，基本上会有30%的提升，文件越大性能区别越大。 //从文件加载英文属性与中文属性对照表 QFile file(\":/propertyname.txt\"); if (file.open(QFile::ReadOnly)) { //QTextStream方法读取速度至少快百分之30 #if 0 while(!file.atEnd()) { QString line = file.readLine(); appendName(line); } #else QTextStream in(\u0026file); while (!in.atEnd()) { QString line = in.readLine(); appendName(line); } #endif file.close(); } 用QFile.readAll()读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果。 void frmMain::initStyle() { //加载样式表 QString qss; //QFile file(\":/qss/psblack.css\"); //QFile file(\":/qss/flatwhite.css\"); QFile file(\":/qss/lightblue.css\"); if (file.open(QFile::ReadOnly)) { #if 1 //用QTextStream读取样式文件不用区分文件编码 带bom也行 QStringList list; QTextStream in(\u0026file); //in.setCodec(\"utf-8\"); while (!in.atEnd()) { QString line; in \u003e\u003e line; list \u003c\u003c line; } qss = list.join(\"\\n\"); #else //用readAll读取默认支持的是ANSI格式,如果不小心用creator打开编辑过了很可能打不开 qss = QLatin1String(file.readAll()); #endif QString paletteColor = qss.mid(20, 7); qApp-\u003esetPalette(QPalette(QColor(paletteColor))); qApp-\u003esetStyleSheet(qss); file.close(); } } QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可。 QString s1, s2; s1 = \"666.5567124\"; s2.setNum(888.5632123, 'f', 7); qDebug() \u003c\u003c qSetRealNumberPrecision(10) \u003c\u003c s1.toDouble() \u003c\u003c s2.toDouble(); 用QScriptValueIterator解析数据的时候，会发现总是会多一个节点内容，并且内容为空，如果需要跳过则增加一行代码。 while (it.hasNext()) { it.next(); if (it.flags() \u0026 QScriptValue::SkipInEnumeration) continue; qDebug() \u003c\u003c it.name(); } setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:10","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"11：101-110 如果需要在尺寸改变的时候不重绘窗体，则设置属性即可 this-\u003esetAttribute(Qt::WA_StaticContents, true); 这样可以避免对已经显示区域的重新绘制。 默认程序中获取焦点以后会有虚边框，如果看着觉得碍眼不舒服可以去掉，设置样式即可：setStyleSheet(\"*{outline:0px;}\"); Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget。 void QUIHelper::initTableView(QTableView *tableView, int rowHeight, bool headVisible, bool edit) { //奇数偶数行颜色交替 tableView-\u003esetAlternatingRowColors(false); //垂直表头是否可见 tableView-\u003everticalHeader()-\u003esetVisible(headVisible); //选中一行表头是否加粗 tableView-\u003ehorizontalHeader()-\u003esetHighlightSections(false); //最后一行拉伸填充 tableView-\u003ehorizontalHeader()-\u003esetStretchLastSection(true); //行标题最小宽度尺寸 tableView-\u003ehorizontalHeader()-\u003esetMinimumSectionSize(0); //行标题最大高度 tableView-\u003ehorizontalHeader()-\u003esetMaximumHeight(rowHeight); //默认行高 tableView-\u003everticalHeader()-\u003esetDefaultSectionSize(rowHeight); //选中时一行整体选中 tableView-\u003esetSelectionBehavior(QAbstractItemView::SelectRows); //只允许选择单个 tableView-\u003esetSelectionMode(QAbstractItemView::SingleSelection); //表头不可单击 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,0,0)) tableView-\u003ehorizontalHeader()-\u003esetSectionsClickable(false); #else tableView-\u003ehorizontalHeader()-\u003esetClickable(false); #endif //鼠标按下即进入编辑模式 if (edit) { tableView-\u003esetEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked); } else { tableView-\u003esetEditTriggers(QAbstractItemView::NoEditTriggers); } } 在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则。 TEMPLATE = subdirs #设置ordered参数以后会依次编译 projA projB projC CONFIG += ordered SUBDIRS += projA SUBDIRS += projB SUBDIRS += projC #还可以通过设置depends指定某个项目依赖 比如下面指定projB依赖projA projB.depends = projA projC.depends = projA projD.depends = projC MSVC编译器的选择说明 如果是32位的Qt则编译器选择x86开头的 如果是64位的Qt则编译器选择amd64开头的 具体是看安装的Qt构建套件版本以及目标运行平台的系统位数和架构 一般现在的电脑默认以64位的居多，选择amd64即可 如果用户需要兼容32位的系统则建议选择32位的Qt，这样即可在32位也可以在64位系统运行 诸葛大佬补充：x86/x64都是编译环境和运行环境相同，没有或。带下划线的就是交叉编译，前面是编译环境，后面是运行环境。 名称 说明 x86 32/64位系统上编译在32/64位系统上运行 x86_amd64 32/64位系统上编译在64位系统上运行 x86_arm 32/64位系统上编译在arm系统上运行 amd64 64位系统上编译在64位系统上运行 amd64_x86 64位系统上编译在32/64位系统上运行 amd64_arm 64位系统上编译在arm系统上运行 很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置。 QDialog dialog; dialog.setWindowModality(Qt::WindowModal); 很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源。 如果你没有使用wait***函数的话，大部分的界面卡都出在数据处理和展示中，比如传过来的是一张图片的数据，你需要将这些数据转成图片，这个肯定是耗时的； 还有就是就收到的数据曲线绘制出来，如果过于频繁或者间隔过短，肯定会给UI造成很大的压力的，最好的办法是解决如何不要频繁绘制UI比如合并数据一起绘制等； 如果是因为绘制UI造成的卡，那多线程也是没啥用的，因为UI只能在主线程； 串口和网络的数据收发默认都是异步的，由操作系统调度的，如果数据处理复杂而且数据量大，你要做的是将数据处理放到多线程中； 如果没有严格的数据同步需求，根本不需要调用wait***之类的函数来立即发送和接收数据，实际需求中大部分的应用场景其实异步收发数据就足够了； 有严格数据同步需求的场景还是放到多线程会好一些，不然你wait***就卡在那边了； 多线程是需要占用系统资源的，理论上来说，如果线程数量超过了CPU的核心数量，其实多线程调度可能花费的时间更多，各位在使用过程中要权衡利弊； 再次强调，不要指望Qt的网络通信支持高并发，最多到1000个能正常工作就万事大吉，一般建议500以内的连接数。有大量高并发的需求请用第三方库比如swoole等。 在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行。 //这种方式设置的无边框窗体在嵌入式设备上无法产生焦点 setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint); //需要在show以后主动激活窗体 w-\u003eshow(); w-\u003eactivateWindow(); QString的replace函数会改变原字符串，切记，他在返回替换后的新字符串的同时也会改变原字符串，我的乖乖！ QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:11","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"12：111-120 在不同的平台上文件路径的斜杠也是不一样的，比如linux系统一般都是 / 斜杠，而在windows上都是 \\ 两个反斜杠，Qt本身程序内部无论在win还是linux都支持 / 斜杠的路径，但是一些第三方库的话可能需要转换成对应系统的路径，这就需要用到斜杠转换，Qt当然内置类方法。 QString path = \"C:/temp/test.txt\"; path = QDir::toNativeSeparators(path); //输出 C:\\\\temp\\\\test.txt QString path = \"C:\\\\temp\\\\test.txt\"; path = QDir::toNativeSeparators(path); //输出 C:/temp/test.txt 巧用QMetaObject::invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, “fun”, Qt::QueuedConnection); 这种方式来就可以。 invokeMethod函数有很多重载参数，可以传入返回值和执行方法的参数等。 invokeMethod函数不仅支持槽函数还支持信号，而且这逼居然是线程安全的，可以在线程中放心使用，牛逼！ 测试下来发现只能执行signals或者slots标识的方法。 默认可以执行private(protected/public) slots下的函数，但是不能执行private(protected/public)下的函数。 毛总补充：前提必须是slots或者signals标注的函数，不是标注的函数不在元信息导致无法查找，执行之后会提示No such method。 2021-11-06补充：如果要执行private(protected/public)下的函数，需要函数前面加上 Q_INVOKABLE 关键字，今天又学到了，必须加鸡腿。 其实这样看下来，就是任何方法函数都能执行了，这就超越了private(protected/public)的权限限定了，相当于一个类的私有函数用了 Q_INVOKABLE 关键字修饰也可以被 invokeMethod 执行，哇咔咔。 //头文件声明信号和槽函数 signals: void sig_test(int type,double value); private slots: void slot_test(int type, double value); private: Q_INVOKABLE void fun_test(int type, double value); //构造函数关联信号槽 connect(this, SIGNAL(sig_test(int, double)), this, SLOT(slot_test(int, double))); //单击按钮触发信号和槽,这里是同时举例信号槽都可以 void MainWindow::on_pushButton_clicked() { QMetaObject::invokeMethod(this, \"sig_test\", Q_ARG(int, 66), Q_ARG(double, 66.66)); QMetaObject::invokeMethod(this, \"slot_test\", Q_ARG(int, 88), Q_ARG(double, 88.88)); QMetaObject::invokeMethod(this, \"fun_test\", Q_ARG(int, 99), Q_ARG(double, 99.99)); } //会打印 66 66.66、88 88.88 void MainWindow::slot_test(int type, double value) { qDebug() \u003c\u003c type \u003c\u003c value; } //会打印 99.99 void MainWindow::fun_test(int type, double value) { qDebug() \u003c\u003c type \u003c\u003c value; } Qt5中的信号是public的，可以在需要的地方直接emit即可，而在Qt4中信号是protected的，不能直接使用，需要定义一个public函数来emit。 Qt5.15版本开始官方不再提供安装包，只提供源码，可以自行编译或者在线安装，估计每次编译各种版本太麻烦，更多的是为了统计收集用户使用信息比如通过在线安装，后期可能会逐步加大商业化力度。 有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有 QT += 的方式添加的模块，可以用 contains来判断。 qtHaveModule(webenginewidgets) { message(\"当前Qt库有找到 webenginewidgets 模块\") } !qtHaveModule(webkit) { message(\"当前Qt库没有找到 webkit 模块\") } contains(QT, network) { message(\"当前项目已经引入 network 模块\") } !contains(QT, widgets) { message(\"当前项目没有引入 widgets 模块\") } c++11新引入了原始字符串格式，用户避免在字符串中加入转义字符\\，可以用于表示json字符串等场景。 QString s1 = R\"(test\\001.jpg)\"; s1.replace(\"\\\\\", \"#\"); qDebug()\u003c\u003c s1; //结果 test#001.jpg 安卓上打印信息建议使用 qInfo() 而不是 qDebug() ，qInfo()才有效果。 Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置 setTimerType(Qt::PreciseTimer)。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用 startTimer(interval, Qt::PreciseTimer); Qt::PreciseTimer 精确的定时器，尽量保持毫秒精度。 Qt::CoarseTimer 粗略的定时器，尽量保持精度在所需的时间间隔5%范围内。 Qt::VeryCoarseTimer 很粗略的定时器，只保留完整的第二精度。 精度再高，也依赖对应的操作系统中断，假设中断需要 5ms，则定时器精度不可能高于5毫秒。 QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用。 用QSettings设置注册表，如果不是管理员身份运行会打印 QSettings: failed to set subkey “xxx” (拒绝访问。)，你需要手动鼠标右键管理员身份运行就可以。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:12","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"13：121-130 QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途。 限制输入只能输入IP地址。 限制输入范围，强烈推荐使用 QRegExpValidator 正则表达式来处理。 //正在表达式限制输入 QString str = \"\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b\"; ui-\u003elineEdit-\u003esetValidator(new QRegExpValidator(QRegExp(str))); //用于占位 ui-\u003elineEdit-\u003esetInputMask(\"000.000.000.000\"); #if 0 //下面代码设置浮点数范围限制失败 ui-\u003elineEdit-\u003esetValidator(new QDoubleValidator(20, 50, 1)); #else //下面代码设置浮点数范围限制成功 QDoubleValidator *validator = new QDoubleValidator(20, 50, 1); validator-\u003esetNotation(QDoubleValidator::StandardNotation); ui-\u003elineEdit-\u003esetValidator(validator); #endif //下面代码设置整数范围限制成功 ui-\u003elineEdit-\u003esetValidator(new QIntValidator(10, 120)); //其实上面的代码缺陷很多，只能限制只输入小数，无法设定数值范围，很操蛋 //需要来个万能的牛逼的 QRegExpValidator //限制浮点数输入范围为[-180,180] QRegExp regexp(\"^-?(180|1?[0-7]?\\\\d(\\\\.\\\\d+)?)$\"); //限制浮点数输入范围为[-90,90]并限定为小数位后4位 QRegExp regexp(\"^-?(90|[1-8]?\\\\d(\\\\.\\\\d{1,4})?)$\"); QRegExpValidator *validator = new QRegExpValidator(regexp, this); ui-\u003elineEdit-\u003esetValidator(validator); 在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5.14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串 rtmp://58.200.131.2:1935/livetv/cctv1，会显示成 rtmp://… ，而在旧版本的Qt中会显示成 rtmp://58.200.131… ，很多时候我们并不想看到烦人的省略号，可以设置取消。 //取消自动换行 tableView-\u003esetWordWrap(false); //超出文本不显示省略号 tableView-\u003esetTextElideMode(Qt::ElideNone); QVideoWidget播放视频，可能会遇到画面闪烁的情况，播放视频的窗体需要设置个属性。 QVideoWidget *videoWidget = new QVideoWidget; videoWidget-\u003esetAttribute(Qt::WA_OpaquePaintEvent); Qt bug成千上万，这个不用大惊小怪，也基本上遇不到，大部分都是特殊极端情况特定应用场景出现，甚至你会遇到有些是debug可以release报错，有些release可以debug却报错的情况，最神奇的还有先是debug报错，然后release正常，再返回去用debug又正常，需要用release激活一下！学习编程的路本来就是一条坑坑洼洼的路，不断填坑，尽量规避坑！很多时候很多看起来的坑其实是自己没有注意细节导致的。 Qt视图中默认排序是按照字符串的ASCII排序的，如果是IP地址的话会出现192.168.1.117排在192.168.1.2前面的情况，如果要规避这种情况，一种做法是取末尾的地址转成整型再比较大小，缺点是跨网段就歇菜了，又会出现192.168.2.65出现在192.168.1.70前面，终极大法是将IP地址转成整型再比较大小。 QString QUIHelper::ipv4IntToString(quint32 ip) { QString result = QString(\"%1.%2.%3.%4\").arg((ip \u003e\u003e 24) \u0026 0xFF).arg((ip \u003e\u003e 16) \u0026 0xFF).arg((ip \u003e\u003e 8) \u0026 0xFF).arg(ip \u0026 0xFF); return result; } quint32 QUIHelper::ipv4StringToInt(const QString \u0026ip) { int result = 0; if (isIP(ip)) { QStringList list = ip.split(\".\"); int ip0 = list.at(0).toInt(); int ip1 = list.at(1).toInt(); int ip2 = list.at(2).toInt(); int ip3 = list.at(3).toInt(); result = ip3 | ip2 \u003c\u003c 8 | ip1 \u003c\u003c 16 | ip0 \u003c\u003c 24; } return result; } 在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致。 Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出。 #禁用qdebug打印输出 DEFINES += QT_NO_DEBUG_OUTPUT 在使用 QT_NO_DEBUG_OUTPUT 关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实 QT_NO_DEBUG_OUTPUT 禁用的 qdebug 的输出，Qt还有其他几种打印信息比如 qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用 qInfo 来输出信息就好。特别注意：qFatal 打印完信息程序会自动结束。 qDebug() \u003c\u003c \"qDebug\"; qInfo() \u003c\u003c \"qInfo\"; qWarning() \u003c\u003c \"qWarning\"; qCritical() \u003c\u003c \"qCritical\"; qDebug(\"qDebug\"); qWarning(\"qWarning\"); qCritical(\"qCritical\"); Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去。 #禁用qdebug打印输出 DEFINES += QT_NO_DEBUG_OUTPUT #自定义define变量 可以在整个项目中使用 #pro文件可以这样判断 contains(DEFINES, videovlc) {} #代码文件可以这样判断 #ifdef videovlc DEFINES += videovlc1 videoffmpeg #关闭编译警告提示 眼不见为净 CONFIG += warn_off #指定编译生成的文件到temp目录 分门别类存储 MOC_DIR = temp/moc RCC_DIR = temp/rcc UI_DIR = temp/ui OBJECTS_DIR = temp/obj #指定编译生成的可执行文件到bin目录 DESTDIR = bin Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理。 //主窗体头文件 protected: bool nativeEvent(const QByteArray \u0026eventType, void *message, long *result); #ifdef Q_OS_WIN bool winEvent(MSG *message, long *result); #endif //主窗体实现函数 #ifdef Q_OS_WIN #include \"Windows.h\" #endif bool frmMain::nativeEvent(const QByteArray \u0026eventType, void *message, long *result) { if (eventType == \"windows_g","date":"0001-01-01","objectID":"/1/01/qt/:0:13","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"14：131-140 Qt新版本往往会带来一些头文件的更新，比如以前使用QPainter绘制，不需要额外包含QPainterPath头文件，而5.15版本开始就需要显示主动引入#include “qpainterpath.h\"才行。 Qt6.0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件 QT += core5compat 才能用， 具体说明在https://doc.qt.io/qt-6/qtcore5-index.html。 qDebug输出打印信息，默认会完整打印转义字符，例如：\\ \" \\t \\n” 等，所以当你发现你明明设置了转义字符以后打印确还是转义前的字符，这就懵逼了，其实这是qdebug为了方便调试将各种字符都打印输出。无可否认，很多时候，我们极其兴奋的享受着Qt带来的各种轮子各种便利，但是偶尔，稍不留意，这些便利可能也会坑你一把。要做的就是擦亮眼睛，时刻谨慎，一步一个脚印踏踏实实码代码。 QString s1 = R\"(\\:device0)\"; //TNND居然输出的是 \\\\:device0 qDebug() \u003c\u003c s1; //这次终于正确的输出 \\:device0 qDebug().noquote() \u003c\u003c s1; 很多人有疑问为何qss对浏览器控件中的网页样式没法控制，其实用屁股想想也知道，那玩意是html css去控制的，和Qt一毛钱关系也没有，根本管不着，如果想要对滚动条样式设置，可以在网页代码中设置样式就行。 \u003cstyle type=\"text/css\"\u003e ::-webkit-scrollbar{width:0.8em;} ::-webkit-scrollbar-track{background:rgb(241,241,241);} ::-webkit-scrollbar-thumb{background:rgb(188,188,188);} \u003c/style\u003e Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件。 //设置了编码以后配置文件内容为 Company=上海物联网技术研究中心 //没有设置编码则配置文件内容为 Company=\\xe4\\xb8\\x8a\\xe6\\xb5\\xb7\\xe7\\x89\\xa9\\xe8\\x81\\x94\\xe7\\xbd\\x91\\xe6\\x8a\\x80\\xe6\\x9c\\xaf\\xe7\\xa0\\x94\\xe7\\xa9\\xb6\\xe4\\xb8\\xad\\xe5\\xbf\\x83 void App::readConfig() { QSettings set(App::ConfigFile, QSettings::IniFormat); set.setIniCodec(\"utf-8\"); set.beginGroup(\"AppConfig1\"); App::Company = set.value(\"Company\", App::Company).toString(); set.endGroup(); } void App::writeConfig() { QSettings set(App::ConfigFile, QSettings::IniFormat); set.setIniCodec(\"utf-8\"); set.beginGroup(\"AppConfig1\"); set.setValue(\"Company\", App::Company); set.endGroup(); } 用Qt做安卓开发都会遇到权限的问题，早期的安卓版本可以直接通过 AndroidManifest.xml 配置文件来添加需要的权限，这样在安装app的时候就会提示该app需要哪些权限让用户同意，现在的安卓版本都改成了动态权限，需要在app运行的时候弹出提示让用户确认再有权限，Qt迎合了这种策略内置了动态申请权限的方法 QtAndroid::requestPermissionsSync。 //动态设置权限 bool checkPermission(const QString \u0026permission) { #ifdef Q_OS_ANDROID #if (QT_VERSION \u003e= QT_VERSION_CHECK(5, 10, 0)) QtAndroid::PermissionResult result = QtAndroid::checkPermission(permission); if (result == QtAndroid::PermissionResult::Denied) { QtAndroid::requestPermissionsSync(QStringList() \u003c\u003c permission); result = QtAndroid::checkPermission(permission); if (result == QtAndroid::PermissionResult::Denied) { return false; } } #endif #endif return true; } int main(int argc, char *argv[]) { QApplication a(argc, argv); //请求权限 checkPermission(\"android.permission.READ_EXTERNAL_STORAGE\"); checkPermission(\"android.permission.WRITE_EXTERNAL_STORAGE\"); return a.exec(); } Qt重载qDebug输出自定义的信息。 struct FunctionInfo { QString function; QString name; QString groupEnabled; QString action; QString group; friend QDebug operator \u003c\u003c (QDebug debug, const FunctionInfo \u0026functionInfo) { QString info = QString(\"功能: %1 名称: %2 启用: %3 方法: %4 分组: %5\") .arg(functionInfo.function).arg(functionInfo.name).arg(functionInfo.groupEnabled) .arg(functionInfo.action).arg(functionInfo.group); debug \u003c\u003c info; return debug; } }; 对高分屏不同缩放比例的自适应处理方法。 //方法1：在main函数的最前面加上下面这句 5.6版本才开始有这个函数 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,6,0)) QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling); //开启高缩放支持以后图片可能发虚还要开启下面这个属性 QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps); #endif //方法2：在可执行文件同目录下新建文件 qt.conf 填入下面内容 [Platforms] WindowsArguments = dpiawareness=0 //下面这行用来解决Qt高DPI下文字显示有锯齿的问题 WindowsArguments = fontengine=freetype //方法3：在main函数最前面设置Qt内部的环境变量 qputenv(\"QT_AUTO_SCREEN_SCALE_FACTOR\", \"1.5\"); //方法4：新版本的Qt比如Qt5.14修正了对高分屏的处理支持不是整数的缩放 qputenv(\"QT_ENABLE_HIGHDPI_SCALING\", \"1\"); QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough); //禁用缩放 //测试发现AA_Use96Dpi属性在Qt5.9以上版本完全正常，以下版本比如5.7有部分控件在175%缩放不正常比如QTextEdit，需要外层套个widget才行。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) QApplication::setAttribute(Qt::AA_Use96Dpi); #endif #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,14,0)) QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要","date":"0001-01-01","objectID":"/1/01/qt/:0:14","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"15：141-150 QImage支持xpm图标，查看Qt内置的QStyle风格的代码中可以发现大量的xpm图标定义，通过代码的形式来产生图标，哇咔咔好牛逼。 static const char * const imgData[] = { \"15 11 6 1\", \" c None\", \"+ c #979797\", \"@ c #C9C9C9\", \"$ c #C1C1C1\", \"b c None\", \"d c None\", \" $++++++++$ \", \"$+bbbbbbbb+$ \", \"+b $$ +$ \", \"+b $@ +$ \", \"+b +$\", \"+b d+\", \"+b d+$\", \"+b $$ d+$ \", \"+b $@ d+$ \", \"$+dddddddd+$ \", \" $++++++++$ \"}; //这样就能直接显示一个箭头的图形 QImage img(imgData); QLabel lab; lab.setPixmap(QPixmap::fromImage(img)); lab.show(); 在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文。 int main(int argc, char *argv[]) { //需要设置共享上下文不然停靠窗体从正常到浮动后QOpenGLWidget窗体会失效 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,4,0)) QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts); #endif QApplication a(argc, argv); ... } 关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99%以上的Qt版本的乱码问题。 第一步：代码文件选择用utf8编码带bom。 第二步：在有中文汉字的代码文件顶部加一行（一般是cpp文件） #pragma execution_character_set(“utf-8”) 可以考虑放在head.h中，然后需要的地方就引入head头文件就行，而不是这行代码写的到处都是；这行代码是为了告诉msvc编译器当前代码文件用utf8去编译。 第三步：main函数中加入设置编码的代码，以便兼容Qt4，如果没有Qt4的场景可以不用，从Qt5开始默认就是utf8编码。 void QUIHelper::setCode() { #if (QT_VERSION \u003c= QT_VERSION_CHECK(5,0,0)) #if _MSC_VER QTextCodec *codec = QTextCodec::codecForName(\"gbk\"); #else QTextCodec *codec = QTextCodec::codecForName(\"utf-8\"); #endif QTextCodec::setCodecForLocale(codec); QTextCodec::setCodecForCStrings(codec); QTextCodec::setCodecForTr(codec); #else QTextCodec *codec = QTextCodec::codecForName(\"utf-8\"); QTextCodec::setCodecForLocale(codec); #endif } 关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论。 Qt在二进制兼容这块，已经做了最大的努力，通过将各种代码细节隐藏，Q指针+D指针技巧，尽量保持了接口的统一； 是否兼容最主要考虑编译器的因素，毕竟任何Qt版本都是需要通过编译器编译成对应的二进制文件，由他说了算。如果两个Qt版本采用的编译器版本一样，极大概率可执行文件是兼容的，比如 Qt5.10+msvc2015 32 位 和 Qt5.11+msvc2015 32位 编译出来的可执行文件，都用Qt5.11的库是可行的； mingw编译器的Qt版本也是如此，就是因为Qt官方安装包集成的mingw编译器一直在更新（极少附近版本没有更新mingw编译器版本除外），比如5.7用的mingw53，5.12用的mingw73，5.15用的mingw81，因为带的Qt库也是这个编译器编译出来的，所以导致看起来全部不兼容； 如果想要完全兼容，还有一个注意要素，那就是对应代码使用的类的头文件接口是否变了，按道理原有的接口极少会变，一般都是新增加，或者大版本才会改变，比如Qt4-Qt5-Qt6这种肯定没法兼容的，接口和模块都变了； 大胆的猜测：如果Qt5.6到Qt5.15你全部用一种编译器比如mingw73或者msvc2015重新编译生成对应的Qt运行库，然后在此基础上开发程序，最后生成的可执行文件用Qt5.15的库是都可以的，这样就轻松跨越了多个版本兼容； 大胆的建议：在附近的几个版本统一编译器，比如5.6-5.12之间就统一用mingw53或者msvc2015,5.12-5.15统一用msvc2017，要尝鲜其他编译器的可以自行源码编译其他版本，这样最起码附近的一大段版本（大概2-3年的版本周期）默认就兼容了。 本人测试的是widget部分，qml未做测试，不清楚是否机制一样； 通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4.7到5.15任意版本，通过查看对应函数的源码可以看到内部会检查是否是 ‘file:///’ 开头，是的话则自动读取样式表文件进行设置，无需手动读取。 //以前都是下面的方法 QFile file(\":/qss/psblack.css\"); if (file.open(QFile::ReadOnly)) { QString qss = QLatin1String(file.readAll()); qApp-\u003esetStyleSheet(qss); file.close(); } //其实一行代码就行 qApp-\u003esetStyleSheet(\"file:///:/qss/psblack.css\"); //特别说明，只支持qApp-\u003esetStyleSheet 不支持其他比如widget-\u003esetStyleSheet Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板 QCalendarWidget 就是 QToolButton+QSpinBox+QTableView 等组成，妙用 findChildren 可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等。 //打印子类类名集合 void printObjectChild(const QObject *obj, int spaceCount) { qDebug() \u003c\u003c QString(\"%1%2 : %3\") .arg(\"\", spaceCount) .arg(obj-\u003emetaObject()-\u003eclassName()) .arg(obj-\u003eobjectName()); QObjectList childs = obj-\u003echildren(); foreach (QObject *child, childs) { printObjectChild(child, spaceCount + 2); } } //拿到对话框进行设置和美化 QFileDialog *fileDialog = new QFileDialog(this); fileDialog-\u003esetOption(QFileDialog::DontUseNativeDialog, true); QLabel *lookinLabel = fileDialog-\u003efindChild\u003cQLabel*\u003e(\"lookInLabel\"); lookinLabel-\u003esetText(QString::fromLocal8Bit(\"文件目录：\")); lookinLabel-\u003esetStyleSheet(\"color:red;\"); //设置日期框默认值为空 QLineEdit *edit = ui-\u003edateEdit-\u003efindChild\u003cQLineEdit *\u003e(\"qt_spinbox_lineedit\"); if (!edit-\u003etext().isEmpty()) { edit-\u003eclear(); } Qt内置了各种对话框，比如文件对话框-QFileDialog ，颜色对话框-QColorDialog ，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理。 QFileDialog *fileDialog = new QFileDialog(this); //不设置此属性根本查找不到任何子元素,因为默认采用的系统对话框 fileDialog-\u003esetOption(QFileDialog::DontUseNativeDialog, true); qDebug() \u003c\u003c fileDialog-\u003efindChildren\u003cQLabel *\u003e(); //打印","date":"0001-01-01","objectID":"/1/01/qt/:0:15","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"16：151-160 当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载。 //Qt中使用二进制资源文件方法如下 //将qrc编译为二进制文件rcc，在控制台执行下列命令 rcc -binary main.qrc -o main.rcc //在应用程序中注册资源，一般在main函数启动后就注册 QResource::registerResource(qApp-\u003eapplicationDirPath() + \"/main.rcc\"); 关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有。 //假设窗体中有子控件，默认字体12px，父类类型是QWidget，父类类名是Widget //下面几种方法只会设置主窗体的字体，子控件不会应用，需要按个调用setFont QFont font; font.setPixelSize(20); this-\u003esetFont(font); this-\u003esetStyleSheet(\"{font:26px;}\"); this-\u003esetStyleSheet(\"QWidget{font:26px;}\"); this-\u003esetStyleSheet(\"Widget{font:26px;}\"); //下面才是通过样式表设置整个控件+子控件的字体 this-\u003esetStyleSheet(\"font:26px;\"); this-\u003esetStyleSheet(\"*{font:26px;}\"); this-\u003esetStyleSheet(\"QWidget\u003e*{font:26px;}\"); this-\u003esetStyleSheet(\"Widget\u003e*{font:26px;}\"); //下面设置全局字体 qApp-\u003esetFont(font); Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format_ARGB32或者Format_RGBA8888。 //pixel 函数获取像素点的颜色 setPixel 函数设置像素点的颜色 此函数任意Qt版本都有 //pixelColor 函数获取像素点的颜色 setPixelColor 函数设置像素点的颜色 此函数Qt5.6以后才有 //pixel函数取出来的是QRgb格式需要用 qRed qGreen qBlue qAlpha 进行转换 QImage image(\"1.png\"); image = image.convertToFormat(QImage::Format_ARGB32); int width = image.width(); int height = image.height(); //遍历图像的每一个像素 for (int x = 0; x \u003c width; ++x) { for (int y = 0; y \u003c height; ++y) { QString name = image.pixelColor(x, y).name(); //将白色以外的颜色全部替换成红色 if (name != \"#ffffff\") { image.setPixelColor(x, y, Qt::red); } } } //保存文件 image.save(\"2.png\"); 在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论。 Qt天生内置了sqlite数据库，只需要发布的时候带上插件就行（可以看到插件动态库文件比其他几种都要大，那是因为直接将数据库的源码都编译进去了，而其他只编译了中间通信交互的插件源码），其他数据库要么还要带上动态库，要么还需要创建数据源； 速度上，绝对无与伦比的出类拔萃，同样的数据库结构（表结构、索引等完全一致），查询速度和批量更新速度、数据库事务等，速度都是其他几种的至少3倍以上，而且随着数据量的增大对比越发明显； 几千万的数据量完全没问题，而且速度和性能都还可以，不要以讹传讹网上部分菜鸡说的不支持百万以上的数据量，本人亲测亿级别，数据量建议千万级别以下，着重注意数据库表和索引的设计； 其他数据库还要注意版本的区别，ODBC数据源形式还容易出错和执行失败； sqlite数据库也有几个重大缺点：不支持加密，不支持网络访问，不支持部分数据库高级特性，不支持海量数据（亿级别以上），但是对于绝大部分Qt项目还是足够； 数据库支持友好度大致是 sqlite \u003e postgresql \u003e mysql \u003e odbc ; 以上都是在Qt环境中个人测试得出的结论，结果未必正确，作为参考即可，其他编程环境比如C#、JAVA请忽略，也许差别可能在中间通信的效率造成的； Qt5.10以后提供了新的类 QRandomGenerator QRandomGenerator64 管理随机数，使用更方便，尤其是取某个区间的随机数。 //早期处理办法 先初始化随机数种子然后取随机数 qsrand(QTime::currentTime().msec()); //取 0-10 之间的随机数 qrand() % 10; //取 0-1 之间的浮点数 qrand() / double(RAND_MAX); //新版处理办法 支持5.10以后的所有版本包括qt6 QRandomGenerator::global()-\u003ebounded(10); //生成一个0和10之间的整数 QRandomGenerator::global()-\u003ebounded(10.123); //生成一个0和10.123之间的浮点数 QRandomGenerator::global()-\u003ebounded(10, 15); //生成一个10和15之间的整数 //兼容qt4-qt6及以后所有版本的方法 就是用标准c++的随机数函数 srand(QTime::currentTime().msec()); rand() % 10; rand() / double(RAND_MAX); //通用公式 a是起始值,n是整数的范围 int value = a + rand() % n; //(min, max)的随机数 int value = min + 1 + (rand() % (max - min - 1)); //(min, max]的随机数 int value = min + 1 + (rand() % (max - min + 0)); //[min, max)的随机数 int value = min + 0 + (rand() % (max - min + 0)); //[min, max]的随机数 int value = min + 0 + (rand() % (max - min + 1)); //如果在线程中取随机数，线程启动的时间几乎一样，很可能出现取到的随机数一样的问题，就算设置随机数为当前时间啥的也没用，电脑太快很可能还是一样的时间，同一个毫秒。 //取巧办法就是在run函数之前最前面将当前线程的id作为种子设置。时间不可靠，线程的id才是唯一的。 //切记 void * 转换到数值必须用 long long，在32位是可以int但是在64位必须long，确保万一直接用quint64最大 srand((long long)currentThreadId()); qrand((long long)currentThreadId()); Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下。 void frmMain::on_btnMenu_Max_clicked() { ...... //最大化以后有个BUG,悬停样式没有取消掉,需要主动模拟鼠标动一下 QEvent event(QEvent::Leave); QApplication::sendEvent(ui-\u003ebtnMenu_Max, \u0026event); } 项目中启用c++11语法支持。 greaterThan(QT_MAJOR_VERSION, 4): CONFIG += c++11 lessThan(QT_MAJOR_VERSION, 5): QMAKE_CXXFLAGS += -std=c++11 Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多。 ui-\u003etextEdit-\u003esetUndoRedoEnabled(false); 其他几点常规小经验，本人在这几个地方摔跤过很多次。 有返回值的函数，一定要主动return返回值，有部分编译器在没有返回值的情况下也能正常编译通过，但是运行的时候会出问题，得不到想要的结果，因为没有return对应的值。 定义的局部变量，主动给定个初始值，是个必须养成的好习惯，不然编译器给的初始值很可能不是你想要的，比如int变量默认0，有时候随机变成一个很大的数值，bool变量的初始值不同编译器不同值，有些是true有些是false，主动给一个初始值更可靠。 某些函数参数很多，而且后期可能还会修改","date":"0001-01-01","objectID":"/1/01/qt/:0:16","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"17：161-170 经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条。 Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5.9以前需要拿到原有的窗体属性做运算，后面可以用新的方法。 //增加一个无边框属性 setWindowFlags(windowFlags() | Qt::FramelessWindowHint); //移除无边框属性 setWindowFlags(windowFlags() \u0026 ~Qt::FramelessWindowHint); //下面是5.9以后新增的方法 //增加一个无边框属性到窗体属性链表 setWindowFlag(Qt::FramelessWindowHint, true); //从窗体属性链表中移除无边框属性 setWindowFlag(Qt::FramelessWindowHint, false); 如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸。 setMinimumSize(0, 0); setMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX); Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-\u003emouseButtons()，全局的鼠标坐标可以用QCursor::pos()。 //在鼠标右键的地方弹出菜单，如果菜单是QMenu而不是QAction则只能通过下面的方式弹出 if (qApp-\u003emouseButtons() == Qt::RightButton) { videoMenu-\u003eexec(QCursor::pos()); } //全局剪切板 qApp-\u003eclipboard(); //顶层控件对象集合 qApp-\u003etopLevelWidgets() //当前焦点所在控件 qApp-\u003efocusWidget() //当前平台名称 qApp-\u003eplatformName() //调用系统蜂鸣器 qApp-\u003ebeep() //打印当前Qt版本信息 qApp-\u003eaboutQt() //设置全局的鼠标样式 qApp-\u003esetOverrideCursor() //不使用系统的标准颜色字体等 QGuiApplication::setDesktopSettingsAware(bool on); QApplication app(argc, argv); //更多的全局对象属性等可以查阅 qguiapplication.h 头文件，你会发现新大陆。 Qt对区分不同的编译器也做了非常细致的处理。 #pro文件可以这样判断 msvc { //要做的处理 } mingw { //要做的处理 } //代码中可以这样判断 #ifdef Q_CC_MINGW //mingw编译器 #elif Q_CC_MSVC //msvc编译器 #endif //判断编译器和编译器版本 #if defined Q_CC_MSVC \u0026\u0026 _MSC_VER \u003c 1300 #if defined(Q_CC_GNU) \u0026\u0026 (__GNUC__ \u003c 4) //代码中判断ARM平台 #ifdef QT_ARCH_ARM //多个条件判断 #if defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE) 有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用 blockSignals 方法。 //方法1：先 disconnect 掉信号，处理好以后再 connect 信号，缺点很明显，很傻，如果信号很多，每个型号都要这么来一次。 disconnect(ui-\u003ecbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int))); for (int i = 0; i \u003c= 100; i++) { ui-\u003ecbox-\u003eaddItem(QString::number(i)); } connect(ui-\u003ecbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int))); //方法2：先调用 blockSignals(true) 阻塞信号，处理号以后再调用 blockSignals(false) 恢复所有信号。 //如果需要指定某个信号进行断开那就只能用 disconnect 来处理。 ui-\u003ecbox-\u003eblockSignals(true); for (int i = 0; i \u003c= 100; i++) { ui-\u003ecbox-\u003eaddItem(QString::number(i)); } ui-\u003ecbox-\u003eblockSignals(false); 项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2。 //方法1：pro文件直接全部引入，而不是每个都添加一次，省心省力。 HEADERS += *.h SOURCES += *.cpp //方法2：分模块文件夹存放，不同模块用pri包含代码文件，比如界面可以放在ui文件夹，下面搞个ui.pri，然后pro项目文件只需要引入这个pri文件即可。 include($$PWD/ui/ui.pri) //还可以加上一句包含路径这样可以省去在使用代码的时候不用写文件夹 INCLUDEPATH += $$PWD/ui //加上上面这行，在使用头文件的时候可以直接 include \"form.h\"，没有加则需要 include \"ui/form.h\"。 在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农名工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的。 //tcp客户端 QTcpSocket *socket = new QTcpSocket(this); //断开所有连接和操作 socket-\u003eabort(); //绑定网卡和端口 socket-\u003ebind(QHostAddress(\"192.168.1.2\"), 6005); //连接服务器 socket-\u003econnectToHost(\"192.168.1.3\", 6000); //打印通信用的本地绑定地址和端口 qDebug() \u003c\u003c socket-\u003elocalAddress() \u003c\u003c socket-\u003elocalPort(); //打印通信服务器对方的地址和端口 qDebug() \u003c\u003c socket-\u003epeerAddress() \u003c\u003c socket-\u003epeerPort() \u003c\u003c socket-\u003epeerName(); //udp客户端 QUdpSocket *socket = new QUdpSocket(this); //绑定网卡和端口,没有绑定过才需要绑定 //采用端口是否一样来判断是为了方便可以直接动态绑定切换端口 if (socket-\u003elocalPort() != 6005) { socket-\u003eabort(); socket-\u003ebind(QHostAddress(\"192.168.1.2\"), 6005); } //指定地址和端口发送数据 socket-\u003ewriteDatagram(buffer, QHostAddress(\"192.168.1.3\"), 6000); //上面是Qt5可以使用bind，","date":"0001-01-01","objectID":"/1/01/qt/:0:17","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"18：171-180 在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen_s函数，比如fmod中也是这个情况。这个时候就需要转码处理。 QString fileName = \"c:/测试目录/1.txt\"; //如果应用程序main函数中没有设置编码则默认采用系统的编码，可以直接通过toLocal8Bit转成正确的数据 const char *name = fileName.toLocal8Bit().constData(); //如果设置过了下面两句则需要主动转码 QTextCodec *codec = QTextCodec::codecForName(\"utf-8\"); QTextCodec::setCodecForLocale(codec); QTextCodec *code = QTextCodec::codecForName(\"gbk\"); const char *name = code-\u003efromUnicode(fileName).constData(); //推荐方式2以防万一保证绝对的正确，哪怕是设置过主程序的编码 //切记一旦设置过QTextCodec::setCodecForLocale会影响toLocal8Bit //有时候可能还有下面这种情况 #ifdef Q_OS_WIN #if defined(_MSC_VER) \u0026\u0026 (_MSC_VER \u003e= 1400) QTextCodec *code = QTextCodec::codecForName(\"utf-8\"); #else QTextCodec *code = QTextCodec::codecForName(\"gbk\"); #endif const char *name = code-\u003efromUnicode(fileName).constData(); #else const char *name = fileName.toUtf8().constData(); #endif 在查阅和学习Qt源码的过程中，发现了一些趋势和改变。 数据类型这块尽量用Qt内部的数据类型，哪怕是重定义过的比如quint8其实unsigned char，qreal就是double，以前翻看源码的时候可能还有些是double，现在慢慢改成了qreal。 循环结构用 for(;;) 替代 while(1)，因为转成汇编指令后 for(;;) 只有一条指令而 while(1) 确有4条，指令少不占用寄存器而且不用跳转，理论上速度要更快。 其实Qt中就重定义了 forever 关键字表示 for(;;) ，我的乖乖，想的真周到。 自动c++11以及后续的标准都支持auto万能数据类型，发现Qt的源码中也慢慢的改成了auto，这样加快了编写代码的效率，不用自己去指定数据类型而是让编译器自己推导数据类型。而且其实也不影响编译器编译的速度，因为无论指定和没有指定数据类型，编译器都要推导右侧的数据类型进行判断。不过有个缺点就是影响了阅读代码的成本，很多时候需要自己去理解推导。 Qt中设置或者打开加载本地文件需要用到QUrl类，本地文件建议加上 file:/// 前缀。 QString url = \"file:///c:/1.html\"; //浏览器控件打开本地网页文件 webView-\u003esetUrl(QUrl(url)); //打开本地网页文件，下面两种方法都可以 QDesktopServices::openUrl(QUrl::fromLocalFile(url)); QDesktopServices::openUrl(QUrl(url, QUrl::TolerantMode)); 在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5.15开始内置了setTransferTimeout来设置超时时间，非常好用。 //局部的事件循环,不卡主界面 QEventLoop eventLoop; //设置超时 5.15开始自带了超时时间函数 默认30秒 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,15,0)) manager-\u003esetTransferTimeout(timeout); #else QTimer timer; connect(\u0026timer, SIGNAL(timeout()), \u0026eventLoop, SLOT(quit())); timer.setSingleShot(true); timer.start(timeout); #endif QNetworkReply *reply = manager-\u003eget(QNetworkRequest(QUrl(url))); connect(reply, SIGNAL(finished()), \u0026eventLoop, SLOT(quit())); eventLoop.exec(); if (reply-\u003ebytesAvailable() \u003e 0 \u0026\u0026 reply-\u003eerror() == QNetworkReply::NoError) { //读取所有数据保存成文件 QByteArray data = reply-\u003ereadAll(); QFile file(dirName + fileName); if (file.open(QFile::WriteOnly | QFile::Truncate)) { file.write(data); file.close(); } } Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick/qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。 //如果是控制台程序则下面的QApplication换成QCoreApplication //如果是quick/qml程序则下面的QApplication换成QGuiApplication int main(int argc, char *argv[]) { //可以用下面这行测试Qt自带的输入法 qtvirtualkeyboard qputenv(\"QT_IM_MODULE\", QByteArray(\"qtvirtualkeyboard\")); //设置不应用操作系统设置比如字体 QApplication::setDesktopSettingsAware(false); #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) //设置高分屏缩放舍入策略 QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif #if (QT_VERSION \u003e QT_VERSION_CHECK(5,6,0)) //设置启用高分屏缩放支持 //要注意开启后计算到的控件或界面宽度高度可能都不对,全部需要用缩放比例运算下 QApplication::setAttribute(Qt::AA_EnableHighDpiScaling); //设置启用高分屏图片支持 QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps); #endif #if (QT_VERSION \u003e QT_VERSION_CHECK(5,4,0)) //设置opengl模式 AA_UseDesktopOpenGL(默认) AA_UseOpenGLES AA_UseSoftwareOpenGL //在一些很旧的设备上或者对opengl支持很低的设备上需要使用AA_UseOpenGLES表示禁用硬件加速 //如果开启的是AA_UseOpenGLES则无法使用硬件加速比如ffmpeg的dxva2 //QApplication::setAttribute(Qt::AA_UseOpenGLES); //设置opengl共享上下文 QApplication::setAttribute(Qt::AA_ShareOpenGLContexts); #endif QApplication a(argc, argv); QWidget w; w.show(); return a.exec(); } QCamera中获取设备的配置参数比如支持的分辨率集合等，需要先调用load后才能正确获取，或者关联stateChanged信号中判断状态是否是ActiveState，然后再读取。 //方法1：调用load后获取 camera = new QCamera(this); //先需要载入才能获取到对应参数 camera-\u003eload(); //输出当前设备支持的分辨率 QList\u003cQSize\u003e sizes = camera-\u003esupportedViewfinderResolutions(); emit resolutions(sizes); //","date":"0001-01-01","objectID":"/1/01/qt/:0:18","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"19：181-190 Qt天生就是linux的，从linux开始发展起来的，所以不少Qt程序员经常的开发环境是linux，比如常用的ubuntu等系统，整理了一点常用的linux命令。 命令 功能 sudo -s 切换到管理员，如果是 sudo -i 切换后会改变当前目录。 apt install g++ 安装软件包（要管理员权限），另一个派系的是 yum install。 cd /home 进入home目录。 ls 罗列当前所在目录所有目录和文件。 ifconfig 查看网卡信息包括IP地址，windows上是 ipconfig。 tar -zxvf bin.tar.gz 解压文件到当前目录。 tar -jxvf bin.tar.xz 解压文件到当前目录。 tar -zxvf bin.tar.gz -C /home 解压文件到/home目录，记住是大写的C。 tar -zcvf bin.tar.gz bin 将bin目录压缩成tar.gz格式文件（压缩比一般）。 tar -jcvf bin.tar.xz bin 将bin目录压缩成tar.xz格式文件（压缩比高，推荐）。 tar -… j z 表示不同的压缩方法，x表示解压，c表示压缩。 gedit 1.txt 用记事本打开文本文件。 vim 1.txt 用vim打开文件，很多时候可以缩写用vi。 ./configure make -j4 make install 通用编译源码命令，第一步./configure执行配置脚本，第二步make -j4启用多线程编译，第三步make install安装编译好的文件。 ./configure -prefix /home/liu/Qt-5.9.3-static -static -sql-sqlite -qt-zlib -qt-xcb -qt-libpng -qt-libjpeg -fontconfig -system-freetype -iconv -nomake tests -nomake examples -skip qt3d -skip qtdoc Qt通用编译命令。 ./configure -static -release -fontconfig -system-freetype -qt-xcb -qt-sql-sqlite -qt-zlib -qt-libpng -qt-libjpeg -nomake tests -nomake examples -prefix /home/liu/qt/Qt5.6.3 Qt静态带中文。 ./configure -prefix /home/liu/Qt-5.9.3-static -static -release -nomake examples -nomake tests -skip qt3d 精简编译命令。 ./configure –prefix=host –enable-static –disable-shared –disable-doc ffmpeg编译命令。 Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等。 //Qt5开始提供了日志上下文信息输出，比如输出当前打印消息所在的代码文件、行号、函数名等。 //如果是release还需要在pro中加上 DEFINES += QT_MESSAGELOGCONTEXT 才能输出上下文，默认release关闭的。 //切记不要在日志钩子函数中再写qdebug之类的，那样就死循环了。 //日志重定向一般就三种处理 //1: 输出到日志文件比如txt文本文件。 //2: 存储到数据库，可以分类存储，以便相关人员查询分析。 //3: 重定向到网络，对方用小工具连接程序后，所有打印信息通过tcp发过去。 //日志重定向 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) void Log(QtMsgType type, const QMessageLogContext \u0026context, const QString \u0026msg) #else void Log(QtMsgType type, const char *msg) #endif { //加锁,防止多线程中qdebug太频繁导致崩溃 static QMutex mutex; QMutexLocker locker(\u0026mutex); QString content; //这里可以根据不同的类型加上不同的头部用于区分 switch (type) { case QtDebugMsg: content = QString(\"%1\").arg(msg); break; case QtWarningMsg: content = QString(\"%1\").arg(msg); break; case QtCriticalMsg: content = QString(\"%1\").arg(msg); break; case QtFatalMsg: content = QString(\"%1\").arg(msg); break; } //加上打印代码所在代码文件、行号、函数名 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) if (SaveLog::Instance()-\u003egetUseContext()) { int line = context.line; QString file = context.file; QString function = context.function; if (line \u003e 0) { content = QString(\"行号: %1 文件: %2 函数: %3\\n%4\").arg(line).arg(file).arg(function).arg(content); } } #endif //将内容传给函数进行处理 SaveLog::Instance()-\u003esave(content); } //安装日志钩子,输出调试信息到文件,便于调试 void SaveLog::start() { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) qInstallMessageHandler(Log); #else qInstallMsgHandler(Log); #endif } //卸载日志钩子 void SaveLog::stop() { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) qInstallMessageHandler(0); #else qInstallMsgHandler(0); #endif } 自从c++11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记。 代码格式：capture mutable -\u003ereturn-type {statement} [capture]：捕捉列表，捕捉列表总是出现在Lambda函数的开始处，实际上，[]是Lambda引出符，编译器根据该引出符判断接下来的代码是否是Lambda函数，捕捉列表能够捕捉上下文中的变量以供Lambda函数使用。 (parameters)：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以连同括号 () 一起省略。 mutable：mutable修饰符，默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。 -\u003ereturn-type：返回类型，用追踪返回类型形式声明函数的返回类型，我们可以在不需要返回值的时候也可以连同符号 -\u003e 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。 {statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。 捕捉列表有以下几种形式： [var]表示值传递方式捕捉变量var。 [=]表示值传递方式捕捉所有父作用域的变量（包括this）。 [\u0026var]表示引用传递捕捉变量var。 [\u0026]表示引用传递方式捕捉所有父作用域的变量（包括this）。 [this]表示值传递方式捕捉当前的this指针。 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-\u003esetupUi(this); //按钮单击不带参数 connect(ui-\u003epushButton, \u0026QPushButton::clicked, [] { qDebug() \u003c\u003c \"hello lambda\"; }); //按钮单击带参数 connect(ui-\u003epushButton, \u0026QPushButton::clicked, [] (bool isCheck) { qDebug() \u003c\u003c \"hello lambda\" \u003c\u003c isCheck; }); //自定义信号带参数 connect(this, \u0026MainWindow::sig_test, [] (int i, int j) { qDebug() \u003c\u003c \"hello lambda\" \u003c\u003c i ","date":"0001-01-01","objectID":"/1/01/qt/:0:19","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"20：191-200 关于QList队列的处理中，我们最常用的就是调用append函数添加item，往前插入item很多人第一印象就是调用insert(0,xxx)来插入，其实QList完全提供了往前追加item的函数prepend、push_front。 QStringList list; list \u003c\u003c \"aaa\" \u003c\u003c \"bbb\" \u003c\u003c \"ccc\"; //往后追加 等价于 append list.push_back(\"ddd\"); //往前追加 等价于 prepend list.push_front(\"xxx\"); //往后追加 list.append(\"ddd\"); //往前追加 list.prepend(\"xxx\"); //指定第一个位置插入 等价于 prepend list.insert(0, \"xxx\"); //输出 QList(\"xxx\", \"aaa\", \"bbb\", \"ccc\", \"ddd\") qDebug() \u003c\u003c list; Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型。 //qwindowdefs.h typedef QList\u003cQWidget *\u003e QWidgetList; typedef QList\u003cQWindow *\u003e QWindowList; typedef QHash\u003cWId, QWidget *\u003e QWidgetMapper; typedef QSet\u003cQWidget *\u003e QWidgetSet; //qmetatype.h typedef QList\u003cQVariant\u003e QVariantList; typedef QMap\u003cQString, QVariant\u003e QVariantMap; typedef QHash\u003cQString, QVariant\u003e QVariantHash; typedef QList\u003cQByteArray\u003e QByteArrayList; Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值。 Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5.6开始提供了 AA_EnableHighDpiScaling 的属性设置开启高分屏，到了5.14以后还可以指定缩放的策略 HighDpiScaleFactorRoundingPolicy 比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了 AA_EnableHighDpiScaling 属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放。 //永远不应用高分屏及缩放 int main(int argc, char *argv[]) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) QApplication::setAttribute(Qt::AA_Use96Dpi); #endif #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,14,0)) QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif QApplication a(argc, argv); .... return a.exec(); } //自动应用高分屏及缩放 //方法很多，综合对比下来还是采用配置文件指定缩放策略最适中。 //新建qt.conf文件放到可执行文件同一目录 [Platforms] WindowsArguments = dpiawareness=0 //有时候想让用户去选择何种策略，需要开启高分屏的之后只需要将qt.conf文件放到可执行文件同一目录即可，就算代码中设置了不应用高分屏及缩放，也无效，也是优先取qt.conf文件的策略。 关于QSS要注意的坑。 qss源自css，相当于css的一个子集，主要支持的是css2标准，很多网上的css3的标准的写法在qss这里是不生效的，所以不要大惊小怪。 qss也不是完全支持所有的css2，比如text-align官方文档就有说明，只支持 QPushButton and QProgressBar，务必看清楚。 有时候偷懒直接来一句 *{xxx}，你会发现大部分是应用了，也有小部分或者极个别没有应用，你可能需要在对应的窗体中 this-\u003esetStyleSheet() 来设置。 qss的执行是有优先级的，如果没有指定父对象，则对所有的应用，比如在窗体widget中 {color:#ff0000;} 这样会对widget以及widget的所有子对象应用该样式，这种问题各大群每周都有人问，你会发现各种奇奇怪怪的异样不正常，怎么办呢，你需要指定类名或者对象名，比如 #widget{color:#ff0000;} 这样就只会对widget对象应用该样式，另一种写法 QWidget#widget{color:#ff0000;}，只想对窗体本身而不是子控件按钮标签等 .QWidget{color:#ff0000;} ，具体详细规则参见官方说明。 qss整体来说还是可以的，解析速度性能在Qt5高版本后期比Qt4好很多，尤其是修复了不少qss中的解析绘制BUG。尽管有这样那样的BUG，怀着包容的心对待它。 qss官方学习地址1：http://47.100.39.100/qtwidgets/stylesheet-reference.html qss官方学习地址2：http://47.100.39.100/qtwidgets/stylesheet-examples.html 关于Qt延时的几种方法。 void QUIHelperCore::sleep(int msec) { if (msec \u003c= 0) { return; } #if 1 //非阻塞方式延时,现在很多人推荐的方法 QEventLoop loop; QTimer::singleShot(msec, \u0026loop, SLOT(quit())); loop.exec(); #else #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) //阻塞方式延时,如果在主线程会卡住主界面 QThread::msleep(msec); #else //非阻塞方式延时,不会卡住主界面,据说可能有问题 QTime endTime = QTime::currentTime().addMSecs(msec); while (QTime::currentTime() \u003c endTime) { QCoreApplication::processEvents(QEventLoop::AllEvents, 100); } #endif #endif } 随着国产化的兴起，各种国产系统和国产数据库等逐渐进入开发者的世界，罗列几个要点。 中标麒麟neokylin基于centos。 银河麒麟kylin早期版本比如V2基于freebsd，新版本V4、V10基于ubuntu。 优麒麟ubuntukylin就是ubuntu的汉化版本，加了点农历控件啥的。 deepin基于debian。 uos基于deepin或者说是deepin的商业分支。 ubuntu基于debian。 linux界主要分两种发行版本，debian（ubuntu、deepin、uos、银河麒麟kylin等）和redhat（fedora、centos、中标麒麟neokylin、中兴新支点newstart等），分别对应apt-get和yum安装命令。绝大部分的linux系统都基于或者衍生自这两种发行版本。 理论上基于同一种系统内核的，在其上编译的程序可以换到另外的系统运行，前提是编译器版本一致，比如都是gcc4.9，在ubuntu14.04 64位用gcc4.9编译的Qt程序，是能够在uos 64位上运行的。 高版本编译器的系统一般能够兼容低版本的，比如你用gcc4.9编译的程序是能够在gcc7.0上运行，反过来不行。 意味着如果你想尽可能兼容更多的系统，尽量用低版本的编译器编译你的程序，当然要你的程序代码语法支持，比如c++11就要从gcc4.7开始才支持，如果你的代码用了c++11则必须至少选择gcc4.7版本及以上。 用Qt编写linux程序为了发布后的可执行文件可以兼容各种linux系统，只要在这两种内核（debian、redhat）的系统上用低版本的编译器比如gcc4.7编译qt程序发布即可。 2022-01-27补充：根据Qt官方安装包，发现基于redhat的gcc4.9编译器发布的，通用各种linux系统（亲测ubuntu各个版本、fedora、centos、deepin、uos、银河麒麟kylin、中标麒","date":"0001-01-01","objectID":"/1/01/qt/:0:20","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"21：201-210 编译生成debug版本动态库，文件末尾自动加上d结尾。 CONFIG(debug, debug|release) { win32: TARGET = $$join(TARGET,,,d) mac: TARGET = $$join(TARGET,,,_debug) unix:!mac: TARGET = $$join(TARGET,,,d) } QtCreator中pro项目文件格式说明。 名称 说明 QT += core gui 添加本项目中需要的模块，影响后面代码文件include的时候自动弹出下拉选择，如果pro文件没有引入该模块则无法自动语法提示，一般打包发布的时候对应动态库文件比如 Qt5Core.dll。 TARGET = xxx 生成最后目标文件的名字，可以是可执行文件或者库文件。 TEMPLATE = app 项目程序的生成模式，默认是app表示生成可执行文件程序，如果是动态库项目就是 TEMPLATE = lib。 CONFIG += qaxcontainer 引入一些配置，在Qt4的时候还用来引入一些模块，其中有部分改成了QT += 方式引入，比如Qt5引入本地activex控件支持改成了QT += qaxcontainer。 DEFINES += xxx 项目中自定义的一些定义，可以在代码文件中识别，通常用来定义一些不同平台的处理，根据项目需要自己定义任何标识。 HEADERS += head.h 项目中用到的头文件，一般拓展名是.h，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。 SOURCES += main.cpp 项目中用到的实现文件，一般拓展名是.cpp，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。 FORMS += Form.ui 项目中用到的UI文件，一般拓展名是.ui，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。 RESOURCES += main.qrc 项目中用到的资源文件，可以多个，写代码使用对应资源文件中的文件时候务必记得资源文件中的前缀。 LIBS += -L$$PWD/ -lavformat -lavcodec 项目中编译时候链接依赖的库，一般是 .lib .a .dylib 文件，可以写在一行，省略文件名的lib打头部分，也可以分多行绝对路径和全名称。 DESTDIR += $$PWD/bin 目标生成路径，$$PWD表示当前目录，一般建议生成的最终文件重定向到另外目录存放，好找，不然一堆临时文件在里面有时候文件太多好难找。 INCLUDEPATH += $$PWD/include 工程需要的头文件，指定整个目录，写代码的时候找到的话会自动下拉。 DEPENDPATH += 工程的依赖路径，用的比较少，一般涉及到引入链接库的时候可能需要。 include($$PWD/3rd.pri) 引入pri模块文件，pri最大的好处就是分目录管理文件，通用的轮子模块可以放到一个目录下，然后用pri统一管理，可以给多个项目公用。 官方详细地址https://doc.qt.io/qt-5/qmake-variable-reference.html 如果发现之前编译正常，突然之间再编译就一直死循环的样子，停留在一行提示并疯狂不停的打印，或者提示文件时间在未来，这说明你很可能改过开发环境的时间（比如测试某个授权文件失效），导致有修改过文件的保存时间在未来，你只需要将时间调整回来，将最后更新时间不正确的代码文件重新保存下就行。Qt的增量编译是根据文件的最后修改时间来判定的，最后的修改时间比上一次的修改时间还要新则认为该文件被修改过，需要重新编译该文件。 Qt的构建套件一般是在安装Qt开发环境的时候自动设置的，当然也可以手动设置，手动设置的时候千万要注意编译器和Qt库必须一致，否则该构建套件是有问题的，千万不能乱设置，尤其是对构建套件命名的时候最好标明qt版本和编译器版本，最好也要一致，不要说名称叫msvc而编译器选择的确是mingw，这样尽管能正常使用该构建套件，但是会造成一种误解，还以为该套件是msvc的，其实里面是mingw的。有个qter说他的qt坏了，死活编译失败，远程一看，尼玛，构建套件名称写的qt_msvc2019 编译器选择的msvc2015（他电脑只安装了vs2015），qt库选择的mingw！差点狂扇自己八个耳光，太离谱了！ 当你编译Qt程序发现编译通不过提示报错，而且报错提示在Qt的头文件的时候，不要去尝试着修改Qt头文件来编译通过，那样没用的，你使用的Qt的库是已经根据原始的头文件编译好的。如果报错提示在编译生成的临时的moc等文件，你也不要尝试去修改他，那个是临时文件，这次你改好了也许编译通过了，你重新编一下又覆盖了还是旧的错误。总之你要从源头（你的代码）找问题。 有时候需要对文本进行分散对齐显示，相当于无论文字多少，尽可能占满整个空间平摊占位宽度，但是在对支持对齐方式的控件比如QLabel调用 setAlignment(Qt::AlignJustify | Qt::AlignVCenter) 设置分散对齐会发现没有任何效果，这个时候就要考虑另外的方式比如通过控制字体的间距来实现分散对齐效果。 QString text = \"测试分散对齐内容\"; //计算当前文本在当前字体下占用的宽度 QFont font = ui-\u003elabel-\u003efont(); int textWidth = ui-\u003elabel-\u003efontMetrics().width(text); //显示文本的区域宽度=标签的宽度-两边的边距 int width = ui-\u003elabel-\u003ewidth() - 12; //需要-1相当于中间有几个间隔 int count = text.count() - 1; //计算每个间距多少 qreal space = qreal(width - textWidth) / count; //设置固定间距 font.setLetterSpacing(QFont::AbsoluteSpacing, space); ui-\u003elabel-\u003esetFont(font); ui-\u003elabel-\u003esetText(text); 随着需求的不断增加，程序不断变大，用到的动态库也越来越多，到了发布程序的时候你会发现和可执行文件同一目录下文件数量真多，此时可能会考虑如何将一些库文件分门别类的存放，这样方便管理。 Qt提供的设置动态库路径的方法setLibraryPaths是用来搜索插件动态库的，而不是程序直接依赖的动态库。 很多人以为这个可以设置Qt的库或者程序中依赖的第三方库的路径，其实想想也知道，因为程序依赖这个库，找不到的话根本跑不起来，程序跑不起来怎么应用执行这个代码呢？ Qt默认是可用通过setLibraryPaths的方式设置Qt插件的动态库目录位置，比如数据库插件sqldrivers，因为这些库文件是真正在Qt程序跑起来以后通过插件形式去加载的。 还可以通过qt.conf文件设置 Plugins=“config” 指定所有插件在可执行文件下的config目录下。 要想设置程序直接依赖的动态库在其他目录，找遍全宇宙也只有一个办法，那就是设置环境变量，除此别无他法。 至于如何设置环境变量方式很多，比如手动在电脑上设置，或者搞个批处理文件执行命令行，在程序安装的时候自动执行，或者程序打包目录下用户手动运行这个批处理。 大神补充：设置插件的目录还可以通过在main函数最前面写 qputenv(“PATH”, QString(\"%1;%2”).arg(qgetenv(“PATH”), pluginFileInfo.path()).toLocal8Bit()); 来实现。 网友补充：最终找插件的路径其实就是这个 QT_PLUGIN_PATH 环境变量。 进度条控件如果设置的垂直方向，就算你设置了文本可见，会发现根本看不到进度文本，经过多方百折不挠的试探，以及和酷码大佬深入的探讨，发现只要设置下border样式（border:1px solid #ff0000、border:none、border-style:solid、border-radius:0px 任意一种）就行，就可以把文本显示出来，这TM就不知道Qt为什么总是不统一规则，这个BUG通用于任何版本，这个可能是因为边框的solid样式冲突了导致无法继续绘制，确切的说这必须是BUG，这个锅Qt必须背。 我们在使用QFileDialog::getOpenFileName、QFileDialog::getExistingDirectory等方法时，有时候会发现首次打开很卡，尤其是在默认目录很多文件的时候，此时你可以考虑设置这些函数最末尾的参数为QFileDialog::DontUseNativeDialog，表示不采用本地系统对话框，这样的话会采用Qt的对话框，速度快很多，估计系统的对话框在打开的时候会做很多初始化加载处理。 QFileDialog::getOpenFileName(this, \"\", \"\", \"\", 0, QFileDialog::DontUseNativeDialog); QFileDialog::getExistingDirectory(this, \"\", \"\", QFileDialog::DontUseNativeDialog); 滑块控件QSlider，如果设置的垂直样式，其进度颜色和剩余颜色，刚好和横向样式的颜色相反的，不确定这个是否是Qt的BUG，Qt456都是这个现象。 QSlider::groove","date":"0001-01-01","objectID":"/1/01/qt/:0:21","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"22：211-220 QMainWindow 在对停靠窗体进行排列的时候，有些不常用的设置容易遗忘，建议将 QMainWindow 的头文件函数过一遍一目了然。详细介绍各种停靠参数文章参见 https://zhuanlan.zhihu.com/p/388544168。 //设置允许各种嵌套比如上下排列左右排列非常灵活 //此设置会和下面的 setDockOptions 中的参数覆盖所以要注意顺序 //this-\u003esetDockNestingEnabled(true); //设置停靠参数,不允许重叠,只允许拖动和嵌套 this-\u003esetDockOptions(AnimatedDocks | AllowNestedDocks); //将底部左侧作为左侧区域，底部右侧作为右侧区域，否则底部区域会填充拉伸 this-\u003esetCorner(Qt::BottomLeftCorner, Qt::LeftDockWidgetArea); this-\u003esetCorner(Qt::BottomRightCorner, Qt::RightDockWidgetArea); 当我们在对QModelIndex取数据的时候，常规的角色的数据（QVariant类型支持to的比如toString、toInt、toDouble等）可以很方便的取出来，特定的数据类型需要用的万能取值模板函数 T value() 取出来。 //显示文本 QString text = index.data(Qt::DisplayRole).toString(); //文本对齐 int align = index.data(Qt::TextAlignmentRole).toInt(); //文字字体 QFont font = index.data(Qt::FontRole).value\u003cQFont\u003e(); //前景色 QColor color = index.data(Qt::ForegroundRole).value\u003cQColor\u003e(); //背景色 QColor color = index.data(Qt::BackgroundRole).value\u003cQColor\u003e(); 很多人以为拖曳只要在dropEvent事件就可以了，其实不行的，没有效果的，需要先在dragEnterEvent事件中执行event-\u003eaccept()才行，不然根本没有效果，很多人尤其是初学者都挂在这里，我就是在这里摔了一跤，好疼！ void frmMain::dropEvent(QDropEvent *event) { QList\u003cQUrl\u003e urls = event-\u003emimeData()-\u003eurls(); } void frmMain::dragEnterEvent(QDragEnterEvent *event) { if(event-\u003emimeData()-\u003ehasFormat(\"application/x-qabstractitemmodeldatalist\")) { event-\u003esetDropAction(Qt::MoveAction); event-\u003eaccept(); } else { event-\u003eignore(); } } Qt5.6以后内置的是webengine浏览器内核，如果需要做web交互的话必须用到 qwebchannel.js 这个文件，此文件是Qt官方提供的，所以不建议去改动其中的源码，要注意的是，由于官方对webengine的支持在不断更新，所以官方提供的对应Qt版本的 qwebchannel.js 文件也不同，意味着你要用对应提供的版本的 qwebchannel.js 文件才ok，该文件默认在 C:\\Qt\\Qt5.12.11\\Examples\\Qt-5.12.11\\webchannel\\shared 目录下。经过几十个Qt版本的测试发现，用高版本的 qwebchannel.js 放到低版本运行不行，低版本放到高版本可以，为了万无一失还是建议直接用对应版本的。 对于QString去除空格，有多种场景，可能需要去除左侧、右侧、所有等位置的空格。 //字符串去空格 -1=移除左侧空格 0=移除所有空格 1=移除右侧空格 2=移除首尾空格 3=首尾清除中间留一个空格 QString QUIHelperData::trimmed(const QString \u0026text, int type) { QString temp = text; QString pattern; if (type == -1) { pattern = \"^ +\\\\s*\"; } else if (type == 0) { pattern = \"\\\\s\"; //temp.replace(\" \", \"\"); } else if (type == 1) { pattern = \"\\\\s* +$\"; } else if (type == 2) { temp = temp.trimmed(); } else if (type == 3) { temp = temp.simplified(); } //调用正则表达式移除空格 if (!pattern.isEmpty()) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) temp.remove(QRegularExpression(pattern)); #else temp.remove(QRegExp(pattern)); #endif } return temp; } //测试代码 QString text = \" a b c d \"; //结果：a b c d QUIHelper::trimmed(text, -1); //结果：abcd QUIHelper::trimmed(text, 0); //结果： a b c d QUIHelper::trimmed(text, 1); //结果：a b c d QUIHelper::trimmed(text, 2); //结果：a b c d QUIHelper::trimmed(text, 3); Qt的网络库支持udp广播搜索和组播搜索，其中组播搜索可以跨网段搜索，有时候你会发现失灵，此时你可以尝试把本地的虚拟机的网卡禁用试试，估计就好了。还有就是在本地开启了代理啥的，先关掉试试。近期在使用tcpsocket连接的时候，发现在Qt4和Qt5中正常的程序，到了Qt6中就不行了，报错提示 The proxy type is invalid for this operation ，原来是本地设置了代理导致的，可能在Qt6以前会默认跳过去不处理。 //也可以通过代码设置跳过代理 #include \u003cQNetworkProxy\u003e QNetworkProxyFactory::setUseSystemConfiguration(false); //下面这样每次设置也可以 tcpSocket-\u003esetProxy(QNetworkProxy::NoProxy); //查阅到文章 https://www.cnblogs.com/cppskill/p/11730452.html //从5.8开始socket默认代理类型是DefaultProxy而不是NoProxy，不知道出于什么考虑。 关于交叉编译，对于初学者来说是个极难跨过去的砍（一旦跨过去了以后遇到需要交叉编译的时候都是顺水推舟信手拈来），因为需要搭建交叉编译环境，好在现在厂家提供的板子基本上都是测试好的环境，尤其是提供的编译器，不用自己再去折腾，按照官方手册来基本上不会有啥的的问题。 在linux系统上编译ffmpeg和qt都是非常简单的事情，初学者也会，前提只要本地的gcc g++编译器正常。 任何编译器包括嵌入式编译器，为了确保环境正常，你可以先查看对应的编译器版本是否ok，g++ -v 或者执行编译器所在目录的绝对路径。 交叉编译器查看版本 /opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux-g++ -v 编译器位数和操作系统位数有关，一般32位的编译器要在32位的系统上做交叉编译，虽然32位也可以安装依赖在64位系统做交叉编译，但是个人不建议，可能会出问题。64位的编译器只能在64位的系统。 设置环境变量只是为了编译的时候让自动寻找编译器，其实也完全可以不用设置环境变量，使用绝对路径指定编译器位置即可。 在linux上编译，无论是ffmpeg还是qt还是其他，都是通用的步骤，第一步：./configure 第二步：make 第三步：make install 。 至于具体configure后面有哪些参数，参照对应源码包的手册就行，搜索也一大堆。当然你用默认的就不带任何参数一般也可以，自动采用默认参数进行编译。 交叉编译ffmpeg命令：./configure –prefix=host –enable-static –disable-shared –disable-doc –cross-prefix=/opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux- –arch=arm –target-os=linux 交叉编译qt前提：修改mkspecs/qws/linux-arm-g++下面的qmake.conf，如果没有设置环境变量则设置对应编译器的绝对路径，并将编译器的名字改成你需要的。 比如修改gcc编译器：QMAKE_CC = /opt/FriendlyARM/toolscha","date":"0001-01-01","objectID":"/1/01/qt/:0:22","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"二、升级到Qt6 ","date":"0001-01-01","objectID":"/1/01/qt/:1:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"00：直观总结 增加了很多轮子，同时原有模块拆分的也更细致，估计为了方便拓展个管理。 把一些过度封装的东西移除了（比如同样的功能有多个函数），保证了只有一个函数执行该功能。 把一些Qt5中兼容Qt4的方法废弃了，必须用Qt5中对应的新的函数。 跟随时代脚步，增加了不少新特性以满足日益增长的客户需求。 对某些模块和类型及处理进行了革命性的重写，运行效率提高不少。 有参数类型的变化，比如 long * 到 qintptr * 等，更加适应后续的拓展以及同时对32 64位不同系统的兼容。 源码中的double数据类型全部换成了qreal，和Qt内部数据类型高度一致和统一。 我测试的都是QWidget部分，quick部分没有测试，估计quick部分更新可能会更多。 强烈建议暂时不要用Qt6.0到Qt6.2之间的版本，一些模块还缺失，相对来说BUG也比较多，推荐6.2.2版本开始正式迁移。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"01：01-10 万能方法：安装5.15版本，定位到报错的函数，切换到源码头文件，可以看到对应提示字样 QT_DEPRECATED_X(“Use sizeInBytes”) 和新函数。按照这个提示类修改就没错，一些函数是从Qt5.7 5.9 5.10等版本新增加的，可能你的项目还用的Qt4的方法，但是Qt6以前都兼容这些旧方法，到了Qt6就彻底需要用新方法了。PS：如果本身就是Qt6新增的功能函数则此方法无效 Qt6对core这个核心类进行了拆分，多出来core5compat，因此你需要在pro增加对应的模块已经代码中引入对应的头文件。 //pro文件引入模块 greaterThan(QT_MAJOR_VERSION, 4): QT += widgets greaterThan(QT_MAJOR_VERSION, 5): QT += core5compat //代码中引入头文件 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) #include \u003cQtWidgets\u003e #endif #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) #include \u003cQtCore5Compat\u003e #endif 默认Qt6开启了高分屏支持，界面会变得很大，甚至字体发虚，很多人会不习惯，因为这种模式如果程序很多坐标计算没有采用devicePixelRatio进行运算的话，100%会出现奇奇怪怪的问题，因为坐标不准确了。要取消这种效果可以设置高分屏缩放因子。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif 原有的随机数函数提示用QRandomGenerator替代，为了兼容所有qt版本，改动最小的办法是直接用c++中的随机数，比如qsrand函数换成srand，qrand函数换成rand，查看过源代码，其实封装的就是c++中的随机数，很多类似的封装比如qSin封装的sin。 QColor的 light 改成 lighter ，dark 改成 darker，其实 lighter、darker 这两个方法以前一直有。 QFontMetricsF 中的 fm.width 换成 fm.horizontalAdvance ，从5.11开始用新函数。 QPalette调色板枚举值，Foreground = WindowText, Background = Window，其中 Foreground 和 Background 没有了，要用 WindowText 和 Window 替代，以前就有。类似的还有 setTextColor 改成了 setForeground 。 QWheelEvent的 delta() 改成 angleDelta().y()，pos() 改成 position() 。 svg模块拆分出来了svgwidgets，如果用到了该模块则需要在pro增加 QT += svgwidgets ，同理opengl模块拆分出来了openglwidgets。 qlayout中的 margin() 函数换成 contentsMargins().left()，查看源码得知以前的 margin() 返回的就是 contentsMargins().left()，在四个数值一样的时候，默认四个数值就是一样。类似的还有setMargin移除了，统统用setContentsMargins。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"02：11-20 之前 QChar c = 0xf105 全部要改成强制转换 QChar c = (QChar)0xf105，不再有隐式转换，不然编译报错提示error: conversion from ‘int’ to ‘QChar’ is ambiguous 。 qSort等一些函数用回c++的 std::sort 。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) std::sort(ipv4s.begin(), ipv4s.end()); #else qSort(ipv4s); #endif Qt::WA_NoBackground 改成 Qt::WA_OpaquePaintEvent 。 QMatrix 类废弃了没有了，换成 QTransform ，函数功能基本一致，QTransform 类在Qt4就一直有。 QTime 计时去掉了，需要改成 QElapsedTimer ，QElapsedTimer 类在Qt4就一直有。 QApplication::desktop()废弃了， 换成了 QApplication::primaryScreen()。 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,0,0)) #include \"qscreen.h\" #define deskGeometry qApp-\u003eprimaryScreen()-\u003egeometry() #define deskGeometry2 qApp-\u003eprimaryScreen()-\u003eavailableGeometry() #else #include \"qdesktopwidget.h\" #define deskGeometry qApp-\u003edesktop()-\u003egeometry() #define deskGeometry2 qApp-\u003edesktop()-\u003eavailableGeometry() #endif 获取当前屏幕索引以及尺寸需要分别处理。 //获取当前屏幕索引 int QUIHelper::getScreenIndex() { //需要对多个屏幕进行处理 int screenIndex = 0; #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) int screenCount = qApp-\u003escreens().count(); #else int screenCount = qApp-\u003edesktop()-\u003escreenCount(); #endif if (screenCount \u003e 1) { //找到当前鼠标所在屏幕 QPoint pos = QCursor::pos(); for (int i = 0; i \u003c screenCount; ++i) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) if (qApp-\u003escreens().at(i)-\u003egeometry().contains(pos)) { #else if (qApp-\u003edesktop()-\u003escreenGeometry(i).contains(pos)) { #endif screenIndex = i; break; } } } return screenIndex; } //获取当前屏幕尺寸区域 QRect QUIHelper::getScreenRect(bool available) { QRect rect; int screenIndex = QUIHelper::getScreenIndex(); if (available) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) rect = qApp-\u003escreens().at(screenIndex)-\u003eavailableGeometry(); #else rect = qApp-\u003edesktop()-\u003eavailableGeometry(screenIndex); #endif } else { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) rect = qApp-\u003escreens().at(screenIndex)-\u003egeometry(); #else rect = qApp-\u003edesktop()-\u003escreenGeometry(screenIndex); #endif } return rect; } QRegExp类移到了core5compat模块，需要主动引入头文件 #include 。 //设置限制只能输入数字+小数位 QString pattern = \"^-?[0-9]+([.]{1}[0-9]+){0,1}$\"; //设置IP地址校验过滤 QString pattern = \"(2[0-5]{2}|2[0-4][0-9]|1?[0-9]{1,2})\"; //确切的说 QRegularExpression QRegularExpressionValidator 从5.0 5.1开始就有 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) QRegularExpression regExp(pattern); QRegularExpressionValidator *validator = new QRegularExpressionValidator(regExp, this); #else QRegExp regExp(pattern); QRegExpValidator *validator = new QRegExpValidator(regExp, this); #endif lineEdit-\u003esetValidator(validator); QWheelEvent构造参数和对应的计算方位函数变了。 //模拟鼠标滚轮 #if (QT_VERSION \u003c QT_VERSION_CHECK(6,0,0)) QWheelEvent wheelEvent(QPoint(0, 0), -scal, Qt::LeftButton, Qt::NoModifier); #else QWheelEvent wheelEvent(QPointF(0, 0), QPointF(0, 0), QPoint(0, 0), QPoint(0, -scal), Qt::LeftButton, Qt::NoModifier, Qt::ScrollBegin, false); #endif QApplication::sendEvent(widget, \u0026wheelEvent); //鼠标滚轮直接修改值 QWheelEvent *whellEvent = (QWheelEvent *)event; //滚动的角度,*8就是鼠标滚动的距离 #if (QT_VERSION \u003c QT_VERSION_CHECK(6,0,0)) int degrees = whellEvent-\u003edelta() / 8; #else int degrees = whellEvent-\u003eangleDelta().x() / 8; #endif //滚动的步数,*15就是鼠标滚动的角度 int steps = degrees / 15; qVariantValue 改成 qvariant_cast ，qVariantSetValue(v, value) 改成了 v.setValue(val)。相当于退回到最原始的方法，查看qVariantValue源码封装的就是qvariant_cast。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:3","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"03：21-30 QStyleOption的init改成了initFrom。 QVariant::Type 换成了 QMetaType::Type ，本身以前的 QVariant::Type 封装的就是 QMetaType::Type 。 QStyleOptionViewItemV2 V3 V4 之类的全部没有了，暂时可以用 QStyleOptionViewItem 替代。 QFont的 resolve 的一个重载函数换成了 resolveMask。 QSettings的 setIniCodec 方法移除了，默认就是utf8，不需要设置。 qcombobox 的 activated(QString) 和 currentIndexChanged(QString) 信号删除了，用int索引参数的那个，然后自己通过索引获取值。个人觉得这个没必要删除。 qtscript模块彻底没有了，尽管从Qt5时代的后期版本就提示为废弃模块，一致坚持到Qt6才正式废弃，各种json数据解析全部换成qjson类解析。 QByteArray 的 append indexOf lastIndexOf 等众多方法的QString参数重载函数废弃了，要直接传 QByteArray，就在原来参数基础上加上 .toUtf8() 。查看源码也看得到以前的QString参数也是转成.toUtf8()再去比较。 QDateTime的时间转换函数 toTime_t + setTime_t 名字改了，对应改成了 toSecsSinceEpoch + setSecsSinceEpoch ，这两个方法在Qt5.8时候新增加的。 QLabel的 pixmap 函数之前是指针 *pixmap() 现在换成了引用 pixmap()。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:4","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"04：31-40 QTableWidget的 sortByColumn 方法移除了默认升序的方法，必须要填入第二个参数表示升序还是降序。 qtnetwork模块中（TCP/UDP相关的socket）的错误信号error换成了errorOccurred，就改了个名字，注意websocket那块居然没统一改过来依然是叫error。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) connect(udpSocket, SIGNAL(errorOccurred(QAbstractSocket::SocketError)), this, SLOT(error())); connect(tcpSocket, SIGNAL(errorOccurred(QAbstractSocket::SocketError)), this, SLOT(error())); #else connect(udpSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error())); connect(tcpSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error())); #endif //特别注意websocket中依然还是用error connect(webSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error())); XmlPatterns模块木有了，全部用xml模块重新解析。 nativeEvent的参数类型变了。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) bool nativeEvent(const QByteArray \u0026eventType, void *message, qintptr *result); #else bool nativeEvent(const QByteArray \u0026eventType, void *message, long *result); #endif QButtonGroup的buttonClicked信号中int参数的函数全部改名字叫idClicked。 QButtonGroup *btnGroup = new QButtonGroup(this); #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) connect(btnGroup, SIGNAL(idClicked(int)), ui-\u003exstackWidget, SLOT(setCurrentIndex(int))); #else connect(btnGroup, SIGNAL(buttonClicked(int)), ui-\u003exstackWidget, SLOT(setCurrentIndex(int))); #endif QWebEngineSettings之前是QWebEngineSettings::defaultSettings();现在改成了QWebEngineProfile::defaultProfile()-\u003esettings();通过查看之前的源码得知QWebEngineSettings::defaultSettings();封装的就是QWebEngineProfile::defaultProfile()-\u003esettings();因为Qt6去除了N多过度封装的函数。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) QWebEngineSettings *webSetting = QWebEngineProfile::defaultProfile()-\u003esettings(); #else QWebEngineSettings *webSetting = QWebEngineSettings::defaultSettings(); #endif Qt6将enterEvent的参数QEvent改成了QEnterEvent也不打个招呼。这种改变编译也不会提示的。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) void enterEvent(QEnterEvent *); #else void enterEvent(QEvent *); #endif //后面经过JasonWong大佬的指点，从父类重新实现的virtual修饰的函数，建议都加上override关键字。 //这样的话一旦父类的函数或者参数变了则会提示编译报错，而不是编译通过但是运行不正常会一脸懵逼茫然，从而把锅扣给Qt。 //下面是父类函数 virtual void enterEvent(QEvent *event); //子类建议加上override void enterEvent(QEvent *event) override; Qt6中多个类进行了合并，比如现在QVector就成了QList的别名，意味着这两个类是同一个类没有任何区别，可能Qt内部对两种的优点都集中在一起，并尽量重写算法或者其他处理规避缺点。同理QStringList现在也成了 QList 的别名，是同一个类，没有单独的类。 在Qt4时代默认QWidget构造函数父类是0，到了Qt5变成了Q_NULLPTR，到了Qt6居然用的是默认的c++标准中的nullptr而不是Qt自定义定义的Q_NULLPTR（同样的还有Q_DECL_OVERRIDE换成了用override等），可能是为了彻底抛弃历史包袱拥抱未来。 //下面依次是Qt4/5/6的写法 MainWindow(QWidget *parent = 0); MainWindow(QWidget *parent = Q_NULLPTR); MainWindow(QWidget *parent = nullptr); //查阅Qt源码查看Q_NULLPTR原来是根据编译器定义来选择 #ifdef Q_COMPILER_NULLPTR # define Q_NULLPTR nullptr #else # define Q_NULLPTR NULL #endif //Qt高版本兼容低版本写法比如Qt5/6都支持 *parent = 0 这种写法。 对于委托的进度条样式QStyleOptionProgressBar类的属性，在Qt4的时候不能设置横向还是垂直样式，默认横向样式，要设置orientation需要用另外的QStyleOptionProgressBarV2。从Qt5开始新增了orientation和bottomToTop属性设置。在Qt6的时候彻底移除了orientation属性，只有bottomToTop属性，而且默认进度是垂直的，很操蛋，理论上默认应该是横向的才对，绝大部分进度条场景都是横向的。这个时候怎么办呢，原来现在的处理逻辑改了，默认垂直的，如果要设置横向的直接设置 styleOption.state |= QStyle::State_Horizontal 这种方式设置才行，而Qt6以前默认方向是通过 orientation 值取得，这个State_Horizontal从Qt4就一直有，Qt6以后要主动设置下才是横向的就是。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:5","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"05：41-50 Qt6.2版本开始增加了对多媒体模块的支持，但是在mingw编译器下还是有问题，直到6.2.2才修复这个问题，官网解释是因为mingw编译器版本不支持，到6.2.2采用了新的mingw900_64，这个编译器版本才支持。所以理论上推荐从6.2.2开始使用新的Qt6。 QTextStream中的setCodec方法改成了setEncoding，参数变了，功能更强大。 QTextStream stream(\u0026file); #if (QT_VERSION \u003c QT_VERSION_CHECK(6,0,0)) stream.setCodec(\"gbk\"); #else stream.setEncoding(QStringConverter::System); #endif QModelIndex的查找子节点child函数去掉了，但是查找父节点parent函数保留，查阅代码得知之前的child函数就是封装的model-\u003eindex(row, column, QModelIndex)函数。 //下面两个函数等价 如果要兼容Qt456则用下面这个方法 QModelIndex index = indexParent.child(i, 0); QModelIndex index = model-\u003eindex(i, 0, indexParent); //下面两个函数等价 如果要兼容Qt456则用下面这个方法 QModelIndex indexChild = index.child(i, 0); QModelIndex indexChild = model-\u003eindex(i, 0, index); 之前QPixmap类中的静态函数grabWindow和grabWidget彻底废弃了，改成了用QApplication::primaryScreen()-\u003egrabWindow，其实这个从Qt5开始就建议用这个。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) QPixmap pixmap = QApplication::primaryScreen()-\u003egrabWindow(widget-\u003ewinId()); #else QPixmap pixmap = QPixmap::grabWidget(widget-\u003ewinId()); #endif ","date":"0001-01-01","objectID":"/1/01/qt/:1:6","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"三、Qt安卓经验 ","date":"0001-01-01","objectID":"/1/01/qt/:2:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"01：01-05 pro中引入安卓拓展模块 QT += androidextras 。 pro中指定安卓打包目录 ANDROID_PACKAGE_SOURCE_DIR = $$PWD/android 指定引入安卓特定目录比如程序图标、变量、颜色、java代码文件、jar库文件等。 AndroidManifest.xml 每个程序唯一的一个全局配置文件，里面xml格式的数据，标明支持的安卓版本、图标位置、横屏竖屏、权限等。这个文件是最关键的，如果没有这个文件则Qt会默认生成一个。 android/res/drawable-hdpi drawable-xxxhdpi 等目录下存放的是应用程序图标。 android/res/layout 目录下存放的布局文件。 android/res/values/libs.xml 存储的一些变量值。 android/libs 目录下存放的jar库文件。 android/src 目录下存放的java代码文件，可以是根据包名建立的一层层子目录，也可以直接在src目录下。 其他目录自行搜索安卓目录规范。 后面的说明统一用的android目录举例，其实你可以改成任意目录，比如你的代码目录下是xxoo存放的安卓相关的打包文件，你就写成 ANDROID_PACKAGE_SOURCE_DIR = $$PWD/xxoo 。 java类名必须和文件名完全一致，区分大小写。 java类必须在android/src目录下不然不会打包到apk文件，可以是子目录比如 android/src/com/qt 。 Qt代码中的QAndroidJniObject指定传入的java包名，必须严格和java文件package完全一致，不然程序执行到此处会因为找不到而崩溃。 android/scr/MainActivity.java 顶部 没有 package 则代码中必须是 QAndroidJniObject javaClass(“MainActivity”); android/scr/MainActivity.java 顶部 package com.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com/qandroid/MainActivity”); android/scr/com/example/MainActivity.java 顶部 package com.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com/qandroid/MainActivity”); android/scr/com/example/MainActivity.java 顶部 package com.example.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com/qandroid/example/MainActivity”); 总之这个包名是和代码中的package后面一段吻合，而不是目录路径。为了统一管理方便查找文件，建议包名和目录路径一致。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"02：06-10 Qt只能干Qt内部类的事情，做一些简单的UI交互还是非常方便，如果涉及到底层操作，还是需要熟悉java会如虎添翼，一般的做法就是写好java文件调试好，提供静态方法给Qt调用，这样通过QAndroidJniObject这个万能胶水可以做到Qt程序调用java中的函数并拿到执行结果，也可以接收java中的函数。 pro中通过 OTHER_FILES += android/AndroidManifest.xml OTHER_FILES += android/src/JniMessenger.java 引入文件其实对整个程序的编译打包没有任何影响，就是为了方便在QtCreator中查看和编辑。 在Qt中与安卓的java文件交互都是用万能的QAndroidJniObject，可以执行java类中的普通函数、静态函数，可以传类对象jclass、类名className、方法methodName、参数，也可以拿到执行结果返回值。 (I)V括号中的是参数类型，括号后面的是返回值类型，void返回值对应V，由于String在java中不是数据类型而是类，所以要用Ljava/lang/String;表示，其他类作为参数也是这样处理。 调用实例方法：callMethod、callObjectMethod。 调用静态方法：callStaticMethod、callStaticObjectMethod。 不带Object的函数名用来执行无返回值或者常规返回值int、float等的方法。 如果返回值是String或者类则需要用带Object的函数名来执行，返回QAndroidJniObject类型再转换处理拿到结果，比如toString拿到字符串。 各种参数和返回值示例。 package org.qt; import org.qt.QtAndroidData; public class QtAndroidTest { //需要通过实例来调用 测试发现不论 private public 或者不写都可以调用 我擦 private void printText() { System.out.println(\"printText\"); } public static void printMsg() { System.out.println(\"printMsg\"); } public static void printValue(int value) { System.out.println(\"printValue:\" + value); } public static void setValue(float value1, double value2, char value3) { System.out.println(\"value1:\" + value1 + \" value2:\" + value2 + \" value3:\" + value3); } public static int getValue() { return 65536; } public static int getValue(int value) { return value + 1; } public static void setMsg(String message) { System.out.println(\"setMsg:\" + message); } public static String getMsg() { return \"hello from java\"; } public static void setText(int value1, float value2, boolean value3, String message) { System.out.println(\"value1:\" + value1 + \" value2:\" + value2 + \" value3:\" + value3 + \" message:\" + message); } public static String getText(int value1, float value2, boolean value3, String message) { //同时演示触发静态函数发给Qt QtAndroidData.receiveData(\"message\", \"你好啊 java\"); //下面两种办法都可以拼字符串 return \"value1:\" + value1 + \" value2:\" + value2 + \" value3:\" + value3 + \" message:\" + message; //return \"value1:\" + String.valueOf(value1) + \" value2:\" + String.valueOf(value2) + \" value3:\" + String.valueOf(value3) + \" message:\" + message; } } #include \"androidtest.h\" //java类对应的包名+类名 #define className \"org/qt/QtAndroidTest\" void AndroidTest::test() { jint a = 12; jint b = 4; //可以直接调用java内置类中的方法 jint max = QAndroidJniObject::callStaticMethod\u003cjint\u003e(\"java/lang/Math\", \"max\", \"(II)I\", a, b); //jclass javaMathClass = \"java/lang/Math\"; jdouble value = QAndroidJniObject::callStaticMethod\u003cjdouble\u003e(\"java/lang/Math\", \"random\"); qDebug() \u003c\u003c \"111\" \u003c\u003c max \u003c\u003c value; } void AndroidTest::printText() { QAndroidJniEnvironment env; jclass clazz = env.findClass(className); QAndroidJniObject obj(clazz); obj.callMethod\u003cvoid\u003e(\"printText\"); } void AndroidTest::printMsg() { #if 0 //查看源码得知不传入jclass类的函数中内部会自动根据类名查找jclass QAndroidJniEnvironment env; jclass clazz = env.findClass(className); QAndroidJniObject::callStaticMethod\u003cvoid\u003e(clazz, \"printMsg\"); #else //没有参数和返回值可以忽略第三个参数 QAndroidJniObject::callStaticMethod\u003cvoid\u003e(className, \"printMsg\"); //QAndroidJniObject::callStaticMethod\u003cvoid\u003e(classNameTest, \"printMsg\", \"()V\"); #endif } void AndroidTest::printValue(int value) { QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"printValue\", \"(I)I\", (jint)value); } void AndroidTest::setValue(float value1, double value2, char value3) { QAndroidJniObject::callStaticMethod\u003cvoid\u003e(className, \"setValue\", \"(FDC)V\", (jfloat)value1, (jdouble)value2, (jchar)value3); } int AndroidTest::getValue(int value) { //java类中有两个 getValue 函数 一个需要传参数 //jint result = QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"getValue\"); jint result = QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"getValue\", \"(I)I\", (jint)value); return result; } void AndroidTest::setMsg(const QString \u0026msg) { QAndroidJniObject jmsg = QAndroidJniObject::fromString(msg); QAndroidJniObject::callStaticMethod\u003cvoid\u003e(className, \"setMsg\", \"(Ljava/lang/String;)V\", jmsg.object\u003cjstring\u003e()); } QString AndroidTest::getMsg() { QAndroidJniObject result = QAndroidJniObject::callStaticObjectMe","date":"0001-01-01","objectID":"/1/01/qt/:2:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"03：11-15 安卓中一个界面窗体对应一个Activity，多个界面就有多个Activity，而在Qt安卓程序中，Qt这边只有一个Activity那就是QtActivity（包名全路径 org.qtproject.qt5.android.bindings.QtActivity），这个QtActivity是固定的写好的，整个Qt程序都是在这个QtActivity界面中。你打开AndroidManifest.xml文件可以看到对应节点有个name=org.qtproject.qt5.android.bindings.QtActivity，所以如果要让Qt程序能够更方便通畅的与对应的java类进行交互（需要上下文传递Activity的，比如震动，消息提示等），建议新建一个java类，继承自QtActivity即可，这样相当于默认Qt启动的就是你java类中定义的Activity，可以很好的控制和交互。 由于AndroidManifest.xml文件每个程序都可能不一样，为了做成通用的组件，这就要求可能不能带上AndroidManifest.xml文件，这样的话每个Qt安卓程序都启动默认内置的Activity，如果依赖Activity上下文的执行函数需要传入Qt的Activity才行，这里切记Qt的Activity包名是 Lorg/qtproject/qt5/android/bindings/QtActivity; 之前顺手想当然的写的 Landroid/app/Activity; 发现死活不行，原来是包名错了。 一个Qt安卓程序中可以有多个Java类，包括继承自Activity的类（这样的Activity可以通过QtAndroid::startActivity函数来调用），但是只能有一个通过AndroidManifest.xml文件指定的Activity，不指定会默认一个。如果java类中不需要拿到Qt的Activity进行处理的，可以不需要继承任何Activity，比如全部是运算的静态函数。 在java类中如果上面没有主动引入包名，则下面需要写全路径，引入了则不需要全路径可以直接用（包括枚举值都可以直接写，比如 VIBRATOR_SERVICE 这种枚举值引入了包名后不需要写android.content.Context.VIBRATOR_SERVICE），建议引入包名，比如上面写了 import org.qtproject.qt5.android.bindings.QtActivity; 则下面继承类可以直接写 public class QtAndroidActivity extends QtActivity，如果没有引入则需要写成 public class QtAndroidActivity extends org.qtproject.qt5.android.bindings.QtActivity 。 建议搭配 android studio 工具开发，因为在 android studio 中写代码都有自动语法提示，包名会提示自动引入，可以查看有那些函数方法等，还可以校验代码是否正确，而如果在QtCreator中手写有时候可能会写错，尤其是某个字母写错，当然这种错误是编译通不过的，会提示错误在哪行。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:3","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"04：16-20 用Qt做安卓开发最大难点两个，第一个就是传参数这些奇奇怪怪的字符（Ljava/lang/String;）啥意思，如何对应，这也不是Qt故意为难初学者啥的，因为这套定义机制是安卓系统底层要求的，系统层面定义的一套规范，其实这个在帮助文档中写的很清楚，都有数据类型对照表，用熟悉了几次就很简单了。第二个难点就是用java写对应的类，如果是会安卓开发的人来说那不要太简单，尤其是搜索那么方便一大堆，没有搞过安卓开发的人来说就需要学习下，这个没有捷径，只是希望Qt能够尽可能最大化的封装一些可以直接使用的类，比如后期版本就提供了权限申请的类 QtAndroid::requestPermissionsSync 之类的，用起来就非常的爽，不用自己写个java类调来调去的。 理论上来说按照Qt提供的万能大法类QAndroidJniObject，可以不用写java类也能执行各种处理，拿到安卓库中的属性和执行方法，就是写起来太绕太费劲，在java类中一行代码，这里起码三行，所以终极大法就是熟悉安卓开发，直接封装好java类进行调用。 测试发现GetStringUTFChars方法对应的数据字符串中不能带有temp字样，否则解析有问题，不知什么原因。 数据类型参数和返回值类型必须完全一致，否则执行会提示找不到对应的函数，有返回值一定要写上返回值。 jar文件对包名的命名没有要求，只要放在android/libs目录下即可，安卓底层是通过包名去查找，而不是通过文件名，你甚至可以将原来的包名重新改成也可以正常使用，比如classes.jar改成test.jar也能正常使用。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:4","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"05：21-25 关于权限设置，在早期的安卓版本，所有权限都写在全局配置文件AndroidManifest.xml中，这种叫安装时权限，就是安装的时候告诉安卓系统当前app需要哪些权限。大概从安卓6开始，部分权限需要动态申请，这种叫动态权限，这种申请到的权限也可以动态撤销，就是要求程序再次执行代码去向系统申请权限，比如拍照、存储读写等。也不是所有的权限都改成了动态申请，意味着兼容安卓6以上的系统你既要在AndroidManifest.xml中写上要求的权限，也要通过checkPermission申请你需要的权限。 android studio 新建并生产jar包步骤。 第一步：文件（File）-》新建（new）-》项目（new project）-》空白窗体（empty activity）。 第二步：刚才新建好的项目鼠标右键新建（new）-》模块（new module）-》安卓库（android library）。 说明：如果选择的不是安卓库（android library）而是java库（Java Library），则直接编译出来的就是jar文件，默认包名 com.example.lib.MyClass。推荐选择java库，编译后不用去一堆文件中找jar文件。 第三步：写好库名字，根据项目需要选择好最低sdk版本-》完成。 第四步：在刚才新建好的库项目mylibrary，依次找到子节点src/main/java/com.example.mylibrary上鼠标右键新建-》class类。切记是这个节点不是java节点或者其他节点。 第五步：写好你的类方法函数等。 package com.example.mylibrary; public class Test { public static int add(int a, int b) { return a + b; } } 第六步：选中库项目mylibrary，菜单执行编译（build）-》编译库（make module xxx）。 第七步：此时在mylibrary/build目录下有outputs目录和intermediates目录，其中outputs/aar目录下是生成的Android库项目的二进制归档文件，包含所有资源，class以及res资源文件全部包含。有时候我们仅仅需要jar文件，只包含了class文件与清单文件 ，不包含资源文件，如图片等所有res中的文件。需要到intermediates/aar_main_jar/debug目录下，可以看到classes.jar，将这个拷贝出来使用即可。当然你也可以对刚才的aar文件用解压缩软件解压出来也能看到classes.jar，是同一个文件。 其他：调用jar包非常简单，只需要将jar文件放在你的项目的libs目录下即可，对应的包名和函数一般jar包提供者会提供，没有提供的话，可以在android studio中新建空白项目，切换到project视图，找到libs目录，鼠标右键最下面作为包动态库添加到项目，导入包完成以后会自动在libs目录列出，双击刚刚导入的包然后就自动列出对应的类和函数。 Qt安卓使用jar包步骤。 第一步：将classes.jar放到android/libs目录下，为啥是这个目录？因为这是安卓的规则约定，这个目录就是放库文件，放在这个目录下的文件会自动打包编译到apk文件中。 第二步：调用jar文件之前，前提是你知道jar文件中的函数详细信息，这个一般jar提供者会提供好手册，如果代码没有混肴的话，你可以在android studio中双击打开查阅具体的函数。 第三步：如果jar文件中的函数简单，直接拿到结果不需要绕来绕去，可以直接写Qt类来调用；如果还是很复杂，建议再去新建java类处理完再交给Qt，当然也可以让jar的作者尽可能封装函数的时候就做好，尽量提供最简单的接口返回需要的数据。比如返回图片数据可以做成jar内部存储好图片，然后返回图片路径即可，不然有些数据转换也挺烦。 第四步：编写最终的调用函数。 int AndroidJar::add(int a, int b) { #ifdef Q_OS_ANDROID const char *className = \"com/example/mylibrary/Test\"; jint result = QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"add\", \"(II)I\", (jint)a, (jint)b); return result; #endif } Qt6中对安卓支持部分做了大的改动，目前还不完善，如果是不涉及到与java交互的纯Qt项目，可以正常移植，涉及到的暂时不建议移植到Qt6，等所有类完善了再说。 移除了安卓插件androidextras，将其中部分功能类移到core模块中，不需要额外引入。 类名发生了变化，比如QAndroidJniObject改成了QJniObject、QAndroidJniEnvironment改成了QJniEnvironment，可能是为了统一移动开发平台类，弱化安卓的影响。 对应的安卓jdk要用jdk11而不是jdk1.8，Qt5.15两个都支持，建议就统一用jdk11。 对应封装的java类包名去掉了qt5标识，org.qtproject.qt5.android.bindings.QtActivity改成了org.qtproject.qt.android.bindings.QtActivity、org.qtproject.qt5.android.bindings.QtApplication改成了org.qtproject.qt.android.bindings.QtApplication。 对安卓最低sdk有要求，所以建议在配置AndroidManifest.xml文件的时候不要带上最低版本要求。 对AndroidManifest.xml文件内容有要求，之前Qt5安卓的不能在Qt6安卓下使用，具体内容参见示例下的文件。 对应示例demo在 C:\\Qt\\Examples\\Qt-6.3.0\\corelib\\platform 目录下，之前是 C:\\Qt\\Examples\\Qt-5.15.2\\androidextras ，目前就一个示例，可能因为其他类还没有移植好。 如果想要安卓全屏遮挡住顶部状态栏，可以在main函数中将show改成showFullScreen即可，当然也可以采用java的方式在onCreate函数中加一行 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); ","date":"0001-01-01","objectID":"/1/01/qt/:2:5","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"06：25-30 横竖屏切换的识别，在Qt中会同时反映到resizeEvent事件中，你可以在这个是尺寸变化后读取下当前屏幕是横屏还是竖屏，然后界面上做出调整，比如上下排列改成左右排列。 由于不同Qt版本对应的安卓配置文件 AndroidManifest.xml 内容格式不一样，高版本和低版本模板格式互不兼容，所以建议使用自己的Qt版本创建的 AndroidManifest.xml 文件，创建好以后如果使用的是自己重新定义的java文件的启动窗体则需要将 AndroidManifest.xml 文件中的 android:name=“org.qtproject.qt5.android.bindings.QtActivity” 换掉就行。 如果自己用android studio编译的jar文件放到Qt项目的libs目录下，导致编译通不过，提示 com.android.dx.cf.iface.ParseException: bad class file magic 之类的，那是因为jdk版本不一致导致的，你可能需要在android studio项目中找到模块编jdk版本设置的地方降低版本，比如你用的ndk是r14，则需要选择jdk1.6或者jdk1.7。一般来说高版本兼容低版本，因为ndk版本太低无法兼容jdk1.8。后面发现如果直接新建的是java库（Java Library）则不存在这个问题，如果选择的是安卓库（android library）就可能有这个问题。 安卓项目配置文件是固定的名字 AndroidManifest.xml ，改成其他名字就不认识，不要想当然改成其他名字导致无法正常识别。 AndroidManifest.xml文件中的package=“org.qtproject.example\"是包名，也是整个apk程序的内部唯一标识，如果多个apk这个包名一样，则会覆盖，所以一定要注意不同的程序记得把这个包名改成你自己的。这个包名也决定了java文件中需要使用资源文件时候的引入包名 import org.qtproject.example.R; 如果包名不一样则编译都通不过。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:6","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"四、Qt设计模式 读《c++ Qt设计模式》书籍整理的一点经验。此书和官方的《C++ GUI Qt4编程》一起的。 通常而言，好的做法是在包含了Qt头文件之后再包含非Qt头文件，由于Qt（为编译器和预处理器）定义了许多符号，这使得避免名称冲突变得更容易，也更容易找到文件。 #include \"frminput2019.h\" #include \"ui_frminput2019.h\" #include \"qdatetime.h\" #include \"qdebug.h\" #include \"input2019.h\" #include \"inputnumber.h\" 一种好的编程实践是在代码中使用const实体而不是嵌入数字型常量（有时称他们为“幻数”）。如果以后需要修改他的值时，就可以获得这种灵活性。一般而言，将常量“孤立”出来，可提高程序的可维护性。 //不推荐写法 for (int i = 0; i \u003c 100; ++i) { ... } //推荐下面的写法 const int count = 100; for (int i = 0; i \u003c count; ++i) { ... } 内存管理使程序员获得了强大的能力，但是，“权力越大，责任越大”。 只要有可能，就应当使用列表而不是数组，比如应该使用 QList 代替 int [] ，在c++中数组被看成是“邪恶的”。 在利用Qt编写程序的过程中，因为Qt的父子所有权继承关系，很少会用到智能指针，因为需要调用delete的情况很少。任何时候只要我们需要调用delete，或者是需要将某个指针设定为0时，应该考虑使用一个智能指针。 实际上，我们不能完全确定使用多线程就一定能够真正改善程序的性能，例如，如果增加使用线程的数量，使他与系统可用的内核数量成正比，这样做或许还会降低程序的性能，因为所获得的收益会因线程竞争的剧增而消失殆尽。有时候，单线程中最有效的算法在多线程中却不一定有效。因此，如果真的是想改进程序的性能，理想的做法是，使用不同的实现方法，并与他们的性能进行比较后加以分类，当然测试对比的前提是使用完全相同的硬件和软件配置环境。 在源代码中关于文件路径，使用 / 会更方便一些，因为无论是在何种平台上，Qt都能理解他，不需要对他进行转换。但是，当我们想为用户显示路径时，最好还是根据应用程序所在平台的正确形式来显示他。 当我们有很多项数据需要处理时，比如成千上万或者更多，那么为每个处理都创建一个线程可能导致大量的开销，这样来依次处理数据或许更快些。一种解决办法就是创建少量的辅助线程，并让每个线程只处理一组数据。 ","date":"0001-01-01","objectID":"/1/01/qt/:3:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"五、Qt大佬专区 ","date":"0001-01-01","objectID":"/1/01/qt/:4:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"5.1 酷码大佬 微信：Kuma-NPC 关于Qt事件传递的一个说明： 通常写win32程序，鼠标消息应该是直接发给指定窗口句柄的，指定窗口没有处理就会转化成透传消息，交给父窗口处理。你在一个普通文字label上点击，父窗口也能收到鼠标事件。 Qt应该是所有消息都发给了顶层窗口，所以事件分发逻辑是自己处理，主窗口收到鼠标事件然后Qt自己分发给指定子控件，QEvent会有ignore或者accept表示自己处理了没有，例如鼠标点击事件，事件分发器发现没有被处理，数据重新计算然后分发给父窗口。这样父窗口收到的事件坐标就是基于自己窗口内的。用eventFilter就需要自己计算坐标。 再比如，当使用QDialog，放一个QLineEdit并设置焦点，按Esc时QDialog也会自动关闭，本质上就是因为QLineEdit并不处理Esc的按键事件，透传给了QDialog。 ","date":"0001-01-01","objectID":"/1/01/qt/:4:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"5.2 小豆君 无论你是学Qt，Java，Python或其它，都需要明白一个道理：摒弃掉你的好奇心，千万不要去追求第三方类或工具是怎么实现的，这往往会让你收效甚微，其实，你只需要熟练掌握它的接口，知道类的目的即可，不可犯面向过程的毛病，刨根问底。记住，你的目标是让其它工具为你服务，你要踩在巨人的肩膀上创造世界。 Qt真正的核心：元对象系统、属性系统、对象模型、对象树、信号槽。往死里啃这五大特性，在你的项目中，逐渐的设法加入这些特性，多多练习使用它们，长此以往你会收获意想不到的效果。 一边请教别人，一边多多重构，其实编码这条路虽然有人给你指路，但真正走下去的是你自己，当你真正走完时，你的编码水平一定会有非常大的提升。也许别人1000行的代码，在你这里几十行就搞定了，这也正事Qt的魅力。 在阅读Qt的帮助文档时，要静下心来，不要放过每一句，记住在文档中没有废话，尤其是每段的开头。 ","date":"0001-01-01","objectID":"/1/01/qt/:4:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"六、其他经验 Qt界的中文乱码问题，版本众多导致的如何选择安装包问题，如何打包发布程序的问题，堪称Qt界的三座大山！ 在Qt的学习过程中，学会查看对应类的头文件是一个好习惯，如果在该类的头文件没有找到对应的函数，可以去他的父类中找找，实在不行还有爷爷类，肯定能找到的。通过头文件你会发现很多函数接口其实Qt已经帮我们封装好了，有空还可以阅读下他的实现代码。 Qt安装目录下的Examples目录下的例子，看完学完，月薪20K起步；Qt常用类的头文件的函数看完学完使用一遍并加以融会贯通，月薪30K起步。 Qt在开发阶段不支持中文目录（运行阶段可以，比如打包发布的程序放到中文目录运行是ok的），切记，这是无数人可能犯的错误，在安装Qt集成开发环境以及编译器的时候，务必记得目录必须英文，Qt项目源码也必须是英文目录，否则很可能不正常，建议尽量用默认的安装位置。 如果出现崩溃和段错误，80%都是因为要么越界，要么未初始化，死扣这两点，80%的问题解决了。 Qt一共有几百个版本，关于如何选择Qt版本的问题，我一般保留四个版本，为了兼容Qt4用4.8.7，最后的支持XP的版本5.7.0，最新的长期支持版本比如5.15，最高的新版本比如5.15.2。强烈不建议使用4.7以前和5.0到5.3之间的版本（Qt6.0到Qt6.2之间、不含6.2的版本也不建议，很多模块还没有集成），太多bug和坑，稳定性和兼容性相比于之后的版本相当差，能换就换，不能换睡服领导也要换。如果没有历史包袱建议用5.15.2，目前新推出的6.0版本也强烈不建议使用，官方还在整合当中，好多类和模块暂时没有整合，需要等到6.2.2版本再用。 Qt和msvc编译器常见搭配是Qt5.7+VS2013、Qt5.9+VS2015、Qt5.12+VS2017、Qt5.15+VS2019、Qt6.2+VS2019，按照这些搭配来，基本上常用的模块都会有，比如webengine模块，如果选用的Qt5.12+msvc2015，则很可能官方没有编译这个模块，只是编译了Qt5.12+msvc2017的，如果一定要用msvc2015不想换msvc2017则只能选择Qt5.9+msvc2015套件，或者自行源码重新编译（这个难度超大，初学者绕过）。 Qt默认有对应VS版本，在下载对应VS插件的时候心里要有个数，官方默认提供的是原配的插件，如果想要Qt4.8+VS2015的插件，需要自行编译。一般来说是Qt4.8原配VS2010，Qt5.6原配VS2013，Qt5.9原配VS2015，Qt5.12原配VS2017，Qt5.15原配VS2019，切记：原配最好。 用Qt做开发机器建议用win10，尤其是2021年以后新发布的Qt版本，比如Qt5.12.12、Qt5.15.2、Qt6.2.2等，因为很可能自带的QtCreator用的最新的版本，Qt6开始不再支持win7，或者由于其他的原因，对win7的支持不友好，会出现奇奇怪怪的问题等，所以又是没得选必须用win10。建议各位拥抱新时代的变化，这世上唯一不变的只有变化。 新版本Qt安装包安装的时候需要填写注册信息，如果不想填写，先禁用网卡，在运行安装包，可以直接跳过这一步进行安装。从Qt5.15开始不再提供离线安装包，意味着必须使用在线安装器安装Qt的后续版本，必须填写用户信息，没得选。 终极秘籍：如果遇到问题搜索Qt方面找不到答案，试着将关键字用JAVA C# android打头，你会发现别有一番天地，其他人其他语言其他领域很可能做过！ 如果Qt能从下面几个方面努力，相信会更有发展前景。 QWidget支持CSS3，具有诸多的牛逼的效果，目前支持的是CSS2。 QWidget支持GPU绘制，可选切换CPU或者GPU，提升绘制效率，利用现在强大的硬件。 Qml无缝支持js，可以利用现在各种js轮子，指数级提升qml的项目范围。 支持将程序转成web运行，比如转成cgi之类的程序，目前Qt for WebAssembly很鸡肋，功能极其有限，sql/network/本地访问等都不支持，首次加载速度超慢，大部分Qt类还不支持。 Qt自从4.7以后引入的QML。从此以后，Qt开发就分成了两种流派，一者使用原来的C++ 语言进行开发，另外一种使用QML语言进行开发。这下搞得嘞，经常吵吵不亦乐乎，在Qt界从此就有两大阵营产生激烈的纷争，那就是选用qml还是widget好，大量初学者也会问这个问题，有以下几点总结。 widget属于传统界面开发，和VB/VC/Delphi等拖曳控件开发类似，走CPU绘制，能最大化的兼容现有的硬件和过去的相对偏低性能的硬件。 qml属于新时代的产物，大概从2010年开始，和flutter/Electron等web开发框架及移动开发框架类似，为了适应各种移动端开发及动画流畅性触摸丝滑体验、充分利用和“榨干”现在的GPU性能，把CPU留出来给用户最大化发挥。 硬件性能越好，GPU越是强劲，qml的综合性能越是完爆widget，反之对比也是指数级的。除了极其省成本的嵌入式硬件领域或者国产CPU等，其他领域的硬件性能都是暴增。 widget主要集中在金融、军工、安防、航天、船舶、教育等领域，qml主要集中在汽车仪表、车机、直播等领域。 目前国内widget多于qml，国外可能偏向qml，这个不难看出，流行的移动端开发框架都是国外开发者居多。 可预见的十年内，这两者将长期并存，官方基本不再更新widget而是主推qml，意味着将来对qml的性能优化只增不减，未来趋势是qml。 没有编程经验的新手qml学习成本更低，而从VB/VC等传统软件开发转过来的从业者更适合学习widget。 有的时候不禁要问，既生widget何生qml，学习成本和选择又多了，其实这正是和这个世界的哲学一样：世界是简单的又是复杂的。为了适应各种需求和满足需要。 总之，无论qml还是widget，和找老婆一样，适合自己的就是最好的，自己擅长哪个就用哪个。 如果还不知道擅长哪个，有空就两个都学，学习过程中自己就会有切身感受和对比，能者多劳多多益善。能够顺利的最快的完成老板的任务给老板赚钱才是王道。 网友补充：如果你的软件最终是手指操作的多，就用qml，如果是鼠标操作的多，就选择widget。 写程序过程中发现问题，比如有些问题是极端特殊情况下出现，最好找到问题的根源，有时候肯定多多少少会怀疑是不是Qt本身的问题，怀疑是对的，但是99.9%的问题最终证实下来还是自己的代码写的不够好导致的，如果为了赶时间老板催的急，实在不行再用重启或者复位大法，比如搞个定时器、线程、网络通信啥的去检测程序是否正常，程序中某个模块或者功能是否正常，不正常就复位程序或者重启程序，在嵌入式上还可以更暴力一点就是系统重启和断电重启。 写程序过程中尤其要注意32位的库和64位的库互不兼容，比如32位的程序引用64位的库，64位的程序引用32位的库，都是编译通不过的，而在windows64位系统中是能够运行32位程序的，因为64位的系统提供了32位的运行环境，一般目录在Program Files(x86)，32位的程序在64位的环境中最终引用的还是32位的库。关于如何判断自己的Qt库是多少位，有个误区就是很多人要么看成了QtCreator的关于信息中列出的位数，要么以为自己是64位的系统就认为是64位的Qt，最终要在Qt构建套件中查看具体位数，大概从Qt5.14开始基本上很少提供32位的库，尤其是Qt6.0以后基本上默认就是只有64位的库了，这也是顺应时代潮流，毕竟不久的将来（个人预计2030年以前）基本上32位的系统占比不超过1%，放心大胆的用64位的库吧，抛弃烦人的32位以及XP系统。 关于程序中动态和静态的一点个人理解： 在Qt程序中，分动态库版本的Qt和静态库版本的Qt。 官方默认提供的二进制包就是动态库版本的Qt，如果自行编译则编译的时候对应参数 -shared。 静态库版本的Qt需要自行编译，编译的时候对应参数 -static，（理论上无论商业非商业使用Qt静态库需要收费，因为静态编译后都看不到Qt的相关库文件）。 使用动态库的Qt支持编译生成动态库和静态库（CONFIG += staticlib）的程序。 使用动态库的Qt程序支持动态库的引用（引用的时候 LIB += ，运行的时候需要动态库文件比如 .dll .so 文件支持）。 使用动态库的Qt程序支持静态库的引用（引用的时候 LIB += ，运行的时候无需库文件支持，可以理解为该文件已经和可执行文件合二为一，缺点是可执行文件体积变大）。 通过生成文件的个数和大小可以发现，静态库相当于把运行时需要的文件也一并合并到一个文件了，而动态库是拆分成两个文件，一个用于编译，一个用于运行。 上述动态库的规则也通用于静态库。 此规则应该是通用于其他语言框架。 很多人有个误区包括几年前的我，以为要用Qt编写静态库就必须用静态的Qt库，其实动态库的Qt也可以编写静态的库，只是该库不会生成动态库文件。 如果要将Qt程序编译成静态的可执行文件（单个文件无依赖），前提是所用的Qt库必须静态的。 后期的Qt版本，大致从5.15开始，就不在提供离线版本下载，需要自行通过在线安装器安装，由于默认服务器在国外，很多人反映下载的时候很慢，或者选择晚上的时候下载要快很多，为了解决这个烦人的问题，不至于时间都浪费在没有意义的等待上，有个极其简单的方法可以将速度提升几万倍，甚至冲坏你的硬盘。先下载 Fiddler5（尽量选择中文版本不然小白看不懂），双击打开程序后（可能win10自带的杀毒软件会报毒删除，","date":"0001-01-01","objectID":"/1/01/qt/:5:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"日报 2022-09 开始写日志，勉励自己不断提高技术能力 主要 Linux 文件系统学习，通过实践来梳理文件系统相关知识点 业余 hugo自制模板学习 + hugo 文档翻译 ","date":"0001-01-01","objectID":"/timeline/:0:0","tags":null,"title":"","uri":"/timeline/"},{"categories":null,"content":" 2022-09-06 6.0.0内核发布了，编译安装新版内核后尝试根据《Linux内核探秘——文件系统》中例子实现 aufs，不成功！取新版本内核模块 btfs 代码，改为 aufs OK. 搭建ycm环境，加强vim自动补全方面的功能 ","date":"0001-01-01","objectID":"/%E6%97%A5%E6%8A%A5/:0:0","tags":null,"title":"日报","uri":"/%E6%97%A5%E6%8A%A5/"}]