[{"categories":["linux"],"content":" 列数 含义 1 设备名 2 挂载点 3 文件系统格式(比如:ext, ext2, msdos, iso9660, nfs, swap), 字段来源:/proc/filesytems 4 挂载参数，详细看 man mount，不同文件系统挂载参数可能不同。常见参数:auto: 系统自动挂载;defaults: rw,suid,dev,exec,auto,nousernoauto:开机不自动挂载;nouser: 只有超级用户可以挂载;ro: 只读挂载; rw: 读写挂载; user: 任何用户都可挂载; 注意: 光驱和软驱只有再装有介质时候才能挂载，因此它是noauto 5 转储参数(0: 不备份; 1: 要备份，一般根分区都要备份) 6 自检顺序(0: 不自检; 1和2都是要自检，根分区一定设为1,其它分区要自检只能是2)，数字越小越先检查，数字相同则同时检查 ","date":"2022-08-01","objectID":"/2022/08/0011-linux-fstab%E9%85%8D%E7%BD%AE%E6%AF%8F%E5%88%97%E5%90%AB%E4%B9%89/:0:0","tags":["linux","fstab"],"title":"Linux Fstab配置每列含义","uri":"/2022/08/0011-linux-fstab%E9%85%8D%E7%BD%AE%E6%AF%8F%E5%88%97%E5%90%AB%E4%B9%89/"},{"categories":["linux"],"content":"从 windows 换成 linux 之后发现 vmware 在linux 下运行很卡，于是考虑使用 qemu，图形界面开源安装 virt-manager 方便使用，而 vmware 的虚拟磁盘用的是 vmdk， 需要转为qemu支持的 qcow2。 使用 qemu-img 完成 vmdk 转 qcow2 qemu-img convert -f vmdk \u003c此处写vmware虚拟磁盘 xxx.vmdk 文件路径\u003e -O qcow2 \u003c此处写转换后要保存的 qemu 虚拟文件路径\u003e 亲测原先vmware装的linux虚拟机可以很容易转成功，但是vmware虚拟机是windows10转换后没办法引导，以后解决引导问题再补充。 ","date":"2022-07-24","objectID":"/2022/07/0009-vmware%E8%BD%ACqemu/:0:0","tags":["linux","qemu","vmware"],"title":"Vmware转qemu","uri":"/2022/07/0009-vmware%E8%BD%ACqemu/"},{"categories":["linux"],"content":" 确定linux是否有nbd模块 modinfo nbd 插入nbd 模块 sudo modprobe nbd 使用qemu-nbd 工具关联 qcow2 文件和 nbd 设备节点 sudo qemu-nbd -c /dev/nbd0 \u003cqcow2的路径\u003e 通过/dev/nbd0px按需挂载 qcow2 设备 最后 卸载设备 sudo qemu-nbd -d /dev/nbd0 ","date":"2022-07-24","objectID":"/2022/07/0010-linux%E6%8C%82%E8%BD%BDqcow2/:0:0","tags":["linux","qcow2"],"title":"0010 Linux挂载qcow2","uri":"/2022/07/0010-linux%E6%8C%82%E8%BD%BDqcow2/"},{"categories":["apache"],"content":"tika 是什么 Apache Tika 用于文件类型检测和从各种格式的文件内容提取的库。在内部，Tika使用现有的各种文件解析器和文档类型的检测技术来检测和提取数据。使用Tika，人们可以开发出通用型检测器和内容提取到的不同类型的文件，如电子表格，文本文件，图像，PDF文件甚至多媒体输入格式，在一定程度上提取结构化文本以及元数据。 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:1:0","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika 特点 支持上千种不同的文件类型 提供了多种实用工具，如tika-app, tika-server等 除了Java，还提供了其他编程语言的调用，如Julia，Python 扩展性很好，支持自定义文件类型和解析器 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:2:0","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika 组成 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:0","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-core tika-core是tika的核心，提供了文件类型检测，语言检测，以及解析器框架。tika-core并不包含具体的解析器，而是提供了一个api，实际的解析器实现放在tika-parsers中。 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:1","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-parsers 解析文件 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:2","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-app tika-app包含了tika核心类库和它的相关依赖，提供了命令行工具和图形用户界面，可以在脚本中使用，并支持管道。 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:3","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-server 一个restful服务，方便和现有应用系统集成: $ curl -X PUT --data-binary @GeoSPARQL.pdf http://localhost:9998/tika --header \"Content-type: application/pdf\" $ curl -T price.xls http://localhost:9998/tika --header \"Accept: text/html\" ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:4","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-bundle 一个OSGi bundle，方便和基于OSGi的应用系统集成 OSGi: 开放服务网关协议，支持模块的动态加载，热拔插，可以在不停机的情况下，让应用程序加载新的模块，并提供新的服务 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:5","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika-eval 一个命令行工具，可以批量解析文件，然后把结果保存到数据库，支持多种类型的数据库，如h2，mysql…，默认数据库为h2，使用其他类型的数据库需要在启动时将相关的依赖放到classpath下 ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:3:6","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["apache"],"content":"tika 设计与实现 tika的核心功能是文件内容分析，这里分析主要有两个含义，一是提取文件的元数据(Metadata)，包括文件类型，版本，作者，编辑工具，压缩算法等；二是解析文件得到文本内容(Text)，这里的文本是指在相应的阅览软件中打开文件时看到的内容。 为了实现上述目标，tika设计了一个扩展性极强的框架，主要包括文件类型检测和内容解析两个部分。首先判断文件类型(Detector)，再根据文件类型选用适当的解析器(Parser)，解析结果保存在Metadata和ContentHandler中，我们可以通过自定义ContentHandler来得到想要的信息。 tika ","date":"2022-07-22","objectID":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/:4:0","tags":["apache","tika"],"title":"解析各种文件格式 Tika","uri":"/2022/07/0001-%E8%A7%A3%E6%9E%90%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-tika/"},{"categories":["c\u0026c++"],"content":"ProtoBuf 简介 ProtoBuf(Protocol Buffers) 是 Google 用于实现序列化与反序列化的开源项目，支持多语言、跨平台、可扩展的用于结构化数据的解决方案。 目前常见的序列化、反序列化方法包括但不限于以下几种： JSON XML ProtoBuf Boost Serialization ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:1:0","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"ProtoBuf 数据结构 proto文件消息类型 C++ 类型 说明 double double 双精度浮点型 float float 单精度浮点型 int32 int32 使用可变长编码方式，负数时不够高效，应该使用sint32 int64 int64 同上 uint32 uint32 使用可变长编码方式 uint64 uint64 同上 sint32 int32 使用可变长编码方式，有符号的整型值，负数编码时比通常的int32高效 sint64 sint64 同上 fixed32 uint32 总是4个字节，如果数值总是比2^28大的话，这个类型会比uint32高效 fixed64 uint64 总是8个字节，如果数值总是比2^56大的话，这个类型会比uint64高效 sfixed32 int32 总是4个字节 sfixed64 int64 总是8个字节 bool bool string string 一个字符串必须是utf-8编码或者7-bit的ascii编码的文本 bytes string 可能包含任意顺序的字节数据 ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:2:0","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":".proto 文件 关键字 说明 syntax 指定proto语言版本 option 修改配置选项 service 声明一个服务 rpc 声明一个方法 resturns 方法的返回值 message 定义一个消息类型 repeated 数组 stream 用流来交互 ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:3:0","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"一些例子 指定一个版本 syntax = \"proto3\" 定义一个服务和方法 service TestService { rpc testMethod(Request) returns (Result) {} } message Request { } message Result { } ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:3:1","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"ProtoBuf使用一般步骤 ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:4:0","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"1. 定义proto文件 proto文件中就是定义了我们需要存储或传输的数据结构/传输协议 proto文件的定义主要分为两部分： 为每一个需要序列化的数据结构添加一个消息(message)。 为消息(message)中的每一个字段(field)指定一个名字、类型和修饰符以及唯一标识(tag)。 其中每一个消息对应到C++就是一个类，嵌套消息对应的就是嵌套类。 另外，一个proto文件中可以定义多个消息，就像一个头文件中可以定义多个类一样。 // [START declaration] syntax = \"proto3\"; package tutorial; import \"google/protobuf/timestamp.proto\"; // [END declaration] // [START java_declaration] option java_multiple_files = true; option java_package = \"com.example.tutorial.protos\"; option java_outer_classname = \"AddressBookProtos\"; // [END java_declaration] // [START csharp_declaration] option csharp_namespace = \"Google.Protobuf.Examples.AddressBook\"; // [END csharp_declaration] // [START go_declaration] option go_package = \"github.com/protocolbuffers/protobuf/examples/go/tutorialpb\"; // [END go_declaration] // [START messages] message Person { string name = 1; int32 id = 2; // Unique ID number for this person. string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { string number = 1; PhoneType type = 2; } repeated PhoneNumber phones = 4; google.protobuf.Timestamp last_updated = 5; } // Our address book file is just one of these. message AddressBook { repeated Person people = 1; } // [END messages] package 声明：.proto 文件以一个 package 声明开始，这个声明是为了防止不同项目之间的命名冲突，对应到 c++ 中，这个 .proto 文件生成的类将被放置在一个与package名相同的命名空间中。 字段类型：定义 message 时候，一个 message 就是某些类型字段的集合。具体支持的字段类型见：字段类型 修饰符：每个字段都必须用以下之一的修饰符来修饰： 修饰符 含义 required 必须提供字段值，否则对应的消息会被认为是\"未初始化“的。注意：解析\"未初始化\"的消息会导致失败。 optional 字段值指定与否都可以，它是每个字段默认值。调用时候没有指定message的字段值，会自动使用默认值：string默认值是空字符串；int默认值是0 repeated 字段会重复N次(N可以是0)，重复值的顺序会被保存在ProtoBuf中注意：可以把重复字段视为数组。 唯一编号：每个消息中的每个字段都有唯一的编号，字段后边的=1、=2等。这些字段编号用于标识消息二进制中的字段，并且在使用消息类型后不应该再更改。注意：1 ~ 15 中的字段需要一个字节进行编码，包括字段编号和字段类型。16 ~ 2047 中的字段编号需要两个字节。所以保留 1 - 15 作为非常频繁出现的消息元素，也要注意为将来可能频繁出现的消息元素预留位置。 可以指定的最小字段编号为：1，最大字段编号：$2^{29}-1$ 或 536 870 911。 也不能使用数字19 000 到 19 999，他们是 protobuf 保留的。 ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:4:1","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"2. 编译proto文件 protoc --cpp_out=/data/code/demo/protobuf/c++ -I/data/code/demo/protobuf/c++ xxx.proto 其中： --cpp_out=\u003cdir\u003e 表示生成代码输出到的指定文件夹 -I\u003cdir\u003e 表示在哪个文件夹下寻找 xxx.proto 文件 xxx.proto 就是我们写好的 .proto 文件 完整例子 注意：如果编译上述例子出错，则可以重新编译安装 protobuf，几乎没有依赖，克隆源码就可编译安装。 亲测我的 archlinux 使用包管理器安装的 protobuf 是不能用的。 编译 protobuf 源码具体步骤如下： 克隆源码：https://github.com/protocolbuffers/protobuf.git 进入源码目录执行安装：./autogen.sh \u0026\u0026 ./configure --prefix=/usr \u0026\u0026 make -j8 \u0026\u0026 sudo make install ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:4:2","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["c\u0026c++"],"content":"3. 使用生成的代码来读写消息 // [1] 验证版本 GOOGLE_PROTOBUF_VERIFY_VERSION; // [2] 根据 protobuf 中 message 生成的对象 test1::Response p1; p1.set_data(\"data\"); p1.set_status(1); cout \u003c\u003c \"=================================\\n\"; cout \u003c\u003c \"p1.data: \" \u003c\u003c p1.data() \u003c\u003c \"\\n\" \u003c\u003c \"p1.status: \" \u003c\u003c p1.status() \u003c\u003c \"\\n\"; // [3] 执行序列化 // 注意：序列化之后可以用 p1.DebugString(); 来查看序列化字符串 cout \u003c\u003c \"serialize string:\" \u003c\u003c p1.SerializeAsString() \u003c\u003c \"\\n\"; cout \u003c\u003c \"=================================\\n\"; // [4] 反序列化 // 反序列化之前也可以使用 DebugString() 来查看要反需列化的字符串是否正确 // 反序列化 bool ParseFromString(const string\u0026 data); // [5] 释放 protobuf 相关内存 google::protobuf::ShutdownProtobufLibrary(); 序列化与反序列化过程中尽量保证使用 char* 或 std::string 来接收数据。 亲测QString参与会导致反序列化失败。 完整例子 ","date":"2022-07-21","objectID":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/:4:3","tags":["c","c++","protobuf","序列化","反序列化"],"title":"高效的序列化、反序列化工具——ProtoBuf","uri":"/2022/07/0006-%E9%AB%98%E6%95%88%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7protocol-buffers/"},{"categories":["git"],"content":"问题描述 电脑使用了clash代理工具，配好环境之后浏览器可以访问谷歌和github，但是终端无法推送代码到github ","date":"2022-07-19","objectID":"/2022/07/0003-linux%E7%BB%88%E7%AB%AFgit%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/:1:0","tags":["git"],"title":"Linux终端git无法联网","uri":"/2022/07/0003-linux%E7%BB%88%E7%AB%AFgit%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/"},{"categories":["git"],"content":"解决方法 打开终端执行如下命令： git config --global http.proxy 'sockets5://127.0.0.1:7891' git config --global https.proxy 'sockets5://127.0.0.1:7891' # 或者 git config --global http.proxy 'http://127.0.0.1:7890' git config --global https.proxy 'https://127.0.0.1:7890' 具体看使用啥代理方式 ","date":"2022-07-19","objectID":"/2022/07/0003-linux%E7%BB%88%E7%AB%AFgit%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/:2:0","tags":["git"],"title":"Linux终端git无法联网","uri":"/2022/07/0003-linux%E7%BB%88%E7%AB%AFgit%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/"},{"categories":["c\u0026c++"],"content":"原理 Linux 允许让我们自己的动态库加载在其它动态库之前，甚至是系统库(libc.so.6)，如此我们可以通过自己实现动态库并提前加载来拦截系统调用。 具体例子参看: https://github.com/dingjingmaster/demo/tree/master/syscall/dlopen 编译之后根据Makefile提示设置环境变量，然后在终端内执行任何包含读写操作的命令，都会有相关打印输出。 ","date":"2022-07-12","objectID":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/:1:0","tags":["linux","c"],"title":"用户空间拦截系统调用","uri":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"},{"categories":["c\u0026c++"],"content":"实现过程 通过 dlopen() 打开动态库 使用 dlsym() 确对应系统调用的地址 自定义系统调用(自定义函数名并保证函数类型与系统调用一致)，可以在自定义函数中实现系统调用拦截操作 将以上代码打包成动态库并编译为 xxx.so 当前终端配置环境变量: export LD_PRELOAD=/path/to/xxx.so 在当前终端执行包含要拦截系统调用的命令 ","date":"2022-07-12","objectID":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/:2:0","tags":["linux","c"],"title":"用户空间拦截系统调用","uri":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"},{"categories":["c\u0026c++"],"content":"以拦截 open() read() 系统调用为例 动态库源码 #include \u003cstdio.h\u003e #include \u003cdlfcn.h\u003e #include \u003cstdarg.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003cstdbool.h\u003e void* libc_handle = NULL; int (*open_ptr) (const char*, int) = NULL; int (*close_ptr) (int) = NULL; ssize_t (*read_ptr) (int, void*, size_t) = NULL; static bool inited = false; _Noreturn void die (const char* fmt, ...) { va_list va; va_start (va, fmt); vprintf (fmt, va); _exit (0); } static void find_original_function () { if (inited) return; printf (\"libc path: %s\\n\", LIBC); libc_handle = dlopen (LIBC, RTLD_LAZY); if (libc_handle == NULL) { die (\"cannot open libc.so\\n\"); } open_ptr = dlsym (libc_handle, \"open\"); if (open_ptr == NULL) { die (\"cannot find open()\\n\"); } close_ptr = dlsym (libc_handle, \"close\"); if (close_ptr == NULL) { die (\"cannot find close()\\n\"); } read_ptr = dlsym (libc_handle, \"read\"); if (read_ptr == NULL) { die (\"cannot find read()\\n\"); } inited = true; } int open (const char* pathName, int flag) { find_original_function(); printf (\"start open()\\n\"); int fd = (*open_ptr) (pathName, flag); printf (\"end open()\\n\"); return fd; } int close (int fd) { find_original_function(); printf (\"start close()\\n\"); int ret = (*close_ptr) (fd); printf (\"end close()\\n\"); return ret; } ssize_t read (int fd, void* buf, size_t count) { find_original_function(); printf (\"start read()\\n\"); ssize_t ret = (*read_ptr) (fd, buf, count); printf (\"end read()\\n\"); return ret; } 编译成动态库 gcc -fpic -shared -Wall -o dlopen-shared-lib.so dlopen-shared-lib.c -ldl -DLIBC=\\\"`find /usr/lib -name \"libc.so.6\"`\\\" 通过uptime命令验证 LD_PRELOAD=$PWD/dlopen-shared-lib.so \u0026\u0026 export LD_PRELOAD \u0026\u0026 uptime uptime 命令会读取 /proc/uptime 文件 ","date":"2022-07-12","objectID":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/:3:0","tags":["linux","c"],"title":"用户空间拦截系统调用","uri":"/2022/07/0005-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"},{"categories":["linux"],"content":"BPF与eBPF是什么 BPF(Berkeley Packet Filter)，伯克利数据包过滤器，这项技术诞生于 1992 年，其作用是提升网络包过滤工具的性能，2014年正式加入Linux内核主线。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:0","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 作用 BPF 提供了一种在各种内核事件和应用程序事件发生时候运行一段小程序的机制。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:1","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 组成 BPF 由指令集、存储对象、辅助函数等几部分组成 BPF 采用虚拟指令规范，因此也将它视为一种虚拟机实现，BPF 指令由 linux 内核中的运行时模块执行。 BPF 运行时的两种执行机制：1. 解释器；2. 将BPF指令动态转换为本地化指令的即时(JIT)编译器 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:2","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 执行 在实际执行之前，BPF 指令必须先通过验证器的安全性检查，以确保 BFP 程序自身不会崩溃或者损坏内核 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:3","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 应用领域 网络 客观测性 安全 扩展后的 BPF 就是 eBPF ，官方的 BPF 不带 e，实际上指的就是 eBPF ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:4","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"名词: 跟踪、嗅探、采样、剖析、可观测性 跟踪(嗅探) 跟踪是基于事件的记录，这也是 BPF 工具所使用的监测方式。比如：strace 可以记录和打印系统调用事件的信息；top 使用固定的计数器统计监测事件的频次。 跟踪工具的一个显著标志是，它具备记录原始事件和事件元数据的能力，既可以是直接输出原始事件，也可以是统计原始事件的频次。 嗅探(跟踪) 嗅探实际上和跟踪指的是一回事，嗅探更多的适用于solaris系统上的跟踪工具 采样 采样工具通过获取全部管测量的子集来描绘目标的大致图像，这也被称为 生成性能剖析样本 或 profiling。比如：profile命令，它基于计时器来对运行中的代码定时采样(每隔10s采样一次)。 采样工具的优点是：其性能开销比跟踪工具小 缺点是：它只提供大致画像，会遗漏事件 可观测性 可观测性指通过全面观测来理解一个系统，可以实现这一目标的工具就可以归纳为可观测性工具。 可观测性工具包括：跟踪工具、采样工具、基于固定计数器的工具。 可观测性工具不包括基准测量工具(benchmark)，基准测量工具在系统上模拟业务负载，会更改系统的状态。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:5","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"编写 BPF 程序(BCC、bpftrace) 直接编写 BPF 程序是繁琐的，在跟踪用途方面，可以使用支持高级语言的 BPF 前端编写 BPF 程序——BCC和bpftrace BPF编译集合(BPF Compiler Collection, 即BCC) BCC 是最早用于开发 BPF 跟踪程序的高级框架。它提供了一个编写内核 BPF 程序的 C 语言环境，同时还提供了其它高级语言(如：Python、Lua和C++)环境来实现用户端接口。它也是 libbcc 和 libbpf 库的前身，这两个库提供了使用 BPF 程序对事件进行观测的库函数。 BCC 源代码库中提供了 70 多个 BPF 工具，可以用来支持性能分析和排障工作。 BCC 适合开发复杂的脚本和作为后台进程使用，它还可以调用其它库的支持。比如：使用python开发的BCC程序，还使用python的argparse库来提供复杂、惊喜的工具命令行参数支持。 bpftrace bpftrace 是新近出现的前端，也是基于 libbcc 和 libbpf 库进行构建的。 bpftrace 适合编写功能强大的单行程序、短小的脚本。 bpftrace 和 BCC 可以互补使用 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:6","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"IO Visor BCC 和 bpftrace 不在内核代码仓库中，而是属于 IO Visor 的 Linux 基金会项目 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:7","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 跟踪的能见度 BPF 跟踪可以在整个软件栈范围内提供能见度，允许我们随时根据需要开发新的工具和监测功能。 在生产环境中可以立即部署 BPF 跟踪程序，不需要重启系统，也不需要以特殊方式重启应用软件。 下图展示了一个通用的系统软件栈，用相应的 BPF 性能工具对各个部分进行了标记。工具基本来自 BCC 和 bpftrace。 BPF 工具对应的通用系统软件栈 下图列出传统工具与 BPF 工具对组建监测的支持情况 组件 传统分析工具 BPF跟踪 基于语言运行时开发的应用程序:Java、Nodee.js、Ruby、PHP 运行时调试器 是，在运行时支持的情况下 基于编译型代码开发的应用程序:C、C++、Golang 系统调试器 是 系统库:/lib/* ltrace(1) 是 系统调用接口 strace(1)、perf(1) 是 内核:调度器、文件系统、TCP、IP等 用于采样的perf(1) 是，更加详尽 硬件:CPU核心、设备 perf、sar、/proc计数器 是，直接或间接(BPF无法直接对设备上的固件进行观测，可以通过对内核驱动事件或者性能监测计数器PMC进行跟踪，间接推断相关行为) 传统工具提供的信息可以作为性能分析的起点，后续则可以通过 BPF 跟踪工具做更加深入的调查 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:8","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"动态插桩: kprobes 和 uprobes 动态插桩技术(也叫动态跟踪技术)——在生产环境中对正在运行的软件插入观测点的能力，具体插桩的函数可以是软件栈中运行函数的任意一个(在内核函数或应用函数的开始或结束位置进行插桩)。 动态插桩技术是2012年在Linux上开始支持，具体使用例子如下: 探针 描述 kprobe:vfs_read 在内核函数vfs_read()的开始位置进行插桩 kretprobe:vfs_read 在内核函数vfs_read()的返回位置处进行插桩 uprobe:/bin/bash:readline 在/bin/bash程序中的readline()函数开始位置进行插桩 uretprobe:/bin/bash:readline 在/bin/bash程序中的readline()函数返回位置进行插桩 未启用时候动态插桩开销为0。 动态插桩有一点不好：随着软件版本的变更，被插桩的函数有可能被重新命名，或者移除，导致 BPF 无法正常工作，或者可能打印出一写错误信息；另一个问题是编译器启动优化，把某些函数做内联处理，使得这些函数无法做动态插桩。以上问题，使用静态插桩技术解决。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:9","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"静态插桩 tracepoint和USDT 静态插桩将稳定的事件名字编码到软件代码中，由开发者维护。BPF 跟踪工具支持内核的静态跟踪点插桩技术，也支持用户态的静态定义跟踪插桩技术USDT(user level statically defined tracing)。 静态插桩问题：增加开发者维护成本，因此软件中的静态插桩要数量有限。 除非需要自己开发 BPF 工具，否则上边提到的静态插桩、动态插桩细节无须关注。如果确实要开发 BPF 工具，一个推荐的策略是：首先尝试静态跟踪技术(跟踪点或USDT)，如果不够的话再使用动态跟踪技术(kprobes或uprobes)。 下边是 bpftrace 用到的跟踪点和USDT例子 探针 描述 tracepoint:syscalls:sys_enter_open 对open(2)系统调用进行插桩 usdt:/usr/sbin/mysqld:mysql:query_start 对/usr/sbin/mysqld程序中的query_start探针进行插桩 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:10","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"例子 bpftrace跟踪open() bpftrace -e 'tracepoint:syscalls:sys_enter_open {printf(\"%s %s\\n\", comm, str(args-\u003efilename));}' 输出结果打印了进程的名字和传递给 open(2) 系统调用的文件名: bpftrace 是全系统层面的跟踪，因此任何调用了 open(2) 的应用都能覆盖。 BPF 程序被定义在单引号所包围的代码内，当敲击Enter键运行bpftrace命令时候，它会立即被编译并且运行。 当然 open() 函数还有其它变体，比如：openat()，可以使用如下命令列出所有与open系统调用相关的跟踪点 # -l 和通配符 一起使用，列出所有与 open 系统调用相关的跟踪点 bpftrace -l 'tracepoint:syscalls:sys_enter_open*' # open() 及其变体的使用频率 bpftrace -e 'tracepoint:syscalls:sys_enter_open* {@[probe] = count();}' ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:1:11","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 技术原理 BPF 技术原理 BPF 程序使用 BPF字节码(BPF虚拟机的指令集)定义过滤表达式，然后传递给内核，由解释器执行，无须数据包复制。 BPF 提供了安全保障，用户自定义的过滤器在执行前必须先通过安全性验证，且必须在内核空间执行。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:2:0","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"早期BPF和扩展版BPF 1997年进入Linux2.1.75：最初BPF被称为“经典BPF”，它是一个功能有限的虚拟机。 2011年7月Linux3.0 中增加了BPF即时编译器(just-in-time, JIT)，相比解释器来说，它执行效率更高。 2012年 Will Drewry 为安全计算系统调用添加了 BPF 过滤器，这是第一次运用在网络领域之外，也先是出BPF可以作为一个通用执行引擎的潜力。 2013年12月提议在此之前创造的eBPF合入Linux内核 2014年eBPF补丁开始合入Linux内核 2014年6月，JIT组件并入Linux内核3.15中 2014年12月，用于控制BPF的bpf(2)系统调用进入Linux3.18版本中。之后在Linux4.x内核增加了对 kprobes、uprobes、tracepoints 和 perf_events 的BPF支持。 目前所说的BPF都指eBPF ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:2:1","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"BPF 运行时 下图展示 BPF 指令如何通过BPF验证器验证，再由BPF虚拟机执行过程： BPF 运行时各模块架构 BPF 虚拟机实现包括:解释器和JIT编译器，JIT编译器负责生成处理器可直接执行的机器指令。验证器会拒绝那些不安全的操作，这包括针对无界循环的检查：BPF程序必须在有限的时间内执行完成。 BPF 可以利用辅助函数获取内核状态，利用BPF映射表进行存储。BPF程序在特定事件发生时候执行，包括 kprobes、uprobes和跟踪点等事件。 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:2:2","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"使用 BPF 或 内核模块实现性能分析工具的思路 …. ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:2:3","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"编写BPF程序 很多前端工具可以用来支持 BPF 编程，在跟踪观测方面，主要的前端按照开发语言从低级到高级排列如下： LLVM BCC bpftrace LLVM 编译器支持将 BPF 作为编译目标体系结构。BPF 程序可以使用 LLVM 支持的更高级语言编写，比如 C 语言(借助Clang)或LLVM中间表示形式，然后再编译成 BPF。 LLVM 自带优化器，可以对它生成的 BPF 指令进行效率和体积上的优化。 …. 留坑后续再填… ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:2:4","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["linux"],"content":"参考 BPF 相关源码所在仓库: https://github.com/iovisor 以 Arch Linux 为例，使用 BCC 则执行pacman -S bcc bcc-tools python-bcc，同时要注意一些内核编译配置。安装成功之后进入本地系统 /usr/share/bcc查看相关工具 ","date":"2022-06-29","objectID":"/2022/06/0001-bpf%E4%B8%8Eebpf/:3:0","tags":["linux","BPF","eBPF"],"title":"BPF与eBPF","uri":"/2022/06/0001-bpf%E4%B8%8Eebpf/"},{"categories":["IDE"],"content":"问题 已经安装好go并配置好GOROOT和GOPATH之后，在Goland无法自动识别出GOROOT。在Goland设置选择go安装目录下，提示\"Go SDK 非法的家目录\" ","date":"2022-06-21","objectID":"/2022/06/0003-golang%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABgoroot/:1:0","tags":["go","goland","GOROOT"],"title":"Golang无法识别GOROOT","uri":"/2022/06/0003-golang%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABgoroot/"},{"categories":["IDE"],"content":"解决 修改${GROOT}/src/runtime/internal/sys/zversion.go，添加go SDK 对应的版本号信息: const TheVersion = 'go1.18.3' ","date":"2022-06-21","objectID":"/2022/06/0003-golang%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABgoroot/:2:0","tags":["go","goland","GOROOT"],"title":"Golang无法识别GOROOT","uri":"/2022/06/0003-golang%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABgoroot/"},{"categories":["linux"],"content":"pkcheck 检查进程是否被授权 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:0","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"说明 pkcheck用于检查进程(由–process(见下文)或–system-bus-name指定)是否被授权执行操作。可以多次使用–detail选项传递有关操作的细节。如果–allow-user-interaction被传递，pkcheck在等待身份验证时阻塞。 调用pkcheck –list-temp将列出当前会话的所有临时授权，而pkcheck –revoke-temp将撤销当前会话的所有临时授权。 这个命令是对polkit D-Bus接口的简单包装;详细信息请参见D-Bus接口文档。 Usage: pkcheck [OPTION...] Help Options: -h, --help Show help options Application Options: -a, --action-id=ACTION Check authorization to perform ACTION -u, --allow-user-interaction Interact with the user if necessary -d, --details=KEY VALUE Add (KEY, VALUE) to information about the action --enable-internal-agent Use an internal authentication agent if necessary --list-temp List temporary authorizations for current session -p, --process=PID[,START_TIME,UID] Check authorization of specified process --revoke-temp Revoke all temporary authorizations for current session -s, --system-bus-name=BUS_NAME Check authorization of owner of BUS_NAME --version Show version Report bugs to: http://lists.freedesktop.org/mailman/listinfo/polkit-devel polkit home page: \u003chttp://www.freedesktop.org/wiki/Software/polkit\u003e ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:1","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"返回值 如果指定的进程被授权，pkcheck将以0的返回值退出。如果授权结果包含任何详细信息，它们将使用环境样式的报告作为键/值对打印在标准输出上，例如，首先键后跟一个等号，然后值后跟一个换行符。 KEY1=VALUE1 KEY2=VALUE2 KEY3=VALUE3 ... 不包含在[a-zA-Z0-9_]中的八进制代码使用以\\为前缀的八进制代码进行转义。例如,utf-8字符串flø你好将 将显示为: \\303\\270l\\54\\344\\275\\240\\345\\245\\275。 如果指定的进程未被授权，pkcheck将退出，返回值为1，并在标准错误时打印诊断消息。详细信息打印在标准输出上。 如果指定的进程没有获得授权，因为没有合适的身份验证代理可用，或者没有通过 –allow-user-interaction，那么pkcheck将退出，返回值为2，并在标准错误时打印一条诊断消息。详细信息打印在标准输出上。 如果指定的进程没有被授权，因为身份验证对话框/请求被用户驳回，pkcheck退出，返回值为3，并在标准错误上打印诊断消息。详细信息打印在标准输出上。 如果在检查授权时发生错误，pkcheck退出，返回值为127，并在标准错误上打印诊断消息。 如果传递的一个或多个选项是不规范的，则pkcheck退出，返回值为126。如果stdin是一个tty，那么也会显示此手册页。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:2","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"注意 不要针对 –process 选项仅仅使用pid或pid,start-time 语法。新代码应该总是使用pid,pid-start-time,uid。start-time的值可以通过参考proc(5)文件系统来确定，具体取决于操作系统。如果传入的参数少于3个，pkcheck将尝试在内部查找它们，但注意这可能是不正常的。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:3","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"pkaction 获取已注册操作的详细信息 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:0","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"说明 pkaction用于获取关于已注册polkit操作的信息。如果调用时没有使用–action-id，则显示所有操作。如果调用时不带–verbose选项，则只显示操作的名称。否则将显示有关操作的详细信息。 Usage: pkaction [OPTION?] [--action-id ACTION] Help Options: -h, --help Show help options Application Options: -a, --action-id=ACTION Only output information about ACTION -v, --verbose Output detailed action information --version Show version Report bugs to: http://lists.freedesktop.org/mailman/listinfo/polkit-devel polkit home page: \u003chttp://www.freedesktop.org/wiki/Software/polkit\u003e ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:1","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"返回值 如果成功，pkaction返回0。否则将返回非零值，并在标准错误时打印诊断消息。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:2","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"pkexec 以其他用户身份执行命令 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:0","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"说明 pkexec允许授权用户作为另一个用户执行PROGRAM。如果没有指定PROGRAM，将运行默认的shell。如果没有指定用户名，那么程序将以管理超级用户root执行。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:1","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"返回值 成功完成后，返回值就是PROGRAM的返回值。如果调用进程未被授权或无法通过身份验证获得授权或发生错误，则pkexec退出，返回值为127。如果由于用户取消了身份验证对话框而无法获得授权，则pkexec退出，返回值为126。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:2","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"认证代理 与任何其他polkit应用程序一样，pkexec将使用为调用进程或会话注册的身份验证代理。但是，如果没有可用的身份验证代理，那么pkexec将注册它自己的文本身份验证代理。可以通过传递–disable-internal-agent选项来关闭此行为。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:3","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"安全方面 作为另一个用户执行程序是一种特权操作。默认情况下，要检查的操作(请参阅“action AND AUTHORIZATIONS”一节)需要管理员身份验证。此外，呈现给用户的身份验证对话框将显示要执行的程序的完整路径，以便用户知道将发生什么。 PROGRAM运行它的环境将被设置为最小已知和安全的环境，以避免通过LD_LIBRARY_PATH或类似机制注入代码。另外，PKEXEC_UID环境变量被设置为调用pkexec的进程的用户id。因此，pkexec默认情况下不允许您以另一个用户的身份运行X11应用程序，因为没有设置$DISPLAY和$XAUTHORITY环境变量。如果action上的org.freedesktop.policykit.exec.allow_gui注释被设置为非空值，那么这两个变量将被保留;但是，这是不鼓励的，应该只用于遗留程序。 注意，pkexec不验证传递给PROGRAM的ARGUMENTS。在正常情况下(每次使用pkexec时都需要管理员身份验证)，这不是问题，因为如果用户是管理员，他可能只需要运行pkexec bash来获得根用户。 但是，如果使用了用户可以保留授权的操作(或者用户是隐式授权的)，这可能是一个安全漏洞。因此，根据经验，更改默认所需授权的程序永远不应该隐式信任用户输入(例如，像任何其他编写良好的suid程序)。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:4","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"action和授权 默认使用“org.freedesktop.policykit.exec”动作。要使用另一个操作，请在一个action上使用org.freedesktop.policykit.exec.path注释，该注释的值设置为程序的完整路径。除了指定程序之外，还可以指定身份验证消息、描述、图标和默认值。如果有org.freedesktop.policykitexec.argv1注释，则只有当程序的第一个参数与注释的值匹配时，才会选择该操作。 请注意，身份验证消息可能会引用变量(请参阅“变量”一节)，例如$(user)将被扩展为用户变量的值。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:5","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"包装使用 为了避免修改现有软件以使用pkexec作为命令行调用的前缀，可以在she-bang包装器中使用pkexec，如下所示: #!/usr/bin/pkexec /usr/bin/python import os import sys print \"Hello, I'm running as uid %d\"%(os.getuid()) for n in range(len(sys.argv)): print \"arg[%d]=`%s'\"%(n, sys.argv[n]) 如果这个脚本被安装到/usr/bin/my-pk-test，那么下面的注释 [...] \u003cannotate key=\"org.freedesktop.policykit.exec.path\"\u003e/usr/bin/python\u003c/annotate\u003e \u003cannotate key=\"org.freedesktop.policykit.exec.argv1\"\u003e/usr/bin/my-pk-test\u003c/annotate\u003e [...] 可以用来选择合适的polkit动作。注意正确使用后面的注释，否则它将匹配/usr/bin/python脚本的任何pkexec调用。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:6","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"变量 以下变量是由pkexec设置的。它们可以用于授权规则和身份验证对话框中显示的消息: 参数 说明 program 要执行程序的完全限定路径。例如:“/bin/cat” command_line 请求的命令行(不要将其用于任何安全检查，它不安全)。示例:“cat /srv/xyz/foobar” user 执行程序的用户的用户名 user.gecos 执行程序的用户的全名 user.display 用户执行程序的一种表示形式，适合在身份验证对话框中显示。通常设置为用户名和全名的组合。例如:“David Zeuthen (davidz)” ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:7","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"pkttyagent 文本验证助手 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:4:0","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"说明 pkttyagent用于启动由 –process 或 –system-bus-name指定的主题的文本身份验证代理。如果没有提供这两个选项，则使用父进程。 要在注册身份验证代理时获得通知，可以侦听changed D-Bus信号，或使用–notify-fd传递已传递给程序的文件描述符的编号。当身份验证代理成功注册后，将关闭此文件描述符。 如果使用 –fallback，文本身份验证代理将不会替换现有的身份验证代理。 Usage: pkttyagent [OPTION?] Help Options: -h, --help Show help options Application Options: --fallback Don't replace existing agent if any --notify-fd=FD Close FD when the agent is registered -p, --process=PID[,START_TIME] Register the agent for the specified process -s, --system-bus-name=BUS_NAME Register the agent for the owner of BUS_NAME --version Show version Report bugs to: http://lists.freedesktop.org/mailman/listinfo/polkit-devel polkit home page: \u003chttp://www.freedesktop.org/wiki/Software/polkit\u003e ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:4:1","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"返回值 如果无法注册身份验证代理，pkttyagent将退出，退出码为127。诊断消息在标准错误时打印。 如果传递的一个或多个选项是不正确的，pkttyagent将退出，退出代码为126。如果stdin是一个tty，那么也会显示此手册页。 如果成功注册了身份验证代理，pkttyagent将继续运行，根据需要与用户交互。当不再需要它的服务时，可以终止该进程。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:4:2","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"注意 因为进程标识符可以循环使用，所以在使用 –process选项时，调用者应该始终使用pid,pid-start-time。pid-start-time的值可以通过参考proc(5)文件系统来确定，具体取决于操作系统。如果只将pid传递给–process选项，那么pkttyagent将查找启动时间本身，但请注意，这可能是不正常的。 ","date":"2022-06-07","objectID":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:4:3","tags":["linux","polkit"],"title":"polkit 相关命令","uri":"/2022/06/0003-polkit-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"说明 polkit提供了一个授权API，特权程序(“MECHANISMS”)使用它为非特权程序(“SUBJECTS”)提供服务，这些服务通常通过某种进程间通信机制实现。在这种情况下，特权程序通常将非特权程序视为不可信的。对于来自某个非特权程序的每个请求，该特权程序需要确定该请求是被授权的，还是应该拒绝为该非特权程序服务。使用polkit api，一种机制可以将此决策转移给受信任的一方:polkit。 polkit是作为系统守护进程polkitd(8)实现的，它本身没有什么特权，因为它是作为polkitd系统用户运行的。机制、主体和身份验证代理使用系统消息总线与权威机构通信。 除了充当授权机构之外，polkit还允许用户通过对管理用户或客户端所属会话的所有者进行身份验证来获得临时授权。这对于需要验证系统操作员是否真的是用户或管理用户的机制非常有用。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:1:0","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"系统架构 polkit的系统体系结构由Authority(作为系统消息总线上的服务实现)和每个用户会话(由用户的图形环境提供和启动)的Authentication Agent组成。操作由应用程序定义。厂商、站点和系统管理员可以通过“授权规则”控制授权策略。 polkit 系统架构 为了方便起见，libpolkit-gobject-1库封装了polkit D-Bus API，可用于任何C/C++程序以及支持GObjectIntrospection的高级语言，如JavaScript和Python。一种机制也可以使用D-Bus API或pkcheck(1)命令来检查授权。libpolkit-agent-1库提供了一个本地认证系统的抽象，例如pam(8)，还提供了注册和与polkit D-Bus服务通信的设施。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:1:1","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"认证代理 身份验证代理用于使会话的用户证明该会话的用户确实是该用户(通过身份验证为用户)或管理用户(通过身份验证为管理员)。为了与用户会话的其他部分很好地集成(例如匹配外观和感觉)，身份验证代理应该由用户使用的用户会话提供。例如，身份验证代理可能看起来像这样: 如果系统配置为没有root帐户，它可能会提示指定一个特定的用户作为管理用户: 不运行在桌面环境下的应用程序(例如，如果从ssh(1)登录启动)可能没有与它们相关联的身份验证代理。这样的应用程序可以使用PolkitAgentTextListener类型或pkttyagent(1)助手，这样用户可以使用文本接口进行身份验证。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:1:2","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"声明的Action 特权程序需要声明一组actions才能使用polkit。action对应于客户机可以请求特权程序执行的操作，并定义在XML文件中，特权程序将这些文件安装到/usr/share/polkit-1/actions目录中。 polkit操作有名称空间，只能包含字符“[A-Z][a-z][0-9].-”，即: ASCII、数字、句点和连字符。每个XML文件可以包含多个操作，但是所有操作都需要在同一个名称空间中，并且文件需要以名称空间命名并具有.policy扩展名。 XML文件必须具有以下doctype声明 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE policyconfig PUBLIC \"-//freedesktop//DTD polkit Policy Configuration 1.0//EN\" \"http://www.freedesktop.org/software/polkit/policyconfig-1.dtd\"\u003e policyconfig元素必须只出现一次。可以在policyconfig中使用的元素包括: 字段 说明 vendor 在XML文档中提供操作的项目或供应商的名称。可选的 vendor_url 指向在XML文档中提供操作的项目或供应商的URL。可选的 icon_name 表示在XML文档中提供操作的项目或供应商的图标。图标名称必须遵循Freedesktop.org图标命名规范。可选的 action 声明了一个action。操作名称使用id属性指定，并且只能包含字符“[A-Z][A-Z][0-9].-”，即: ASCII、数字、句点和连字符 可以在内部操作中使用的元素包括: 字段 说明 description 对操作的可读描述 message 当用户需要身份验证时要求凭证时，显示给用户的提示消息，说明为什么要做权限验证 defaults 此元素用于为客户端指定隐式授权。可以在默认值中使用的元素包括:allow_any: 适用于任何客户端的隐式授权。可选的。allow_inactive: 隐式授权，应用于本地控制台上非活动会话中的客户端。可选 allow_active: 应用于本地控制台活动会话中的客户端的隐式授权。可选的。其中allow_any, allow_inactive和allow_active元素可以包含以下值:no:未验证通过yes:验证通过auth_self:需要由客户机所在会话的所有者进行身份验证。注意，对于多用户系统的大多数使用，这是不够严格的;一般推荐使用auth_admin*auth_admin:需要由管理用户进行身份验证auth_self_keep:类似于auth_self，但授权只保留一小段时间(例如5分钟)。上面关于auth_self的警告同样适用auth_admin_keep:同上 annotate 用于用键/值对注释操作。键是使用key属性指定的，值是使用value属性指定的。该元素可以出现0次或多次。见下面的已知注释。 vendor 用于在每个操作的基础上重写供应商。可选的 vendor_url 用于在每个操作的基础上重写供应商URL。可选的 icon_name 用于在每个操作的基础上重写图标名称。可选的 对于本地化，description和message元素可以在不同的xml:lang属性中出现多次。 要列出已安装的polkit action，使用pkaction(1)命令。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:1:3","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"已知的annotations polkit附带的pkexec程序使用org.freedesktop.policykit.exec.path annotations 请参阅pkexec(1)手册页了解详细信息。 org.freedesktop.policykit.imply annotations(它的值是一个包含空格分隔的操作标识符列表的字符串)可以用来定义元操作。它的工作方式是，如果一个主题被授权执行带有该注释的操作，那么它也被授权执行该注释指定的任何操作。这个注释的典型用法是在定义带有单个锁定按钮的UI shell时，该按钮应该可以从不同的机制解锁多个操作。 org.freedesktop.policykit.owner annotations可用于定义一组用户，这些用户可以查询客户端是否被授权执行此操作。如果没有指定此注释，则只有根用户可以查询作为不同用户运行的客户端是否被授权执行某个操作。这个注释的值是一个字符串，包含一个空格分隔的PolkitIdentity条目列表，例如“unix-user:42 unix-user:colord”。这个注释的典型用途是作为系统用户而不是根用户运行的守护进程。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:1:4","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"验证规则 polkitd从 /etc/polkit-1/rules.d 和 /usr/share/polkit-1/rules.d 中读取 .rules， 方法是根据每个文件的基名按词法顺序对文件进行排序(如果有一个tie， /etc中的文件会在/usr中的文件之前处理)。例如，对于以下四个文件，顺序是 /etc/polkit-1/rules.d/10-auth.rules /usr/share/polkit-1/rules.d/10-auth.rules /etc/polkit-1/rules.d/15-auth.rules /usr/share/polkit-1/rules.d/20-auth.rules 这两个目录都受到监控，因此，如果更改、添加或删除规则文件，则清除现有的规则，并再次读取和处理所有文件。规则文件是用JavaScript编程语言编写的，并通过全局polkit对象(类型为polkit)与polkitd接口。 虽然在polkit的特定版本中使用的JavaScript解释器可能支持非标准特性(比如let关键字)，但授权规则必须符合ECMA-262 edition 5(换句话说，在polkit的未来版本中使用的JavaScript解释器可能会改变)。 授权规则针对两个特定的受众: 系统管理员 特殊用途的操作系统/环境 而且只针对这些观众。特别是，应用程序、机制和通用操作系统绝不能包含任何授权规则。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:2:0","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"The Polkit type 以下方法在polkit对象上可用: void addRule(polkit.Result function(action, subject) {...}); void addAdminRule(string[] function(action, subject) {...}); void log(string message); string spawn(string[] argv); addRule()方法用于添加一个函数，在执行动作和主题的授权检查时可以调用该函数。函数被调用的顺序是它们被添加的顺序，直到其中一个函数返回一个值。因此，要添加一个在其他规则之前处理的授权规则，请将其放在/etc/polkit-1/rules.d的文件中，其名称排在其他规则文件之前，例如00-early-checks.rules。每个函数都应该从polkit.Result返回一个值 polkit.Result = { NO : \"no\", YES : \"yes\", AUTH_SELF : \"auth_self\", AUTH_SELF_KEEP : \"auth_self_keep\", AUTH_ADMIN : \"auth_admin\", AUTH_ADMIN_KEEP : \"auth_admin_keep\", NOT_HANDLED : null }; 对应于可以用作默认值的值。如果函数返回polkit.Result.NOT_HANDLED、null、undefined或不返回值，将尝试下一个用户函数。 记住，如果返回polkit.result.AUTH_SELF_KEEP或polkit.Result.AUTH_ADMIN_KEEP，那么在下一个短时间内(例如5分钟)，对相同动作标识符和主题的授权检查将会成功(即返回polkit.Result.YES)，即使检查传递的变量不同。因此，如果授权规则的结果依赖于这些变量，那么它不应该使用“*_KEEP”常量(如果需要类似的功能，那么授权规则可以使用时间戳的Date类型轻松实现临时授权)。 addAdminRule()方法用于添加一个函数，在需要进行管理员身份验证时可以调用该函数。该函数用于指定哪些身份可以用于管理员身份验证，以便进行由动作和主题标识的授权检查。添加的函数将按照添加的顺序调用，直到其中一个函数返回值为止。每个函数都应该返回一个字符串数组，其中每个字符串的形式为\"unix-group:\"， “unix-netgroup:“或\"unix-user:\"。如果函数返回null、未定义或根本不返回值，则尝试下一个函数。 不能保证使用addRule()或addAdminRule()注册的函数会被调用——例如，早期的规则文件可以注册一个总是返回值的函数，从而确保以后添加的函数永远不会被调用。 如果用户提供的代码执行时间较长，则会抛出异常，通常会导致函数终止(当前限制为15秒)。这用于捕获失控脚本。 spawn()方法生成一个由参数向量argv标识的外部helper，并等待它终止。如果发生错误或helper没有以退出码0正常退出，则会抛出异常。如果助手没有在10秒内退出，它就会被杀死。否则，程序的标准输出将作为字符串返回。应该谨慎使用spawn()方法，因为helper可能需要很长时间或不确定的时间来完成，并且在helper运行时不能处理其他授权检查。注意，生成的程序将作为无特权的polkitd系统用户运行。 log()方法将给定的消息写入以JavaScript文件名和行号为前缀的系统日志记录器。日志条目是使用LOG_AUTHPRIV标志发出的，这意味着日志条目通常最后出现在文件/var/log/secure中。log()方法通常只在调试规则时使用。Action和Subject类型有适合于方便日志记录的toString()方法，例如， polkit.addRule(function(action, subject) { if (action.id == \"org.freedesktop.policykit.exec\") { polkit.log(\"action=\" + action); polkit.log(\"subject=\" + subject); } }); 当用户在shell中运行’pkexec -u bateman bash -i’时将产生以下结果: May 24 14:28:50 thinkpad polkitd[32217]: /etc/polkit-1/rules.d/10-test.rules:3: action=[Action id='org.freedesktop.policykit.exec' command_line='/usr/bin/bash -i' program='/usr/bin/bash' user='bateman' user.gecos='Patrick Bateman' user.display='Patrick Bateman (bateman)'] May 24 14:28:50 thinkpad polkitd[32217]: /etc/polkit-1/rules.d/10-test.rules:4: subject=[Subject pid=1352 user='davidz' groups=davidz,wheel, seat='seat0' session='1' local=true active=true] ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:2:1","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"The Action type 传递给用户函数的action参数是一个对象，其中包含正在检查的操作的信息。它的类型是Action，具有以下属性: string id: 动作标识符，例如org.freedesktop.policykit.exec。 以下方法在Action类型上可用: string lookup(string key); lookup()方法用于查找从该机制传递的polkit变量。例如，pkexec(1)机制设置可以在JavaScript中使用表达式action.lookup(“program”)获得的变量程序。如果给定的键没有值，则返回undefined。 请参阅每种机制的文档，了解每个操作可以使用哪些变量。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:2:2","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"The Subject type 传递给用户函数的subject参数是一个带有正在检查的进程信息的对象。它的类型是Subject，具有以下属性 类型 说明 int pid 进程id string user 用户名 string[] groups 用户所属的组 string seat subject所属的seat，不是本地seat则为空(ps:关于seat查看linux seat了解) string session subject所属session boolean local 仅仅是本地seat才会设置为 true boolean active 当session是active才会设置为true 以下方法可用于Subject类型: boolean isInGroup(string groupName); boolean isInNetGroup(string netGroupName); isInGroup()方法可以用来检查subject是否在给定的组中，isInNetGroup()方法可以用来检查subject是否在给定的网络组中。 ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:2:3","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"Authorization Rules Examples 允许admin组的所有用户进行用户管理，不改变其他用户的策略: polkit.addRule(function(action, subject) { if (action.id == \"org.freedesktop.accounts.user-administration\" \u0026\u0026 subject.isInGroup(\"admin\")) { return polkit.Result.YES; } }); 定义管理用户为wheel组中的用户: polkit.addAdminRule(function(action, subject) { return [\"unix-group:wheel\"]; }); 禁止子组中的用户更改主机名配置(即任何标识符以org.freedesktop.hostname1开头的操作)，并允许其他任何人在验证为自己之后这样做: polkit.addRule(function(action, subject) { if (action.id.indexOf(\"org.freedesktop.hostname1.\") == 0) { if (subject.isInGroup(\"children\")) { return polkit.Result.NO; } else { return polkit.Result.AUTH_SELF_KEEP; } } }); 运行一个外部助手来确定当前用户是否可能重启系统: polkit.addRule(function(action, subject) { if (action.id.indexOf(\"org.freedesktop.login1.reboot\") == 0) { try { // user-may-reboot exits with success (exit code 0) // only if the passed username is authorized polkit.spawn([\"/opt/company/bin/user-may-reboot\", subject.user]); return polkit.Result.YES; } catch (error) { // Nope, but do allow admin authentication return polkit.Result.AUTH_ADMIN; } } }); 下面的例子展示了授权决策如何依赖于pkexec(1)机制传递的变量: polkit.addRule(function(action, subject) { if (action.id == \"org.freedesktop.policykit.exec\" \u0026\u0026 action.lookup(\"program\") == \"/usr/bin/cat\") { return polkit.Result.AUTH_ADMIN; } }); 下面的示例展示了从该机制传递的变量的另一种用法。在这种情况下，机制是UDisks，它定义了一组用于匹配的操作和变量: // Allow users in group 'engineers' to perform any operation on // some drives without having to authenticate // polkit.addRule(function(action, subject) { if (action.id.indexOf(\"org.freedesktop.udisks2.\") == 0 \u0026\u0026 action.lookup(\"drive.vendor\") == \"SEAGATE\" \u0026\u0026 action.lookup(\"drive.model\") == \"ST3300657SS\" \u0026\u0026 subject.isInGroup(\"engineers\")) { return polkit.Result.YES; } } }); ","date":"2022-06-07","objectID":"/2022/06/0002-polkit/:2:4","tags":["linux","polkit","Authorization manager"],"title":"polkit 授权管理器","uri":"/2022/06/0002-polkit/"},{"categories":["linux"],"content":"polkit是什么? polkit提供了一个授权API，旨在由特权程序(“机制”)使用，为非特权程序(“客户端”)提供服务。查看polkit手册页面了解系统架构和总体情况。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:0","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"polkit 程序 Polkit 应用程序是使用 Polkit 权限作为决策组件的应用程序(polkitd)。他们通过将.policy文件安装到/usr/share/polkit-1/actions目录中，并在运行时与polkitd进行通信(通过D-Bus API或间接通过libpolkit-gobject-1库或pkcheck命令)。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:1","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"polkit 适用场景 如果您正在编写特权机制(即以root身份运行或具有特殊权限)，打算由非特权程序使用，则使用polkit。 认真考虑定义什么行为。在许多情况下，操作和polkit动作之间没有1:1的映射。通常，polkit操作与操作所处理的对象的关系比操作本身的关系更大。在粒度过细和粒度过粗之间取得适当的平衡是很重要的。 尝试选择操作和隐式授权，以便使用您的机制的应用程序能够为在控制台登录的用户开箱即用。应该优先考虑不使用身份验证对话框打断控制台用户。例如，对于添加打印机队列这样的普通任务，要求控制台用户进行身份验证是不明智的(如果管理员真的希望操作系统以这种方式工作，他总是可以部署合适的授权规则)。 考虑所选择的隐式授权对多用户系统的影响。一般情况下，普通用户既不能为其他用户修改重要系统的行为/配置，也不能查看其他用户的私人数据。如果您的应用程序需要授权框架，那么至少在某些情况下，默认配置很可能会拒绝授权。默认使用auth_admin 而不是auth_self。(在单用户桌面中，单个用户通常被配置为polkit管理员，因此这两种变体的行为是相同的。在多用户系统中，非管理员用户将受到默认配置的限制。) 将polkit变量与CheckAuthorization()请求一起传递，这样就可以编写与这些请求匹配的授权规则。还要在文档中记录这些变量(例如，请参阅udisks2操作和变量)。 传递一个定制的身份验证消息(使用polkit.message 和 polkit.gettext_domain 变量)，它包含比.policy文件的message元素中声明的请求更详细的信息。例如：显示 “需要身份验证来格式化INTEL SSDSA2MH080G1GC (/dev/sda)”，而不是仅仅显示“需要身份验证来格式化设备”。 确保您的应用程序工作，即使当org.freedesktop.PolicyKit1 D-Bus 服务不可用(这可能发生，如polkitd(8)没有安装或polkit.service被屏蔽)。如果你使用libpolkit-gobject-1库，这意味着处理polkit_authority_get_sync()或polkit_authority_get_finish()返回NULL或polkit_authority_check_authorization() / polkit_authority_check_authorization_sync()失败，返回错误不在POLKIT_ERROR域。处理polkit权限不可用的一种适当方法可以是只允许uid 0执行操作，禁止所有操作或其他操作。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:2","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"polkit 不适用的场景 如果您的程序不打算供非特权程序使用，则不要使用polkit。例如，如果您正在编写开发人员工具或低级核心OS命令行工具，那么只要求用户是root就可以了。用户可以通过sudo(8)， pkexec(1)或编写一个简单的使用polkit的机制来访问工具的(安全)子集。 除非必要，否则不要使用polkit。换句话说，并不是每个为非特权程序提供服务的特权程序都必须使用polkit。 不要在每次授权机构发出change信号时对所有操作调用CheckAuthorization()。这不仅是对资源的浪费，结果也可能不准确，因为授权规则可以在任何时候返回它们想要的任何内容。 在等待权限回复时，不要阻塞你的主线程(例如用于服务来自非特权程序的IPC请求的主线程)——CheckAuthorization()调用可能需要很长时间(秒，甚至分钟)才能完成，因为可能涉及用户交互。相反，可以使用异步API，或者使用带有同步API的专用线程。 不要在应用程序中包含任何授权规则，因为这只适用于管理员和特殊用途的操作系统/环境。有关更多信息，请参阅“授权规则”一节。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:3","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"在非特权程序中的使用 非特权程序通常不直接使用polkit——它只是调用特权机制，该机制在使用polkit进行检查(可能包括显示身份验证对话框)后呈现服务(或拒绝请求)。在这种设置中，非特权程序不知道正在使用polkit—它只是等待特权机制执行请求(如果涉及身份验证对话框，这可能需要许多秒)。这是一件好事，因为不必担心诸如polkit之类的实现细节，这有助于简化非特权程序。 有时，没有特权的程序需要禁用、修改或删除UI元素，以向用户传达某些操作无法执行(例如，用户没有获得授权)或需要验证(例如，在UI中显示挂锁图标)。在这种情况下，最好的方法通常是让非特权程序从特权机制(而不是polkit)获得该信息。这一点尤其正确，因为通常没有可靠的方法可以让非特权程序知道将要使用什么polkit操作。一般来说,不能保证操作(如d-bus方法)映射 1:1: 到 polkit 的某个 action ——例如,一个磁盘管理器服务的Format()方法可能检查net.company.diskmanager.format-removable 磁盘是否可移除 和 net.company.diskmanager.format-fixed 磁盘是固定的格式。 然而，在某些情况下，例如在使用org.freedesktop.policykit.imply (参见polkit(8)手册页)时，对于非特权程序查询polkit权限它是有意义的(如更新UI元素),只要无特权的程序不通过任何变量随着CheckAuthorization()调用，这种查询操作是被允许的(否则很容易欺骗身份验证对话框和旁路授权规则)。事实上，由于这个用例是如此常见，libpolkit-gobject-1提供了可以与GtkLockButton一起使用的PolkitPermission类型(它派生自GPermission)。注意，要使GtkLockButton正常工作，支持它的polkit操作应该使用auth_admin_keep作为隐式授权(或者很少使用auth_self_keep作为不影响其他用户的服务)。这通常用于实现一个即时应用范例，用户解锁(通过身份验证)，例如一个首选项窗格窗口，然后可以自由更改设置，直到授权过期或被撤销。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:4","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"没有身份验证代理 如果一个polkit应用程序想要处理没有身份验证代理存在的情况(例如，如果应用程序是通过ssh(1)登录启动的)，应用程序可以使用PolkitAgentTextListener类型来根据需要生成自己的身份验证代理。另外，也可以使用pkttyagent(1) helper来完成此任务。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:1:5","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["linux"],"content":"编写polkit认证代理 认证代理由桌面环境提供。当用户会话开始时，代理使用RegisterAuthenticationAgent()方法向polkit Authority注册。当需要服务时，机构将调用org.freedesktop.PolicyKit1.AuthenticationAgent D-Bus接口上的方法。一旦用户通过身份验证，(特权部分)代理将调用AuthenticationAgentResponse2()方法。这个方法应该被视为内部实现细节，调用者应该使用PolkitAgentSession API来调用它，它目前使用一个setuid助手程序。 libpolkit-agent-1库提供了帮助程序，使构建使用本机身份验证系统的身份验证代理变得容易，例如pam(8)。 如果设置了环境变量POLKIT_DEBUG，则libpolkit-agent-1库将在标准输出中输出诊断信息。 ","date":"2022-06-07","objectID":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/:2:0","tags":["linux","polkit"],"title":"Polkit 介绍","uri":"/2022/06/0001-polkit%E4%BB%8B%E7%BB%8D/"},{"categories":["c++"],"content":" 现代C++，快速上手 C++11、C++14、C++17、C++20 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:0:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"概述 C++98 是C++第一个版本 C++98 之后积累十年出现 C++11 C++14/17 对C++11做了重要补充和优化 C++20 则将这门语言领进了现代的大门 将将C++98划分为传统C++；C++11、C++14、C++17、C++20划分为现代C++ 注意：现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会 变得合法，为了提高可移植性，写代码时候尽量使用标准的语法和特性。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:1:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"迈向现代C++ 编译环境：clang++ 编译器 + std=c++2a 编译标志 clang++ 版本大于10 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:2:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"被弃用的特性 注意：弃用并非彻底不能用，只是暗示程序员这些特性将从未来的标准中消失，要避免使用。但是，已弃用的特性仍然是标准库的一部分，并且出于兼容性的考虑，大部分特性会「永久」保留。 从C++11 开始被弃用的主要特性： 不再允许字符串字面值常量赋值给一个 char *。如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto。 char *str = \"hello world!\"; // 将出现弃用警告 C++98 异常说明、unexpected_handler、set_unexpected() 相关特性被弃用，应该使用 noexcept。 auto_ptr 被弃用，应该使用 unique_ptr。 register 关键字被弃用，可以使用但不具备任何实际含义。 bool类型的++操作被弃用。 如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。 C 语言风格的类型转换被弃用(即在变量前使用 (convert_type))，应该使用 static_cast、 reinterpret_cast、const_cast 来进行类型转换。 特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 \u003cccomplex\u003e、 \u003ccstdalign\u003e、\u003ccstdbool\u003e 与 \u003cctgmath\u003e 等 … 其他\u003c待补充\u003e 还有一些其他诸如参数绑定(C++11 提供了 std::bind 和 std::function)、export 等特性也均 被弃用。前面提到的这些特性如果你从未使用或者听说过，也请不要尝试去了解他们，应该向新标准靠 拢，直接学习新特性。毕竟，技术是向前发展的。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:2:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"与C的兼容性 早期C++中使用了一些C语言代码(例如：Linux系统调用)，所以大多数人认为C++是C的超集，其实这个观念是不对的(从一开始就不是)，在写C++代码的时候要避免使用C中的程序风格，而不得不使用C的时候，要注意使用extern \"C\" 这种特性，将C语言的代码与C++代码进行分离编译再统一链接这一做法。 例如： // foo.h #ifdef __cplusplus extern \"C\" { #endif int add(int x, int y); #ifdef __cplusplus } #endif // foo.c int add(int x, int y) { return x+y; } // 1.1.cpp #include \"foo.h\" #include \u003ciostream\u003e #include \u003cfunctional\u003e int main() { [out = std::ref(std::cout \u003c\u003c \"Result from C code: \" \u003c\u003c add(1, 2))](){ out.get() \u003c\u003c \".\\n\"; }(); return 0; } // 应先使用 gcc 编译 C 语言的代码 gcc -c foo.c // 编译出 foo.o 文件，再使用 clang++ 将 C++ 代码和 .o 文件链接起来(或者都编译为 .o 再统一 链接) clang++ 1.1.cpp foo.o -std=c++2a -o xxx.out 下图为C与C++关系 C与C++相互兼容情况 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:2:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"进一步阅读的参考文献 c++语言导学 C++历史 C++特性在GCC/Clang等编译器中的支持情况 C++98 与 C99之间的区别 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:2:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"语言可用性的强化 当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都 是运行时之前，可能发生在编写代码或编译器编译代码时的行为。为此，我们通常谈及语言可用性，是指那些发生在运行时之前的语言行为。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"常量 nullptr nullptr 出现的目的是为了替代 NULL。在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。 C++ 不允许直接将 void * 隐式转换到其他类型。但如果编译器尝试把NULL定义为((void*)0)那么针对如下代码： void foo (char*); void foo (int); char* ch = NULL; // 会使调用 void foo(int)，导致违反本意 没有了 void* 隐式转换的 C++ 只好将 NULL 定义为 0。这将导致C++重载特性发生混乱。 NULL毕竟是C代码里的语法，((void*)0)这种写法在C++里不推荐，C里0和空指针就是一个值，但是C++里涉及到函数重载就不行了。 为了解决上述问题，C++引入了关键字nullptr，专门区分空指针、0。nullptr 类型为nullptr_t constexpr C++ 本身已经具备了常量表达式的概念，比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没 有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。 C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式。 注意：是编译期就是常量表达式。 此外，constexpr 修饰的函数可以使用递归 从 C++14 开始，`constexpr` 函数可以在内部使用局部变量、循环和分支等简单语句，代码在C++11标准下是不能通过编译的： constexpr int fibonacci(const int n) { // 循环语句在 c++14 才支持 if(n == 1) return 1; if(n == 2) return 1; return fibonacci(n-1) + fibonacci(n-2); } 为此，我们可以写出下面这类简化的版本来使得函数从 C++11 开始即可用: constexpr int fibonacci(const int n) { return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2); } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"变量及其初始化 if/switch 变量声明强化 在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终没有办法在 if 和 switch 语句中声明一个临时的变量。 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e int main() { std::vector\u003cint\u003e vec = {1, 2, 3, 4}; // 在 c++17 之前 const std::vector\u003cint\u003e::iterator itr = std::find(vec.begin(), vec.end(), 2); if (itr != vec.end()) { *itr = 3; } // 需要重新定义一个新的变量 const std::vector\u003cint\u003e::iterator itr2 = std::find(vec.begin(), vec.end(), 3); if (itr2 != vec.end()) { *itr2 = 4; } // 将输出 1, 4, 3, 4 for (std::vector\u003cint\u003e::iterator element = vec.begin(); element != vec.end(); ++element) std::cout \u003c\u003c *element \u003c\u003c std::endl; } 在上面的代码中，我们可以看到 itr 这一变量是定义在整个 main() 的作用域内的，这导致当我们 需要再次遍历整个 std::vectors 时，需要重新命名另一个变量。C++17 消除了这一限制，使得我们可 以在 if(或 switch)中完成这一操作: // 将临时变量放到 if 语句内 // 注意，if 条件是由两个表达式组成 if (const std::vector\u003cint\u003e::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) { *itr = 4; } 初始化列表 初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。在传统 C++ 中， 不同的对象有着不同的初始化方法，例如普通数组、POD (Plain Old Data，即没有构造、析构和虚函 数的类或结构体)类型都可以使用 {} 进行初始化，也就是我们所说的初始化列表。而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 () 进行。这些不同方法都针对各自对象，不能通用。例如: #include \u003ciostream\u003e #include \u003cvector\u003e class Foo { public: int value_a; int value_b; // 类的初始化 Foo(int a, int b) : value_a(a), value_b(b) {} }; int main() { // before C++11 int arr[3] = {1, 2, 3}; Foo foo(1, 2); std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; std::cout \u003c\u003c \"arr[0]: \" \u003c\u003c arr[0] \u003c\u003c std::endl; std::cout \u003c\u003c \"foo:\" \u003c\u003c foo.value_a \u003c\u003c \", \" \u003c\u003c foo.value_b \u003c\u003c std::endl; for (std::vector\u003cint\u003e::iterator it = vec.begin(); it != vec.end(); ++it) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } return 0; } 为了解决这个问题，C++11 首先把初始化列表的概念绑定到了类型上，并将其称之为 std::initializer_list， 允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初 始化方法提供了统一的桥梁，例如: #include \u003cinitializer_list\u003e #include \u003cvector\u003e class MagicFoo { public: std::vector\u003cint\u003e vec; MagicFoo(std::initializer_list\u003cint\u003e list) { for (std::initializer_list\u003cint\u003e::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it); } }; int main() { // after C++11 MagicFoo magicFoo = {1, 2, 3, 4, 5}; } 这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。 初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如: class MagicFoo { public: void foo(std::initializer_list\u003cint\u003e list) { for (std::initializer_list\u003cint\u003e::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it); } }; // 使用时候 magicFoo.foo({6,7,8,9}); 其次，C++11 还提供了统一的语法来初始化任意的对象，例如: Foo foo2 {3, 4}; 结构化绑定 结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新 增了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11/14 并没有提供一种 简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。 C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码: #include \u003ciostream\u003e #include \u003ctuple\u003e std::tuple\u003cint, double, std::string\u003e f() { return std::make_tuple(1, 2.3, \"456\"); } int main() { auto [x, y, z] = f(); std::cout \u003c\u003c x \u003c\u003c \", \" \u003c\u003c y \u003c\u003c \", \" \u003c\u003c z \u003c\u003c std::endl; return 0; } 关于 auto 类型推导会在auto 类型推导一节中进行介绍 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"类型推导 在传统 C 和 C++ 中，参数的类型都必须明确定义，这其实对我们快速进行编码没有任何帮助，尤 其是当我们面对一大堆复杂的模板类型时，必须明确的指出变量的类型才能进行后续的编码，这不仅拖 慢我们的开发效率，也让代码变得又臭又长。 C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。这 使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。 auto auto 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 register 并 存。在传统 C++ 中，如果一个变量没有声明为 register 变量，将自动被视为一个 auto 变量。 随着 register 被弃用(在 C++17 中作为保留关键字，以后使用，目前不具备实际意义)，对 auto 的语义变 更也就非常自然了。 使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。你应该在前面的小节里看到 了传统 C++ 中冗长的迭代写法: // c++11 之前 for(vector\u003cint\u003e::const_iterator it = vec.cbegin(); itr != vec.cend(); ++it) ... // c++11 之后使用 auto for (auto it = list.begin(); it != list.end(); ++it) ... auto 其他写法 auto i = 5; // i 被推导为 int auto arr = new auto(10); // arr 被推导为 int * 从 C++ 20 起，auto 甚至能用于函数传参，考虑下面的例子: int add(auto x, auto y) { return x+y; } auto i = 5; // 被推导为 int auto j = 6; // 被推导为 int std::cout \u003c\u003c add(i, j) \u003c\u003c std::endl; 注意:auto 还不能用于推导数组类型 auto auto_arr2[10] = {arr}; // 错误, 无法推导数组元素类型 decltype decltype 用来对表达式进行推导 decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 typeof 很相似: decltype(表达式) 有时候，我们可能需要计算某个表达式的类型，例如: auto x = 1; auto y = 2; decltype(x+y) z; 下面这个例子就是判断x, y, z 是否是同一类型: auto x = 1; auto y = 2; decltype(x+y) z; if (std::is_same\u003cdecltype(x), int\u003e::value) std::cout \u003c\u003c \"type x == int\" \u003c\u003c std::endl; if (std::is_same\u003cdecltype(x), float\u003e::value) std::cout \u003c\u003c \"type x == float\" \u003c\u003c std::endl; if (std::is_same\u003cdecltype(x), decltype(z)\u003e::value) std::cout \u003c\u003c \"type z == type x\" \u003c\u003c std::endl; 其中，std::is_same\u003cT, U\u003e 用于判断 T 和 U 这两个类型是否相等。 输出结果为: type x == int type z == type x 返回类型推导 你可能会思考，在介绍 auto 时，我们已经提过 auto 不能用于函数形参进行类型推导，那么 auto 能不能用于推导函数的返回类型呢?还是考虑一个加法函数的例子，在传统 C++ 中我们必须这么写: template\u003ctypename R, typename T, typename U\u003e R add(T x, U y) { return x+y; } 注意: typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。 但在模板中定义有嵌套依赖类型的变量时，需要用 typename 消除歧义 在 C++11 中这个问题得到解决，为了解决这个问题，C++11 还引入了一个叫做尾返回类型(trailing return type)，利用 auto 关键 字将返回类型后置： template\u003ctypename T, typename U\u003e auto add2(T x, U y) -\u003e decltype(x+y) { return x + y; } 令人欣慰的是从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法: template\u003ctypename T, typename U\u003e auto add3(T x, U y) { return x + y; } 可以检查一下类型推导是否正确: // after c++11 auto w = add2\u003cint, double\u003e(1, 2.0); if (std::is_same\u003cdecltype(w), double\u003e::value) { std::cout \u003c\u003c \"w is double: \"; } std::cout \u003c\u003c w \u003c\u003c std::endl; // after c++14 auto q = add3\u003cdouble, int\u003e(1.0, 2); std::cout \u003c\u003c \"q: \" \u003c\u003c q \u003c\u003c std::endl; decltype(auto) decltype(auto) 是 C++14 开始提供的一个略微复杂的用法。 要理解它你需要知道 C++ 中参数转发的概念，我们会在语言运行时强化一章中详细介绍，你可以到时再回来看这一小节的内容。 简单来说，decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 decltype 的参数表达式。 考虑看下面的例子，当我们需要对下面两个函数进行封装时: std::string lookup1(); std::string\u0026 lookup2(); 在 C++11 中，封装实现是如下形式: std::string look_up_a_string_1() { return lookup1(); } std::string\u0026 look_up_a_string_2() { return lookup2(); } 而有了 decltype(auto)，我们可以让编译器完成这一件烦人的参数转发: decltype(auto) look_up_a_string_1() { return lookup1(); } decltype(auto) look_up_a_string_2() { return lookup2(); } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"控制流 if constexpr 正如本章开头出，我们知道了 C++11 引入了 constexpr 关键字，它将表达式或函数编译为常量结 果。一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断， 岂不是能让程序效率更高? C++17 将 constexpr 这个关键字引入到 if 语句中，允许在代码中声明常量 表达式的判断条件，考虑下面的代码: #include \u003ciostream\u003e template\u003ctypename T\u003e auto print_type_info(const T\u0026 t) { if constexpr (std::is_integral\u003cT\u003e::value) { return t + 1; } else { return t + 0.001; } } int main() { std::cout \u003c\u003c print_type_info(5) \u003c\u003c std::endl; std::cout \u003c\u003c print_type_info(3.14) \u003c\u003c std::endl; } 在编译时，实际代码就会表现为如下: int print_type_info(const int\u0026 t) { return t + 1; } double print_type_info(const double\u0026 t) { return t + 0.001; } int main() { std::cout \u003c\u003c print_type_info(5) \u003c\u003c std::endl; std::cout \u003c\u003c print_type_info(3.14) \u003c\u003c std::endl; } 区间 for 迭代 终于，C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句，我们可以进一步简化前面的例子: #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e int main() { std::vector\u003cint\u003e vec = {1, 2, 3, 4}; if (auto itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) *itr = 4; for (auto element : vec) std::cout \u003c\u003c element \u003c\u003c std::endl; // read only for (auto \u0026element : vec) { element += 1; // writeable } for (auto element : vec) std::cout \u003c\u003c element \u003c\u003c std::endl; // read only } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"模版 C++ 的模板一直是这门语言的一种特殊的艺术，模板甚至可以独立作为一门新的语言来进行使用。 模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动 态服务，进而大幅优化运行期的性能。 因此模板也被很多人视作 C++ 的黑魔法之一。 外部模版 传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元(文件)中 编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。 并且，我们没有办法通知编译器不要触发模板的实例化。 为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能 够显式的通知编译器何时进行模板的实例化： template class std::vector\u003cbool\u003e; // 强行实例化 extern template class std::vector\u003cdouble\u003e; // 不在该当前编译文件中实例化模板 尖括号\"\u003e\" 在传统 C++ 的编译器中，» 一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌 套模板的代码: std::vector\u003cstd::vector\u003cint\u003e\u003e matrix; 这在传统 C++ 编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且 能够顺利通过编译。甚至于像下面这种写法都能够通过编译: template\u003cbool T\u003e class MagicType { bool magic = T; }; // in main function: std::vector\u003cMagicType\u003c(1\u003e2)\u003e\u003e magic; // 合法, 但不建议写出这样的代码 类型别名模版 在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话:模板是用来产生类型的。在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如： template\u003ctypename T, typename U\u003e class MagicType { public: T dark; U magic; }; // 不合法 template\u003ctypename T\u003e typedef MagicType\u003cstd::vector\u003cT\u003e, std::string\u003e FakeDarkMagic; C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效: typedef int (*process)(void *); using NewProcess = int(*)(void *); template\u003ctypename T\u003e using TrueDarkMagic = MagicType\u003cstd::vector\u003cT\u003e, std::string\u003e; int main() { TrueDarkMagic\u003cbool\u003e you; } 通常我们使用 typedef 定义别名的语法是:typedef 原名称 新名称 但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。 变长参数模版 在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数 而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。 template\u003ctypename... Ts\u003e class Magic; 模版类 Magic 对象，能够接受不受限制个数的 typename 作为模版的形式参数，例如下边的定义： class Magic\u003cint, std::vector\u003cint\u003e, std::map\u003cstd::string, std::vector\u003cint\u003e\u003e\u003e darkMagic; 既然是任意形式，所以个数为0 的模板参数也是可以的:class Magic\u003c\u003e nothing;。 如果不希望产生的模板参数个数为 0，可以手动的定义至少一个模板参数: template\u003ctypename Require, typename... Args\u003e class Magic; 变长参数模板也能被直接调整到到模板函数上。传统 C 中的 printf 函数，虽然也能达成不定个数的形参的调用，但其并非类别安全。而 C++11 除了能定义类别安全的变长参数函数外，还可以使类似 printf 的函数能自然地处理非自带类别的对象。除了在模板参数中能使用 … 表示不定长模板参数外，函数参数也使用同样的表示法代表不定长参数，这也就为我们简单编写变长参数函数提供了便捷的手段，例如: template\u003ctypename... Args\u003e void printf(const std::string \u0026str, Args... args); 那么我们定义了变长的模板参数，如何对参数进行解包呢? 首先，我们可以使用 sizeof… 来计算参数的个数: template\u003ctypename... Ts\u003e void magic(Ts... args) { std::cout \u003c\u003c sizeof...(args) \u003c\u003c std::endl; } 我们可以传递任意个参数给 magic 函数: magic(); // 输出 0 magic(1); // 输出 1 magic(1, \"\"); // 输出 2 其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法: 递归模版函数 递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的: #include \u003ciostream\u003e template\u003ctypename T0\u003e void printf1(T0 value) { std::cout \u003c\u003c value \u003c\u003c std::endl; } template\u003ctypename T, typename... Ts\u003e void printf1(T value, Ts... args) { std::cout \u003c\u003c value \u003c\u003c std::endl; printf1(args...); } int main() { printf1(1, 2, \"123\", 1.1); return 0; } 变参模版展开 你应该感受到了这很繁琐，在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 printf 的编写： template\u003ctypename T0, typename... T\u003e void printf2(T0 t0, T... t) { std::cout \u003c\u003c t0 \u003c\u003c std::endl; if constexpr (sizeof...(t) \u003e 0) printf2(t...); } 事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 std::bind 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。 初始化列表展开 递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。 这里介绍一种使用初始化列表展开的黑魔法: template\u003ctypename T, typename... Ts\u003e auto printf3(T value, Ts... args) { std::cout \u003c\u003c value \u003c\u003c std::endl; (void) std::initializer_list\u003cT\u003e {([\u0026args] { std::cout \u003c\u003c args \u003c\u003c std::endl; }(), value)...}; } 在这个代码中，额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性(下一节中将 提到)。 通过初始化列表，(lambda 表达式, value)… 将会被展开。由于逗号表达式的出现，首先会执行 前面的 lambda 表达式，完成参数的输出。为了避免编译器警告，我们可以将 std::initializer_list 显式的转为 void。 折叠表达式 C++ 17 中将变长参数这种特性进一步带给了表达式，考虑下面这个例子: #include \u003ciostream\u003e template\u003ctypename ... T\u003e auto sum(T ... t) { return (t + ...); } int main() { std::cout \u003c\u003c sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) \u003c\u003c std::endl; } 非类型模版参数推导 前面我们主要提及的是模板参数的一种形式:类型模板参数 template \u003ctypename T, typename U\u003e auto add(T t, U u) { return t+u; } 其中模板的参数 T 和 U 为具体的类型。但还有一种常见模板参数形式可以让不同字面量成为模板参 数，即非类型模板参数: template \u003ctypename T, int BufSize\u003e class buffer_t { public: T\u0026 alloc(); void free(T\u0026 item); private: T data[BufSize]; } buffer_t\u003cint, 100\u003e buf; // 100 作为模板参数 在这种模板参数形式下，我们可以将 100 作为模板的参数进行","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:5","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 本节介绍了现代 C++ 中对语言可用性的增强，其中笔者认为最为重要的几个特性是几乎所有人都 需要了解并熟练使用的: auto 类型推导 范围 for 迭代 初始化列表 变参模板 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:3:6","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"语言运行期间的强化 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"Lambda表达式 Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类 似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用 的。这样的场景其实有很多很多，所以匿名函数几乎是现代编程语言的标配。 基础 Lambda 表达式的基本语法如下: [捕获列表](参数列表) mutable(可选) 异常属性 -\u003e 返回类型 { // 函数体 } 上面的语法规则除了 [捕获列表] 内的东西外，其他部分都很好理解，只是一般函数的函数名被略 去，返回值使用了一个 -\u003e 的形式进行(我们在上一节前面的尾返回类型已经提到过这种写法了)。 所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能 够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列 表也分为以下几种: 值捕获 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝，而非调用时才拷贝: void lambda_value_capture() { int value = 1; auto copy_value = [value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout \u003c\u003c \"stored_value = \" \u003c\u003c stored_value \u003c\u003c std::endl; // 这时, stored_value == 1, 而 value == 100. // 因为 copy_value 在创建时就保存了一份 value 的拷贝 } 引用捕获 与引用传参类似，引用捕获保存的是引用，值会发生变化。 void lambda_reference_capture() { int value = 1; auto copy_value = [\u0026value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout \u003c\u003c \"stored_value = \" \u003c\u003c stored_value \u003c\u003c std::endl; // 这时, stored_value == 100, value == 100. // 因为 copy_value 保存的是引用 } 隐式捕获 手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时 候可以在捕获列表中写一个 \u0026 或 = 向编译器声明采用引用捕获或者值捕获. 总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是: [] 空捕获列表 [name1, name2, …] 捕获一系列变量 [\u0026] 引用捕获，让编译器自行推导引用列表 [=] 值捕获，让编译器自行推导值捕获列表 表达式捕获 这部分内容需要了解后面马上要提到的右值引用以及智能指针 上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左 值，而不能捕获右值。 C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被 声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的: #include \u003ciostream\u003e #include \u003cmemory\u003e // std::make_unique #include \u003cutility\u003e // std::move void lambda_expression_capture() { auto important = std::make_unique\u003cint\u003e(1); auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -\u003e int { return x+y+v1+(*v2); }; std::cout \u003c\u003c add(3,4) \u003c\u003c std::endl; } 在上面的代码中，important 是一个独占指针，是不能够被 “=” 值捕获到，这时候我们可以将其转 移为右值，在表达式中初始化。 范型Lambda 上一节中我们提到了 auto 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生 冲突。但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。这就为我们造成了 一定程度上的麻烦:参数表不能够泛化，必须明确参数表类型。 幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型: auto add = [](auto x, auto y) { return x+y; }; add(1, 2); add(1.1, 2.2); ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"函数对象包装器 这部分内容虽然属于标准库的一部分，但是从本质上来看，它却增强了 C++ 语言运行时的能力，这 部分内容也相当重要，所以放到这里来进行介绍。 std::function Lambda 表达式的本质是一个和函数对象类型相似的类类型(称为闭包类型)的对象(称为闭包对 象)，当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如: #include \u003ciostream\u003e using foo = void(int); // 定义函数类型, using 的使用见上一节中的别名语法 // 定义在参数列表中的函数类型 foo 被视为退化后的函数指针类型 foo* void functional(foo f) { f(1); // 通过函数指针调用函数 } int main() { auto f = [](int value) { std::cout \u003c\u003c value \u003c\u003c std::endl; }; functional(f); // 传递闭包对象，隐式转换为 foo* 类型的函数指针值 f(1); // lambda 表达式调用 return 0; } 上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用，而另一种则是直接调用 Lambda 表达式 在 C++11 中，统一了这些概念，将能够被调用的对象的类型，统一称之为可调用类型。而这种类型，便是通过 std::function 引入的。 C++11 std::function 是一种通用、多态的函数封装，它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，它也是对 C++ 中现有的可调用实体的一种类型安全的包裹(相对来说，函数指针的调用不是类型安全的)，换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。例如: #include \u003cfunctional\u003e #include \u003ciostream\u003e int foo(int para) { return para; } int main() { // std::function 包装了一个返回值为 int, 参数为 int 的函数 std::function\u003cint(int)\u003e func = foo; int important = 10; std::function\u003cint(int)\u003e func2 = [\u0026](int value) -\u003e int { return 1+value+important; }; std::cout \u003c\u003c func(10) \u003c\u003c std::endl; std::cout \u003c\u003c func2(10) \u003c\u003c std::endl; } std::bind 和 std::placeholder 而 std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。例如: int foo(int a, int b, int c) { ; } int main() { // 将参数 1,2 绑定到函数 foo 上，但是使用 std::placeholders::_1 来对第一个参数进行占位 auto bindFoo = std::bind(foo, std::placeholders::_1, 1,2); // 这时调用 bindFoo 时，只需要提供第一个参数即可 bindFoo(1); } 提示：注意 auto 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型，但是我们却可以通过 auto 的使用来规避这一问题的出现。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"右值引用 右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大量的历史遗留问题，消除了诸如 std::vector、std::string 之类的额外开销，也才使得函数对象容器 std::function 成为了可能。 左值、右值的纯右值、将亡值、右值 左值 顾名思义就是赋值符号左边的值。准确来说，左值是表达式(不一定是 赋值表达式)后依然存在的持久对象。 右值 右边的值，是指表达式结束后就不再存在的临时对象 而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为:纯右值、将亡值。 纯右值 纯粹的右值，要么是纯粹的字面量，例如 10, true;要么是求值 结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、原 始字面量、Lambda 表达式都属于纯右值。 需要注意的是，字符串字面量只有在类中才是右值，当其位于普通函数中是左值。例如: class Foo { const char*\u0026\u0026 right = \"this is a rvalue\"; // 此处字符串字面量为右值 public: void bar() { right = \"still rvalue\"; // 此处字符串字面量为右值 } }; int main() { const char* const \u0026left = \"this is an lvalue\"; // 此处字符串字面量为左值 } 将亡值 将亡值 (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念(因此在传统 C++ 中，纯右值和右值是同一个概念)，也就是即将被销毁、却能够被移动的值。 将亡值可能稍有些难以理解，我们来看这样的代码: std::vector\u003cint\u003e foo() { std::vector\u003cint\u003e temp = {1, 2, 3, 4}; return temp; } std::vector\u003cint\u003e v = foo(); 在这样的代码中，就传统的理解而言，函数 foo 的返回值 temp 在内部创建然后被赋值给 v，然而 v 获得这个对象时，会将整个 temp 拷贝一份，然后把 temp 销毁，如果这个 temp 非常大，这将造成大量额外的开销(这也就是传统 C++ 一直被诟病的问题)。 在最后一行中，v 是左值、foo() 返回的值就是右值(也是纯右值)。但是，v 可以被别的变量捕获到，而 foo() 产生的那个返回值作为一个临时值，一旦被 v 复制后，将立即被销毁，无法获取、也不能修改。而将亡值就定义了这样一种行为:临时的值能够被识别、同时又能够被移动。 在 C++11 之后，编译器为我们做了一些工作，此处的左值 temp 会被进行此隐式右值转换，等价于 static_cast\u003cstd::vector\u003cint\u003e \u0026\u0026\u003e(temp)，进而此处的 v 会将 foo 局部返回的值进行移动。也就是后面我们将会提到的移动语义。 右值引用和左值引用 要拿到一个将亡值，就需要用到右值引用:T \u0026\u0026，其中 T 是类型。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。 C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象，例如: #include \u003ciostream\u003e #include \u003cstring\u003e void reference(std::string\u0026 str) { std::cout \u003c\u003c \" 左值\" \u003c\u003c std::endl; } void reference(std::string\u0026\u0026 str) { std::cout \u003c\u003c \" 右值\" \u003c\u003c std::endl; } int main() { std::string lv1 = \"string,\"; // lv1 是一个左值 // std::string\u0026\u0026 r1 = lv1; // 非法, 右值引用不能引用左值 std::string\u0026\u0026 rv1 = std::move(lv1); // 合法, std::move 可以将左值转移为右值 std::cout \u003c\u003c rv1 \u003c\u003c std::endl; // string, const std::string\u0026 lv2 = lv1 + lv1; // 合法, 常量左值引用能够延长临时变量的生命周期 // lv2 += \"Test\"; // 非法, 常量引用无法被修改 std::cout \u003c\u003c lv2 \u003c\u003c std::endl; // string,string, std::string\u0026\u0026 rv2 = lv1 + lv2; // 合法, 右值引用延长临时对象生命周期 rv2 += \"Test\"; // 合法, 非常量引用能够修改临时变量 std::cout \u003c\u003c rv2 \u003c\u003c std::endl; // string,string,string,Test reference(rv2); // 输出左值 return 0; } rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。 注意，这里有一个很有趣的历史遗留问题，我们先看下面的代码: #include \u003ciostream\u003e int main() { // int \u0026a = std::move(1); // 不合法，非常量左引用无法引用右值 const int \u0026b = std::move(1); // 合法, 常量左引用允许引用右值 std::cout \u003c\u003c a \u003c\u003c b \u003c\u003c std::endl; } 第一个问题，为什么不允许非常量引用绑定到非左值?这是因为这种做法存在逻辑错误: void increase(int \u0026 v) { v++; } void foo() { double s = 1; increase(s); } 由于 int\u0026 不能引用 double 类型的参数，因此必须产生一个临时值来保存 s 的值，从而当 increase() 修改这个临时值时，调用完成后 s 本身并没有被修改。 第二个问题，为什么常量引用允许绑定到非左值?原因很简单，因为 Fortran 需要。 移动语义 传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的 移动操作，调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。试想，搬家的 时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份(重买)再放到新家、再把原来的东 西全部扔掉(销毁)，这是非常反人类的一件事情。 传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间。右值 引用的出现恰好就解决了这两个概念的混淆问题，例如: #include \u003ciostream\u003e class A { public: int *pointer; A() : pointer(new int(1)) { std::cout \u003c\u003c \" 构造\" \u003c\u003c pointer \u003c\u003c std::endl; } A(A\u0026 a) : pointer(new int(*a.pointer)) { std::cout \u003c\u003c \" 拷贝\" \u003c\u003c pointer \u003c\u003c std::endl; } // 无意义的对象拷贝 A(A\u0026\u0026 a):pointer(a.pointer) { a.pointer = nullptr; std::cout \u003c\u003c \" 移动\" \u003c\u003c pointer \u003c\u003c std::endl; } ~A() { std::cout \u003c\u003c \" 析构\" \u003c\u003c pointer \u003c\u003c std::endl; delete pointer; } }; // 防止编译器优化 A return_rvalue(bool test) { A a,b; if(test) return a; // 等价于 static_cast\u003cA\u0026\u0026\u003e(a); else return b; // 等价于 static_cast\u003cA\u0026\u0026\u003e(b); } int main() { A obj = return_rvalue(false); std::cout \u003c\u003c \"obj:\" \u003c\u003c std::endl; std::cout \u003c\u003c obj.pointer \u003c\u003c std::endl; std::cout \u003c\u003c *obj.pointer \u003c\u003c std::endl; return 0; } 在上面的代码中: 首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出; 函数返回后，产生一个将亡值，被 A 的移动构造(A(A\u0026\u0026))引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。 从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子: #include \u003ciostream\u003e // std::cout #include \u003cutility\u003e // std::move #include \u003cvector\u003e // std::vector #include \u003cstring\u003e // std::string int main() { std::string str = \"Hello world.\"; std::vector\u003cstd::string\u003e v; // 将使用 push_back(const T\u0026), 即产生拷贝行","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 本章介绍了现代 C++ 中最为重要的几个语言运行时的增强，其中笔者认为本节中提到的所有特性 都是值得掌握的: Lambda 表达式 函数对象容器 std::function 3. 右值引用 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"进一步阅读参考文献 Bjarne Stroustrup, C++ 语言的设计与演化 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:4:5","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"容器 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:5:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"线性容器 std::array 看到这个容器的时候肯定会出现这样的问题: 为什么要引入 std::array 而不是直接使用 std::vector? 已经有了传统数组，为什么要用 std::array? 先回答第一个问题，与 std::vector 不同，std::array 对象的大小是固定的，如果容器大小是固 定的，那么可以优先考虑使用 std::array 容器。另外由于 std::vector 是自动扩容的，当存入大量的 数据后，并且对容器进行了删除操作，容器并不会自动归还被删除元素相应的内存，这时候就需要手动 运行 shrink_to_fit() 释放这部分内存。 std::vector\u003cint\u003e v; std::cout \u003c\u003c \"size:\" \u003c\u003c v.size() \u003c\u003c std::endl; // 输出 0 std::cout \u003c\u003c \"capacity:\" \u003c\u003c v.capacity() \u003c\u003c std::endl; // 输出 0 // 如下可看出 std::vector 的存储是自动管理的，按需自动扩张 // 但是如果空间不足，需要重新分配更多内存，而重分配内存通常是性能上有开销的操作 v.push_back(1); v.push_back(2); v.push_back(3); std::cout \u003c\u003c \"size:\" \u003c\u003c v.size() \u003c\u003c std::endl; // 输出 3 std::cout \u003c\u003c \"capacity:\" \u003c\u003c v.capacity() \u003c\u003c std::endl; // 输出 4 // 这里的自动扩张逻辑与 Golang 的 slice 很像 v.push_back(4); v.push_back(5); std::cout \u003c\u003c \"size:\" \u003c\u003c v.size() \u003c\u003c std::endl; // 输出 5 std::cout \u003c\u003c \"capacity:\" \u003c\u003c v.capacity() \u003c\u003c std::endl; // 输出 8 // 如下可看出容器虽然清空了元素，但是被清空元素的内存并没有归还 v.clear(); std::cout \u003c\u003c \"size:\" \u003c\u003c v.size() \u003c\u003c std::endl; // 输出 0 std::cout \u003c\u003c \"capacity:\" \u003c\u003c v.capacity() \u003c\u003c std::endl; // 输出 8 // 额外内存可通过 shrink_to_fit() 调用返回给系统 v.shrink_to_fit(); std::cout \u003c\u003c \"size:\" \u003c\u003c v.size() \u003c\u003c std::endl; // 输出 0 std::cout \u003c\u003c \"capacity:\" \u003c\u003c v.capacity() \u003c\u003c std::endl; // 输出 0 而第二个问题就更加简单，使用 std::array 能够让代码变得更加 现代化，而且封装了一些操作函 数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 std::sort。 使用 std::array 很简单，只需指定其类型和大小即可: std::array\u003cint, 4\u003e arr = {1, 2, 3, 4}; arr.empty(); // 检查容器是否为空 arr.size(); // 返回容纳的元素数 // 迭代器支持 for (auto \u0026i : arr) { // ... } // 用 lambda 表达式排序 std::sort(arr.begin(), arr.end(), [](int a, int b) { return b \u003c a; }); // 数组大小参数必须是常量表达式 constexpr int len = 4; std::array\u003cint, len\u003e arr = {1, 2, 3, 4}; // 非法, 不同于 C 风格数组，std::array 不会自动退化成 T* // int *arr_p = arr; 当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法: void foo(int *p, int len) { return; } std::array\u003cint, 4\u003e arr = {1,2,3,4}; // C 风格接口传参 // foo(arr, arr.size()); // 非法, 无法隐式转换 foo(\u0026arr[0], arr.size()); foo(arr.data(), arr.size()); // 使用 ‘std::sort‘ std::sort(arr.begin(), arr.end()); std::forward_list std::forward_list 是一个列表容器，使用方法和 std::list 基本类似，因此我们就不花费篇幅进 行介绍了。 需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问(这也是链表的特点)，也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:5:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"无序容器 我们已经熟知了传统 C++ 中的有序容器 std::map/std::set，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 \u003c 操作符比较元素大小并判断 元素是否相同，并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 \u003c 操作符的顺序来逐个遍历。 而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。 C++11 引入了的两组无序容器分别是:std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。 它们的用法和原有的 std::map/std::multimap/std::set/set::multiset 基本类似，由于这些容器我们已经很熟悉了，便不一一举例，我们直接来比较一下 std::map 和 std::unordered_map: #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cunordered_map\u003e #include \u003cmap\u003e int main() { // 两组结构按同样的顺序初始化 std::unordered_map\u003cint, std::string\u003e u = { {1, \"1\"}, {3, \"3\"}, {2, \"2\"} }; std::map\u003cint, std::string\u003e v = { {1, \"1\"}, {3, \"3\"}, {2, \"2\"} }; // 分别对两组结构进行遍历 std::cout \u003c\u003c \"std::unordered_map\" \u003c\u003c std::endl; for( const auto \u0026 n : u) std::cout \u003c\u003c \"Key:[\" \u003c\u003c n.first \u003c\u003c \"] Value:[\" \u003c\u003c n.second \u003c\u003c \"]\\n\"; std::cout \u003c\u003c std::endl; std::cout \u003c\u003c \"std::map\" \u003c\u003c std::endl; for( const auto \u0026 n : v) std::cout \u003c\u003c \"Key:[\" \u003c\u003c n.first \u003c\u003c \"] Value:[\" \u003c\u003c n.second \u003c\u003c \"]\\n\"; } 最终输出结果为： std::unordered_map Key:[2] Value:[2] Key:[3] Value:[3] Key:[1] Value:[1] std::map Key:[1] Value:[1] Key:[2] Value:[2] Key:[3] Value:[3] ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:5:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"元组 了解过 Python 的程序员应该知道元组的概念，纵观传统 C++ 中的容器，除了 std::pair 外，似 乎没有现成的结构能够用来存放不同类型的数据(通常我们会自己定义结构)。但 std::pair 的缺陷是 显而易见的，只能保存两个元素。 元组基本操作 关于元组的使用有三个核心的函数: std::make_tuple: 构造元组 std::get: 获得元组某个位置的值 std::tie: 元组拆包 #include \u003ctuple\u003e #include \u003ciostream\u003e auto get_student(int id) { // 返回类型被推断为 std::tuple\u003cdouble, char, std::string\u003e if (id == 0) return std::make_tuple(3.8, ’A’, \" 张三\"); if (id == 1) return std::make_tuple(2.9, ’C’, \" 李四\"); if (id == 2) return std::make_tuple(1.7, ’D’, \" 王五\"); return std::make_tuple(0.0, ’D’, \"null\"); // 如果只写 0 会出现推断错误, 编译失败 } int main() { auto student = get_student(0); std::cout \u003c\u003c \"ID: 0, \" \u003c\u003c \"GPA: \" \u003c\u003c std::get\u003c0\u003e(student) \u003c\u003c \", \" \u003c\u003c \" 成绩: \" \u003c\u003c std::get\u003c1\u003e(student) \u003c\u003c \", \" \u003c\u003c \" 姓名: \" \u003c\u003c std::get\u003c2\u003e(student) \u003c\u003c ’\\n’; double gpa; char grade; std::string name; // 元组进行拆包 std::tie(gpa, grade, name) = get_student(1); std::cout \u003c\u003c \"ID: 1, \" \u003c\u003c \"GPA: \" \u003c\u003c gpa \u003c\u003c \", \" \u003c\u003c \" 成绩: \" \u003c\u003c grade \u003c\u003c \", \" \u003c\u003c \" 姓名: \" \u003c\u003c name \u003c\u003c ’\\n’; } std::get 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象: std::tuple\u003cstd::string, double, double, int\u003e t(\"123\", 4.5, 6.7, 8); std::cout \u003c\u003c std::get\u003cstd::string\u003e(t) \u003c\u003c std::endl; std::cout \u003c\u003c std::get\u003cdouble\u003e(t) \u003c\u003c std::endl; // 非法, 引发编译期错误 std::cout \u003c\u003c std::get\u003c3\u003e(t) \u003c\u003c std::endl; 运行期索引 如果你仔细思考一下可能就会发现上面代码的问题，std::get\u003c\u003e 依赖一个编译期的常量，所以下面 的方式是不合法的: int index = 1; std::get\u003cindex\u003e(t); 那么要怎么处理?答案是，使用 std::variant\u003c\u003e(C++ 17 引入)，提供给 variant\u003c\u003e 的类型模板 参数可以让一个 variant\u003c\u003e 从而容纳提供的几种类型的变量(在其他语言，例如 Python/JavaScript 等， 表现为动态类型): #include \u003cvariant\u003e template \u003csize_t n, typename... T\u003e constexpr std::variant\u003cT...\u003e _tuple_index(const std::tuple\u003cT...\u003e\u0026 tpl, size_t i) { if constexpr (n \u003e= sizeof...(T)) throw std::out_of_range(\" 越界.\"); if (i == n) return std::variant\u003cT...\u003e{ std::in_place_index\u003cn\u003e, std::get\u003cn\u003e(tpl) }; return _tuple_index\u003c(n \u003c sizeof...(T)-1 ? n+1 : 0)\u003e(tpl, i); } template \u003ctypename... T\u003e constexpr std::variant\u003cT...\u003e tuple_index(const std::tuple\u003cT...\u003e\u0026 tpl, size_t i) { return _tuple_index\u003c0\u003e(tpl, i); } template \u003ctypename T0, typename ... Ts\u003e std::ostream \u0026 operator\u003c\u003c (std::ostream \u0026 s, std::variant\u003cT0, Ts...\u003e const \u0026 v) { std::visit([\u0026](auto \u0026\u0026 x){ s \u003c\u003c x;}, v); return s; } 这样我们就能： int i = 1; std::cout \u003c\u003c tuple_index(t, i) \u003c\u003c std::endl; 元组合并与遍历 还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现: auto new_tuple = std::tuple_cat(get_student(1), std::move(t)); 马上就能够发现，应该如何快速遍历一个元组?但是我们刚才介绍了如何在运行期通过非常数索引 一个 tuple 那么遍历就变得简单了，首先我们需要知道一个元组的长度，可以: template \u003ctypename T\u003e auto tuple_len(T \u0026tpl) { return std::tuple_size\u003cT\u003e::value; } 这样就能够对元组进行迭代了: // 迭代 for(int i = 0; i != tuple_len(new_tuple); ++i) std::cout \u003c\u003c tuple_index(new_tuple, i) \u003c\u003c std::endl; ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:5:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 本章简单介绍了现代 C++ 中新增的容器，它们的用法和传统 C++ 中已有的容器类似，相对简单， 可以根据实际场景丰富的选择需要使用的容器，从而获得更好的性能。 std::tuple 虽然有效，但是标准库提供的功能有限，没办法满足运行期索引和迭代的需求，好在我 们还有其他的方法可以自行实现。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:5:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"智能指针与内存管理 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"RAII 与引用计数 了解 Objective-C/Swift 的程序员应该知道引用计数的概念。引用计数这种计数是为了防止内存泄 露而产生的。基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那 么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减 为零时，就自动删除指向的堆内存。 在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源 而导致泄露。所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数(在 离开作用域时调用)的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。 凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 new 和 delete 去『记得』对资源进行释放。而 C++11 引入智能指针的概念，使用引用计数的想法，让程序员不 再需要关心手动释放内存。这些智能指针就包括 std::shared_ptr/std::unique_ptr/std::weak_ptr， 使用它们需要包含头文件 。 注意:引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过 程中也不会造成长时间的等待，更能够清晰明确的表明资源的生命周期。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"std::shared_ptr std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当引用计数变为零的时候就会将对象自动删除。 但还不够，因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。 std::make_shared 就能够用来消除显式的使用 new，所以 std::make_shared 会分配创建传入参数中的对象，并返回这个对象类型的 std::shared_ptr 指针。例如: #include \u003ciostream\u003e #include \u003cmemory\u003e void foo(std::shared_ptr\u003cint\u003e i) { (*i)++; } int main() { // auto pointer = new int(10); // illegal, no direct assignment // Constructed a std::shared_ptr auto pointer = std::make_shared\u003cint\u003e(10); foo(pointer); std::cout \u003c\u003c *pointer \u003c\u003c std::endl; // 11 // The shared_ptr will be destructed before leaving the scope return 0; } std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数，并通过 use_count() 来查看一个对象的引用计数。例如: auto pointer = std::make_shared\u003cint\u003e(10); auto pointer2 = pointer; // 引用计数 +1 auto pointer3 = pointer; // 引用计数 +1 int *p = pointer.get(); // 这样不会增加引用计数 std::cout \u003c\u003c \"pointer.use_count() = \" \u003c\u003c pointer.use_count() \u003c\u003c std::endl; // 3 std::cout \u003c\u003c \"pointer2.use_count() = \" \u003c\u003c pointer2.use_count() \u003c\u003c std::endl; // 3 std::cout \u003c\u003c \"pointer3.use_count() = \" \u003c\u003c pointer3.use_count() \u003c\u003c std::endl; // 3 pointer2.reset(); std::cout \u003c\u003c \"reset pointer2:\" \u003c\u003c std::endl; std::cout \u003c\u003c \"pointer.use_count() = \" \u003c\u003c pointer.use_count() \u003c\u003c std::endl; // 2 std::cout \u003c\u003c \"pointer2.use_count() = \" \u003c\u003c pointer2.use_count() \u003c\u003c std::endl; // 0, pointer2 已 reset std::cout \u003c\u003c \"pointer3.use_count() = \" \u003c\u003c pointer3.use_count() \u003c\u003c std::endl; // 2 pointer3.reset(); std::cout \u003c\u003c \"reset pointer3:\" \u003c\u003c std::endl; std::cout \u003c\u003c \"pointer.use_count() = \" \u003c\u003c pointer.use_count() \u003c\u003c std::endl; // 1 std::cout \u003c\u003c \"pointer2.use_count() = \" \u003c\u003c pointer2.use_count() \u003c\u003c std::endl; // 0 std::cout \u003c\u003c \"pointer3.use_count() = \" \u003c\u003c pointer3.use_count() \u003c\u003c std::endl; // 0, pointer3 已 reset ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"std::unique_ptr std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代 码的安全: std::unique_ptr\u003cint\u003e pointer = std::make_unique\u003cint\u003e(10); // make_unique 从 C++14 引入 std::unique_ptr\u003cint\u003e pointer2 = pointer; // 非法 make_unique 并不复杂，C++11 没有提供 std::make_unique，可以自行实现: template\u003ctypename T, typename ...Args\u003e std::unique_ptr\u003cT\u003e make_unique( Args\u0026\u0026 ...args ) { return std::unique_ptr\u003cT\u003e( new T( std::forward\u003cArgs\u003e(args)... ) ); } 至于为什么没有提供，C++ 标准委员会主席 Herb Sutter 在他的博客中提到原因是因为『被 他们忘记了』。 既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr，例如: #include \u003ciostream\u003e #include \u003cmemory\u003e struct Foo { Foo() { std::cout \u003c\u003c \"Foo::Foo\" \u003c\u003c std::endl; } ~Foo() { std::cout \u003c\u003c \"Foo::~Foo\" \u003c\u003c std::endl; } void foo() { std::cout \u003c\u003c \"Foo::foo\" \u003c\u003c std::endl; } }; void f(const Foo \u0026) { std::cout \u003c\u003c \"f(const Foo\u0026)\" \u003c\u003c std::endl; } int main() { std::unique_ptr\u003cFoo\u003e p1(std::make_unique\u003cFoo\u003e()); // p1 不空, 输出 if (p1) p1-\u003efoo(); { std::unique_ptr\u003cFoo\u003e p2(std::move(p1)); // p2 不空, 输出 f(*p2); // p2 不空, 输出 if(p2) p2-\u003efoo(); // p1 为空, 无输出 if(p1) p1-\u003efoo(); p1 = std::move(p2); // p2 为空, 无输出 if(p2) p2-\u003efoo(); std::cout \u003c\u003c \"p2 被销毁\" \u003c\u003c std::endl; } // p1 不空, 输出 if (p1) p1-\u003efoo(); // Foo 的实例会在离开作用域时被销毁 } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"std::weak_ptr 如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。看下面这个例子: struct A; struct B; struct A { std::shared_ptr\u003cB\u003e pointer; ~A() { std::cout \u003c\u003c \"A 被销毁\" \u003c\u003c std::endl; } }; struct B { std::shared_ptr\u003cA\u003e pointer; ~B() { std::cout \u003c\u003c \"B 被销毁\" \u003c\u003c std::endl; } }; int main() { auto a = std::make_shared\u003cA\u003e(); auto b = std::make_shared\u003cB\u003e(); a-\u003epointer = b; b-\u003epointer = a; } 运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，这使得 a,b 的引 用计数均变为了 2，而离开作用域时，a,b 智能指针被析构，却只能造成这块区域的引用计数减一，这样 就导致了 a,b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了 内存泄露，如图 shared_ptr 相互引用导致无法释放 解决这个问题的办法就是使用弱引用指针 std::weak_ptr，std::weak_ptr 是一种弱引用(相比较而言 std::shared_ptr 就是一种强引用)。弱引用不会引起引用计数增加，当换用弱引用时候，最终的 释放流程如图所示: weak_ptr 相互引用可以释放 在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。 std::weak_ptr 没有 * 运算符和 -\u003e 运算符，所以不能够对资源进行操作，它可以用于检查 std::shared_ptr 是否存在，其 expired() 方法能在资源未被释放时，会返回 false，否则返回 true; 除此之外，它也可以用于获取指向原始对象的 std::shared_ptr 指针，其 lock() 方法在原始对象未被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回 nullptr。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 智能指针这种技术并不新奇，在很多语言中都是一种常见的技术，现代 C++ 将这项技术引进，在 一定程度上消除了 new/delete 的滥用，是一种更加成熟的编程范式。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:5","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"进一步阅读的参考资料 stackoverflow 上关于『C++11 为什么没有 make_unique』的讨论 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:6:6","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"正则表达式 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:7:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"正则表达式简介 正则表达式不是 C++ 语言的一部分，这里仅做简单的介绍。 正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求: 检查一个串是否包含某种形式的子串; 将匹配的子串替换; 从某个串中取出符合条件的子串。 正则表达式是由普通字符(例如 a 到 z)以及特殊字符组成的文字模式。模式描述在搜索文本时要 匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所 有数字、所有标点符号和一些其他符号。 特殊字符 特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表: 特殊字符 说明 $ 匹配输入字符串的结尾位置 (,) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用 * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 . 匹配除换行符 \\n 之外的任何单字符 [ 标记一个中括号表达式的开始 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如，n 匹配字符 n。\\n 匹配换行符。序列 \\\\ 匹配 \\ 字符，而 \\( 则匹配 ( 字符。 ˆ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合 { 标记限定符表达式的开始 | 指明两项之间的一个选择 限定符 限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表: 限定符 说明 * 匹配前面的子表达式零次或多次。例如，foo* 能匹配 fo 以及 foooo。* 等价于 {0,} + 匹配前面的子表达式一次或多次。例如，foo+ 能匹配 foo 以及 foooo，但不能匹配 fo。+ 等价于 {1,} ? 匹配前面的子表达式零次或一次。例如，Your(s)? 可以匹配 Your 或 Yours 中的 Your 。? 等价于 {0,1} {n} n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 for 中的 o，但是能匹配 foo 中的两个 o {n,} n 是一个非负整数。至少匹配 n 次。例如，o{2,} 不能匹配 for 中的 o，但能匹配 foooooo 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o* {n,m} m 和 n 均为非负整数，其中 n 小于等于 m。最少匹配 n 次且最多匹配 m 次。例如,o{1,3} 将匹配 foooooo 中的前三个o。o{0,1} 等价于 o?。注意，在逗号和两个数之间不能有空格 有了这两张表，我们通常就能够读懂几乎所有的正则表达式了。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:7:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"std::regex 及其相关 对字符串内容进行匹配的最常见手段就是使用正则表达式。可惜在传统 C++ 中正则表达式一直没有得到语言层面的支持，没有纳入标准库，而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时，使用正则表达式也是工业界最为成熟的普遍做法。 一般的解决方案就是使用 boost 的正则表达式库。而 C++11 正式将正则表达式的的处理方法纳入标准库的行列，从语言级上提供了标准的支持，不再依赖第三方。 C++11 提供的正则表达式库操作 std::string 对象，模式 std::regex (本质是 std::basic_regex) 进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch(本质是 std::match_results 对象)。 我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式: [a-z]+\\.txt: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多次，因此 [a-z]+ 能够匹配一个小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字符，而 \\. 则表示匹配字符 .，最后的 txt 表示严格匹配 txt 这三个字母。因此这个正则表达式的 所要匹配的内容就是由纯小写字母组成的文本文件。 std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是 传入 std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。例如: #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cregex\u003e int main() { std::string fnames[] = {\"foo.txt\", \"bar.txt\", \"test\", \"a0.txt\", \"AAA.txt\"}; // 在 C++ 中 \\ 会被作为字符串内的转义符，为使 \\. 作为正则表达式传递进去生效，需要对 \\ 进行二次转义， std::regex txt_regex(\"[a-z]+\\\\.txt\"); for (const auto \u0026fname: fnames) std::cout \u003c\u003c fname \u003c\u003c \": \" \u003c\u003c std::regex_match(fname, txt_regex) \u003c\u003c std::endl; } 另一种常用的形式就是依次传入 std::string/std::smatch/std::regex 三个参数，其中std::smatch 的本质其实是 std::match_results。在标准库中，std::smatch 被定义为了 std::match_results\u003cstd::string 也就是一个子串迭代器类型的 match_results。使用 std::smatch 可以方便的对匹配的结果进行获取，例如: std::regex base_regex(\"([a-z]+)\\\\.txt\"); std::smatch base_match; for(const auto \u0026fname: fnames) { if (std::regex_match(fname, base_match, base_regex)) { // std::smatch 的第一个元素匹配整个字符串 // std::smatch 的第二个元素匹配了第一个括号表达式 if (base_match.size() == 2) { std::string base = base_match[1].str(); std::cout \u003c\u003c \"sub-match[0]: \" \u003c\u003c base_match[0].str() \u003c\u003c std::endl; std::cout \u003c\u003c fname \u003c\u003c \" sub-match[1]: \" \u003c\u003c base \u003c\u003c std::endl; } } } 以上两个代码段的输出结果为: foo.txt: 1 bar.txt: 1 test: 0 a0.txt: 0 AAA.txt: 0 sub-match[0]: foo.txt foo.txt sub-match[1]: foo sub-match[0]: bar.txt bar.txt sub-match[1]: bar ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:7:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 本节简单介绍了正则表达式本身，然后根据使用正则表达式的主要需求，通过一个实际的例子介绍了正则表达式库的使用。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:7:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"进一步阅读的参考资料 知乎『如何评价 GCC 的 C++11 正则表达式?』中原库作者 Tim Shen 的回答 正则表达式库文档 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:7:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"并行与并发 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"并行基础 std::thread 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含 \u003cthread\u003e 头文件，它提供了很多基本的线程操作，例如 get_id() 来获取所创建线程的线程 ID，使用 join() 来加入一个线程等等，例如: #include \u003ciostream\u003e #include \u003cthread\u003e int main() { std::thread t([]() { std::cout \u003c\u003c \"hello world.\" \u003c\u003c std::endl; }); t.join(); return 0; } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"互斥量与临界区 我们在操作系统、亦或是数据库的相关知识中已经了解过了有关并发技术的基本知识，mutex 就是其中的核心之一。C++11 引入了 mutex 相关的类，其所有相关的函数都放在 头文件中。 std::mutex 是 C++11 中最基本的 mutex 类，通过实例化 std::mutex 可以创建互斥量，而通过其 成员函数 lock() 可以进行上锁，unlock() 可以进行解锁。但是在实际编写代码的过程中，最好不去直 接调用成员函数，因为调用成员函数就需要在每个临界区的出口处调用 unlock()，当然，还包括异常。 这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类 std::lock_guard。RAII 在不失代码简洁性 的同时，很好的保证了代码的异常安全性。 在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如: #include \u003ciostream\u003e #include \u003cmutex\u003e #include \u003cthread\u003e int v = 1; void critical_section(int change_v) { static std::mutex mtx; std::lock_guard\u003cstd::mutex\u003e lock(mtx); // 执行竞争操作 v = change_v; // 离开此作用域后 mtx 会被释放 } int main() { std::thread t1(critical_section, 2), t2(critical_section, 3); t1.join(); t2.join(); std::cout \u003c\u003c v \u003c\u003c std::endl; return 0; } 由于 C++ 保证了所有栈对象在生命周期结束时会被销毁，所以这样的代码也是异常安全的。无论 critical_section() 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 unlock()。 而 std::unique_lock 则相对于 std::lock_guard 出现的，std::unique_lock 更加灵活，std::unique_lock 的对象会以独占所有权(没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权)的方式管理 mutex 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 std::unique_lock。 std::lock_guard 不能显式的调用 lock 和 unlock，而 std::unique_lock 可以在声明后的任意位置调用，可以缩小锁的作用范围，提供更高的并发度。 如果你用到了条件变量 std::condition_variable::wait 则必须使用 std::unique_lock 作为参数。 例如： #include \u003ciostream\u003e #include \u003cmutex\u003e #include \u003cthread\u003e int v = 1; void critical_section(int change_v) { static std::mutex mtx; std::unique_lock\u003cstd::mutex\u003e lock(mtx); // 执行竞争操作 v = change_v; std::cout \u003c\u003c v \u003c\u003c std::endl; // 将锁进行释放 lock.unlock(); // 在此期间，任何人都可以抢夺 v 的持有权 // 开始另一组竞争操作，再次加锁 lock.lock(); v += 1; std::cout \u003c\u003c v \u003c\u003c std::endl; } int main() { std::thread t1(critical_section, 2), t2(critical_section, 3); t1.join(); t2.join(); return 0; } ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"期物 期物(Future)表现为 std::future，它提供了一个访问异步操作结果的途径，这句话很不好理解。为了理解这个特性，我们需要先理解一下在 C++11 之前的多线程行为。 试想，如果我们的主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务，并返回我一个结 果。而这时候，线程 A 可能正在忙其他的事情，无暇顾及 B 的结果，所以我们会很自然的希望能够在某 个特定的时间获得线程 B 的结果。 在 C++11 的 std::future 被引入之前，通常的做法是:创建一个线程 A，在线程 A 里启动任务 B，当准备完毕后发送一个事件，并将结果保存在全局变量中。而主函数线程 A 里正在做其他的事情，当 需要结果的时候，调用一个线程等待函数来获得执行的结果。 而 C++11 提供的 std::future 简化了这个流程，可以用来获取异步任务的结果。自然地，我们很 容易能够想象到把它作为一种简单的线程同步手段，即屏障(barrier)。 为了看一个例子，我们这里额外使用 std::packaged_task，它可以用来封装任何可以调用的目标， 从而用于实现异步的调用。举例来说: #include \u003ciostream\u003e #include \u003cfuture\u003e #include \u003cthread\u003e int main() { // 将一个返回值为 7 的 lambda 表达式封装到 task 中 // std::packaged_task 的模板参数为要封装函数的类型 std::packaged_task\u003cint()\u003e task([](){return 7;}); // 获得 task 的期物 std::future\u003cint\u003e result = task.get_future(); // 在一个线程中执行 task std::thread(std::move(task)).detach(); std::cout \u003c\u003c \"waiting...\"; result.wait(); // 在此设置屏障，阻塞到期物的完成 // 输出执行结果 std::cout \u003c\u003c \"done!\" \u003c\u003c std:: endl \u003c\u003c \"future result is \" \u003c\u003c result.get() \u003c\u003c std::endl; return 0; } 在封装好要调用的目标后，可以使用 get_future() 来获得一个 std::future 对象，以便之后实施 线程同步。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"条件变量 条件变量 std::condition_variable 是为了解决死锁而生，当互斥操作不够用而引入的。比如，线程 可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临 界区使得条件为真时，就会发生死锁。所以，condition_variable 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。std::condition_variable 的 notify_one() 用于唤醒一个线程;notify_all() 则是通知所有线程。下面是一个生产者和消费者模型的例子: #include \u003cqueue\u003e #include \u003cchrono\u003e #include \u003cmutex\u003e #include \u003cthread\u003e #include \u003ciostream\u003e #include \u003ccondition_variable\u003e int main() { std::queue\u003cint\u003e produced_nums; std::mutex mtx; std::condition_variable cv; bool notified = false; // 通知信号 // 生产者 auto producer = [\u0026]() { for (int i = 0; ; i++) { std::this_thread::sleep_for(std::chrono::milliseconds(900)); std::unique_lock\u003cstd::mutex\u003e lock(mtx); std::cout \u003c\u003c \"producing \" \u003c\u003c i \u003c\u003c std::endl; produced_nums.push(i); notified = true; cv.notify_all(); // 此处也可以使用 notify_one } }; // 消费者 auto consumer = [\u0026]() { while (true) { std::unique_lock\u003cstd::mutex\u003e lock(mtx); while (!notified) { // 避免虚假唤醒 cv.wait(lock); } // 短暂取消锁，使得生产者有机会在消费者消费空前继续生产 lock.unlock(); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // 消费者慢于生产者 lock.lock(); while (!produced_nums.empty()) { std::cout \u003c\u003c \"consuming \" \u003c\u003c produced_nums.front() \u003c\u003c std::endl; produced_nums.pop(); } notified = false; } }; // 分别在不同的线程中运行 std::thread p(producer); std::thread cs[2]; for (int i = 0; i \u003c 2; ++i) { cs[i] = std::thread(consumer); } p.join(); for (int i = 0; i \u003c 2; ++i) { cs[i].join(); } return 0; } 值得一提的是，在生产者中我们虽然可以使用 notify_one()，但实际上并不建议在此处使用，因为在多消费者的情况下，我们的消费者实现中简单放弃了锁的持有，这使得可能让其他消费者争夺此锁，从 而更好的利用多个消费者之间的并发。话虽如此，但实际上因为 std::mutex 的排他性，我们根本无法 期待多个消费者能真正意义上的并行消费队列的中生产的内容，我们仍需要粒度更细的手段。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"原子操作与内存模型 细心的读者可能会对前一小节中生产者消费者模型的例子可能存在编译器优化导致程序出错的情况 产生疑惑。例如，布尔值 notified 没有被 volatile 修饰，编译器可能对此变量存在优化，例如将其作 为一个寄存器的值，从而导致消费者线程永远无法观察到此值的变化。这是一个好问题，为了解释清楚 这个问题，我们需要进一步讨论从 C++ 11 起引入的内存模型这一概念。我们首先来看一个问题，下面 这段代码输出结果是多少？ #include \u003cthread\u003e #include \u003ciostream\u003e int main() { int a = 0; int flag = 0; std::thread t1([\u0026]() { while (flag != 1); int b = a; std::cout \u003c\u003c \"b = \" \u003c\u003c b \u003c\u003c std::endl; }); std::thread t2([\u0026]() { a = 5; flag = 1; }); t1.join(); t2.join(); return 0; } 从直观上看，t2 中 a = 5; 这一条语句似乎总在 flag = 1; 之前得到执行，而 t1 中 while (flag != 1) 似乎保证了 std::cout \u003c\u003c \"b = \" \u003c\u003c b \u003c\u003c std::endl; 不会再标记被改变前执行。从逻辑上看，似乎 b 的值应该等于 5。但实际情况远比此复杂得多，或者说这段代码本身属于未定义的行为，因为对于 a 和 flag 而言，他们在两个并行的线程中被读写，出现了竞争。除此之外，即便我们忽略竞争读写，仍然可能受 CPU 的乱序执行，编译器对指令的重排的影响，导致 a = 5 发生在 flag = 1 之后。 从而 b 可能输出 0。 原子操作 std::mutex 可以解决上面出现的并发读写的问题，但互斥锁是操作系统级的功能，这是因为一个互斥锁的实现通常包含两条基本原理: 提供线程间自动的状态转换，即『锁住』这个状态 保障在互斥锁操作期间，所操作变量的内存与临界区外进行隔离 这是一组非常强的同步条件，换句话说当最终编译为 CPU 指令时会表现为非常多的指令(我们之 后再来看如何实现一个简单的互斥锁)。这对于一个仅需原子级操作(没有中间态)的变量，似乎太苛刻 了。 关于同步条件的研究有着非常久远的历史，我们在这里不进行赘述。读者应该明白，在现代 CPU 体 系结构下提供了 CPU 指令级的原子操作，因此在 C++11 中多线程下共享变量的读写这一问题上，还引 入了 std::atomic 模板，使得我们实例化一个原子类型，将一个原子类型读写操作从一组指令，最小化 到单个 CPU 指令。例如: std::atomic\u003cint\u003e counter; 并为整数或浮点数的原子类型提供了基本的数值成员函数，举例来说，包括 fetch_add, fetch_sub 等，同时通过重载方便的提供了对应的 +，- 版本。比如下面的例子: #include \u003catomic\u003e #include \u003cthread\u003e #include \u003ciostream\u003e std::atomic\u003cint\u003e count = {0}; int main() { std::thread t1([](){ count.fetch_add(1); }); std::thread t2([](){ count++; // 等价于 fetch_add count += 1; // 等价于 fetch_add }); t1.join(); t2.join(); std::cout \u003c\u003c count \u003c\u003c std::endl; return 0; } 当然，并非所有的类型都能提供原子操作，这是因为原子操作的可行性取决于 CPU 的架构以及所实 例化的类型结构是否满足该架构对内存对齐条件的要求，因而我们总是可以通过 std::atomic::is_lock_free 来检查该原子类型是否需支持原子操作，例如: #include \u003catomic\u003e #include \u003ciostream\u003e struct A { float x; int y; long long z; }; int main() { std::atomic\u003cA\u003e a; std::cout \u003c\u003c std::boolalpha \u003c\u003c a.is_lock_free() \u003c\u003c std::endl; return 0; } 一致性模型 并行执行的多个线程，从某种宏观层面上讨论，可以粗略的视为一种分布式系统。在分布式系统中，任何通信乃至本地操作都需要消耗一定时间，甚至出现不可靠的通信。 如果我们强行将一个变量 v 在多个线程之间的操作设为原子操作，即任何一个线程在操作完 v 后， 其他线程均能同步感知到 v 的变化，则对于变量 v 而言，表现为顺序执行的程序，它并没有由于引入多 线程而得到任何效率上的收益。对此有什么办法能够适当的加速呢?答案便是削弱原子操作的在进程间 的同步条件。 从原理上看，每个线程可以对应为一个集群节点，而线程间的通信也几乎等价于集群节点间的通信。削弱进程间的同步条件，通常我们会考虑四种不同的一致性模型: 线性一致性 又称强一致性或原子一致性。它要求任何一次读操作都能读到某个数据的最近一次写 的数据，并且所有线程的操作顺序与全局时钟下的顺序是一致的。 线性一致性 在这种情况下线程 T1, T2 对 x 的两次写操作是原子的，且 x.store(1) 是严格的发生在 x.store(2) 之前，x.store(2) 严格的发生在 x.load() 之前。值得一提的是，线性一致性对全局时钟的要求 是难以实现的，这也是人们不断研究比这个一致性更弱条件下其他一致性的算法的原因。 顺序一致性 同样要求任何一次读操作都能读到数据最近一次写入的数据，但未要求与全局时钟的 顺序一致。 或者： 顺序一致性 在顺序一致性的要求下，x.load() 必须读到最近一次写入的数据，因此 x.store(2) 与 x.store(1) 并无任何先后保障，即只要 T2 的 x.store(2) 发生在 x.store(3) 之前即可。 因果一致性 它的要求进一步降低，只需要有因果关系的操作顺序得到保障，而非因果关系的操作顺序则不做要求。 或者： 亦或者： 因果一致性 上面给出的三种例子都是属于因果一致的，因为整个过程中，只有 c 对 a 和 b 产生依赖，而 x 和 y 在此例子中表现为没有关系(但实际情况中我们需要更详细的信息才能确定 x 与 y 确实无关) 最终一致性 是最弱的一致性要求，它只保障某个操作在未来的某个时间节点上会被观察到，但并 未要求被观察到的时间。因此我们甚至可以对此条件稍作加强，例如规定某个操作被观察到的时间 总是有界的。当然这已经不在我们的讨论范围之内了。 最终一致性 在上面的情况中，如果我们假设 x 的初始值为 0，则 T2 中四次 x.read() 结果可能但不限于以下 情况: 3 4 4 4 // x 的写操作被很快观察到 0 3 3 4 // x 的写操作被观察到的时间存在一定延迟 0 0 0 4 // 最后一次读操作读到了 x 的最终值，但此前的变化并未观察到 0 0 0 0 // 在当前时间段内 x 的写操作均未被观察到，但未来某个时间点上一定能观察到 x 为 4 的情况 内存顺序 为了追求极致的性能，实现各种强度要求的一致性，C++11 为原子操作定义了六种不同的内存顺序 std::memory_order 的选项，表达了四种多线程间的同步模型: 宽松模型 在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间 原子操作的顺序是任意的。类型通过 std::memory_order_relaxed 指定。我们来看一个例子: std::atomic\u003cint\u003e counter = {0}; std::vector\u003cstd::thread\u003e vt; for (int i = 0; i \u003c 100; ++i) { vt.emplace_back([\u0026](){ counter.fetch_add(1, std::memory_order_relaxed); }); } for (auto\u0026 t : vt) { t.join(); } std::cout \u003c\u003c \"current counter:\" \u003c\u003c counter \u003c\u003c std::endl; 释放/消费模型 在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但另一个线程会对该值的某次操作产生依赖，即后者依赖前者。具体而言，线程 A 完成了三次对 x 的 写操作，线程 B 仅依赖其中第三次 x 的写操作，与 x 的前两次写行为无关，则当 A 主动 x.release() 时候(即使用 std::memory_order_release)，选项 std::memory_order_consume 能够确保 B 在 调用 x.load() 时候观察到 A 中第三次对 x 的写操作。我们来看一个例子: // 初始化为 nullptr 防止 consumer 线程从野指针进行读取 std::atomic\u003cint*\u003e ptr(nullptr); int v; std::thread producer([\u0026]() { int* p = new int(42); v = 1024; ptr.store(p, std::memory_order_release); }); std::thr","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:5","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 C++11 语言层提供了并发编程的相关支持，本节简单的介绍了 std::thread, std::mutex, std::future 这些并发编程中不可回避的重要工具。除此之外，我们还介绍了 C++11 最重要的几个特 性之一的『内存模型』，它们为 C++ 在标准化高性能计算中提供了重要的基础。 ### 进一步阅读的参考资料 [C++ 并发编程 (中文版)](https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details) [线程支持库文档](https://en.cppreference.com/w/cpp/thread) ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:8:6","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"文件系统 文件系统库提供了文件系统、路径、常规文件、目录等等相关组件进行操作的相关功能。和正则表达式库类似，他也是最先由 boost 发起，并最终被合并为 C++ 标准的众多库之一。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:9:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"其他杂项 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"新类型 long long int long long int 并不是 C++11 最先引入的，其实早在 C99，long long int 就已经被纳入 C 标 准中，所以大部分的编译器早已支持。C++11 的工作则是正式把它纳入标准库，规定了一个 long long int 类型至少具备 64 位的比特数。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"noexcept 的修饰和操作 C++ 相比于 C 的一大优势就在于 C++ 本身就定义了一套完整的异常处理机制。然而在 C++11之前，几乎没有人去使用在函数名后书写异常声明表达式，从 C++11 开始，这套机制被弃用，所以我们不去讨论也不去介绍以前这套机制是如何工作如何使用，你更不应该主动去了解它。 C++11 将异常的声明简化为以下两种情况: 函数可能抛出任何异常 函数不能抛出任何异常 并使用 noexcept 对这两种行为进行限制，例如: void may_throw(); // 可能抛出异常 void no_throw() noexcept; // 不可能抛出异常 使用 noexcept 修饰过的函数如果抛出异常，编译器会使用 std::terminate() 来立即终止程序运 行。 noexcept 还能够做操作符，用于操作一个表达式，当表达式无异常时，返回 true，否则返回 false。 #include \u003ciostream\u003e void may_throw() { throw true; } auto non_block_throw = [] { may_throw(); }; void no_throw() noexcept { return; } auto block_throw = []() noexcept { no_throw(); }; int main() { std::cout \u003c\u003c std::boolalpha \u003c\u003c \"may_throw() noexcept? \" \u003c\u003c noexcept(may_throw()) \u003c\u003c std::endl \u003c\u003c \"no_throw() noexcept? \" \u003c\u003c noexcept(no_throw()) \u003c\u003c std::endl \u003c\u003c \"lmay_throw() noexcept? \" \u003c\u003c noexcept(non_block_throw()) \u003c\u003c std::endl \u003c\u003c \"lno_throw() noexcept? \" \u003c\u003c noexcept(block_throw()) \u003c\u003c std::endl; return 0; } noexcept 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发。 例如: try { may_throw(); } catch (...) { std::cout \u003c\u003c \" 捕获异常, 来自 may_throw()\" \u003c\u003c std::endl; } try { non_block_throw(); } catch (...) { std::cout \u003c\u003c \" 捕获异常, 来自 non_block_throw()\" \u003c\u003c std::endl; } try { block_throw(); } catch (...) { std::cout \u003c\u003c \" 捕获异常, 来自 block_throw()\" \u003c\u003c std::endl; } 最终输出为： 捕获异常, 来自 may_throw() 捕获异常, 来自 non_block_throw() ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"字面量 原是字符串字面量 传统 C++ 里面要编写一个充满特殊字符的字符串其实是非常痛苦的一件事情，比如一个 包含 HTML 本体的字符串需要添加大量的转义符，例如一个 Windows 上的文件路径经常会: C:\\File\\To\\Path。 C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 R 来修饰这个字符串，同时， 将原始字符串使用括号包裹，例如: #include \u003ciostream\u003e #include \u003cstring\u003e int main() { std::string str = R\"(C:\\File\\To\\Path)\"; std::cout \u003c\u003c str \u003c\u003c std::endl; return 0; } 自定义字面量 C++11 引进了自定义字面量的能力，通过重载双引号后缀运算符实现: // 字符串字面量自定义必须设置如下的参数列表 std::string operator\"\" _wow1(const char *wow1, size_t len) { return std::string(wow1)+\"woooooooooow, amazing\"; } std::string operator\"\" _wow2 (unsigned long long i) { return std::to_string(i)+\"woooooooooow, amazing\"; } int main() { auto str = \"abc\"_wow1; auto num = 1_wow2; std::cout \u003c\u003c str \u003c\u003c std::endl; std::cout \u003c\u003c num \u003c\u003c std::endl; return 0; } 自定义字面量支持四种字面量: 整型字面量:重载时必须使用 unsigned long long、const char *、模板字面量算符参数，在上 面的代码中使用的是前者; 浮点型字面量:重载时必须使用 long double、const char *、模板字面量算符; 字符串字面量:必须使用 (const char *, size_t) 形式的参数表; 字符字面量:参数只能是 char, wchar_t, char16_t, char32_t 这几种类型。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"内存对齐 C++ 11 引入了两个新的关键字 alignof 和 alignas 来支持对内存对齐进行控制。alignof 关键字 能够获得一个与平台相关的 std::size_t 类型的值，用于查询该平台的对齐方式。当然我们有时候并不 满足于此，甚至希望自定定义结构的对齐方式，同样，C++ 11 还引入了 alignas 来重新修饰某个结构 的对齐方式。我们来看两个例子: #include \u003ciostream\u003e struct Storage { char a; int b; double c; long long d; }; struct alignas(std::max_align_t) AlignasStorage { char a; int b; double c; long long d; }; int main() { std::cout \u003c\u003c alignof(Storage) \u003c\u003c std::endl; std::cout \u003c\u003c alignof(AlignasStorage) \u003c\u003c std::endl; return 0; } 其中 std::max_align_t 要求每个标量类型的对齐方式严格一样，因此它几乎是最大标量没有差异， 进而大部分平台上得到的结果为 long double，因此我们这里得到的 AlignasStorage 的对齐要求是 8 或 16。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:4","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 本节介绍的几个特性是从仍未介绍的现代 C++ 新特性里使用频次较靠前的特性了，noexcept 是最 为重要的特性，它的一个功能在于能够阻止异常的扩散传播，有效的让编译器最大限度的优化我们的代 码。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:10:5","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"展望 C++20 C++20 如同 C++11 一样，似乎能够成为一个振奋人心的更新。例如，早在 C++11 时期就跃跃欲 试呼声极高却最终落选的 Concept，如今已经箭在弦上。C++ 组委会在讨论投票最终确定 C++20 有很 多提案，诸如 Concepts/Module/Coroutine/Ranges/ 等等。本章我们就来一览 C++20 即将引入的 那些重要特性。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:11:0","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"概念与约束 概念(Concepts)是对 C++ 模板编程的进一步增强扩展。简单来说，概念是一种编译期的特性，它 能够让编译器在编译期时对模板参数进行判断，从而大幅度增强我们在 C++ 中模板编程的体验。使用 模板进行编程时候我们经常会遇到各种令人发指的错误，这是因为到目前为止我们始终不能够对模板参 数进行检查与限制。举例而言，下面简单的两行代码会造成大量的几乎不可读的编译错误: #include \u003clist\u003e #include \u003calgorithm\u003e int main() { std::list\u003cint\u003e l = {1, 2, 3}; std::sort(l.begin(), l.end()); return 0; } 而这段代码出现错误的根本原因在于，std::sort 对排序容器必须提供随机迭代器，否则就不能使 用，而我们知道 std::list 是不支持随机访问的。用概念的语言来说就是:std::list 中的迭代器不满 足 std::sort 中随机迭代器这个概念的约束(Constraint)。在引入概念后，我们就可以这样对模板参数 进行约束: template \u003ctypename T\u003e requires Sortable\u003cT\u003e // Sortable 是一个概念 void sort(T\u0026 c); 缩写为： template\u003cSortable T\u003e // T 是一个 Sortable 的类型名 void sort(T\u0026 c) 甚至直接将其作为类型来使用： void sort(Sortable\u0026 c); // c 是一个 Sortable 类型的对象 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:11:1","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"总结 总的来说，终于在 C++20 中看到 Concepts/Ranges/Modules 这些令人兴奋的特性，这对于一门已 经三十多岁『高龄』的编程语言，依然是充满魅力的。 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:11:2","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["c++"],"content":"进一步阅读参考资料 Why Concepts didn’t make C++17? C++11/14/17/20 编译器支持情况 C++ 历史 ","date":"2022-06-01","objectID":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/:11:3","tags":["c++","c++11","c++14","c++17","c++20"],"title":"现代c++","uri":"/2022/06/0003-%E7%8E%B0%E4%BB%A3c-/"},{"categories":["git"],"content":"简单概括 git rebase 和 git merge 这两个命令旨在将更改代码从一个分支合并到另一个分支，只是两者合并方式不一样。 融合代码到公共分支的时候用 git merge，而不能使用 git rebase 融合代码到个人分支的时候用 git rebase， 可以不污染分支的提交记录，形成简洁的线性提交历史记录 git rebase aa bb, 会把 bb 合并到 aa 的头部 git checkout main \u0026\u0026 git rebase bb 会把 main 放到 bb 头部 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"rebase 详细过程 初始状态 git checkout -b aa \u0026\u0026 git commit -m \"aa\" git checkout -b main \u0026\u0026 git commit -m \"main\" git rebase aa main git commit -m \"rebase\" 上图中 main 原来的 HEAD 是 c3，rebase 之后变成了 c3'，main 分支到了 c2 之后，c3' 与 c3 相比就是 commit id 发生了变化 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:1:1","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"场景模拟 假设当前我们有master和feature分支，当你在专用分支上开发新 feature 时，然后另一个团队成员在 master 分支提交了新的 commits，这种属于正常的Git工作场景。如下图： 实际工作场景 现在，假设在 master 分支上的新提交与你正在开发的 feature 相关，需要master分支将新提交的记录合并到你的 feature 分支中。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git merge 合并master到feature git checkout feature git merge master 或者缩写一句 git merge feature master git merge feature master 由此可见，git merge 会在 feature 分支中新增一个新的 merge commit，然后将两个分支的历史联系在一起 使用 merge 是很好的方式，因为它是一种非破坏性的操作，对现有分支不会以任何方式被更改 另一方面，这也意味着 feature 分支每次需要合并上游更改时候，都会产生一个额外的合并提交。 如果 master 提交非常活跃，这可能会严重污染你的 feature 分支历史记录。不过这个问题可以使用高级选项 git log 来缓解 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:2:1","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git rebase 合并master到feature git checkout feature git rebase master 缩写为一句就是： git rebase feature master git rebase feature master rebase 会将整个 feature 分支移动到 master 分支的顶端，从而有效地整个了所有 master 分支上的提交。 但是，与merge 提交方式不同，rebase通过为原始分之中的每个提交创建全新的 commits 来重写项目历史记录，特点是仍然会在 feature 分支上形成线性提交。 rebase 的主要好处是可以获得更清晰的项目历史。首先，它消除了 git merge 所需的不必要的合并提交；其次，正如你在上图中所看到的，rebase 会产生完美线性的历史记录，你可以在 feature 分支上没有任何分叉的情况下一直追寻到项目的初始提交。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:2:2","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git rebase 原理 将 master 分之代码合并到 feature 上： 这边需要强调一个概念：reapply(重放)，使用 rebase 并不是简单的好像用 ctrl-x/ctrl-v 一样进行剪切复制一样，rebase会依次将你所要操作的分支的所有提交应用到目标分之上。 合并过程如下图： git rebase 合并图 从上图可以看出，在对特征分之进行 rebase 之后，其等效于创建了新的提交。并且老的提交也没有被销毁，只是简单的不能再被访问或者使用。 实际上在执行 rebase 的时候，有两个隐含的注意点： 在重放之前的提交的时候，Git会创建新的提交，也就是说即使你重放的提交与之前的一模一样Git也会将之当做新的独立的提交进行处理。 git rebase并不会删除老的提交，也就是说你在对某个分支执行了rebase操作之后，老的提交仍然会存放在.git文件夹的objects目录下。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:3:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"如何选择 git merge 和 git rebase 根据上面的对比可知： git merge 分支代码合并后不破坏原分支的代码提交记录，缺点就是会产生额外的提交记录并进行两条分支的合并 git rebase 优点是无须新增提交记录到目标分支，rebase后可以将对象分支的提交历史续上目标分支上，形成线性提交历史记录，进行review的时候更加直观 git merge 如果有多人进行开发并进行分支合并，会形成复杂的合并分支图 问题：既然rebase如此有用，那么可以使用rebase完全取代merge吗？ 答案：不能！ git rebase 黄金法则：不能在一个共享的分支上进行 git rebase 操作 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:4:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"rebase 的黄金法则 为什么不能在一个共享的分支上进行git rebase操作呢？ 所谓共享的分支，即是指那些存在于远端并且允许团队中的其他人进行Pull操作的分支，比如我们Git工作的master分支就是最常见的公共分支。 假设现在Bob和Anna在同一个项目组中工作，项目所属的仓库和分支大概是下图这样： 现在Bob为了图一时方便打破了原则(使用了git rebase)，正巧这时Anna在特征分支上进行了新的提交，此时的结构图大概是这样的： 当Bob推送自己的分支到远端的时候，现在的分支情况如下： 然后呢，当Anna也进行推送的时候，她会得到如下的提醒，Git提醒Anna她本地的版本与远程分支并不一致，需要向远端服务器拉取代码进行同步： 在Anna提交之前，分支中的Commit序列是如下这样的： A--B--C--D' origin/feature // GitHub A--B--D--E feature // Anna 在进行Pull操作之后，Git会进行自动地合并操作，结果大概是这样的： 这个第M个提交即代表着合并的提交，也就是Anna本地的分支与Github上的特征分支最终合并的点，现在Anna解决了所有的合并冲突并且可以Push她的代码，在Bob进行Pull之后，每个人的Git Commit结构为： 看到上面这个混乱的流线图，相信你对于Rebase和所谓的黄金准则也有了更形象深入的理解。 假设下还有一哥们Emma，第三个开发人员，在他进行了本地Commit并且Push到远端之后，仓库变为了： 另外，相信你也注意到，在远端的仓库中存有大量的重复的Commit信息，这会大大浪费我们的存储空间。 因此，不能在一个共享的分支上进行Git rebase操作,避免出现项目分支代码提交记录错乱和浪费存储空间的现象。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:5:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"使用 rebase 合并多次提交记录 rebase和merge不同的作用还有一个就是合并分支多次提交记录。 在分支开发的过程中，我们常常会出现为了调试程序而多次提交代码记录，但是这些记录的共同目的都是为了解决某一个需求，所以，是否可以将这些记录合并起来为一个新的记录会更方便进行代码的review呢？ ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:6:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"合并记录 尝试合并分支的最近 4 次提交纪录 git rebase -i HEAD~4 这时候，会自动进入 vi 编辑模式： 进入编辑模式，第一列为操作指令，第二列为commit号，第三列为commit信息。 - pick：保留该commit - reword：保留该commit但是修改commit信息 - edit：保留该commit但是要修改commit内容 - squash：将该commit和前一个commit合并 - fixup：将该commit和前一个commit合并，并不保留该commit的commit信息 - exec：执行shell命令 - drop：删除该commit 按照如上命令来修改你的提交记录： p 799770a add article s 72530e4 add article s 53284b1 add article s 9f6e388 add article 成功合并了四条记录为一条： 如果保存的时候，你碰到了这个错误： error: cannot 'squash' without a previous commit 说明你在合并记录的时候顺序错误了，压缩顺序应该是从下往上，而不是从上往下，否则就会触发上面的错误。也就是以新记录为准。 中途出现异常退出了 vi窗口，执行下面命令可以返回编辑窗口： git rebase --edit-todo 继续编辑合并记录的操作，修改完保存一下： git rebase --continue ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:6:1","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git pull -rebase 的应用 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:7:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"场景 同事都基于git flow工作流的话都会从develop拉出分支进行并行开发，这里的分支可能是多到数十个，然后彼此在进行自己的逻辑编写，时间可能需要几天或者几周。 在这期间你可能需要时不时的需要pull下远程develop分支上的同事的提交。这是个好的习惯，这样下去就可以避免你在一个无用的代码上进行长期的开发，回头来看这些代码不是新的代码。甚至是会面临很多冲突需要解决，而这个时候你可能还需要对冲突的部分代码进行测试和问题解决，你在有些时候pull代码的时候会有这样的一个提示： 通常习惯性的你可能会，”esc ：wq“，直接默认commit注释。然后你的commit log就多了一笔很不好看的log。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:7:1","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"如何移除多余的 merge commit 很简单，只要你在pull时候需要习惯性的加上—rebase参数，这样可以避免很多问题。 git pull --rebase可以免去分支中出现大量的merge commit，基本原理就像上面rebase一样，合并过程会直接融合到目标分支的顶端，形成线性历史提交。 注意： 在公共的分支上，例如master仍然要遵守rebase黄金原则，不用使用git pull –rabase进行代码的拉取，更改代码的历史提交记录。 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:7:2","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"最后 很好的git学习网站：git 命令学习 ","date":"2022-05-31","objectID":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/:8:0","tags":["git","git merge","git rebase"],"title":"git rebase与merge的区别","uri":"/2022/05/0002-rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"简单概括 git fetch 是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。 git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull \u003c==\u003e git fetch + git merge，这样可能会产生冲突，需要手动解决。 ","date":"2022-05-31","objectID":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/:1:0","tags":["git","git fetch","git pull"],"title":"git fetch与pull区别","uri":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git fetch 用法 # 将某个远程主机的更新全部取回本地 git fetch \u003c远程主机名\u003e # 只去会特定分之的更新，可以增加分支名 git fetch \u003c远程主机名\u003e \u003c分支名\u003e # 取回更新后，会返回一个 `FETCH_HEAD`，指向的是某个 branch 在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息 git log -p FETCH_HEAD ","date":"2022-05-31","objectID":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/:2:0","tags":["git","git fetch","git pull"],"title":"git fetch与pull区别","uri":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"git pull 用法 git pull \u003c远程主机名\u003e \u003c远程分支名\u003e:\u003c本地分支名\u003e # 如果远程分支是与当前分支合并，则冒号后面的部分可以省略 git pull origin xxx ","date":"2022-05-31","objectID":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/:3:0","tags":["git","git fetch","git pull"],"title":"git fetch与pull区别","uri":"/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/"},{"categories":["kernel"],"content":"ldmappings 大多数文件系统开发人员都遇到过idmapping。当从磁盘读取或写入权限、向用户空间报告所有权或用于权限检查时使用它们。本文的目标读者是想知道idmappings如何工作的文件系统开发人员。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:1:0","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"formal notes idmapping本质上是将一个id范围转换为另一个或相同范围的id。在用户空间中广泛使用的idmappings表示法惯例是: u:k:r u 表示上层idmapset u的第一个元素 k 表示下层idmapset k的第一个元素 r 参数表示idmapping的范围，即映射了多少个id。 从现在开始，我们总是在id前加上u或k，以明确我们谈论的是上idmapset中的id还是下idmapset中的id。 为了看看实际情况，让我们看看下面的idmapping: u22:k10000:r3 并写下它将生成的映射: u22 -\u003e k10000 u23 -\u003e k10001 u24 -\u003e k10002 从数学的观点来看，U 和 K 是有序集，而idmapping是 U 到 K 的有序同构，所以 U 和 K 是有序同构的。事实上，U 和 K 总是一个给定系统中所有可用id集合的有序子集。 简单地从数学角度分析这个问题有助于我们突出一些属性，这些属性使我们更容易理解如何在idmapping之间进行转换。例如，我们知道逆idmapping也是一个有序同构: k10000 -\u003e u22 k10001 -\u003e u23 k10002 -\u003e u24 考虑到我们处理的是有序同构，加上我们处理的是子集，我们可以相互嵌入idmapping，也就是说，我们可以在不同的idmapping之间进行合理的转换。例如，假设我们已经得到了三个idmappings: 1. u0:k10000:r10000 2. u0:k20000:r10000 3. u0:k30000:r10000 以及第一次idmapping产生的id k11000，它将上idmapset中的u1000映射到下idmapset中的k11000。 因为我们处理的是有序同构子集，所以询问第二个或第三个idmapping中id k11000对应的是什么是有意义的。使用的简单算法是应用第一个idmapping的逆，将k11000映射到u1000。然后，我们可以使用第二个idmapping映射或第三个idmapping映射来映射u1000。第二个idmapping将u1000映射到21000。第三个idmapping将u1000映射到u31000。 如果我们给以下三个idmappings相同的任务: 1. u0:k10000:r10000 2. u0:k20000:r200 3. u0:k30000:r300 我们将无法进行转换，因为这些集合不再是第一个idmapping的整个范围内的有序同构(然而，它们是第二个idmapping的整个范围内的有序同构。)第二个或第三个idmapping在上层idmapset u中都不包含u1000。这相当于没有id映射。我们可以简单地说u1000在第二个和第三个idmapping中是未映射的。内核将向用户空间报告未映射的id为overflowuid (uid_t)-1或overflowgid (gid_t)-1。 计算给定id映射到什么位置的算法非常简单。首先，我们需要验证范围是否可以包含目标id。为了简单起见，我们将跳过这一步。之后，如果我们想知道id映射到什么，我们可以做一些简单的计算: 如果我们想要从左到右映射: u:k:r id - u + k = n 如果我们想要从右到左映射: u:k:r id - k + u = n 除了“从左到右”，我们还可以说“向下”，除了“从右到左”，我们还可以说“向上”。很明显，向下和向上的映射是相反的。 要查看上面的简单公式是否有效，请考虑以下两个idmappings: 1. u0:k20000:r10000 2. u500:k30000:r10000 假设我们在第一个idmapping的下idmapset中给定k21000。我们想知道这是从第一个idmapping的上层idmapset中的哪个id映射过来的。我们在第一个idmapping中向上映射: id - k + u = n k21000 - k20000 + u0 = u1000 现在假设我们在第二个idmapping的上层idmapset中有一个id u1100，我们想知道这个id在第二个idmapping的下层idmapset中映射到什么。这意味着我们在第二个idmapping中向下映射: id - u + k = n u1100 - u500 + k30000 = k30600 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:1:1","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"General note 在内核环境中，idmapping可以被解释为将一系列用户空间id映射到一系列内核id: userspace-id:kernel-id:range 用户空间id总是uid_t或gid_t类型的idmap的上层idmapset中的一个元素，而内核id总是kuid_t或kgid_t类型的idmapset的下层idmapset中的一个元素。从现在开始，“用户空间id”将用于表示众所周知的uid_t和gid_t类型，而“内核id”将用于表示kuid_t和kgid_t。 内核主要关心内核id。它们在执行权限检查时使用，并存储在inode的i_uid和i_gid字段中。另一方面，用户空间id是一个由内核报告给用户空间的id，或者由用户空间传递给内核的id，或者从磁盘写入或读取的原始设备id。 注意，我们只关心内核存储idmappings的方式，而不关心用户空间如何指定它们。 在本文档的其余部分中，我们将在所有用户空间id前加上u，在所有内核id前加上k。idmappings范围将以r为前缀。因此，idmapping将被写成u0:k10000:r10000。 例如，id u1000是idmapset上层或以u1000开头的“userspace idmapset”中的id。它被映射到k11000，这是一个内核id，位于较低的idmapset或“内核idmapset”中，以k10000开头。 内核id总是由一个idmapping创建的。这样的id映射与用户名称空间相关联。因为我们主要关心idmappings是如何工作的，所以我们不需要关心idmappings是如何创建的，也不需要关心在文件系统上下文之外如何使用它们。这最好留给用户名称空间来解释。 初始用户命名空间是特殊的。它总是有一个如下形式的idmapping: u0:k0:r4294967295 它是在这个系统上所有可用id范围上的身份映射。 其他用户名称空间通常有非标识的id映射，例如: u0:k10000:r10000 当进程创建或想要更改文件的所有权时，或者当文件系统从磁盘读取文件的所有权时，根据与相关用户名称空间相关联的idmapping，用户空间id立即被转换为内核id。 例如，考虑由文件系统存储在磁盘上的文件被u1000所拥有: 如果一个文件系统要挂载在初始用户名称空间中(就像大多数文件系统那样)，那么将使用初始idmapping。正如我们看到的，这是简单的身份映射。这意味着从磁盘读取的id u1000将被映射到id k1000。因此，inode的i_uid和i_gid字段将包含k1000。 如果要以u0:k10000:r10000的id映射挂载文件系统，那么从磁盘读取的u1000将被映射到k11000。所以一个inode的i_uid和i_gid将包含k11000。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:1:2","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"转换算法 我们已经简要地看到，可以在不同的idmapping之间进行转换。现在我们将进一步了解它是如何工作的。 交叉映射 内核在很多地方都使用这种转换算法。例如，当通过stat()系统调用系列向用户空间报告文件的所有权时，使用它。 如果我们从一个idmapping中得到k11000我们可以把这个id映射到另一个idmapping中。为了使它工作，两个idmapping需要在它们的内核idmapset中包含相同的内核id。例如，考虑以下idmappings: 1. u0:k10000:r10000 2. u20000:k10000:r10000 我们在第一个idmapping中将u1000映射到k11000。然后，我们可以使用第二个idmapping的内核idmapset将k11000转换为第二个idmapping中的用户空间id: /* Map the kernel id up into a userspace id in the second idmapping. */ from_kuid(u20000:k10000:r10000, k11000) = u21000 注意，我们如何通过颠倒算法在第一个idmapping中返回内核id: /* Map the userspace id down into a kernel id in the second idmapping. */ make_kuid(u20000:k10000:r10000, u21000) = k11000 /* Map the kernel id up into a userspace id in the first idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 这个算法允许我们回答这样一个问题:给定的内核id对应于给定的idmapping中的哪个用户空间id。为了能够回答这个问题，两个idmapping都需要在各自的内核idmapset中包含相同的内核id。 例如，当内核从磁盘读取一个原始用户空间id时，它会根据与文件系统相关联的idmapping将其映射到内核id。让我们假设文件系统的id映射为u0:k20000:r10000，它从磁盘读取u1000拥有的文件。这意味着u1000将映射到k21000, k21000将存储在inode的i_uid和i_gid字段中。 当用户空间中的某人调用stat()或相关函数来获取文件的所有权信息时，内核不能简单地根据文件系统的idmapping来映射id，因为如果调用者使用idmapping，这会给出错误的所有者。 因此，内核将把id映射回调用者的idmapping中。让我们假设调用者有一个稍微不寻常的idmapping u3000:k20000:r10000，那么k21000将映射回u4000。因此，用户会看到这个文件属于u4000。 重新映射 通过两个idmapping的用户空间idmapset，可以将一个内核id从一个idmapping转换为另一个idmapping。这相当于重新映射内核id。 让我们来看一个例子。我们给出了以下两个idmappings: 1. u0:k10000:r10000 2. u0:k20000:r10000 我们在第一个idmapping中得到k11000。为了将第一个idmapping中的内核id转换为第二个idmapping中的内核id，我们需要执行两个步骤: 在第一个idmapping中将内核id映射到用户空间id: /* Map the kernel id up into a userspace id in the first idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 在第二个idmapping中将用户空间id映射到内核id: /* Map the userspace id down into a kernel id in the second idmapping. */ make_kuid(u0:k20000:r10000, u1000) = k21000 如您所见，我们在两个idmapping中都使用了用户空间idmapset来将一个idmapping中的内核id转换为另一个idmapping中的内核id。 这允许我们回答这样一个问题:我们需要使用哪个内核id才能在另一个idmapping中获得相同的用户空间id。为了回答这个问题，两个idmapping都需要在各自的用户空间idmapset中包含相同的用户空间id。 注意，在第一个idmapping中，我们可以通过颠倒算法轻松地返回内核id: 在第二个idmapping中将内核id映射到用户空间id: /* Map the kernel id up into a userspace id in the second idmapping. */ from_kuid(u0:k20000:r10000, k21000) = u1000 在第一个idmapping中将用户空间id映射到内核id: /* Map the userspace id down into a kernel id in the first idmapping. */ make_kuid(u0:k10000:r10000, u1000) = k11000 观察这种转换的另一种方法是，如果两个idmapping都有相关的用户空间id映射，则将其视为一个idmapping的倒置和另一个idmapping的应用。在使用idmapped挂载时，这将会派上用场。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:1:3","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"非法转换 在一个idmapping的内核idmapset中使用一个id作为另一个或相同idmapping的用户空间idmapset中的id永远是无效的。内核idmapset总是表示内核id空间中的一个idmapset，而用户空间idmapset表示用户空间id。所以下面的翻译是被禁止的: /* Map the userspace id down into a kernel id in the first idmapping. */ make_kuid(u0:k10000:r10000, u1000) = k11000 /* INVALID: Map the kernel id down into a kernel id in the second idmapping. */ make_kuid(u10000:k20000:r10000, k110000) = k21000 ~~~~~~~ 和同样是错误的: /* Map the kernel id up into a userspace id in the first idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 /* INVALID: Map the userspace id up into a userspace id in the second idmapping. */ from_kuid(u20000:k0:r10000, u1000) = k21000 ~~~~~ ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:1:4","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"创建文件系统对象时的Idmappings id向下映射或向上映射的概念在文件系统开发人员非常熟悉的两个内核函数中表达，我们已经在本文档中使用了它们: /* Map the userspace id down into a kernel id. */ make_kuid(idmapping, uid) /* Map the kernel id up into a userspace id. */ from_kuid(idmapping, kuid) 我们将简要介绍idmappings如何创建文件系统对象。为了简单起见，我们将只研究当VFS在调用文件系统本身之前已经完成路径查找时发生的情况。因此，我们关心的是调用vfs_mkdir()时会发生什么。我们还将假设创建文件系统对象的目录对每个人都是可读可写的。 当创建一个文件系统对象时，调用者将查看调用者的文件系统id。这些只是普通的uid_t和gid_t用户空间id，但它们在确定文件所有权时被专门使用，这就是为什么它们被称为“文件系统id”。它们通常与调用者的uid和gid相同，但也可以不同。我们将只假设它们总是相同的，以避免迷失在太多的细节中。 当调用者进入内核时，会发生两件事: 在调用者的idmapping中将调用者的用户空间id向下映射到内核id。(准确地说，内核只会查看隐藏在当前任务凭证中的内核id，但对于我们的教育，我们将假设这个转换是及时发生的。) 验证调用者的内核id可以映射到文件系统idmapping中的用户空间id。 第二步很重要，因为常规文件系统在写入磁盘时最终需要将内核id映射回用户空间id。因此，在第二步中，内核保证可以将有效的用户空间id写入磁盘。如果不能，内核将拒绝创建请求，甚至不冒远程文件系统损坏的风险。 精明的读者应该已经意识到这只是我们在上一节中提到的交叉映射算法的一个变种。首先，内核根据调用者的idmapping将调用者的用户空间id映射到内核id，然后根据文件系统的idmapping将内核id映射到内核id。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:0","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例1 caller id: u1000 caller idmapping: u0:k0:r4294967295 filesystem idmapping: u0:k0:r4294967295 调用者和文件系统都使用标识idmapping: 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k0:r4294967295, u1000) = k1000 验证调用者的内核id可以映射到文件系统idmapping中的用户空间id。 对于第二步，内核将调用fsuidgid_has_mapping()函数，最终归结为调用from_kuid(): from_kuid(u0:k0:r4294967295, k1000) = u1000 在本例中，两个idmappings是相同的，所以没有什么令人兴奋的事情发生。最终，放置在磁盘上的用户空间id将是u1000。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:1","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例2 caller id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k20000:r10000 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k10000:r10000, u1000) = k11000 验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k20000:r10000, k11000) = u-1 很明显，虽然调用者的用户空间id可以在调用者的idmapping中成功映射到内核id，但内核id不能根据文件系统的idmapping进行映射。因此，内核将拒绝这个创建请求。 请注意，虽然这个示例不太常见，但由于大多数文件系统不能使用非初始idmappings挂载，这是一个常见的问题，我们可以在下一个示例中看到。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:2","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例3 caller id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k0:r4294967295 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k10000:r10000, u1000) = k11000 验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k0:r4294967295, k11000) = u11000 我们可以看到，翻译总是成功的。文件系统最终放入磁盘的用户空间id将始终与调用者的idmapping中创建的内核id的值相同。这主要有两个后果。 首先，我们不能允许调用者最终使用另一个用户空间id写入磁盘。只有在使用调用者的或另一个idmapping挂载整个fileystem时才能这样做。但是该解决方案仅限于少数文件系统，而且不太灵活。但这是一个在容器化工作负载中非常重要的用例。 其次，调用者通常无法创建任何具有严格权限的文件或访问目录，因为在调用者的idmapping中，没有一个文件系统的内核id映射到有效的用户空间id 在文件系统的idmapping中将原始用户空间id映射到内核id: make_kuid(u0:k0:r4294967295, u1000) = k1000 在调用者的idmapping中映射内核id到用户空间id: from_kuid(u0:k10000:r10000, k1000) = u-1 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:3","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例4 file id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k0:r4294967295 为了向用户空间报告所有权，内核使用了上一节介绍的交叉映射算法: 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k0:r4294967295, u1000) = k1000 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k10000:r10000, k1000) = u-1 在这种情况下，交叉映射算法失败，因为文件系统idmapping中的内核id不能映射到调用者idmapping中的用户空间id。因此，内核将报告该文件的所有权为溢出。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:4","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例5 file id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k20000:r10000 为了向用户空间报告所有权，内核使用了上一节介绍的交叉映射算法: 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k20000:r10000, u1000) = k21000 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k10000:r10000, k21000) = u-1 在这种情况下，交叉映射算法同样失败，因为文件系统idmapping中的内核id不能映射到调用者idmapping中的用户空间id。因此，内核将报告该文件的所有权为溢出。 注意，如果调用者使用初始idmapping，那么在最后两个示例中，事情将变得多么简单。对于使用初始idmapping安装的文件系统来说，这很简单。所以我们只考虑一个id映射为u0:k20000:r10000的文件系统: 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k20000:r10000, u1000) = k21000 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k0:r4294967295, k21000) = u21000 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:2:5","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"idmapped挂载上的Idmappings 在上一节中我们看到的调用者的idmapping和文件系统的idmapping不兼容的例子会导致工作负载的各种问题。对于一个更复杂但常见的示例，考虑在主机上启动两个容器。为了完全防止这两个容器相互影响，管理员通常可以为这两个容器使用不同的不重叠的idmapping: container1 idmapping: u0:k10000:r10000 container2 idmapping: u0:k20000:r10000 filesystem idmapping: u0:k30000:r10000 管理员希望对以下文件集提供简单的读写访问: dir id: u0 dir/file1 id: u1000 dir/file2 id: u2000 到两个容器目前都不能。 当然，管理员可以选择通过chown()递归地更改所有权。例如，他们可以改变所有权，以便dir和它下面的所有文件可以从文件系统的交叉映射到容器的idmapping。让我们假设它们改变了所有权，以便与第一个容器的idmapping兼容: dir id: u10000 dir/file1 id: u11000 dir/file2 id: u12000 这仍然会使dir对第二个容器毫无用处。事实上，dir和它下面的所有文件将继续显示为第二个容器的溢出所有。 再来看看另一个越来越受欢迎的例子。一些服务管理器，比如systemd，实现了一个叫做“可移植主目录”的概念。用户可能希望在分配了不同登录用户空间id的不同机器上使用自己的主目录。大多数用户在家里的机器上将u1000作为登录id，并且他们主目录中的所有文件通常都属于u1000。在大学或工作单位，他们可能有另一个登录id，如u1125。这使得在他们的工作机器上与他们的主目录交互变得相当困难。 在这两种情况下，递归地改变所有权都有严重的影响。最明显的一个是所有权是全球性和永久性的变化。在主目录的情况下，所有权甚至需要在每次用户从他们的主目录切换到他们的工作机器时发生这种变化。对于非常大的文件集，这将变得越来越昂贵。 如果用户幸运的话，他们处理的文件系统是在用户名称空间内安装的。但是这也会全局地改变所有权，所有权的改变与文件系统挂载的生命周期有关，也就是超级块。更改所有权的惟一方法是完全卸载文件系统，然后在另一个用户名称空间中再次挂载它。这通常是不可能的，因为这意味着当前访问文件系统的所有用户都不能再访问了。这意味着dir仍然不能在具有不同idmapping的两个容器之间共享。但通常用户甚至没有这个选项，因为大多数文件系统在容器内是不可安装的。并且不要安装它们可能是可取的，因为它不需要文件系统处理恶意的文件系统映像。 但是上面提到的用例以及更多的情况都可以通过idmapped挂载来处理。它们允许在不同的坐骑上暴露同一套拥有不同所有权的dentry。这是通过通过mount_setattr()系统调用用用户名称空间标记挂载来实现的。然后使用与它相关联的idmapping从调用者的idmapping转换到文件系统的idmapping，然后使用我们前面介绍的重新映射算法进行反向转换。 Idmapped挂载使得以一种临时和本地化的方式改变所有权成为可能。所有权的变更仅限于一个特定的坐骑，并且与坐骑的生命周期相关。暴露文件系统的所有其他用户和位置都不受影响。 支持idmapped挂载的文件系统没有任何真正的理由来支持在用户名称空间内被挂载。可以在idmapped挂载下完全公开文件系统，以获得相同的效果。这样做的好处是，文件系统可以将超级块的创建留给初始用户名称空间中的特权用户。 但是，完全可以将idmapped挂载与用户名称空间内可挂载的文件系统结合起来。我们将在下面进一步讨论这个问题。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:0","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"重新映射 helpers 添加了Idmapping函数，在Idmapping之间进行转换。它们使用了我们前面介绍过的重新映射算法。我们来看看两个例子: i_uid_into_mnt() 和 i_gid_into_mnt() i_*id_into_mnt()函数将文件系统的内核id转换为挂载的idmapping中的内核id: /* Map the filesystem's kernel id up into a userspace id in the filesystem's idmapping. */ from_kuid(filesystem, kid) = uid /* Map the filesystem's userspace id down ito a kernel id in the mount's idmapping. */ make_kuid(mount, uid) = kuid mapped_fsuid() 和 mapped_fsgid() mapped_fs*id()函数将调用者的内核id转换为文件系统idmapping中的内核id。这个转换是通过使用挂载的idmapping重新映射调用者的内核id来实现的: /* Map the caller's kernel id up into a userspace id in the mount's idmapping. */ from_kuid(mount, kid) = uid /* Map the mount's userspace id down into a kernel id in the filesystem's idmapping. */ make_kuid(filesystem, uid) = kuid 注意，这两个函数是相反的。考虑以下idmappings: caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k20000:r10000 mount idmapping: u0:k10000:r10000 假设从磁盘读取属于u1000的文件。文件系统根据它的idmapping将这个id映射到k21000。这是存储在inode的i_uid和i_gid字段中的内容。 当调用者通过stat()查询这个文件的所有权时，内核通常会简单地使用交叉映射算法，并将文件系统的内核id映射到调用者的idmapping中的用户空间id。 但是当调用者访问idmapped挂载上的文件时，内核会首先调用i_uid_into_mnt()，从而将文件系统的内核id转换成挂载的idmapping中的内核id: i_uid_into_mnt(k21000): /* Map the filesystem's kernel id up into a userspace id. */ from_kuid(u0:k20000:r10000, k21000) = u1000 /* Map the filesystem's userspace id down ito a kernel id in the mount's idmapping. */ make_kuid(u0:k10000:r10000, u1000) = k11000 最后，当内核向调用者报告所有者时，它将把挂载的idmapping中的内核id转换为调用者idmapping中的用户空间id: from_kuid(u0:k10000:r10000, k11000) = u1000 我们可以通过验证在创建新文件时发生了什么来测试这个算法是否真的有效。假设用户正在创建一个u1000的文件。 内核将其映射到调用者的idmapping中的k11000。通常，内核现在会应用交叉映射，验证k11000可以映射到文件系统idmapping中的用户空间id。由于k11000不能直接映射到文件系统的idmapping中，所以创建请求失败。 但是当调用者访问idmapped挂载上的文件时，内核会首先调用mapped_fs*id()，从而根据挂载的idmapping将调用者的内核id转换成一个内核id: mapped_fsuid(k11000): /* Map the caller's kernel id up into a userspace id in the mount's idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 /* Map the mount's userspace id down into a kernel id in the filesystem's idmapping. */ make_kuid(u0:k20000:r10000, u1000) = k21000 当最后写入磁盘时，内核会将k21000映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k20000:r10000, k21000) = u1000 正如我们所看到的，我们最终得到了一个可逆的，因此信息保持的算法。在idmapped挂载上从u1000创建的文件也会被报告为u1000所拥有，反之亦然。 现在，让我们在idmapped挂载上下文中简要地重新考虑前面失败的例子。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:1","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例2 reconsider caller id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k20000:r10000 mount idmapping: u0:k10000:r10000 当调用者使用非初始idmapping时，通常的情况是将相同的idmapping附加到挂载上。现在我们执行三个步骤: 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k10000:r10000, u1000) = k11000 将调用者的内核id转换为文件系统idmapping中的内核id: mapped_fsuid(k11000): /* Map the kernel id up into a userspace id in the mount's idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 /* Map the userspace id down into a kernel id in the filesystem's idmapping. */ make_kuid(u0:k20000:r10000, u1000) = k21000 验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k20000:r10000, k21000) = u1000 所以磁盘上的所有权是u1000。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:2","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例3 reconsidered caller id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k0:r4294967295 mount idmapping: u0:k10000:r10000 同样的转换算法也适用于第三个例子。 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k10000:r10000, u1000) = k11000 将调用者的内核id转换为文件系统idmapping中的内核id: mapped_fsuid(k11000): /* Map the kernel id up into a userspace id in the mount's idmapping. */ from_kuid(u0:k10000:r10000, k11000) = u1000 /* Map the userspace id down into a kernel id in the filesystem's idmapping. */ make_kuid(u0:k0:r4294967295, u1000) = k1000 验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k0:r4294967295, k21000) = u1000 所以磁盘上的所有权是u1000。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:3","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例4 reconsidered file id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k0:r4294967295 mount idmapping: u0:k10000:r10000 为了向用户空间报告所有权，内核现在使用我们前面介绍的转换算法执行三个步骤: 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k0:r4294967295, u1000) = k1000 将内核id转换为挂载的idmapping中的内核id: i_uid_into_mnt(k1000): /* Map the kernel id up into a userspace id in the filesystem's idmapping. */ from_kuid(u0:k0:r4294967295, k1000) = u1000 /* Map the userspace id down into a kernel id in the mounts's idmapping. */ make_kuid(u0:k10000:r10000, u1000) = k11000 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k10000:r10000, k11000) = u1000 之前，调用者的内核id不能在文件系统的idmapping中交叉映射。有了idmapped挂载之后，现在可以通过挂载的idmapping将它交叉映射到文件系统的idmapping中。现在将根据挂载的idmapping使用u1000创建文件。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:4","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"例5 reconsidered file id: u1000 caller idmapping: u0:k10000:r10000 filesystem idmapping: u0:k20000:r10000 mount idmapping: u0:k10000:r10000 同样，为了向用户空间报告所有权，内核现在使用我们前面介绍的转换算法执行三个步骤: 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k20000:r10000, u1000) = k21000 将内核id转换为挂载的idmapping中的内核id: i_uid_into_mnt(k21000): /* Map the kernel id up into a userspace id in the filesystem's idmapping. */ from_kuid(u0:k20000:r10000, k21000) = u1000 /* Map the userspace id down into a kernel id in the mounts's idmapping. */ make_kuid(u0:k10000:r10000, u1000) = k11000 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k10000:r10000, k11000) = u1000 以前，文件的内核id不能在文件系统的idmapping中交叉映射。有了idmapped挂载之后，现在可以通过挂载的idmapping将它交叉映射到文件系统的idmapping中。根据挂载的idmapping，该文件现在属于u1000。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:3:5","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"更改主目录的所有权 我们在上面已经看到了当调用者、文件系统或两者都使用非初始idmapping时，如何使用idmapped挂载在idmapping之间进行转换。当调用者使用非初始idmapping时，存在各种各样的用例。这通常发生在容器化工作负载的上下文中。结果就像我们看到的那样，对于使用初始idmapping挂载的文件系统和使用非初始idmapping挂载的文件系统，对文件系统的访问无法工作，因为内核id不能在调用者的和文件系统的idmapping之间交叉映射。 正如我们在上面看到的，idmapped挂载提供了一种解决方案，它根据挂载的idmapping重新映射调用者或文件系统的idmapping。 除了容器化的工作负载之外，idmapped挂载还有一个优点:当调用者和文件系统都使用初始idmapping时，它们也可以工作，这意味着主机上的用户可以在每次挂载的基础上改变目录和文件的所有权。 考虑我们前面的示例，其中用户的主目录位于可移植存储上。在家里，他们的id是u1000，在他们的主目录中的所有文件都属于u1000，而在uni或work，他们的登录id是u1125。 带着他们的主目录会有问题。它们不能轻松地访问它们的文件，如果不应用宽松的权限或acl，它们可能无法写入磁盘，而且即使它们可以这样做，它们也将以u1000和u1125拥有的文件和目录混合而结束。 Idmapped挂载允许解决这个问题。用户可以在他们的工作计算机或家里的计算机上为他们的主目录创建idmapped挂载，这取决于他们希望最终在便携存储本身上拥有什么所有权。 假设他们希望磁盘上的所有文件都属于u1000。当用户在他们的工作岗位插入便携存储时，他们可以设置一个作业，该作业创建一个idmapped挂载，其中的idmapping最小值为u1000:k1125:r1。所以现在当他们创建一个文件时，内核执行以下步骤，我们已经从上面知道:: caller id: u1125 caller idmapping: u0:k0:r4294967295 filesystem idmapping: u0:k0:r4294967295 mount idmapping: u1000:k1125:r1 在调用者的idmapping中将调用者的用户空间id映射到内核id: make_kuid(u0:k0:r4294967295, u1125) = k1125 将调用者的内核id转换为文件系统idmapping中的内核id: mapped_fsuid(k1125): /* Map the kernel id up into a userspace id in the mount's idmapping. */ from_kuid(u1000:k1125:r1, k1125) = u1000 /* Map the userspace id down into a kernel id in the filesystem's idmapping. */ make_kuid(u0:k0:r4294967295, u1000) = k1000 验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id: from_kuid(u0:k0:r4294967295, k1000) = u1000 因此，最终将在磁盘上创建u1000文件。 现在让我们简单地看看id为u1125的调用者将在他们的工作计算机上看到什么所有权: file id: u1000 caller idmapping: u0:k0:r4294967295 filesystem idmapping: u0:k0:r4294967295 mount idmapping: u1000:k1125:r1 将磁盘上的用户空间id映射到文件系统idmapping中的内核id: make_kuid(u0:k0:r4294967295, u1000) = k1000 将内核id转换为挂载的idmapping中的内核id: i_uid_into_mnt(k1000): /* Map the kernel id up into a userspace id in the filesystem's idmapping. */ from_kuid(u0:k0:r4294967295, k1000) = u1000 /* Map the userspace id down into a kernel id in the mounts's idmapping. */ make_kuid(u1000:k1125:r1, u1000) = k1125 在调用者的idmapping中将内核id映射到用户空间id: from_kuid(u0:k0:r4294967295, k1125) = u1125 因此，最终将报告调用者文件属于u1125，在我们的示例中，u1125是调用者工作站上的用户空间id。 放置在磁盘上的原始用户空间id是u1000，因此当用户将他们的主目录返回到他们的主计算机时，他们使用初始idmapping分配了u1000，并使用初始idmapping挂载文件系统，他们将看到u1000拥有的所有文件。 ","date":"2022-05-30","objectID":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/:4:0","tags":["linux","kernel","filesystem","文件系统"],"title":"ldmappings 文件系统权限","uri":"/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"categories":["kernel"],"content":"自动挂载支持 希望实现自动挂载支持的文件系统也可以获得支持(例如可以在 fs/afs/ 中找到kAFS，在 fs/nfs/ 中找到NFS)。这个功能包括允许执行核内挂载以及请求降级挂载点。降级后的挂载点用户空间也可以访问。 ","date":"2022-05-30","objectID":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/:1:0","tags":["linux","kernel","automount","自动挂载","filesystem","文件系统"],"title":"自动挂载支持","uri":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/"},{"categories":["kernel"],"content":"核内自动挂载 参见: autofs的“挂载陷阱”部分-它是如何工作的 在用户空间中，你可以这样做: [root@andromeda root]# mount -t \u003c文件系统\u003e \u003c挂载设备\u003e \u003c挂载点\u003e [root@andromeda root]# ls /afs asd cambridge cambridge.redhat.com grand.central.org [root@andromeda root]# ls /afs/cambridge afsdoc [root@andromeda root]# ls /afs/cambridge/afsdoc/ ChangeLog html LICENSE pdf RELNOTES-1.2.2 然后如果你看一下挂载点目录，你会看到这样的东西: [root@andromeda root]# cat /proc/mounts ... #root.afs. /afs afs rw 0 0 #root.cell. /afs/cambridge.redhat.com afs rw 0 0 #afsdoc. /afs/cambridge.redhat.com/afsdoc afs rw 0 0 ","date":"2022-05-30","objectID":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/:1:1","tags":["linux","kernel","automount","自动挂载","filesystem","文件系统"],"title":"自动挂载支持","uri":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/"},{"categories":["kernel"],"content":"自动挂载点过期 挂载点的自动过期是很容易的，前提是您已经在单独列出的自动挂载过程中挂载了将要过期的挂载点。 要想过期，你需要遵循以下步骤: 创建至少一个列表，以便将过期的vfmount挂起。 当在-\u003ed_automount方法中创建一个新的挂载点时，使用mnt_set_expiry()将mnt添加到列表中: mnt_set_expiry(newmnt, \u0026afs_vfsmounts); 当您希望挂载点过期时，使用指向该列表的指针调用mark_mounts_for_expiry()。这将处理列表，将其上的每个vfmount标记为下一次调用的潜在到期。 如果一个vfmount已经被标记为过期，并且它的使用计数为1(它只被它的父vfmount引用)，那么它将从命名空间中删除并丢弃(实际上是卸载)。 最简单的方法可能是定期调用它，使用某种定时事件来驱动它。 通过调用mntput来清除过期标志。这意味着只有在上次访问挂载点之后的第二次过期请求时才会发生过期。 如果一个挂载点被移动，它将从过期列表中删除。如果绑定挂载是在一个可过期挂载上进行的，那么新的vfmount将不在过期列表中，也不会过期。 如果复制了一个名称空间，那么其中包含的所有挂载点都将被复制，过期列表中挂载点的副本将被添加到相同的过期列表中。 ","date":"2022-05-30","objectID":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/:1:2","tags":["linux","kernel","automount","自动挂载","filesystem","文件系统"],"title":"自动挂载支持","uri":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/"},{"categories":["kernel"],"content":"用户空间驱动到期 作为一种替代方案，用户空间可以请求任何挂载点的过期(尽管有些挂载点会被拒绝——例如卸载rootfs)。它通过将MNT_EXPIRE标志传递给umount()来实现这一点。该标志被认为与MNT_FORCE和MNT_DETACH不兼容。 如果有问题的挂载点不是由umount()或它的父挂载点引用的，那么将返回一个EBUSY错误，并且该挂载点不会被标记为过期或卸载。 如果挂载点在那时还没有被标记为过期，将会给出一个EAGAIN错误，它不会被卸载。 否则，如果它已经被标记并且没有被引用，卸载将照常进行。 同样，每当umount()以外的任何程序查看挂载点时，过期标志将被清除。 ","date":"2022-05-30","objectID":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/:1:3","tags":["linux","kernel","automount","自动挂载","filesystem","文件系统"],"title":"自动挂载支持","uri":"/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/"},{"categories":["kernel"],"content":"路径名查询说明 路径名查找几乎没有可以取巧的方法，因此反而比较复杂。有许多规则、特殊情况和实现替代方案，所有这些都使读者感到困惑。 然而，计算机科学早就熟悉这种复杂性，这就是我们广泛使用的一种方法——“分而治之”。对于分析的早期部分，我们将划分符号链接 - 将它们留到最后部分。在我们讨论符号链接之前，我们有另一个基于 VFS 锁定方法的主要部分，这将允许我们分别回顾“REF-walk”和“RCU-walk”。但我们正在超越自己。我们需要首先澄清一些重要的低级区别。 用于标识文件系统中的对象的路径名(有时是“文件名”)对大多数读者来说都很熟悉。它们包含两种类型的元素:“斜杠”是一个或多个“/”字符的序列，以及“文件夹/文件元素”是一个或多个非“/”字符的序列。 共有两种路径：那些以斜杠开始的是“绝对的”，并且从文件系统根目录开始；其他是“相对的”，从当前目录开始，或者从*at()系统调用(如openat())所给出的文件描述符指定的其他位置开始。 将相对路径描述为从当前目录开始是可以的，但这并不总是准确的:路径名可以既没有斜杠又没有文件/文件夹名，换句话说，它可以是空的。这在POSIX中通常是被禁止的，但是Linux中的一些*at()系统调用在给出AT_EMPTY_PATH标志时允许这样做。例如，如果在可执行文件上有一个打开的文件描述符，那么可以通过传递文件描述符、空路径和AT_EMPTY_PATH标志，调用execveat()来执行它。 这些路径可以分为两个部分:最终元素和其他内容。“其他一切”是容易的部分。在所有情况下，它必须识别一个已经存在的目录，否则将报告一个错误，如ENOENT或ENOTDIR。 最后一个组成部分就没那么简单了。不仅不同的系统调用对它的解释非常不同(例如，一些创建了它，一些没有)，而且它甚至可能不存在:空的路径名或只是斜杠的路径名都没有最终元素。如果它确实存在，它可能是\".“或”..\"，处理方式与其他组件截然不同。 如果一个路径名以斜杠结尾，例如“/tmp/foo/”，它可能会考虑有一个空的最终组件。在很多方面，这会导致正确的结果，但并不总是如此。特别是，mkdir()和rmdir()都会创建或删除一个由最终组件命名的目录，它们需要处理以“/”结尾的路径名。根据POSIX: 包含至少一个非切割字符的路径（pathname），以一个或多个切割字符结尾，是不合法的，除非最后一个切割符之前的的元素是一个已存在的文件夹，或者是一个将要创建的文件夹，这样的路径才是合法的。 Linux路径名遍历代码(主要在fs/name.c中)处理所有这些问题:将路径分解为组件，与最终组件完全分开处理“其他所有内容”，并检查在不允许的地方是否使用末尾的斜杠。它还解决了并发访问的重要问题。 当一个进程查找路径名时，另一个进程可能会做出影响该查找的更改。一个相当极端的情况是，如果“a/b”被重命名为“a/c/b”，而另一个进程正在查找“a/b/..”，该过程可能导致查询结果为“a/c”。大多数竞争要微妙得多，路径名查找的主要任务是防止它们产生破坏性影响。许多可能的竞争在“dcache”上下文中表现得最为清晰，理解dcache对于理解路径名查找至关重要。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:1:0","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"不止是一个缓冲 “dcache”在每个文件系统中缓存关于名称的信息，以便快速查找。每个条目(被称为“dentry”)包含三个重要的字段:一个组件名称，一个指向父dentry的指针，以及一个指向“inode”的指针，该inode包含给定名称的父节点中对象的进一步信息。inode指针可以是NULL，表示该名称在父节点中不存在。虽然在目录的dentry中可以链接到子目录的dentry，但该链接不用于路径名查找，因此这里不考虑。 除了加速查找之外，dcache还有许多用途。特别重要的一点是，它与记录文件系统安装位置的挂载表紧密集成。挂载表实际存储的是哪个dentry挂载在哪个dentry上。 在考虑dcache时，我们还有另一个“两种类型”的区别:有两种类型的文件系统。 有些文件系统确保dcache中的信息总是完全准确的(尽管不一定是完整的)。这允许VFS在不检查文件系统的情况下确定某个特定文件是否存在，这意味着VFS可以保护文件系统免受某些竞争和其他问题的影响。这些是典型的“本地”文件系统，如ext3、XFS和Btrfs。 其他文件系统不提供这种保证，因为它们不能。这些通常是跨网络共享的文件系统，无论是像NFS和9P这样的远程文件系统，还是像ocfs2或cephfs这样的集群文件系统。这些文件系统允许VFS重新验证缓存的信息，并且必须提供自己的保护来防止尴尬的竞争。VFS可以通过dentry中设置的DCACHE_OP_REVALIDATE标志来检测这些文件系统。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:2:0","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"REF-walk:包含refcount和自旋锁的简单并发管理 仔细分类后，我们现在可以开始观察沿着路径行走的实际过程。特别地，我们将从处理路径名的“其他一切”部分开始，并重点关注并发管理的“ref-walk”方法。这段代码可以在link_path_walk()函数中找到，如果你忽略所有只有在设置了LOOKUP_RCU(表示使用了RCU-walk)时才运行的地方。 REF-walk对锁和引用计数的处理相当繁琐。不像以前的“big kernel lock”时代那样笨拙，但肯定不用担心在需要锁的时候使用锁。它使用各种不同的并发控制。对各种原语的背景理解是假设的，或者可以从其他地方收集，如Meet the locker。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:3:0","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"REF-walk使用的锁定机制包括: dentry-\u003ed_lockref 这使用了lockref原语来提供自旋锁和引用计数。这个原语的特殊之处在于概念序列的“lock; inc_ref; unlock 通常可以通过单个原子内存操作来执行。在dentry上持有引用可以确保dentry不会突然被释放并用于其他内容，因此各个字段中的值将按照预期的方式运行。它还在一定程度上保护了对inode的-\u003ed_inode引用。dentry与其inode之间的关联是相当持久的。例如，当重命名一个文件时，dentry和inode会一起移动到新位置。当一个文件被创建时，dentry最初是负的(例如，d_inode是NULL)，并在创建过程中被赋值给新的inode。当一个文件被删除时，可以通过将d_inode设置为NULL或从用于在父目录中查找名称的哈希表中删除它来反映在缓存中。如果dentry仍在使用，则使用第二种选择，因为在删除文件后继续使用打开的文件是完全合法的，而且有dentry在身边会有所帮助。如果dentry没有被使用(例如，如果d_lockref中的引用计数是一个)，只有这时d_inode才会被设置为NULL。对于一个非常常见的情况，这样做更有效。因此，只要统计的引用保存在dentry中，-\u003ed_inode值如果为非空，则值永远不会被改变。 dentry-\u003ed_lock d_lock是上面d_lockref中的自旋锁的同义词。持有此锁可以防止dentry被重命名或取消链接。特别是，它的父节点(d_parent)和它的名称(d_name)不能更改，也不能从dentry哈希表中删除它。当在目录中查找名称时，REF-walk对它在散列表中找到的每个候选dentry使用d_lock，然后检查父节点和名称是否正确。所以它在缓存中搜索时不会锁定父节点;它只锁孩子。当查找给定名称的父类(以处理\" .. “)时，REF-walk可以使用d_lock来获得对d_parent的稳定引用，但它首先尝试一种更轻量级的方法。正如在dget_parent()中看到的，如果可以对父对象声明引用，并且随后可以看到d_parent没有更改，那么就不需要对子对象实际使用锁。 rename_lock 在给定目录中查找给定的名称涉及到从两个值(目录的名称和dentry)计算哈希值，访问哈希表中的槽，并搜索在那里找到的链表。当dentry被重命名时，名称和父dentry都可能改变，所以哈希值几乎肯定也会改变。这将把dentry移动到哈希表中的另一个链上。如果文件名搜索碰巧在查找以这种方式移动的dentry，它可能最终会沿着错误的链继续搜索，从而错过正确链的一部分。名称查找进程(d_lookup())不会试图阻止这种情况的发生，而只是检测它何时发生。rename_lock是一个sequlock，每当重命名任何dentry时都会更新它。如果d_lookup在未成功扫描哈希表中的链时发现发生了重命名，它会简单地再次尝试。当解析“..”时，rename_lock还用于检测和防御针对LOOKUP_BENEATH和LOOKUP_IN_ROOT的潜在攻击。(父目录被移到根目录之外，绕过了path_equal()检查)。如果在查找过程中更新了rename_lock，并且路径遇到了一个 ..，一个潜在的攻击发生了，handle_dots()将跳出并报错-EAGAIN。 inode-\u003ei_rwsem i_rwsem是一个读/写信号量，它序列化对特定目录的所有更改。例如，这确保了unlink()和rename()不能同时发生。当要求文件系统查找当前不在dcache中的名称时，或者使用readdir()检索目录中的条目列表时，它还可以保持目录的稳定。 这与目录上的d_lock: i_rwsem具有补充作用，保护该目录中的所有名称，而名称上的d_lock只保护目录中的一个名称。对dcache的大多数更改在相关目录inode上保持i_rwsem，并在发生更改时在一个或多个dentry上短暂地使用d_lock。一个例外是由于内存压力而从dcache中删除空闲的dentry。这使用了d_lock，但是i_rwsem不扮演任何角色。 信号量以两种不同的方式影响路径名查找。首先，它可以防止在查找目录中的名称时发生更改。Walk_component()首先使用lookup_fast()，然后它检查名称是否在缓存中，只使用d_lock锁定。如果没有找到这个名称，那么walk_component()会退回到lookup_slow()，它在i_rwsem上接受一个共享锁，再次检查名称是否不在缓存中，然后调用文件系统以获得确定的答案。无论结果如何，都会向缓存中添加一个新的dentry。 其次，当路径名查找到达最后一个组件时，有时需要在执行最后一个查找之前在i_rwsem上获得一个排他锁，以便能够实现所需的排除。路径查找如何选择使用或不使用i_rwsem是下一节要讨论的问题之一。 如果两个线程试图同时查找相同的名称(这个名称还没有出现在dcache中)，i_rwsem上的共享锁将不会阻止它们同时添加具有相同名称的新dentry。由于这将导致混乱，因此使用了额外的联锁级别，这是基于二级哈希表(in_lookup_hashtable)和每个dentry标志位(DCACHE_PAR_LOOKUP)。 要在缓存中添加一个新的dentry，同时只持有i_rwsem上的共享锁，线程必须调用d_alloc_parallel()。它分配一个dentry，在其中存储所需的名称和父元素，检查主哈希表或辅助哈希表中是否已经存在匹配的dentry，如果没有，则使用DCACHE_PAR_LOOKUP集在辅助哈希表中存储新分配的dentry。 如果在主哈希表中找到匹配的dentry，则返回该dentry，调用者可以知道它在与添加条目的其他线程的竞争中失败了。如果在两个缓存中都没有找到匹配的dentry，则返回新分配的dentry，调用者可以从DCACHE_PAR_LOOKUP中检测到这一点。在本例中，它知道它已经赢得了比赛，现在负责请求文件系统执行查找并找到匹配的索引节点。当查找完成时，它必须调用d_lookup_done()，它会清除标记，并进行一些其他的内部维护，包括从二级哈希表中删除dentry——它通常已经被添加到主哈希表中。注意，waitqueue_head结构体被传递给d_alloc_parallel()，并且当这个waitqueue_head仍然在作用域中时，必须调用d_lookup_done()。 如果在二级散列表中找到匹配的dentry, d_alloc_parallel()需要做更多的工作。它首先等待DCACHE_PAR_LOOKUP被清除，使用一个wait_queue被传递给赢得竞争的d_alloc_parallel()实例，该实例将通过调用d_lookup_done()被唤醒。然后检查dentry现在是否已添加到主散列表中。如果有，则返回dentry，调用者只会看到它输掉了所有竞赛。如果没有将它添加到主哈希表中，最可能的解释是使用d_splice_alias()添加了其他dentry。在任何情况下，d_alloc_parallel()都会从一开始重复所有的查找，并且通常会从主哈希表返回一些内容。 mnt-\u003emnt_count mnt_count是“mount”结构上每个cpu的引用计数器。这里的Per-CPU意味着增加计数很便宜，因为它只使用CPU本地内存，但检查计数是否为零则很昂贵，因为它需要检查每个CPU。接受mnt_count引用可以防止挂载结构作为常规卸载操作的结果消失，但不能防止“惰性”卸载。因此，持有mnt_count不能确保挂载保持在名称空间中，特别是不能稳定到挂载的dentry的链接。但是，它可以确保挂载数据结构保持一致，并且提供了对挂载文件系统根目录的引用。因此，通过-\u003emnt_count的引用提供了对挂载的dentry的稳定引用，而不是挂载的dentry。 mount_lock mount_lock是一个全局序列锁，有点像rename_lock。它可以用来检查是否对任何挂载点进行了更改。 当沿着树向下走(离开根节点)时，在通过挂载点时使用此锁检查挂载点是否安全。也就是说，读取seqlock中的值，然后代码查找挂载在当前目录上的挂载(如果有挂载的话)，并增加mnt_count。最后，根据旧值检查mount_lock中的值。如果没有变化，那么穿越是安全的。如果发生了更改，则减少mnt_count，并重试整个进程。 当向根目录遍历(遍历当前目录..)链接时，需要多加注意。在这种情况下，seqlock(包含一个计数器和一个自旋锁)被完全锁定，以防止在升级时对任何挂载点进行任何更改。需要使用此锁定来稳定到挂载dentry的链接，而挂载上的引用本身不能确保这一点。 mount_lock还用于在解析..时检测和防御针对LOOKUP_BENEATH和LOOKUP_IN_ROOT的潜在攻击。(父目录被移到根目录之外，绕过了path_equal()检查)。如果mount_lock在查找过程中更新，并且路径遇到一个..，一个潜在的攻击发生了，handle_dots()将跳出-EAGAIN。 RCU 最后，全局的(但非常轻量级的)RCU读锁会被时不时地持有，以确保某些数据结构不会意外被释放。 特别是在扫描dcache散列表和挂载点散列表中的链时使用。 struct nameidata 在整个路径遍历的过程中，当前状态被存储在结构nameidata中，“na","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:3:1","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"处理最后一个组件(路径中最后一个文件/文件夹部分) link_path_walk()只遍历设置nd-\u003elast和nd-\u003elast_type以引用路径的最后一个组件。上次它没有调用walk_component()。处理最后的组件还需要调用者来解决。这些调用程序是path_lookupat()、path_parentat()和path_openat()，它们分别处理不同系统调用的不同需求。 path_parentat()显然是最简单的—它只是对link_path_walk()进行了一些整理，并将父目录和最终组件返回给调用者。调用者将旨在创建一个名称(通过filename_create())或删除或重命名一个名称(在这种情况下使用user_path_parent())。它们将在验证并执行操作时使用i_rwsem来排除其他更改。 path_lookupat()几乎同样简单——当需要现有对象时使用它，比如stat()或chmod()。它实际上只是通过调用lookup_last()在最后一个组件上调用walk_component()。path_lookupat()只返回最终dentry。值得注意的是，当设置了标志LOOKUP_MOUNTPOINT时，path_lookupat()将在nameidata中取消设置LOOKUP_JUMPED，这样在后续的路径遍历d_weak_revalidate()将不会被调用。在卸载无法访问的文件系统时，这一点非常重要，比如卸载一个失效的NFS服务器提供的文件系统。 最后path_openat()用于open()系统调用;它包含了以open_last_lookup()开始的支持函数，处理O_CREAT(带或不带O_EXCL)、最后的/字符和末尾的符号链接所需的所有复杂性。我们将在本系列的最后一部分中重新讨论这个问题，重点讨论这些符号链接。open_last_lookup()有时会(但并非总是)接受i_rwsem，这取决于它找到了什么。 每一个组件，或者调用它们的函数，都需要警惕最终组件不是LAST_NORM的可能性。如果查找的目标是创建某个值，那么last_type的任何值(LAST_NORM除外)都将导致错误。例如，如果path_parentat()报告LAST_DOTDOT，那么调用者不会尝试创建该名称。它们还通过测试last.name[last.len]来检查末尾的斜杠。如果在最后一个组件之外有任何字符，则必须是末尾的斜杠。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:3:2","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"检验与加载 除了符号链接之外，REF-walk过程中只有两个部分还没有涉及到。一种是对过期缓存条目的处理，另一种是自动加载。 在需要它的文件系统上，查找例程将调用-\u003ed_revalidate() dentry方法，以确保缓存的信息是当前的。这通常会确认有效性或从服务器更新一些细节。在某些情况下，它可能会发现，在向前遍历的过程中上已经发生了变化，以前被认为是有效的东西实际上是无效的。当发生这种情况时，整个路径的查找将被中止，并设置LOOKUP_REVAL标志重新尝试。这迫使重新验证更加彻底。我们将在下一篇文章中看到这个重试过程的更多细节。 自动挂载点是文件系统中的一些位置，在这些位置上，如果试图查找一个名称，可能会触发对该查找的处理方式的更改，特别是在那里挂载一个文件系统。autofs在Linux文档树中详细介绍了这些内容，但这里有一些与路径查找相关的注意事项。 Linux VFS有一个托管 dentry的概念。这些dentry有三个潜在的有趣的地方，它们对应着在dentry-\u003ed_flags中可能设置的三个不同的标志: DCACHE_MANAGE_TRANSIT 如果设置了这个标志，那么文件系统请求在处理任何可能的挂载点之前调用d_manage() dentry操作。它可以执行两种特定的服务: 它可以阻止以避免比赛。如果正在卸载一个自动挂载点，d_manage()函数通常会等待该进程完成，然后才让新的查找继续进行，并可能触发新的自动挂载。 它可以有选择地只允许一些进程通过一个挂载点。当一个服务器进程正在管理自动挂载时，它可能需要访问一个目录，而不触发正常的自动挂载处理。该服务器进程可以将自己标识给autofs文件系统，然后通过返回-EISDIR给它一个通过d_manage()的特殊传递。 DCACHE_MOUNTED 这个标志设置在每个挂载的dentry上。由于Linux支持多个文件系统名称空间，因此dentry可能不是挂载在这个名称空间上，而是挂载在其他名称空间上。因此，这面旗帜被视为一种暗示，而不是承诺。 如果设置了这个标志，而d_manage()没有返回-EISDIR，那么就会调用lookup_mnt()来检查挂载散列表(使用前面描述的mount_lock)，并可能返回一个新的vfmount和一个新的dentry(都带有计数的引用)。 DCACHE_NEED_AUTOMOUNT 如果d_manage()允许我们走到这一步，而lookup_mnt()没有找到挂载点，那么这个标志将导致调用d_automount() dentry操作。 d_automount()操作可以是任意复杂的，可以与服务器进程等通信，但它最终应该报告有一个错误，没有什么可以挂载，或应该提供一个更新的struct path与新的dentry和vfmount。 在后一种情况下，将调用finish_automount()来安全地将新的挂载点安装到挂载表中。 这里没有导入的新锁，而且在这个处理过程中不要持有锁(只有计算过的引用)，这一点很重要，因为很可能会出现扩展延迟。当我们下次研究rcu walk时，这将变得更加重要，它对延迟特别敏感。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:3:3","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"RCU-walk – Linux中更快的路径名查找 RCU-walk是Linux中执行路径名查找的另一种算法。它在许多方面与REF-walk相似，并且两者共享相当多的代码。rcu遍历的显著区别在于它允许并发访问的可能性。 我们注意到REF-walk很复杂，因为有很多细节和特殊情况。RCU-walk通过简单地拒绝处理一些情况来降低复杂性，它退回到REF-walk。rcu-walk的困难来自于另一个方向:不熟悉。依赖于RCU的锁规则与传统的锁有很大的不同，所以我们将在这些规则上多花一些时间。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:0","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"明确的角色划分 管理并发性的最简单方法是强制阻止任何其他线程更改给定线程正在查看的数据结构。如果没有其他线程考虑更改数据，而许多不同的线程想要同时读取数据，那么这将是非常可贵的。即使使用允许多个并发读取器的锁，更新当前读取器数量的简单操作也会带来不必要的成本。因此，当读取一个没有其他进程改变的共享数据结构时，目标是完全避免向内存写入任何内容。不加锁，不加计数，不留下痕迹。 前面描述的REF-walk机制当然不遵循这一原则，但它实际上是为其他线程修改数据时设计的。相反，RCU-walk是为有很多频繁的读取和只有偶尔的写数据的常见情况而设计的。在文件系统树的所有部分中，这可能并不常见，但在许多部分中，这将是常见的。对于其他部分来说，重要的是RCU-walk可以快速回落到使用REF-walk。 路径名查找总是以RCU-walk模式开始，但只有当它所查找的内容在缓存中并且是稳定的时候才会继续存在。它轻快地沿着缓存的文件系统映像向下查找，不留下任何足迹，并仔细地观察它在哪里，以确保它不会出错。如果它注意到某些内容已经更改或正在更改，或者某些内容不在缓存中，那么它会尝试优雅地停止，并切换到REF-walk。 这个停止需要获取当前vfmount和dentry上的一个已统计的引用，并确保这些仍然有效—使用REF-walk的路径遍历将找到相同的条目。这是RCU-walk必须保证的不变量。它只能做出决定，比如选择下一步，如果同时在树上走，REF-walk也可以做出这样的决定。如果优雅停止成功，路径的其余部分将以可靠的REF-walk(如果速度稍慢)处理。如果RCU-walk发现它不能优雅地停止，它就会放弃，然后用REF-walk从头开始。 在filename_lookup()、filename_parentat()、do_filp_open()和do_file_open_root()等函数中可以清楚地看到这种“尝试RCU-walk，如果失败则尝试REF-walk”的模式。这四个函数大致对应于我们前面遇到的三个path_*()函数，每个函数都调用link_path_walk()。path_*()函数使用不同的模式标志调用，直到找到一个有效的模式。它们首先在LOOKUP_RCU设置请求”RCU-walk“时被调用。如果失败并报错为ECHILD，它们将被再次调用，没有特殊标志来请求REF-walk。如果其中任何一个报错，就会使用LOOKUP_REVAL设置(而不是LOOKUP_RCU设置)进行最后一次尝试，以确保在缓存中找到的条目被强制重新验证——通常情况下，只有当文件系统认为条目太老而不能信任时，才会重新验证条目。 LOOKUP_RCU可能会在内部删除这个标志，然后切换到REF-walk，但是不会尝试切换回RCU-walk。RCU-walk无法继续遍历的地方更有可能靠近树叶，所以没必要再切回 RCU-walk。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:1","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"RCU和seqlocks: 快速和轻量 毫无疑问，RCU对于RCU walk模式是至关重要的。rcu_read_lock()在RCU-walk遍历路径的整个过程中保持。它提供的特殊保证是，在锁被持有时，关键数据结构——dentry、inodes、super_blocks和mount——不会被释放。它们可能以这样或那样的方式被取消链接或失效，但内存不会被重新使用，因此各个字段中的值仍然是有意义的。这是RCU提供的唯一保证;其他所有事情都是使用seqlock完成的。 正如我们上面看到的，REF-walk持有对当前dentry和当前vfmount的已统计的引用，并且在引用“next”dentry或vfmount之前不会释放这些引用。它有时也使用d_lock自旋锁。使用这些引用和锁是为了防止发生某些更改。RCU-walk不能接受这些引用或锁，因此不能阻止这样的更改。相反，它检查是否进行了更改，如果进行了更改，则终止或重试。 为了保持上面提到的不变量(RCU-walk可能只做出REF-walk可能做出的决定)，它必须在REF-walk保存引用的相同位置或附近进行检查。因此，当REF-walk增加引用计数或接受自旋锁时，RCU-walk会使用read_seqcount_begin()或类似的函数对seqlock的状态进行采样。当REF-walk减少计数或丢弃锁时，RCU-walk使用read_seqcount_retry()或类似方法检查采样状态是否仍然有效。 然而，seqlock还有更多的功能。如果RCU-walk访问了一个seqlock保护结构中的两个不同的字段，或者访问同一个字段两次，那么这两次访问的一致性是无法保证的。当需要一致性时(通常是这样)，RCU-walk必须获取一个副本，然后使用read_seqcount_retry()来验证该副本。 read_seqcount_retry()不仅检查序列号，而且施加了一个内存屏障，这样CPU或编译器在调用之前的内存读取指令都不会被延迟到调用之后。在slow_dentry_cmp()中可以看到这样一个简单的例子，对于不使用简单的字节级名称相等的文件系统，它调用文件系统来比较名称与dentry。长度和名称指针被复制到本地变量中，然后调用read_seqcount_retry()来确认两者是一致的，然后才调用-\u003ed_compare()。当使用标准文件名比较时，将调用dentry_cmp()。值得注意的是，它没有使用read_seqcount_retry()，而是用大量注释解释为什么一致性保证不是必要的。后续的read_seqcount_retry()将足以捕获此时可能发生的任何问题。 通过对seqlock的小复习，我们可以看到RCU-walk是如何使用seqlock的。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:2","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"mount_lock和nd-\u003em_seq 当REF-walk使用mount_lock seqlock来确保安全地执行穿越挂载点时，我们已经遇到过它了。RCU-walk也使用它来完成这个任务，但远不止这些。 RCU-walk不是在每个vfmount下行时对它进行计数，而是在遍历开始时对mount_lock的状态进行采样，并将这个初始序列号存储在m_seq字段的struct nameidata中。这一个锁和一个序列号用于验证对所有vfmount的所有访问，以及所有挂载点交叉。由于对挂载表的更改相对较少，所以在发生任何“挂载”或“卸载”时，采用REF-walk是合理的。 m_seq在rcu遍历序列的末尾被检查(使用read_seqretry())，无论在路径的其余部分切换到REF-walk还是到达路径的末尾。它也会在挂载点向下遍历(在__follow_mount_rcu()中)或向上遍历(在follow_dotdot_rcu()中)时被检查。如果发现路径发生了变化，整个RCU-walk序列将被终止，并通过REF-walk再次处理该路径。 如果RCU-walk发现mount_lock没有改变，那么可以确定，如果REF-walk对每个vfmount进行引用计数，结果将是相同的。这确保了不变量保持不变，至少对于vfmount结构是这样。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:3","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"dentry-\u003ed_seq和nd-\u003eseq RCU-walk没有对d_reflock进行计数或锁定，而是对每个dentry的d_seq seqlock进行采样，并将序列号存储在nameidata结构的seq字段中，因此nd-\u003eseq应该始终是nd-\u003edentry的当前序列号。在复制之后和使用dentry的名称、父节点或inode之前，需要重新验证这个数字。 对于名字的处理我们已经看过了，父函数只在follow_dotdot_rcu()中被访问，它非常简单地遵循了所需的模式，尽管它有三种不同的情况。 如果不在挂载点，则会跟随d_parent，并收集它的d_seq。当我们在挂载点时，我们使用mnt-\u003emnt_mountpoint链接来获得一个新的dentry并收集它的d_seq。然后，在最终找到要跟踪的d_parent之后，我们必须检查是否落在了一个挂载点上，如果是，则必须找到该挂载点并遵循mnt-\u003emnt_root链接。这可能意味着一种不常见但肯定可能的情况，即路径查找的起点位于安装的文件系统的一部分，因此从根目录不可见。 存储在-\u003ed_inode中的inode指针更有趣一些。总是需要访问inode至少两次，一次是为了确定它是否为NULL，一次是为了验证访问权限。符号链接处理也需要一个经过验证的inode指针。不是在每次访问时重新验证，而是在第一次访问时进行复制，并将其存储在nameidata的inode字段中，从那里可以安全地访问它，而无需进一步验证。 lookup_fast()是rcu模式中唯一使用的查找例程，因为lookup_slow()太慢了，需要锁。正是在lookup_fast()中，我们找到了当前dentry的重要的“hand over hand”跟踪。 当前dentry和当前seq号被传递给__d_lookup_rcu()，如果成功，返回一个新的dentry和一个新的seq号。然后，lookup_fast()复制inode指针并重新验证新的seq号。然后，它最后一次使用旧seq编号1验证旧dentry，然后才继续。这个获取新dentry的seq号，然后检查旧dentry的seq号的过程与我们在REF-walk中看到的在删除旧dentry之前获取新dentry的计数引用的过程完全相同。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:4","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"No inode-\u003ei_rwsem or even rename_lock 信号量是一个相当重量级的锁，只能在允许它休眠时使用。由于rcu_read_lock()禁止休眠，inode-\u003ei_rwsem在RCU-walk中不起作用。如果其他线程确实接受了i_rwsem并以RCU-walk需要注意的方式修改了目录，结果要么是RCU-walk无法找到它正在寻找的dentry，要么是它会找到一个read_seqretry()无法验证的dentry。在任何一种情况下，它都会下降到REF-walk模式，可以使用任何需要的锁。 虽然rename_lock可以被RCU-walk使用，因为它不需要任何睡眠，但RCU-walk不需要。REF-walk使用rename_lock来防止dcache中的哈希链在搜索时发生变化。这可能会导致找不到实际存在的东西。当RCU-walk在dentry缓存中找不到数据时，不管数据是否真的存在，它都已经下到REF-walk中，并再次尝试使用适当的锁。这可以很好地处理所有情况，所以在rename_lock上添加额外的检查不会带来显著的值。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:5","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"unlazy walk() and complete_walk() “下拉到REF-walk”通常涉及到unlazy_walk()的调用，之所以这样命名是因为“RCU-walk”有时也被称为“lazy walk”。当沿着当前vfmount/dentry对的路径向下走似乎已经成功，但是下一步有问题时，调用unlazy_walk()。如果在dcache中找不到下一个名称，如果在rcu_read_lock()被持有(这禁止sleep)时无法进行权限检查或名称重新验证，如果找到自动挂载点，或者在一些涉及符号链接的情况下，就会发生这种情况。当查找到达最后一个组件或路径的末尾时，也会从complete_walk()调用它，这取决于使用的是哪种查找风格。 退出RCU-walk而不触发unlazy_walk()调用的其他原因是当发现一些不能立即处理的不一致时，例如mount_lock或报告更改的d_seq seqlock之一。在这些情况下，相关函数将返回-ECHILD，该函数将一直渗透到使用REF-walk从顶部触发新的尝试为止。 对于unlazy_walk()是一个选项的情况，它本质上接受它持有的每个指针(vfmount、dentry，可能还有一些符号链接)的引用，然后验证相关的seqlock是否没有被更改。如果发生了更改，它也会使用-ECHILD终止，否则转换为REF-walk是成功的，查找过程会继续。 对这些指针进行引用并不像递增计数器那么简单。如果您已经有了一个引用(通常是通过另一个对象间接地)，那么这样做可以获取第二个引用，但如果您根本没有经过计数的引用，那么这样做是不够的。对于dentry-\u003ed_lockref，增加引用计数器以获得引用是安全的，除非它被显式地标记为“死亡”，包括将计数器设置为-128。lockref_get_not_dead()对这些指针进行引用并不像递增计数器那么简单。如果您已经有了一个引用(通常是通过另一个对象间接地)，那么这样做可以获取第二个引用，但如果您根本没有经过计数的引用，那么这样做是不够的。对于dentry-\u003ed_lockref，增加引用计数器以获得引用是安全的，除非它被显式地标记为“死亡”，包括将计数器设置为-128。lockref_get_not_dead()实现这些。 对于mnt-\u003emnt_count，只要使用mount_lock来验证引用，那么接受引用是安全的。如果验证失败，那么以调用mnt_put()的标准方式删除该引用可能不安全——卸载可能进行得太过了。因此，当它发现它得到的引用可能不安全时，会检查MNT_SYNC_UMOUNT标志，以确定简单的mnt_put()是否正确，或者它是否应该减少计数并假装这些都没有发生。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:6","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"注意文件系统 RCU-walk几乎完全依赖于缓存的信息，通常根本不会调用文件系统。但是，除了前面提到的组件名称比较之外，还有两个地方可能包含文件系统，RCU-walk必须小心。 如果文件系统有非标准的权限检查要求—例如网络文件系统可能需要向服务器进行检查—在rcu walk期间可能会调用i_op-\u003epermission(权限接口)。在这种情况下，一个额外的”MAY_NOT_BLOCK“标志被传递，以便它知道不sleep，但如果它不能及时完成返回-ECHILD。I_op -\u003epermission被赋予了inode指针，而不是dentry，因此它不需要担心进一步的一致性检查。但是，如果它访问任何其他文件系统数据结构，必须确保它们在只持有rcu_read_lock()的情况下是安全的。这通常意味着它们必须使用kfree_rcu()或类似的方法来释放。 如果文件系统可能需要重新验证dcache条目，那么在RCU-walk中也可以调用d_op-\u003ed_revalidate。该接口被传递dentry，但不能访问inode或nameidata中的seq号，因此在访问dentry中的字段时需要格外小心。这种“额外注意”通常包括使用READ_ONCE()访问字段，并在使用它之前验证结果是否为NULL。这个模式可以在nfs_lookup_revalidate()中看到。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:7","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"A pair of patterns 在REF-walk和RCU-walk的各个细节中，以及在大的图片中，有几个相关的模式值得注意。 第一种是“快速尝试并检查，如果失败，慢慢尝试”。我们可以在高级方法中看到，首先尝试RCU-walk，然后尝试REF-walk，在使用unlazy_walk()切换到REF-walk的路径的其他部分。我们在前面的dget_parent()中也看到了它，当跟随一个”..”的链接。它尝试一种快速获取引用的方法，然后在需要时返回获取锁。 第二种模式是“快速尝试并检查，如果失败了，再试一次——重复”。这可以通过在REF-walk中使用rename_lock和mount_lock看到。RCU-walk不使用此模式—如果出现任何错误，则直接中止并尝试更稳定的方法要安全得多。 这里的重点是“快速检查”。应该是“快速仔细尝试，然后检查”。需要检查的事实提醒我们，系统是动态的，只有有限数量的东西是安全的。在整个过程中，最可能导致错误的原因是假设某些东西是安全的，而实际上并非如此。有时需要仔细考虑如何确保每次访问的安全性。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:8","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"在符号链接之间遍历 为了理解符号链接的处理，我们将研究几个基本问题:符号链接堆栈和缓存生存期将帮助我们理解符号链接的整体递归处理，并导致对最终组件的特殊注意。然后考虑访问时更新和控制查找的各种标志的摘要，就可以完成整个过程了。 符号链接堆栈 只有两种文件系统对象可以有效地出现在最后一个组件之前的路径中:目录和符号链接。处理目录非常简单:新目录仅仅成为解释路径上下一个组件的起点。处理符号链接需要更多的工作。 从概念上讲，可以通过编辑路径来处理符号链接。如果一个组件名引用了一个符号链接，那么该组件将被链接体替换，如果链接体以’/‘开头，那么前面所有的路径部分将被丢弃。这就是“readlink -f”命令所做的，尽管它也会编辑掉.和..组件。 在查找路径时，没有必要直接编辑路径字符串，丢弃早期组件也没有意义，因为它们不会被查看。跟踪所有剩余的组件很重要，但它们当然可以分开保存;不需要将它们连接起来。由于一个符号链接可以很容易地引用另一个符号链接，而另一个符号链接又可以引用第三个符号链接，因此我们可能需要保留几个路径的其余组件，每个组件在前一个完成时处理。这些路径残余物被保存在一个有限大小的堆栈中。 对单个路径查找中出现的符号链接数量进行限制有两个原因。最明显的方法就是避免循环。如果符号链接直接或通过中介引用自己，那么跟随符号链接永远不能成功完成——必须返回错误ELOOP。我们可以在不施加限制的情况下检测循环，但限制是最简单的解决方案，考虑到限制的第二个原因，这已经足够了。 第二个原因是Linus最近概括的: 因为这也是一个延迟和DoS问题。我们不仅需要对真正的循环做出反应，也需要对“非常深入”的非循环做出反应。这不是关于内存使用，而是关于用户触发不合理的CPU资源。 Linux对任何路径名的长度都有限制:PATH_MAX，即4096。造成这种限制的原因有很多;其中之一就是不让内核在一条路径上花费太多时间。使用符号链接，您可以有效地生成更长的路径，因此出于同样的原因，需要某种限制。Linux在任何一个路径查找中限制最多40个(MAXSYMLINKS)符号链接。以前，它对递归的最大深度施加了8的限制，但是当实现单独的堆栈时，这个限制提高到了40，所以现在只有一个限制。 我们在前一篇文章中遇到的nameidata结构包含一个小堆栈，可用于存储最多两个符号链接的剩余部分。在许多情况下，这就足够了。如果不是，则分配一个单独的堆栈，并为40个符号链接分配空间。路径名查找永远不会超过这个堆栈，因为一旦检测到第40个符号链接，就会返回一个错误。 看起来这个堆栈中只需要存储名字的残余部分，但是我们还需要更多。为了了解这一点，我们需要继续研究缓存生存期。 缓存符号链接的存储和生存期 与其他文件系统资源(如inode和目录条目)一样，符号链接由Linux缓存，以避免对外部存储的重复昂贵访问。对于RCU-walk来说，能够找到并临时保存这些缓存条目是特别重要的，这样它就不需要下拉到REF-walk中。 虽然每个文件系统都可以自由地做出自己的选择，但符号链接通常存储在两个地方之一。短符号链接通常直接存储在inode中。当一个文件系统分配一个结构节点时，它通常会分配额外的空间来存储私有数据(这是内核中常见的面向对象设计模式)。这有时会包括符号链接的空间。另一个常见的位置是在页面缓存中，它通常存储文件的内容。符号链接中的路径名可以被视为该符号链接的内容，并且可以像文件内容一样容易地存储在页面缓存中。 当这两种方法都不合适时，下一个最有可能的场景是文件系统将分配一些临时内存，并在需要时将符号链接内容复制或构造到该内存中。 当符号链接存储在inode中时，它的生命周期与被RCU保护的inode相同，或者被dentry上的计数引用所保护。这意味着，路径名查找用于安全访问dcache和icache (inode缓存)的机制对于安全访问一些缓存的符号链接已经足够了。在这些情况下，inode中的i_link指针被设置为指向存储符号链接的任何地方，并且在需要时可以直接访问符号链接。 当符号链接存储在页面缓存或其他地方时，情况就不那么简单了。对dentry甚至是inode的引用并不意味着对该inode的缓存页面的引用，即使使用rcu_read_lock()也不足以确保页面不会消失。因此，对于这些符号链接，路径名查找代码需要要求文件系统提供一个稳定的引用，而且，重要的是，需要在使用完该引用后释放该引用。 即使在rcu遍历模式下，也经常可以获取对缓存页的引用。它确实需要改变内存，这是最好避免的，但这并不一定是一个大的成本，它比完全放弃RCU-walk模式要好。即使分配空间来复制符号链接的文件系统也可以使用GFP_ATOMIC来成功地分配内存，而不需要退出RCU-walk。如果一个文件系统不能在RCU-walk模式下成功获得一个引用，它必须返回-ECHILD，并且调用unlazy_walk()返回到允许文件系统休眠的REF-walk模式。 这一切发生的地方是i_op-\u003eget_link() inode方法。这在RCU-walk和REF-walk中都被称为。在RCU-walk中dentry*参数是NULL， -\u003eget_link()可以返回-echild来退出RCU-walk。就像我们之前看到的i_op-\u003epermission()方法一样，-\u003eget_link()需要注意的是，它引用的所有数据结构在没有被计数的引用(只有RCU锁)的情况下都是安全的。一个回调结构体delayed_called将被传递给-\u003eget_link():文件系统可以通过set_delayed_call()设置自己的put_link函数和参数。稍后，当VFS想要放置link时，它将调用do_delayed_call()来调用带有参数的回调函数。 为了在遍历完成时删除对每个符号链接的引用，无论是在RCU-walk还是REF-walk中，符号链接堆栈需要包含路径剩余部分: 提供对前一个路径的引用的结构路径 const char* 用于提供对前一个名称的引用 使路径从RCU-walk安全切换到REF-walk 用于以后调用的结构体delayed_call。 这意味着符号链接堆栈中的每个条目需要保存五个指针和一个整数，而不是只有一个指针(路径剩余部分)。在64位系统上，每个条目大约是40字节;40个条目加起来总共是1600字节，这还不到半页。所以这看起来很多，但绝不是过度。 注意，在给定的堆栈帧中，路径剩余(name)不是其他字段引用的符号链接的一部分。它是符号链接完全解析后要遵循的剩余部分。 符号链接 link_path_walk()中的主循环无缝地遍历路径中的所有组件和所有非结尾符号链接。在处理符号链接时，名称指针被调整为指向一个新的符号链接，或者从堆栈中恢复，这样大部分循环就不需要注意了。在堆栈上和下获取这个name变量非常简单;推入和取出引用稍微复杂一些。 当找到符号链接时，walk_component()通过从文件系统返回链接的step_into()调用pick_link()。如果操作成功，旧的路径名称将被放置在堆栈上，而新值将暂时用作名称。当找到路径的结束(即*name为’\\0’)，旧的名称将从堆栈中恢复，并继续遍历路径。 推入和弹出引用指针(inode、cookie等)更加复杂，部分原因是需要处理尾部递归。当符号链接的最后一个组件本身指向一个符号链接时，我们希望在推入刚刚发现的符号链接之前将刚刚完成的符号链接从堆栈中取出，以避免留下空的路径残余物，否则会挡住去路。 当找到符号链接时，最方便的做法是立即将新的符号链接推入walk_component()中的堆栈;walk_component()也是在遍历最后一个组件时需要查看旧符号链接的最后一段代码。因此，walk_component()可以很方便地释放旧的符号链接，并在为新符号链接推送引用信息之前弹出引用。它由个 flag 引导:WALK_NOFOLLOW，它禁止它在发现符号链接时跟随，WALK_MORE表示现在释放当前符号链接还为时过早，WALK_TRAILING表示它在查找的最后一个组件上，因此，我们将检查用户空间标志LOOKUP_FOLLOW，以确定当它是符号链接时是否跟随它，并调用may_follow_link()来检查我们是否有权限跟随它。 没有最终组件的符号链接 一对特殊情况的符号链接值得进一步解释。这两种方法都会在nameidata中设置一个新的结构路径(包含mount和dentry)，并导致pick_link()返回NULL。 更明显的情况是指向/的符号链接。所有以/开头的符号链接都会在pick_link()中检测到，它会将nameidata重置为指向有效的文件系统根。如果符号链接只包含/，那么就没有更多的事情要做，根本没有组件，所以返回NULL表示可以释放符号链接，并丢弃堆栈帧。 另一种情况是/proc中看起来像符号链接但实际上不是(因此通常被称为“magic-link”): $ ls -l /proc/self/fd/1 lrwx------ 1 neilb neilb 64 Jun 13 10:19 /proc/self/fd/1 -\u003e /dev/pts/4 在/proc中，任何进程中打开的文件描述符都用类似符号链接的东西表示。它实际上是对目标文件的引用，而不仅仅是它的名称。当您读取链接这些对象时，您得到的名称可能指向同一个文件——除非它已被解除链接或挂载。当walk_component()遵循其中之一时，“procfs”中的-\u003eget_link()方法不返回","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:4:9","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["kernel"],"content":"最后 尽管它很复杂，但所有这些路径名查找代码看起来都很好——现在的各个部分肯定比几个版本之前更容易理解了。但这并不意味着它“结束了”。正如前面提到的，RCU-walk目前只跟随存储在索引节点中的符号链接，因此，虽然它处理许多ext4符号链接，但它对NFS、XFS或Btrfs没有帮助。这种支持不太可能拖延太久。 ","date":"2022-05-26","objectID":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/:5:0","tags":["linux","kernel","vfs"],"title":"linux kernel 路径查询","uri":"/2022/05/0003-%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2/"},{"categories":["面试题"],"content":"LRU 缓存机制实现 ","date":"2022-05-25","objectID":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/:1:0","tags":["linux","算法"],"title":"面试题","uri":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["面试题"],"content":"要求 实现一个 LRU(最近最少使用)缓存机制 获取/写入数据时间复杂度是O(1) 获取数据 – 如果数据存在缓存中，则获取到数据的值，否则返回 -1 写入数据 – 如果密钥不存在则写入数据值，当缓存容量达到上限时候，它应该在写入之前删除最近最少使用的数据值，从而为新的数据值留出空间。 ","date":"2022-05-25","objectID":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/:1:1","tags":["linux","算法"],"title":"面试题","uri":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["面试题"],"content":"实现思路 要想O(1)一定要用hash了 有容量大小限制，构造函数需要传入容量限制值 构造函数: 1. 传入容量大小限制的值 2. 再定义属性 size 表示当前使用的容量 3. 定义一个hashmap + 一个双向链表; hashmap存放键+双向链表节点、 双向链表保存键对应的值 + 引用次数 get函数: 判断“键”是否存在于 hashmap，存在则获取对应的值，根据值获取到 hashmap 对应的值，然后更新引用计数，更新后与后一个节点比较，看看是否调整链表位置。 set函数: 判断\"键\"是否存在于 hashmap，存在则直接退出，不存在则创建新节点，插入 hashmap，并把节点放入 双向链表头部 ","date":"2022-05-25","objectID":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/:1:2","tags":["linux","算法"],"title":"面试题","uri":"/2022/05/0001-%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["linux"],"content":"cpu 相关术语 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"工作频率（外频和倍频） 早期的 CPU 架构主要通过北桥来链接系统最重要的 CPU、内存与显卡设备。因为所有的设 备都得通过北桥来链接，因此每个设备的工作频率应该要相同。 于是就有所谓的前端总线 (FSB) 这个东西的产生。但因为 CPU 的运算速度比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。 外频 外频指的是CPU与外部元件进行数据传输时的速度 倍频 倍频则是 CPU 内部用来加速工作性能的一个倍数， 两者相乘才是CPU的频率速度。 如 Intel Core 2 E8400 的内频为 3.0GHz，而外频是333MHz，因此倍频就是9倍啰! (3.0G=333Mx9, 其中1G=1000M) ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"超频 所谓的超频指的是: 将CPU的倍频或者是外频通过主板的设置功能更改成较高频率的一种方式。但因为CPU的倍频通常在出厂时已经被锁定而无法修改，因此较常被超频的为外频。 举例来说，像上述3.0GHz的CPU如果想要超频，可以将他的外频333MHz调整成为400MHz，但如此一来整个主板的各个元件的运行频率可能都会被增加成原本的1.333倍(4/3)，虽然CPU可能可以到达3.6GHz，但却因为频率并非正常速度，故可能会造成死机等问题。 现在 Intel 的 CPU 会主动帮你超频喔!例如 i7-4790 这颗 CPU 的规格 [10] 中，基本频 率为 3.6GHz，但是最高可自动超频到 4GHz 喔! 通过的是 Intel 的 turbo 技术。同时，如果 你没有大量的运算需求，该 CPU 频率会降到 1.xGHz 而已，借此达到节能省电的目的!所 以，各位好朋友， 不需要自己手动超频了!Intel 已经自动帮你进行超频了…所以，如果你用 cpu-z 观察 CPU 频率，发现该频率会一直自动变动。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"北桥 早期的 CPU 架构主要通过北桥来链接系统最重要的 CPU、内存与显卡设备。因为所有的设备都得通过北桥来链接，因此每个设备的工作频率应该要相同。于是就有所谓的前端总线(FSB)这个东西的产生。但如此一来所有的数据都被北桥卡死了，北桥又不可能比 CPU 更快，因此这家伙常常是系统性能的瓶颈。 为了解决这个问题，新的 CPU 设计中， 已经将内存控制器整合到 CPU 内部， 而链接 CPU 与内存、显卡的控制器的设计，在Intel部份使用 QPI (Quick Path Interconnect) 与 DMI 技术，而 AMD 部份则使用 Hyper Transport 了，这些技术都可以让 CPU 直接与内存、显卡等设备分别进行沟通，而不需要通过外部的链接芯片了。 因为现在没有所谓的北桥了(整合到CPU内)，因此，CPU 的频率设计就无须考虑得要同步的外频，只需要考虑整体的频率即可。所以，如果你经常有查阅自己 CPU 频率的习惯， 当使用 cpu-z 这个软件时，应该会很惊讶的发现到，怎么外频变成 100MHz 而倍频可以到达 30 以上!相当有趣呢! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:3","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"cpu 等级 由于x86架构的CPU在Intel的Pentium系列(1993年)后就有不统一的脚位与设计，为了将不 同种类的CPU规范等级， 所以就有i386,i586,i686等名词出现了。 基本上，在Intel Pentium MMX与AMD K6年代的CPU称为i586等级， 而Intel Celeron与AMD Athlon(K7)年代之后的32位CPU就称为i686等级。 至于目前的64位CPU则统称为x86_64等级。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:4","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"超线程(hyper-Threading, HT) 现在的 CPU 至少都是两个核心以上的多核心 CPU 了，但是 Intel 还有个很怪的东 西，叫做 CPU 的超线程 (Hyper-Threading) 功能! 那个是啥鬼东西?我们知道现在的 CPU 运算速度都太快了，因此运算核心经常处于闲置状态下。而我们也知道现在的系统大多 都是多任务的系统， 同时间有很多的程序会让 CPU 来执行。因此，若 CPU 可以假象的同时 执行两个程序，不就可以让系统性能增加了吗?反正 CPU 的运算能力还是没有用完啊! 在每一个 CPU 内部将重要的寄存器 (register) 分成两群， 而让程序分别使用这两群寄存器。也就是 说，可以有两个程序“同时竞争 CPU 的运算单元”，而非通过操作系统的多任务切换! 这一过 程就会让 CPU 好像“同时有两个核心”的模样!因此，虽然大部分 i7 等级的 CPU 其实只有四 个实体核心，但通过 HT 的机制， 则操作系统可以抓到八个核心!并且让每个核心逻辑上分 离，就可以同时运行八个程序了。 虽然很多研究与测试中，大多发现 HT 虽然可以提升性能，不过，有些情况下却可能导致性能 降低喔!因为，实际上明明就仅有一个运算单元嘛! 但是大多数使用场景下是可以提升性能(30%-50%)的。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:1:5","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"内存相关术语 CPU所使用的数据都是来自于内存(main memory)，不论是软件程序还是数据， 都必须要读入内存后CPU才能利用。 个人电脑的内存主要元件为动态随机存取内存 (Dynamic Random Access Memory, DRAM),随机存取内存只有在通电时才能记录与使 用，断电后数据就消失了。因此我们也称这种RAM为挥发性内存。 DRAM根据技术的更新又分好几代，而使用上较广泛的有所谓的SDRAM与DDR SDRAM 两种。这两种内存的差别除了在于脚位与工作电压上的不同之外，DDR是所谓的双倍数据传送 速度(Double Data Rate)， 他可以在一次工作周期中进行两次数据的传送，感觉上就好像是CPU的倍频啦! 所以传输频率方面比SDRAM还要好。 DDR SDRAM又依据技术的发展，有DDR, DDR2, DDR3, DDR4等等，其中，DDR2 的频率倍数则是 4 倍, 而DDR3 则是 8 倍喔! 内存的规格内提到 DDR3/DDR3L 同时支持，我们知道 DDR3 了，那 DDR3L 是啥鬼? 为了节省更多的电力，新的制程中降低了内存的操作电压，因此 DDR3 标 准电压为 1.5V，但 DDR3L 则仅须 1.35V 喔!通常可以用在耗电量需求更低的笔记本中! 但 并非所有的系统都同步支持!这就得要看主板的支持规格啰!否则你买了 DDR3L 安插在不支 持的主板上，DDR3L 内存是可能会烧毁的喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:2:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"工作频率 与 CPU 的频率类似的，内存也是有其工作的频率，这个频率限制还是来自于 CPU 内的内存 控制器所决定的。 CPU 内置的内存控制芯片对内存的工作频率最高可达到 1600MHz。这只是工作频率(每秒几次)。一般来说，每次频率能够传输的数据量，大多为 64 位，这个 64 位就是所谓的“宽度”了! 因此，这个系统中，CPU可以从内存中取 得的最快带宽就是 1600MHz 64bit = 1600MHz 8 Bytes = 12.8GByte/s。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:2:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"字组大小(带宽) 与总线宽度相似的，CPU每次能够处理的数据量称为字组大小(word size)，字组大小依据 CPU 的设计而有32位与64位。 我们现在所称的电脑是32或64位主要是依据这个 CPU 解析的字组大小而来的!早期的32位CPU中，因为CPU每次能够解析的数据量有限，因此由内存传来的数据量就有所限制了。这也导致32位的CPU最多只能支持最大到4GBytes的内存。 得利于北桥整合到 CPU 内部的设计，CPU 得以“个别”跟各个元件进行沟通!因此，每种元件与 CPU 的沟通具有很多不同的方式!例如内存使用系统总线带宽来与 CPU 沟通。而显卡则通过PCI-E的序列信道设计来与CPU沟通喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:2:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"容量大小 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:2:3","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"多通道设计 由于所有的数据都必须要存放在内存，所以内存的数据宽度当然是越大越好。 但传统的总线 宽度一般大约仅达64位，为了要加大这个宽度，因此芯片组厂商就将两个内存汇整在一起， 如果一支内存可达64位，两支内存就可以达到128位了，这就是双通道的设计理念。 要启用双通道的功能你必须要安插两支(或四支)内存，这两支内存最好连型号 都一模一样比较好， 这是因为启动双通道内存功能时，数据是同步写入/读出这一对内存中， 如此才能够提升整体的带宽啊! 所以当然除了容量大小要一致之外，型号也最好相同啦! 服务器所需要的速度更快!因此，除了双通道之外，中阶服务器也经常提供三信道，甚 至四信道的内存环境! 例如 2014 年推出的服务器用 E5-2650 v3 的 Intel CPU 中，它可以接 受的最大信道数就是四信道且为 DDR4 喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:2:4","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"存储分类 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:3:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"DRAM 和 SRAM 除了内存条之外，事实上整部个人电脑当中还有许许多多的内存存在喔!最为我们所知的就 是CPU内的第二层高速缓存内存。 我们现在知道CPU的数据都是由内存提供，但CPU到内存 之间还是得要通过内存控制器啊! 如果某些很常用的程序或数据可以放置到CPU内部的话， 那么CPU数据的读取就不需要跑到内存重新读取了! 这对于性能来说不就可以大大的提升 了?这就是第二层高速缓存的设计概念。 因为第二层高速缓存(L2 cache)整合到CPU内部，因此这个L2内存的速度必须要CPU频率 相同。 使用DRAM是无法达到这个频率速度的，此时就需要静态随机存取内存(Static Random Access Memory, SRAM)的帮忙了。 SRAM在设计上使用的电晶体数量较多，价格 较高，且不易做成大容量，不过由于其速度快， 因此整合到CPU内成为高速缓存内存以加快 数据的存取是个不错的方式喔!新一代的CPU都有内置容量不等的L2高速缓存在CPU内部， 以加快CPU的运行性能。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:3:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"ROM 主板上面的元件是非常多的，而每个元件的参数又具有可调整性。举例来说，CPU与内存的 频率是可调整的; 而主板上面如果有内置的网卡或者是显卡时，该功能是否要启动与该功能 的各项参数， 是被记录到主板上头的一个称为CMOS的芯片上，这个芯片需要借着额外的电源来发挥记录功能， 这也是为什么你的主板上面会有一颗电池的缘故。 那CMOS内的数据如何读取与更新呢?还记得你的电脑在开机的时候可以按下[Del]按键来进 入一个名为BIOS的画面吧? BIOS(Basic Input Output System)是一套程序，这套程序是写 死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就 是只读存储器(Read Only Memory, ROM)。 ROM是一种非挥发性的内存。另外，BIOS对 于个人电脑来说是非常重要的， 因为他是系统在开机的时候首先会去读取的一个小程序喔! 另外，固件(firmware)很多也是使用ROM来进行软件的写入的。 固件像软件一样也是 一个被电脑所执行的程序，然而他是对于硬件内部而言更加重要的部分。例如BIOS就是一个 固件， BIOS虽然对于我们日常操作电脑系统没有什么太大的关系，但是他却控制着开机时各 项硬件参数的取得! 所以我们会知道很多的硬件上头都会有ROM来写入固件这个软件。 BIOS 对电脑系统来讲是非常重要的，因为他掌握了系统硬件的详细信息与开机设备的选择等 等。但是电脑发展的速度太快了， 因此 BIOS 程序码也可能需要作适度的修改才行，所以你 才会在很多主板官网找到 BIOS 的更新程序啊!但是 BIOS 原本使用的是无法改写的 ROM ， 因此根本无法修正 BIOS 程序码!为此，现在的 BIOS 通常是写入类似闪存 (flash) 或 EEPROM中。 很多硬件上面都会有固件喔!例如常用的磁盘阵列卡、10G 的网卡、交换器设备等等!你可以简单的这么想!固件就是绑在硬件上面的控制软件! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:3:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"显卡 显卡又称为VGA(Video Graphics Array)，他对于图形影像的显示扮演相当关键的角色。 一 般对于图形影像的显示重点在于分辨率与色彩深度，因为每个图像显示的颜色会占用掉内 存， 因此显卡上面会有一个内存的容量，这个显存容量将会影响到你的屏幕分辨率与色彩深 度的喔! 除了显存之外，现在由于三度空间游戏(3D game)与一些3D动画的流行，因此显卡的“运算 能力”越来越重要。 一些3D的运算早期是交给CPU去运行的，但是CPU并非完全针对这些3D 来进行设计的，而且CPU平时已经非常忙碌了呢! 所以后来显卡厂商直接在显卡上面嵌入一 个3D加速的芯片，这就是所谓的GPU称谓的由来。 显卡主要也是通过CPU的控制芯片来与CPU、内存等沟通。如前面提到的，对于图形影像 (尤其是3D游戏)来说， 显卡也是需要高速运算的一个元件，所以数据的传输也是越快越 好!因此显卡的规格由早期的PCI导向AGP， 近期AGP又被PCI-Express规格所取代了。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:4:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"磁盘 硬盘依据台式机与笔记本电脑而有分为3.5英寸及2.5英寸的大小。我 们以3.5英寸的台式机使用硬盘来说明。 在硬盘盒里面其实是由许许多多的圆形盘片、机械手 臂、 磁头与主轴马达所组成的 实际的数据都是写在具有磁性物质的盘片上头，而读写主要是通过在机械手臂上的磁头 (head)来达成。 实际运行时， 主轴马达让盘片转动，然后机械手臂可伸展让磁头在盘片上 头进行读写的动作。 另外，由于单一盘片的容量有限，因此有的硬盘内部会有两个以上的盘 片喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"扇区 磁盘设计就是在类似盘片同心 圆上面切出一个一个的小区块，这些小区块整合成一个圆形，让机器手臂上的磁头去存取。这个小区块就是磁盘的最小物理储存单位，称之为扇区 (sector) ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"磁道 同一个同心圆的扇区 组合成的圆就是所谓的磁道(track)。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"柱面 由于磁盘里面可能会有多个盘片，因此在所有盘片上 面的同一个磁道可以组合成所谓的柱面 (cylinder)。 我们知道同心圆外圈的圆比较大，占用的面积比内圈多啊!所以，为了善用这些空间，因此 外围的圆会具有更多的扇区[16]! 就如同图 0.2.5 的示意一般。此外，当盘片转一圈时，外圈 的扇区数量比较多，因此如果数据写入在外圈，转一圈能够读写的数据量当然比内圈还要 多! 因此通常数据的读写会由外圈开始往内写的喔!这是默认值啊! 另外，原本硬盘的扇区都是设计成 512Byte 的容量，但因为近期以来硬盘的容量越来越大， 为了减少数据量的拆解，所以新的大容量硬盘已经有 4KByte 的扇区设计!要注意一下。也因为这个扇区的设计不同了，因此在磁盘的分区方面，目前有旧式的 MSDOS 相容模式，以及较新的 GPT 模式喔! 在较新的 GPT 模式下，磁盘的分区通常使用 扇区号码来设计，跟过去旧的 MSDOS 是通过柱面号码来分区的情况不同喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:3","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"传输接口 为了要提升磁盘的传输速度，磁盘与主板的连接接口也经过多次的改版，传统磁盘接口包括有 SATA, SAS, IDE 与 SCSI 等等。 若考虑外接式磁盘，那就还 包括了 USB, eSATA 等等接口喔!不过目前 IDE 已经被 SATA 取代，而 SCSI 则被 SAS 取 代，因此我们下面将仅介绍 SATA, USB 与 SAS 接口而已。 SATA接口 这种插槽所使用的排线比较窄 小， 而且每个设备需要使用掉一条SATA线。因为SATA线比较窄小之故，所以对于安装与机 箱内的通风都比较好!因此原本的IDE粗排线接口就被SATA取代了! 由于SATA一条排线仅接一颗硬盘，所以你不需要调整跳针。不过一张主板上面SATA插槽的数 量并不是固定的， 且每个插槽都有编号，在连接SATA硬盘与主板的时候，还是需要留意一 下。此外，目前的 SATA 版本已经到了第三代 [17]， 每一代之间的传输速度如下所示，而且 重点是，每一代都可以向下相容喔!只是速度上会差很多就是了。目前主流都是使用 SATA3 这个接口速度可达 600MByte/s 的接口! 版本 带宽(Gbit/s) 速度(MByte/s) SATA 1.0 1.5 150 SATA 2.0 3 300 SATA 3.0 6 600 因为 SATA 传输接口传输时，通过的数据演算法的关系，当传输 10 位编码时，仅有 8 位为数 据，其余 2 位为检验之用。因此带宽的计算上面， 使用的换算 (bit 转 Byte) 为 1:10 而不 是 1Byte=8bits 喔!上表的对应要稍微注意一下。另外，虽然这个 SATA3 接口理论上可达 600MBytes/s 的传输速度， 不过目前传统的硬盘由于其物理组成的限制，一般极限速度大约 在 150~200MByte/s 而已啦!所以厂商们才要发展固态硬盘啊! SAS 接口 早期工作站或大型大脑上面，为了读写速度与稳定性，因此在这样的机器上面，大多使用的 是 SCSI 这种高阶的连接接口。 不过这种接口的速度后来被 SATA 打败了!但是 SCSI 有其 值得开发的功能，因此后来就有串行式 SCSI (Serial Attached SCSI, SAS) 的发展。这种 接口的速度比 SATA 来的快，而且连接的 SAS 硬盘的盘片转速与传输的速度也都比 SATA 硬 盘好! 只是…好贵喔!而且一般个人电脑的主板上面通常没有内置 SAS 连接接口，得要通过 外接卡才能够支持。因此一般个人电脑主机还是以 SATA 接口为主要的磁盘连接接口啰。 版本 带宽(Gbit/s) 速度(MByte/s) SAS 1 3 300 SAS 2 6 600 SAS 3 12 1200 因为这种接口的速度确实比较快喔!而且还支持例如热拔插等功能，因此，许多的设备连接 会以这种接口来链接! 例如我们经常会听到的磁盘阵列卡的连接插槽，就是利用这种 SAS 接 口开发出来的支持的 SFF-8087 设备等等。 USB接口 如果你的磁盘是外接式的接口，那么很可能跟主板链接的就是 USB 这种接口了!这也是目前 (2015) 最常见到的外接式磁盘接口了。 不过传统的 USB 速度挺慢的，即使是比较慢的传 统硬盘，其传输率大概兜还有 80~120MBytes/s ，但传统的 USB 2.0 仅有大约 60MBytes/s 的理论传输率， 通常实做在主板上面的连接口，竟然都仅有 30~40 MByte/s 而已呢!实在发 挥不出磁盘的性能啊! 为了改善 USB 的传输率，因此新一代的 USB 3.0 速度就快很多了!据说还有更新的 USB 3.1 正在发展中!这几代版本的带宽与速度制表如下： 版本 带宽(Mbit/s) 速度(MByte/s) USB 1.0 12 1.5 USB 2.0 480 60 USB 3.0 5G 500 USB 3.1 10G 1000 跟 SATA 接口一样，不是理论速度到达该数值，实际上就可以跑到这么高!USB 3.0 虽然速 度很快，但如果你去市面上面买 USB 的传统磁盘或闪存盘， 其实他的读写速度还是差不多在 100MBytes/s 而已啦!不过这样就超级快了!因为一般 USB2.0 的闪存盘读写速度大约是 40MBytes/10MBytes 左右而已说。 在购买这方面的外接式磁盘时，要特别考虑喔! 固态硬盘(solid State Disk, SSD) 传统硬盘有个很致命的问题，就是需要驱动马达去转动盘片~这会造成很严重的磁盘读取延 迟!想想看，你得要知道数据在哪个扇区上面，然后再命令马达开始转， 之后再让磁头去读 取正确的数据。另外，如果数据放置的比较离散(扇区分佈比较广又不连续)，那么读写的 速度就会延迟更明显!速度快不起来。因此， 后来就有厂商拿闪存去制作成大容量的设备， 这些设备的连接接口也是通过 SATA 或 SAS，而且外型还做的跟传统磁盘一样!所以， 虽然 这类的设备已经不能称为是磁盘 (因为没有磁头与盘片啊!都是内存!)。但是为了方便大 家称呼，所以还是称为磁盘!只是跟传统磁盘 (Hard Disk Drive, HDD) 不同， 就称为固态 硬盘 (Solid State Disk 或 Solid State Driver, SSD)。 固态硬盘最大的好处是，它没有马达不需要转动，而是通过内存直接读写的特性，因此除了 没数据延迟且快速之外，还很省电! 不过早期的 SSD 有个很重要的致命伤，就是这些闪存 有“写入次数的限制”，因此通常 SSD 的寿命大概两年就顶天了!所以数据存放时， 需要考虑 到备份或者是可能要使用 RAID 的机制来防止 SSD 的损毁 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:4","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"扩展卡与接口 你的服务器可能因为某些特殊的需求，因此需要使用主板之外的其他适配卡。所以主板上面 通常会预留多个扩充接口的插槽， 这些插槽依据历史沿革，包括 PCI/AGP/PCI-X/PCIe 等 等，但是由于 PCIe 速度快到太好用了，因此几乎所有的卡都以 PCIe 来设计了! 但是有些比 较老旧的卡可能还需要使用啊，因此一般主板大多还是会保留一两个 PCI 插槽，其他的则是 以 PCIe 来设计。 多信号卡 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:5:5","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"主板 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:6:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"设备I/O位址与IRQ中断信道 主板是负责各个电脑元件之间的沟通，但是电脑元件实在太多了，有输出/输入/不同的储存设 备等等， 主板芯片组怎么知道如何负责沟通呐?这个时候就需要用到所谓的I/O位址与IRQ 啰! I/O位址有点类似每个设备的门牌号码，每个设备都有他自己的位址，一般来说，不能有两个 设备使用同一个I/O位址， 否则系统就会不晓得该如何运行这两个设备了。而除了I/O位址之 外，还有个IRQ中断(Interrupt)这个咚咚。 如果I/O位址想成是各设备的门牌号码的话，那么IRQ就可以想成是各个门牌连接到邮件中心 (CPU)的专门路径啰! 各设备可以通过IRQ中断信道来告知CPU该设备的工作情况，以方 便CPU进行工作分配的任务。 老式的主板芯片组IRQ只有15个，如果你的周边接口太多时可 能就会不够用， 这个时候你可以选择将一些没有用到的周边接口关掉，以空出一些IRQ来给 真正需要使用的接口喔! 当然，也有所谓的sharing IRQ的技术就是了! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:6:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"CMOS与BIOS CMOS主要的 功能为记录主板上面的重要参数， 包括系统时间、CPU电压与频率、各项设备的I/O位址与 IRQ等，由于这些数据的记录要花费电力，因此主板上面才有电池。 BIOS为写入到主板上某 一块 flash 或 EEPROM 的程序，他可以在开机的时候执行，以载入CMOS当中的参数， 并尝 试调用储存设备中的开机程序，进一步进入操作系统当中。BIOS程序也可以修改CMOS中的 数据， 每种主板调用BIOS设置程序的按键都不同，一般台式机常见的是使用[del]按键进入 BIOS设置画面。 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:6:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"连接周边设备的接口 主板与各项输出/输入设备的链接主要都是在主机机箱的后方，主要有: PS/2接口:这原本是常见的键盘与鼠标的接口，不过目前渐渐被USB接口取代，甚至较 新的主板可能就不再提供 PS/2 接口了; USB接口:通常只剩下 USB 2.0 与 USB 3.0，为了方便区分，USB 3.0 为蓝色的插槽颜 色喔! 声音输出、输入与麦克风:这个是一些圆形的插孔，而必须你的主板上面有内置音效芯 片时，才会有这三个东西; RJ-45网络头:如果有内置网络芯片的话，那么就会有这种接头出现。 这种接头有点类 似电话接头，不过内部有八蕊线喔!接上网络线后在这个接头上会有灯号亮起才对! HDMI:如果有内置显示芯片的话，可能就会提供这个与屏幕连接的接口了!这种接口可 以同时传输声音与影像， 目前也是电视机屏幕的主流连接接口喔! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:6:3","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"电源供应器 除了上面这些元件之外，其实还有一个很重要的元件也要来谈一谈，那就是电源供应器 (Power)。 在你的机箱内，有个大大的铁盒子，上头有很多电源线会跑出来，那就是电源 供应器了。 我们的CPU/RAM/主板/硬盘等等都需要用电，而近来的电脑元件耗电量越来越高，以前很古早的230W电源已经不够用了， 有的系统甚至得要有500W以上的电源才能够运 行~真可怕~ 电源供应器的价差非常大!贵一点的300W可以到4000 NT，便宜一点的300W只要500 NT不 到! 怎么差这么多?没错~因为Power的用料不同，电源供应的稳定性也会差很多。如前所 述，电源供应器相当于你的心脏， 心脏差的话，活动力就会不足了!所以， 稳定性差的电源 供应器甚至是造成电脑不稳定的元凶呢!所以，尽量不要使用太差的电源供应器喔! 能源转换率 电源供应器本身也会吃掉一部份的电力的!如果你的主机系统需要 300W 的电力时，因为电 源供应器本身也会消耗掉一部份的电力， 因此你最好要挑选400W以上的电源供应器。电源供 应器出厂前会有一些测试数据，最好挑选高转换率的电源供应器。 所谓的高转换率指的是“输 出的功率/输入的功率”。意思是说，假如你的主板用电量为250W， 但是电源供应器其实已经 使用掉320W的电力，则转换率为:250/320=0.78的意思。 这个数值越高表示被电源供应 器“玩掉”的电力越少，那就符合能源效益了! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:6:4","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"数据表示方式 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:7:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"数字系统(进制) ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:7:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"文字编码系统 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:7:2","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"linux 历史回顾 操作系统(Operation System)主要在管理与驱动硬件，因此必须要能够管理内存、管 理设备、 负责行程管理以及系统调用等等。因此，只要能够让硬件准备妥当(Ready) 的情况， 就是一个阳春的操作系统了。 Unix的前身是由贝尔实验室(Bell lab.)的Ken Thompson利用组合语言写成的， 后来在 1971-1973年间由Dennis Ritchie以C程序语言进行改写，才称为Unix。 1977年由Bill Joy释出BSD (Berkeley Software Distribution)，这些称为Unix-like的操作 系统。 1984年由Andrew Tanenbaum开始制作Minix操作系统，该系统可以提供源代码以及软 件; 1984年由Richard Stallman提倡GNU计划，倡导自由软件(Free software)， 强调其软 件可以“自由的取得、复制、修改与再发行”，并规范出GPL授权模式， 任何 GPL(General Public License)软件均不可单纯仅贩卖其软件，也不可修改软件授权。 1991年由芬兰人Linus Torvalds开发出Linux操作系统。简而言之，Linux成功的地方主要 在于: Minix(Unix), GNU, Internet, POSIX 及虚拟团队的产生。 符合 Open source 理念的授权相当多，比较知名的如 Apache / BSD / GPL / MIT 等。 Linux本身就是个最阳春的操作系统，其开发网站设立在http://www.kernel.org，我们亦称 Linux操作系统最底层的数据为“核心(Kernel)”。 从 Linux kernel 3.0 开始，已经舍弃奇数、偶数的核心版本规划，新的规划使用主线版本 (MainLine) 为依据， 并提供长期支持版本 (longterm) 来加强某些功能的持续维 护。 Linux distributions的组成含有:“Linux Kernel + Free Software + Documentations(Tools) + 可完整安装的程序”所制成的一套完整的系统。 常见的 Linux distributions 分类有“商业、社群”分类法，或“RPM、DPKG”分类法 ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:8:0","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["linux"],"content":"linux 初探 你在你的主机上面安装了一张网卡，但是开机之后，系统却无法使用，你确定网卡是好 的，那么可能的问题出在哪里?该如何解决?因为所有的硬件都没有问题，所以，可能 出问题的地方在于系统的核心(kernel) 不支持这张网卡。解决的方法，(1)到网卡的 开发商网站，(2)下载支持你主机操作系统的驱动程序， (3)安装网卡驱动程序后， 就可以使用了。 一个操作系统至少要能够完整的控制整个硬件，请问，操作系统应该要控制硬件的哪些 单元?根据硬件的运行，以及数据在主机上面的运算情况与写入/读取情况，我们知道至 少要能够控制: (1)input/output control, (2)device control, (3)process management, (4)file management. 等等! 我在Windows上面玩的游戏，可不可以拿到Linux去玩?当然不行!因为游戏也是一个应 用程序 (application)，他必须要使用到核心所提供的工具来开发他的游戏， 所以这个 游戏是不可在不同的平台间运行的。除非这个游戏已经进行了移植。 Linux本身仅是一个核心与相关的核心工具而已，不过，他已经可以驱动所有的硬件， 所 以，可以算是一个很阳春的操作系统了。经过其他应用程序的开发之后，被整合成为 Linux distribitions。请问众多的distributions之间，有何异同?相同:(1)同样使用 http://www.kernel.org 所释出的核心; (2)支持同样的标准，如 FHS、LSB 等; (3) 使用几乎相同的自由软件 (例如 GNU 里面的 gcc/glibc/vi/apache/bind/sendmail… ); (4)几乎相同的操作接口 (例如均使用 bash/KDE/GNOME 等等)。 不同:使用的 kernel 与各软件的版本可能会不同;各开发商加入的应用工具不同，使用的套件管理模 式不同(dpkg 与 RPM) Unix 是谁写出来的? GNU 计划是谁发起的?Unix 是 Ken Thompson 写的，1973 年再 由 Dennis Ritchie 以 C 语言改写成功。 至于 GNU 与 FSF 则是 Richard Stallman 发起 的。 GNU 的全名为何?他主要由那个基金会支持?GNU 是 GNU is Not Unix 的简写，是个无 穷循环! 另外，这个计划是由自由软件基金会 (Free Software Foundation, FSF) 所支持的! 两者都是由 Stallman 先生所发起的! 何谓多用户 ( Multi-user ) 多任务 ( Multitask )?Multiuser 指的是 Linux 允许多人同 时连上主机之外，每个使用者皆有其各人的使用环境，并且可以同时使用系统的资源! Multitask 指的是多任务环境，在 Linux 系统下， CPU 与其他例如网络资源可以同时进行 多项工作， Linux 最大的特色之一即在于其多任务时，资源分配较为平均! 简单说明 GNU General Public License ( GPL ) 与 Open Source 的精神:1. GPL 的授 权之软件，乃为自由软件(Free software)，任何人皆可拥有他; 2. 开发 GPL 的团体 (或商业企业)可以经由该软件的服务来取得服务的费用; 3. 经过 GPL 授权的软件，其 属于 Open source 的情况，所以应该公布其源代码; 4. 任何人皆可修改经由 GPL 授权 过的软件，使符合自己的需求; 5. 经过修改过后 Open source 应该回馈给 Linux 社群。 什么是 POSIX ?为何说 Linux 使用 POSIX 对于发展有很好的影响?POSIX 是一种标准 规范，主要针对在 Unix 操作系统上面跑的程序来进行规范。 若你的操作系统符合 POSIX ，则符合 POSIX 的程序就可以在你的操作系统上面运行。 Linux 由于支持 POSIX ，因此很多 Unix 上的程序可以直接在 Linux 上运行， 因此程序的移植相当简 易!也让大家容易转换平台，提升 Linux 的使用率。 简单说明 Linux 成功的因素?1. 借由 Minix 操作系统开发的 Unix like ，没有版权的纠 纷; 2. 借助于 GNU 计划所提供的各项工具软件， gcc/bash 等; 3. 借由 Internet 广为 流传; 4. 借由支持 POSIX 标准，让核心能够适合所有软件的开发; 5. 托瓦兹强调务 实，虚拟团队的自然形成! ","date":"2022-05-24","objectID":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/:8:1","tags":["linux","linux基础","linux术语"],"title":"Linux基础-术语","uri":"/2022/05/0008-linux%E5%9F%BA%E7%A1%80-%E6%9C%AF%E8%AF%AD/"},{"categories":["kernel"],"content":"概述 虚拟文件系统(也称为虚拟文件系统交换机)是内核中的软件层，它为用户空间程序提供文件系统接口。它还在内核中提供了一个抽象，允许不同的文件系统实现共存。 VFS系统调用open(2)、stat(2)、read(2)、write(2)、chmod(2)等等都是从进程上下文中调用的。 文件系统锁在文档\"锁\"中进行了介绍。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:1:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"目录条目缓存(dcache) VFS实现了open(2)、stat(2)、chmod(2)和类似的系统调用。传递给它们的pathname参数由VFS用于搜索目录条目缓存(也称为dentry缓存或dcache)。这提供了一种非常快速的查找机制，可以将路径名(filename)转换为特定的dentry。dentry存储在RAM中，从不保存到磁盘:它们的存在只是为了性能。 dentry缓存是整个文件空间的视图。由于大多数计算机不能同时将所有dentry放入RAM中，所以缓存的一些位元会丢失。为了将路径名解析为dentry, VFS可能不得不在过程中创建dentry，然后加载inode。这是通过查找inode来完成的。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:2:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"inode 对象 单个dentry通常有一个指向inode的指针。inode是文件系统对象，比如普通文件、目录、fifo 和其他东西。它们要么存在于磁盘(对于块设备文件系统)，要么存在于内存(对于伪文件系统)。当需要时，将磁盘上的inode复制到内存中，并将对inode的更改写回磁盘。一个inode可以被多个dentry指向(例如，硬链接就是这样做的)。 要查找一个inode, VFS需要调用父目录inode的lookup()方法。该方法由inode所在的特定文件系统实现安装。一旦VFS拥有了所需的dentry(以及inode)，我们就可以执行所有无聊的操作，比如打开(2)文件或stat(2)文件以查看inode数据。stat(2)操作相当简单:一旦VFS有了dentry，它就会查看inode数据，并将其中一些数据传递回用户空间。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:3:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"File 对象 打开文件需要另一项操作:分配文件结构(这是文件描述符的内核端实现)。使用指向dentry的指针和一组文件操作成员函数初始化新分配的文件结构。这些数据来自inode数据。然后调用open()文件方法，这样特定的文件系统实现就可以完成它的工作。您可以看到，这是由VFS执行的另一个开关。文件结构被放置到进程的文件描述符表中。 读取、写入和关闭文件(以及其他各种VFS操作)是通过使用用户空间文件描述符来获取适当的文件结构，然后调用所需的文件结构方法来完成所需的操作。只要文件处于打开状态，它就保持使用dentry，这又意味着VFS inode仍在使用。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:4:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"注册和挂载文件系统 注册和注销文件系统，使用以下API函数: #include \u003clinux/fs.h\u003e extern int register_filesystem(struct file_system_type *); extern int unregister_filesystem(struct file_system_type *); 传递的struct file_system_type描述了文件系统。当需要将文件系统挂载到名称空间中的目录时，VFS将为特定的文件系统调用适当的mount()方法。新vfmount将把 -\u003emount() 返回的树形结构附加到挂载点，这样当路径名解析到达挂载点时，它将跳转到该vfmount的根目录。 您可以在文件/proc/filesystems中看到注册到内核的所有文件系统。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:5:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct file_system_type 这描述了文件系统。在2.6.39内核中，定义了以下成员: struct file_system_type { const char *name; int fs_flags; struct dentry *(*mount) (struct file_system_type *, int, const char *, void *); void (*kill_sb) (struct super_block *); struct module *owner; struct file_system_type * next; struct list_head fs_supers; struct lock_class_key s_lock_key; struct lock_class_key s_umount_key; }; name 文件系统类型的名称，例如“ext2”、“iso9660”、“msdos”等。 fs_flags 各种标志(例如:FS_REQUIRES_DEV, FS_NO_DCACHE等)。 mount 当应该安装该文件系统的新实例时调用的方法。mount()方法必须返回调用者请求的树的根dentry。对其超级块的激活引用必须被抓取，并且超级块必须被锁定。失败时，它应该返回ERR_PTR(错误)。 参数1(struct file_system_type *):描述由特定文件系统代码部分初始化的文件系统 参数2(int):挂载flag; 参数3(const char *): 要挂载的设备名； 参数4(void*)：任意的挂载选项，通常是ASCII字符串(参见“Mount Options”一节) kill_sb 当该文件系统的实例应该关闭时要调用的方法 owner 对于内部VFS使用:你应该在大多数情况下初始化THIS_MODULE。 next 对于内部VFS使用:你应该将其初始化为NULL s_lock_key, s_umount_key lockdep-specific… ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:5:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"superblock 对象 超级块对象表示一个挂载的文件系统。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct super_operations 这描述了VFS如何操作文件系统的超级块。在2.6.22内核中，定义了以下成员: struct super_operations { struct inode *(*alloc_inode)(struct super_block *sb); void (*destroy_inode)(struct inode *); void (*dirty_inode) (struct inode *, int flags); int (*write_inode) (struct inode *, int); void (*drop_inode) (struct inode *); void (*delete_inode) (struct inode *); void (*put_super) (struct super_block *); int (*sync_fs)(struct super_block *sb, int wait); int (*freeze_fs) (struct super_block *); int (*unfreeze_fs) (struct super_block *); int (*statfs) (struct dentry *, struct kstatfs *); int (*remount_fs) (struct super_block *, int *, char *); void (*clear_inode) (struct inode *); void (*umount_begin) (struct super_block *); int (*show_options)(struct seq_file *, struct dentry *); ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t); ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t); int (*nr_cached_objects)(struct super_block *); void (*free_cached_objects)(struct super_block *, int); }; 除非另有说明，否则所有方法都是在不持有任何锁的情况下调用的。这意味着大多数方法都可以安全地阻塞。所有方法只能从进程上下文中调用(即不能从中断处理程序或下半部调用)。 alloc_inode 该方法由alloc_inode()调用，为结构inode分配内存并对其进行初始化。如果未定义此函数，则分配一个简单的struct inode。通常，alloc_inode 会被用来分配一个更大的结构，其中包含一个struct inode嵌入其中。 destroy_inode destroy_inode()调用这个方法来释放分配给结构inode的资源。只有在定义了-\u003ealloc_inode时才需要它，它只是简单地撤销-\u003ealloc_inode所做的任何事情。 dirty_inode 当一个inode被标记为dirty时，VFS会调用这个方法。这是专门针对被标记为dirty的inode本身，而不是它的数据。如果fdatasync()需要持久化更新，则I_DIRTY_DATASYNC将在flags参数中设置。 write_inode 当VFS需要将一个inode写入磁盘时，调用此方法。第二个参数表示写是否应该是同步的，并不是所有的文件系统都检查这个标志。 drop_inode 在删除对inode的最后一次访问时调用，并保持inode-\u003ei_lock自旋锁。 此方法应该是NULL(普通UNIX文件系统语义)或generic_delete_inode(对于不希望缓存inode的文件系统-导致无论i_nlink的值如何，总是调用delete_inode) generic_delete_inode()行为相当于在put_inode()情况下使用force_delete的旧实践，但不具有force_delete()方法所具有的竞争。 delete_inode 当VFS想要删除一个inode时调用 put_super 当VFS希望释放超级块(即卸载)时调用。在超级块锁被持有时调用 sync_fs 当VFS写入与超级块关联的所有脏数据时调用。第二个参数指示方法是否应该等待直到写操作完成。可选的。 freeze_fs 当VFS锁定文件系统并强制其进入一致状态时调用。该方法目前由逻辑卷管理器(LVM)使用。 unfreeze_fs 当VFS解锁文件系统并使其重新可写时调用。 statfs 当VFS需要获取文件系统统计信息时调用。 remount_fs 当重新装载文件系统时调用。这是在内核锁被持有时调用的 clear_inode 调用，则VFS清除该inode。可选 umount_begin 当VFS卸载文件系统时调用。 show_options 由VFS调用，以显示/proc//mounts。(参见“安装选项”一节) quota_read 调用VFS来读取文件系统配额文件。 quota_write 调用VFS来写入文件系统的配额文件。 nr_cached_objects 由sb缓存收缩函数为文件系统调用，以返回它所包含的可释放缓存对象的数量。可选的。 free_cache_objects 由sb缓存收缩函数为文件系统调用，以扫描指定的尝试释放对象的数量。可选，但任何实现此方法的文件系统还需要实现-\u003enr_cached_objects才能正确调用它。 我们无法处理文件系统可能遇到的任何错误，因此返回类型为void。如果VM尝试在GFP_NOFS条件下回收，则永远不会调用该方法，该方法本身不需要处理这种情况。 实现必须包括已完成的任何扫描循环内的条件重调度调用。这使得VFS可以确定适当的扫描批处理大小，而不必担心实现是否会由于大的扫描批处理大小而导致延迟问题。 设置inode的人负责填充i_op字段。这是一个指向struct inode_operations的指针，该指针描述了可以在单个inode上执行的方法。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct xattr_handlers 在支持扩展属性(xattrs)的文件系统上，s_xattr超级块字段指向一个以null结尾的xattr处理程序数组。扩展属性是 key:value 对。 name 指示处理程序匹配具有指定名称的属性(例如system.posix_acl_access);prefix字段必须为NULL。 prefix 指示处理程序匹配所有具有指定名称前缀的属性(如“user.”);名称字段必须为NULL。 list 确定是否应该为特定dentry列出与这个xattr处理程序匹配的属性。用于一些listxattr实现，如generic_listxattr。 get 由VFS调用以获取特定扩展属性的值。该方法由getxattr(2)系统调用调用。 set 由VFS调用，以设置特定扩展属性的值。当新值为NULL时，调用该函数以删除特定的扩展属性。该方法由setxattr(2)和removexattr(2)系统调用调用。 当文件系统的xattr处理程序与指定的属性名不匹配或者文件系统不支持扩展属性时，所有*xattr(2)系统调用将返回-EOPNOTSUPP。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:2","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"inode 对象 inode对象表示文件系统中的一个对象 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct inode_operations 这描述了VFS如何操作文件系统中的inode。在2.6.22内核中，定义了以下成员: struct inode_operations { int (*create) (struct user_namespace *, struct inode *,struct dentry *, umode_t, bool); struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int); int (*link) (struct dentry *,struct inode *,struct dentry *); int (*unlink) (struct inode *,struct dentry *); int (*symlink) (struct user_namespace *, struct inode *,struct dentry *,const char *); int (*mkdir) (struct user_namespace *, struct inode *,struct dentry *,umode_t); int (*rmdir) (struct inode *,struct dentry *); int (*mknod) (struct user_namespace *, struct inode *,struct dentry *,umode_t,dev_t); int (*rename) (struct user_namespace *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int); int (*readlink) (struct dentry *, char __user *,int); const char *(*get_link) (struct dentry *, struct inode *, struct delayed_call *); int (*permission) (struct user_namespace *, struct inode *, int); struct posix_acl * (*get_acl)(struct inode *, int, bool); int (*setattr) (struct user_namespace *, struct dentry *, struct iattr *); int (*getattr) (struct user_namespace *, const struct path *, struct kstat *, u32, unsigned int); ssize_t (*listxattr) (struct dentry *, char *, size_t); void (*update_time)(struct inode *, struct timespec *, int); int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned open_flag, umode_t create_mode); int (*tmpfile) (struct user_namespace *, struct inode *, struct dentry *, umode_t); int (*set_acl)(struct user_namespace *, struct inode *, struct posix_acl *, int); int (*fileattr_set)(struct user_namespace *mnt_userns, struct dentry *dentry, struct fileattr *fa); int (*fileattr_get)(struct dentry *dentry, struct fileattr *fa); }; 同样，调用所有方法时不会持有任何锁，除非另有说明。 create 由open(2)和create(2)系统调用调用。只有在支持常规文件时才需要。你得到的dentry不应该有一个inode(即，它应该是一个负dentry)。在这里，您可能会使用dentry和新创建的inode调用d_instantiate() lookup 当VFS需要在父目录中查找一个inode时调用。要查找的名字在dentry中找到。这个方法必须调用d_add()来将找到的inode插入dentry。inode结构中的“i_count”字段应该递增。如果指定的inode不存在，则应该在dentry中插入一个NULL inode(这称为负dentry)。从这个例程返回错误代码必须只在真正发生错误时才可以，否则使用create(2)、mknod(2)、mkdir(2)等系统调用创建索引节点将会失败。如果你希望重载dentry方法，那么你应该初始化dentry中的“d_dop”字段;这是一个指向结构体“dentry_operations”的指针。在保存目录inode信号量的情况下调用此方法 link 由link(2)系统调用调用。只有在支持硬链接时才需要。您可能需要调用d_instantiate()，就像在create()方法中那样 unlink symlink 由symlink(2)系统调用调用。只有在希望支持符号链接时才需要。您可能需要调用d_instantiate()，就像在create()方法中那样 mkdir rmdir mknod 由mknod(2)系统调用来创建一个设备(char, block) inode或一个命名管道(FIFO)或套接字。只有在希望支持创建这些类型的索引节点时才需要。您可能需要调用d_instantiate()，就像在create()方法中那样 rename 由rename(2)系统调用调用，重命名对象，使其具有由第二个inode和dentry提供的父节点和名称。对于任何不支持或未知的标志，文件系统必须返回-EINVAL。目前实现了以下标志: (1) RENAME_NOREPLACE:该标志表示如果重命名目标存在，重命名将失败，使用-EEXIST代替目标。VFS已经检查是否存在，因此对于本地文件系统，RENAME_NOREPLACE实现等价于普通重命名。 (2) RENAME_EXCHANGE: exchange源和目标。必须存在;这由VFS检查。与普通重命名不同，源和目标可能具有不同的类型。 get_link 由VFS调用，以跟随到它所指向的inode的符号链接。只有在希望支持符号链接时才需要。这个方法返回要遍历的符号链接体(并可能使用nd_jump_link()重置当前位置)。如果在inode消失之前，主体不会消失，那么其他东西就不需要了;如果需要以其他方式固定它，通过让get_link(…，…，done)执行set_delayed_call(done, destructor, argument)来安排它的释放。在这种情况下，一旦VFS处理完您返回的函数体，就会调用estructor(argument)。可以在RCU模式下调用;由NULL dentry参数表示。如果请求不离开RCU模式就不能被处理，让它返回ERR_PTR(-ECHILD)。如果文件系统将符号链接目标存储在-\u003ei_link中，VFS可以直接使用它而不调用-\u003eget_link();但是，-\u003eget_link()仍然必须提供。—\u003ei_link必须在RCU宽限期后才能释放。 readlink 这现在只是readlink(2)在-\u003eget_link使用nd_jump_link()或object实际上不是符号链接的情况下使用的重载。通常文件系统应该只实现-\u003eget_link用于符号链接，readlink(2)将自动使用它。 permission 由VFS调用，以检查类posix文件系统上的访问权限。可以在rcu-walk模式下调用(mask \u0026 MAY_NOT_BLOCK)。如果在rcu-walk模式下，文件系统必须检查权限，而不能阻塞或存储到inode。如果遇到rcu-walk不能处理的情况，返回-ECHILD，它将在refwalk模式中再次被调用。 setattr getattr listxattr update_time atomic_open 对一个open的最后一个组件调用。使用这个可选的方法，文件系统可以在一个原子操作中查找、创建和打开文件。如果它想把实际打开留给调用者(例如，如果文件是一个符号链接、设备，或者只是文件系统不会原子打开的东西)，它可能通过返回finish_no_open(file, dentry)来发出信号。仅当最后一个组件为负数或需要查找时，才调用此方法。缓存的正向dentry仍然由f_op-\u003eopen()处理。如果文件已经创建，FMODE_CREATED标志应该设置在file-\u003ef_mode中。在O_EXCL的情况下，只有在文件不存在的情况下，该方法才会成功，因此FMODE_CREATED总是在成功时设置。 tmpfile 在O_TMPFILE open()的末尾调用。可选，相当于在给定目录中自动创建、打开和解链接文件。 fileattr_get 调用ioctl(FS_IO","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"地址空间对象(The Address Space Object) 地址空间对象用于对页缓存中的页进行分组和管理。它可以用来跟踪文件(或其他文件)中的页面，还可以跟踪文件各部分到进程地址空间的映射。 地址空间可以提供许多不同但相关的服务。这些方法包括通信内存压力、按地址查找页面以及跟踪标记为Dirty或Writeback的页面。 第一个可以单独用于其他的。VM可以尝试写入脏页以清除它们，也可以释放干净页以重用它们。为此，它可以在脏页面上调用-\u003ewritepage方法，在干净页面上调用-\u003ereleasepage方法，并设置pagprivate。没有PagePrivate和没有外部引用的干净页面将在不通知address_space的情况下被释放。 为了实现此功能，需要将页面放置在LRU上，并在使用页面时调用lru_cache_add和mark_page_active。 页面通常通过-\u003eindex保存在基数树索引中。该树维护每个页面的PG_Dirty和PG_Writeback状态信息，以便快速找到带有这两个标志的页面。 Dirty标记主要由mpage_writpages(默认的-\u003ewritpages方法)使用。它使用标记查找脏页并调用-\u003ewritepage。如果没有使用mpage_writepages(即地址提供了自己的-\u003ewritepages)，那么PAGECACHE_TAG_DIRTY标签几乎没有被使用。Write_inode_now和sync_inode使用它(通过__sync_single_inode)来检查-\u003ewritepages是否成功地写出了整个地址空间。 Writeback标记由filemap* wait*和sync_page*函数使用，通过filemap_fdatawait_range函数等待所有的Writeback完成。 address_space处理程序可以附加额外的信息到一个页面，通常使用’struct page‘中的’private‘字段。如果附加了这些信息，则应该设置PG_Private标志。这将导致各种VM例程对address_space处理程序进行额外调用来处理该数据。 地址空间充当存储和应用程序之间的中介。每次将整个页的数据读入地址空间，并通过复制页或对页进行内存映射的方式提供给应用程序。应用程序将数据写入地址空间，然后通常以整个页面的形式将数据写回存储，但是address_space可以更好地控制写大小。 read进程实际上只需要’readpage’。写过程更为复杂，使用write_begin/write_end或dirty_folio将数据写入address_space，使用writepage和writepage将数据回写到存储。 在地址空间中添加和删除页面由inode的i_mutex保护。 当数据写入一个页面时，应该设置PG_Dirty标志。它通常保持设置状态，直到writepage要求写入它。这应该清除PG_Dirty并设置PG_Writeback。它实际上可以在PG_Dirty被清除后的任何时候被写入。一旦知道它是安全的，就清除PG_Writeback。 Writeback利用writeback_control结构来指导操作。这为writepage和writpages操作提供了一些关于回写请求的性质和原因，以及在哪些约束条件下执行的信息。它还用于向调用者返回关于写页面或写页面请求结果的信息。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:8:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"处理回写期间的错误 大多数进行缓冲I/O的应用程序将定期调用文件同步调用(fsync、fdatasync、msync或sync_file_range)，以确保写入的数据已经到达后备存储。当回写过程中出现错误时，他们希望在文件同步请求时报告错误。在报告了一个请求的错误之后，对同一文件描述符的后续请求应该返回0，除非在上一次文件同步之后发生了进一步的回写错误。 理想情况下，内核只会在文件描述中报告错误，而这些文件描述的写操作后来又没有被写回。但是，通用的页面缓存基础设施不会跟踪已经污染每个单独页面的文件描述，因此不可能确定哪个文件描述符应该返回错误。 相反，内核中的通用回写错误跟踪基础设施解决了在错误发生时向fsync报告所有打开的文件描述的错误。在有多个写入器的情况下，所有写入器都会在后续的fsync中返回一个错误，即使通过特定文件描述符完成的所有写入都成功了(或者即使对该文件描述符根本没有写入)。 希望使用此基础结构的文件系统应该调用mapping_set_error，以便在发生错误时在address_space中记录错误。然后，在他们的-\u003efsync操作中从页面缓存写回数据后，他们应该调用file_check_and_advance_wb_err来确保struct file的错误游标已经前进到由备份设备发出的错误流中的正确点。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:9:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct address_space_operations 这描述了VFS如何操作文件到文件系统中页面缓存的映射。定义了以下成员: struct address_space_operations { int (*writepage)(struct page *page, struct writeback_control *wbc); int (*readpage)(struct file *, struct page *); int (*writepages)(struct address_space *, struct writeback_control *); bool (*dirty_folio)(struct address_space *, struct folio *); void (*readahead)(struct readahead_control *); int (*write_begin)(struct file *, struct address_space *mapping, loff_t pos, unsigned len, unsigned flags, struct page **pagep, void **fsdata); int (*write_end)(struct file *, struct address_space *mapping, loff_t pos, unsigned len, unsigned copied, struct page *page, void *fsdata); sector_t (*bmap)(struct address_space *, sector_t); void (*invalidate_folio) (struct folio *, size_t start, size_t len); int (*releasepage) (struct page *, int); void (*freepage)(struct page *); ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter); /* isolate a page for migration */ bool (*isolate_page) (struct page *, isolate_mode_t); /* migrate the contents of a page to the specified target */ int (*migratepage) (struct page *, struct page *); /* put migration-failed page back to right list */ void (*putback_page) (struct page *); int (*launder_folio) (struct folio *); bool (*is_partially_uptodate) (struct folio *, size_t from, size_t count); void (*is_dirty_writeback) (struct page *, bool *, bool *); int (*error_remove_page) (struct mapping *mapping, struct page *page); int (*swap_activate)(struct file *); int (*swap_deactivate)(struct file *); }; writepage 由VM调用，将脏页写入后备存储。这可能是由于数据完整性原因(即“同步”)，或为了释放内存(刷新)。这种差异可以从wbc-\u003esync_mode中看出。PG_Dirty标志已经清除，pagellocked为true。writepage应该启动writeout，应该设置PG_Writeback，并且应该确保在写操作完成时，页面是同步或异步解锁的。如果wbc-\u003esync_mode为WB_SYNC_NONE，如果出现问题，-\u003ewritepage处理起来不会太费劲；如果更容易的话，可以选择从映射中写出其他页面(例如由于内部依赖关系)。如果它选择不启动writeout，它应该返回AOP_WRITEPAGE_ACTIVATE，这样VM就不会一直调用该页上的-\u003ewritepage。 有关更多细节，请参阅文件“Locking”。 readpage 调用VM从后台存储读取页面。当readpage被调用时，该页面将被锁定，并且应该在读取完成后被解锁并标记为最新。如果-\u003ereadpage发现由于某些原因需要解锁页面，它可以这样做，然后返回AOP_TRUNCATED_PAGE。在这种情况下，页面将被重新定位并重新锁定，如果所有操作都成功，则将再次调用-\u003ereadpage。 writepages 由VM调用，以写出与address_space对象关联的页面。如果wbc-\u003esync_mode为WB_SYNC_ALL，则writeback_control将指定必须写入的页面范围。如果它是WB_SYNC_NONE，则给出一个nr_to_write，并且如果可能的话应该写入许多页。如果没有给出-\u003ewritpages，则使用mpage_writpages。这将从标记为DIRTY的地址空间中选择页面，并将它们传递给-\u003ewritepage。 dirty_folio VM调用，将对开本标记为dirty。如果地址空间将私有数据附加到一个 fifo，并且当 fifo 被污染时需要更新该数据，则特别需要这样做。例如，当内存映射页被修改时，就会调用这个函数。如果定义了，它应该在i_pages中设置folio dirty标志和PAGECACHE_TAG_DIRTY搜索标记。 readahead 由VM调用，以读取与address_space对象关联的页。在页缓存中，页是连续的，并且被锁定。实现应该在启动每个页面的I/O后减少页面引用计数。通常，该页面将由I/O完成处理程序解锁。页面集被分为一些同步页面和一些异步页面，rac-\u003era-\u003easync_size给出了异步页面的数量。文件系统应该尝试读取所有同步页面，但可能在到达异步页面时决定停止。如果它决定停止尝试I/O，它可以简单地返回。调用者将从地址空间中删除剩余的页，解锁它们并减小页引用计数。如果I/O成功完成，设置PageUptodate。在任何页面上设置PageError都将被忽略;如果发生I/O错误，只需解锁页面。 write_begin write_end bmap invalidate_folio releasepage freepage direct_IO isolate_page migrate_page putback_page launder_folio is_partially_uptodate is_dirty_writeback error_remove_page swap_activate swap_deactivate ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:9:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"File 对象 文件对象表示进程打开的文件。在POSIX术语中，这也称为“打开文件描述”。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:10:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct file_operations 这描述了VFS如何操作打开的文件。在4.18内核中，定义了以下成员: struct file_operations { struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iopoll)(struct kiocb *kiocb, bool spin); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); __poll_t (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f); #ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *); #endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, loff_t len, unsigned int remap_flags); int (*fadvise)(struct file *, loff_t, loff_t, int); }; 同样，调用所有方法时不会持有任何锁，除非另有说明。 llseek read read_iter write write_iter iopoll iterate iterate_shared poll unlocked_ioctl compat_ioctl mmap open flush release fsync fasync lock get_unmapped_area check_flags flock splice_write splice_read setlease fallocate copy_file_range remap_file_range fadvise 注意，文件操作是由inode所在的特定文件系统实现的。当打开一个设备节点(特殊字符或块)时，大多数文件系统将调用VFS中的特殊支持例程，它将定位所需的设备驱动程序信息。这些支持例程将文件系统文件操作替换为设备驱动程序的操作，然后继续为文件调用新的open()方法。这就是在文件系统中打开设备文件最终如何调用设备驱动程序open()方法的。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:10:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"目录条目缓存(dcache) ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"struct dentry_operations 这描述了文件系统如何重载标准dentry操作。dentry和dcache是VFS和各个文件系统实现的域。设备驱动程序在这里没有什么用。这些方法可以设置为NULL，因为它们要么是可选的，要么VFS使用默认值。在2.6.22内核中，定义了以下成员: struct dentry_operations { int (*d_revalidate)(struct dentry *, unsigned int); int (*d_weak_revalidate)(struct dentry *, unsigned int); int (*d_hash)(const struct dentry *, struct qstr *); int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *); int (*d_delete)(const struct dentry *); int (*d_init)(struct dentry *); void (*d_release)(struct dentry *); void (*d_iput)(struct dentry *, struct inode *); char *(*d_dname)(struct dentry *, char *, int); struct vfsmount *(*d_automount)(struct path *); int (*d_manage)(const struct path *, bool); struct dentry *(*d_real)(struct dentry *, const struct inode *); }; d_revalidate _weak_revalidate d_hash d_compare d_delete d_init d_release d_iput d_dname d_automount d_manage d_real 每个dentry都有一个指向其父dentry的指针，以及子dentry的散列列表。子dentry基本上就像目录中的文件。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"目录条目缓存API(Directory Entry Cache API) 定义了许多允许文件系统操作dentry的函数: dget 为现有的dentry打开一个新的句柄(这只是增加了使用计数) dput 关闭dentry的句柄(减少使用计数)。如果使用计数下降到0, dentry仍然在其父散列中，则调用\"d_delete“方法来检查是否应该缓存它。如果它不应该被缓存，或者dentry没有被散列，它就会被删除。否则，缓存的dentry将被放入LRU列表中，在内存不足时回收。 d_drop 这将从其父哈希列表中解算dentry。如果dentry的使用计数下降到0，则对dput()的后续调用将释放该dentry d_delete 删除一个dentry。如果没有对dentry的其他开放引用，则dentry被转换为负dentry(调用d_iput()方法)。如果有其他引用，则调用d_drop() d_add 添加一个dentry到它的父哈希列表，然后调用d_instantiate() d_instantiate 将dentry添加到inode的别名散列列表中，并更新“d_inode”成员。inode结构中的“i_count”成员应该设置/增加。如果inode指针为NULL, dentry称为“负dentry”。当为现有的负dentry创建一个inode时，通常会调用这个函数 d_lookup 它从dcache哈希表中查找指定名称的子元素。如果找到，引用计数将增加并返回dentry。调用者在使用完dentry后必须使用dput()来释放它。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:2","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"挂载操作(Mount Options) ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"解析挂载配置(Parsing options) 在挂载和重新挂载时，将向文件系统传递一个字符串，其中包含以逗号分隔的挂载选项列表。选项可以有以下两种形式:option 和 option=value \u003clinux/parser.h\u003e头文件定义了一个API来帮助解析这些选项。有很多关于如何在现有文件系统中使用它的示例。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"显示挂载配置(Showing options) 如果文件系统接受挂载选项，它必须定义show_options()来显示所有当前活动的选项。规则是: 选项必须显示哪些不是默认值，或者它们的值与默认值不同 选项可以显示为默认启用或具有默认值 仅在装入帮助程序和内核之间内部使用的选项(如文件描述符)，或者仅在装入过程中起作用的选项(如控制日志创建的选项)不受上述规则的约束。 使用上述规则的根本原因是确保可以根据在/proc/mounts.conf. 中找到的信息准确地复制一个挂载(例如，卸载和重新挂载) 5.x 内核没找到 /proc/mounts.conf ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:2","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["kernel"],"content":"linux虚拟文件系统概述 linux虚拟文件系统概述 ","date":"2022-05-18","objectID":"/2022/05/0000-linux%E5%86%85%E6%A0%B8/:1:0","tags":["linux","kernel","文件系统","filesystem"],"title":"Linux内核","uri":"/2022/05/0000-linux%E5%86%85%E6%A0%B8/"},{"categories":["C"],"content":"C语言 C是一种通用的、命令式的计算机编程语言，支持结构化编程、词法变量作用域和递归，而静态类型系统可以防止许多意想不到的操作。通过设计，C提供了有效地映射到典型机器指令的构造，因此它在以前用汇编语言编写的应用程序中得到了持久的使用，包括操作系统，以及从超级计算机到嵌入式系统的各种应用程序软件。 尽管具有低级功能，但该语言的设计初衷是鼓励跨平台编程。一个符合标准的、可移植编写的C程序可以用于各种各样的计算机平台和操作系统，只需对其源代码进行很少的更改。从嵌入式微控制器到超级计算机，该语言已经在非常广泛的平台上可用。 C语言最初是由Dennis Ritchie于1969年至1973年在贝尔实验室开发的，用于重新实现Unix操作系统。它已经成为有史以来使用最广泛的编程语言之一，来自不同供应商的C编译器可用于大多数现有的计算机架构和操作系统。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"C编译器 GCC, GNU 编译器 clang, 是为LLVM项目提供了C语言家族(C, c++, Objective C/c++, OpenCL, CUDA和RenderScript)的编译器 MSCV, 微软C/C++编译器 gcc 编译器 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"编译器C版本支持 编译器不一定完全支持 C 所有特性，同时编译器也可能通过参数支持一些 C 标准没有的特性，使用时候具体参看 C编译器和对应版本说明。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"代码风格 GNU代码风格 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"C版本 版本 标准 发行时间 K\u0026E 无 1978-02-22 C89 ANSI X3.159-1989 1989-12-14 C90 ISO/IEC 9899:1990 1990-12-20 C95 ISO/IEC 9899/AMD1:1995 1995-03-30 C99 ISO/IEC 9899:1999 1999-12-16 C11 ISO/IEC 9899:2011 2011-12-15 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:4","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"hello world #include \u003cstdio.h\u003e int main(void) { puts(\"Hello, World\"); return 0; } 编译 gcc hello.c -o hello // 我们还可以使用警告选项-Wall -Wextra -Werror，这有助于识别可能导致程序失败或产生意外结果的问题 gcc -Wall -Wextra -Werror -o hello hello.c 对比 K\u0026R C 的Hello world #include \u003cstdio.h\u003e main() { printf(\"hello, world\\n\"); } 注意，在编写《The C programming language》的第一版(1978年)时，C编程语言还没有标准化，而且这个程序可能无法在大多数现代编译器上编译，除非它们被指示接受C90代码。 K\u0026R书中的第一个示例现在被认为质量很差，部分原因是它缺少main()的显式返回类型，部分原因是它缺少返回语句。 在C89中，main的类型默认为int，但K\u0026R示例不向环境返回定义的值。在C99和以后的标准中，返回类型是必需的，但是省略main的返回语句(而且只有main)是安全的，因为C99 5.1.2.2.3引入了一个特殊情况—它相当于返回0，表示成功。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:5","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"字符类型和转换 从流中读取字符类型 #include \u003cctype.h\u003e #include \u003cstdio.h\u003e typedef struct { size_t space; size_t alnum; size_t punct; } chartypes; chartypes classify(FILE *f) { chartypes types = { 0, 0, 0 }; int ch; while ((ch = fgetc(f)) != EOF) { types.space += !!isspace(ch); types.alnum += !!isalnum(ch); types.punct += !!ispunct(ch); } return types; } classify函数从流中读取字符并统计空格、字母数字和标点符号的数量。它需要注意以下几个问题： 当从流中读取一个字符时，结果被保存为int，因为读取EOF(文件结束标记)和具有相同位模式的字符之间会有歧义。 classify函数希望它们的参数可以表示为unsigned char，或者EOF宏的值。因为这正是fgetc返回的，所以这里不需要转换。 字符分类函数的返回值只区分零(false)和非零(true)。为了计算字符分类出现的次数，需要将该值转换为1或0，这可以通过双重否定实现 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:2:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"C标准库 – ctype.h int c = 'A'; isalpha(c); /* Checks if c is alphabetic (A-Z, a-z), returns non-zero here. */ isalnum(c); /* Checks if c is alphanumeric (A-Z, a-z, 0-9), returns non-zero here. */ iscntrl(c); /* Checks is c is a control character (0x00-0x1F, 0x7F), returns zero here. */ isdigit(c); /* Checks if c is a digit (0-9), returns zero here. */ isgraph(c); /* Checks if c has a graphical representation (any printing character except space), returns non-zero here. */ islower(c); /* Checks if c is a lower-case letter (a-z), returns zero here. */ isprint(c); /* Checks if c is any printable character (including space), returns non-zero here. */ ispunct(c); /* Checks if c is a punctuation character, returns zero here. */ isspace(c); /* Checks if c is a white-space character, returns zero here. */ isupper(c); /* Checks if c is an upper-case letter (A-Z), returns non-zero here. */ isxdigit(c); /* Checks if c is a hexadecimal digit (A-F, a-f, 0-9), returns non-zero here.*/ // C99 isblank(c); /* Checks if c is a blank character (space or tab), returns non-zero here. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:2:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"别名和有效类型 这里的别名是英文直译，可以理解为我们常见的类型转换 别名是指向同一个对象的两个指针a和b的属性，即a == b。 C使用数据对象的有效类型来确定可以对该对象执行哪些操作。具体来说，有效类型用于确定两个指针是否可以相互别名。 C语言的严格别名规则是指编译器可能假定哪些对象会(或不会)别名。对于数据指针，你应该记住两条经验法则: 除非另有说明，具有相同基类型的两个指针可以别名。 两个具有不同基类型的指针不能别名，除非两个类型中至少有一个是字符类型。 这里的基本类型指的是抛开类型限制，比如const，比如：double* a 和 const double* b，编译器通常必须假设对*a的修改可能会改变*b。 违反第二条规则会有灾难性后果，所以为了减少问题发生概率，除非源或目标类型为void，否则具有不同基类型的指针之间的所有指针转换都必须是显式的。 这里必须做的类型转换不包括添加限定符 const ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:3:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 不能通过非字符类型访问字符类型 int main(void) { char a[100]; int* b = ( int* )\u0026a; *b = 1; static char c[100]; b = ( int* )\u0026c; *b = 2; _Thread_local char d[100]; b = ( int* )\u0026d; *b = 3; } 在例子中，一个char数组被重新解释为int类型，并且每次对int指针b解引用时，该行为都是未定义的。因为它违反了“有效类型”规则，具有有效类型的数据对象不能通过非字符类型的其他类型访问。因为这里的另一个类型是int，所以这是不允许的。 即使内存对齐和指针大小是已知的，这也不能免除此规则，行为仍然是未定义的。 这特别意味着，在标准C语言中不可能保留可以通过不同类型的指针使用的字符类型的缓冲区对象，因为您将使用由malloc或类似函数接收的缓冲区。 实现上述目标的正确方法是使用 union typedef union bufType bufType; union bufType { char c[sizeof(int[25])]; int i[25]; }; int main( void ) { bufType a = { .c = { 0 } }; // reserve a buffer and initialize int* b = a.i; // no cast necessary *b = 1; static bufType a = { .c = { 0 } }; int* b = a.i; *b = 2; _Thread_local bufType a = { .c = { 0 } }; int* b = a.i; *b = 3; } 这里，union确保编译器从一开始就知道缓冲区可以通过不同的方式访问。这样做的另一个好处是，现在缓冲区有一个a.i，它已经是int类型，不需要进行指针转换。 有效类型 数据对象的有效类型是与之关联的最后一个类型信息(如果有的话)。 // 有效类型是 uint32_t uint32_t a = 0.0; // *pa的有效类型是 uint32_t uint32_t* pa = \u0026a; // 目前 *q 并不是一个有效类型 void* q = malloc(sizeof uint32_t); // 这里的 q 仍然不是一个有效类型，因为还没有数据写入 uint32_t* qb = q; // *qb 目前是一个有效类型 uint32_t，因为一个 uint32_t 值被写入了 *qb = 37; // r 指向的对象尽管已经初始化了，但还不是有效类型 void* r = calloc(1, sizeof uint32_t); // 不是有效类型 uint32_t* rc = r; // *rc 已经是一个有效类型 uint32_t 因为一个值从它那读取了 // 因为使用 calloc 初始化了，所以读操作是合理的 // 此时尽管我们没有写它的值，但是 *rc 已经是一个有效类型了 uint32_t c = *rc; void* s = malloc(sizeof uint32_t); // 因为有 uint32_t 类型复制到指定对象里，所以 *s 已经是有效类型了 memcpy(s, r, sizeof uint32_t); 严重违反类型转换规则 在下面的代码中，让我们假设float和uint32_t有相同的内存大小 void fun(uint32_t* u, float* f) { float a = *f, *u = 22; float b = *f; print(\"%g should equal %g\\n\", a, b); } u 和 f 具有不同的基类型，因此编译器可以假定它们指向不同的对象。 在a和b的两次初始化之间*f不可能发生变化，因此编译器可能会优化代码，使其等价于: void fun(uint32_t* u, float* f) { float a = *f, *u = 22; print(\"%g should equal %g\\n\", a, a); } 即*f的二次加载操作可以完全优化出来。 如果这样调用: float fval = 4; uint32_t uval = 77; fun(\u0026uval, \u0026fval); // 输出: 4 should equal 4 但是如果这样调用： float fval = 4; uint32_t* up = (uint32_t*)\u0026fval; fun(up, \u0026fval); 我们违反了严格的混叠规则。然后这种行为就变得没有定义了。如果编译器优化了第二次访问，输出可能与上面一样，或者完全不同，从而使程序最终处于完全不可靠的状态。 限制条件 如果有两个相同类型的指针实参，编译器就不能做任何假设，必须总是假设对*e的修改可能会改变*f: void fun(float* e, float* f) { float a = *f *e = 22; float b = *f; print(\"is %g equal to %g?\\n\", a, b); } float fval = 4; float eval = 77; fun(\u0026eval, \u0026fval); 正常输出是 is 4 equal to 4? 如果我们通过一些外部信息知道e和f永远不会指向相同的数据对象，那么这可能是低效的。我们可以通过给指针形参添加限制限定符来反映这一点: void fan(float*restrict e, float*restrict f) { float a = *f *e = 22; float b = *f; print(\"is %g equal to %g?\\n\", a, b); } 那么编译器可能总是假设e和f指向不同的对象。 改变字节 一旦对象具有有效类型，就不应该试图通过其他类型的指针修改它，除非其他类型是字符类型、char、signed char或 unsigned char。 #include \u003cinttypes.h\u003e #include \u003cstdio.h\u003e int main(void) { uint32_t a = 57; // conversion from incompatible types needs a cast ! unsigned char* ap = (unsigned char*)\u0026a; for (size_t i = 0; i \u003c sizeof a; ++i) { /* set each byte of a to 42 */ ap[i] = 42; } printf(\"a now has value %\" PRIu32 \"\\n\", a); } 打印结果: a now has value 707406378 正常是因为： 使用unsigned char类型访问单个字节，因此每次修改都有很好的定义。 对象的两个视图，通过别名a和*ap，但由于ap是指向字符类型的指针，因此不适用严格的别名规则。因此，编译器必须假设a的值可能在for循环中被更改了。a的修改值必须从已更改的字节构造。 a的类型的uint32_t没有填充位。其表示的所有位都为值计数，这里是707406378，并且不能有陷阱表示。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:3:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数组 数组是派生数据类型，表示另一种类型的值(“元素”)的有序集合。C语言中的大多数数组都有固定数量的任意一种类型的元素，其表示形式是连续地将元素存储在内存中，没有间隔或填充。C允许多维数组，它的元素是其他数组，也可以是指针数组。 C支持动态分配数组，其大小在运行时确定。C99及以后版本支持可变长度数组或VLAs。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 type name[length]; int arr[10] = {0}; // 初始化所有元素为0 int arr[10] = {42}; // 初始化第一个元素为42，其它为0 int arr[] = {4, 2, 3, 1}; arr[n] = value; value = arr[n]; ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"为什么需要数组 数组提供了一种将对象组织成具有自身意义的聚合的方法。例如，C字符串是字符数组(chars)，而像“Hello, World!”这样的字符串具有聚合的意义，它不是单个字符固有的。类似地，数组通常用于表示数学向量和矩阵，以及多种类型的列表。此外，如果没有对元素进行分组的方法，就需要单独处理每个元素，比如通过单独的变量。它不仅笨重，而且不能方便地容纳不同长度的集合。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"大多数上下文数组隐式转为指针 除了 sizeof 操作，使用 _Alignof 操作、\u0026操作、迭代字符串，它都会转换为第一个元素首地址。 这个隐式转换与数组下标操作符([])的定义紧密耦合:表达式arr[idx]被定义为等价于*(arr + idx)。此外，由于指针算法是可交换的，*(arr + idx)也等价于*(idx + arr)，而*(idx + arr)又等价于idx[arr]。如果idx或arr是指针(或数组，可衰变为指针)，另一个是整数，且整数是指针所指向数组的有效索引，则所有这些表达式都是有效的，计算结果相同。 作为一个特例，观察\u0026(arr[0])等价于\u0026*(arr + 0)，简化为arr。所有的这些表达式都是可互换的(attr最衰减到指针)。这只是再次表示数组衰变为指向其第一个元素的指针。 相反，如果地址操作符应用于类型为T[N]的数组(即\u0026arr)，则结果类型为T (*)[N]并指向整个数组。这与指向数组第一个元素的指针不同，至少在指针算术方面是不同的，指针是根据指向类型的大小定义的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"函数参数不是数组 void foo(int a[], int n); void foo(int *a, int n); 尽管foo的第一个声明对参数a使用了类似数组的语法，但这种语法用于声明一个函数参数，将该参数声明为指向数组元素类型的指针。因此，foo()的第二个签名在语义上与第一个签名相同。这对应于数组值的衰减指针出现作为一个函数调用的参数,这样,如果一个变量和一个函数参数声明相同的数组类型,变量的值是适用于一个函数调用的参数与参数有关。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:4","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"特殊例子 特殊的初始化： int array[5] = { [2] = 5, [1] = 2, [4] = 9 }; /* array is {0, 2, 5, 0, 9} */ int array[] = { [3] = 8, [0] = 9 }; /* size is 4 */ 不允许声明零长度的数组 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:5","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"变长数组(C99/C11) 可变长度数组(简称VLA)是在C99中添加的，在C11中是可选的。它们与普通数组相同，但有一个重要的区别:在编译时不必知道长度。VLA具有自动存储期限。 size_t m = calc_length(); /* calculate array length at runtime */ int vla[m]; /* create array with calculated length */ 重要: VLA有潜在的危险。如果上面示例中的数组vla需要的堆栈空间大于可用空间，则堆栈将溢出。因此不建议使用VLA ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:6","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"清除数组内容 有时需要在初始化完成后将数组设置为零。 #include \u003cstdlib.h\u003e /* for EXIT_SUCCESS */ #define ARRLEN (10) int main(void) { int array[ARRLEN]; /* Allocated but not initialised, as not defined static or global. */ size_t i; for(i = 0; i \u003c ARRLEN; ++i) { array[i] = 0; } return EXIT_SUCCESS; } 或者使用 memset ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:7","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数组长度 sizeof(array) / sizeof(array[0]) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:8","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"设置数组值 array[4] = 5; 4[array] = 5; *(4 + array) = 5; // 获取值 val = 4[array]; ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:9","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"定义数组并访问元素 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:10","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"堆上动态分配空间并初始化数组 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:11","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"迭代数组 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:12","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"多维数组 type name[size1][size2]...[sizeN]; int arr[5][10][4]; // 初始化 3 维数组 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:13","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"断言 在软件遇到断言时，提出的条件必须为真。最常见的是在执行时进行验证的简单断言。静态断言是在编译时检查的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 assert(expression); static_assert(expression, message); _Static_assert(expression, message); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"参数 参数 描述 expression 表达式，判断条件是否满足 message 诊断消息中包含的字符串字面值 assert 和 static_assert 都在 assert.h 中定义。 assert的定义依赖于宏NDEBUG，该宏没有被标准库定义。如果定义了NDEBUG，则assert为无操作: #ifdef NDEBUG # define assert(condition) ((void) 0) #else # define assert(condition) /* implementation defined */ #endif 使用 assert 会导致程序退出，生产环境中不要用 assert，最好使用条件判断 static_assert扩展为_Static_assert，这是一个关键字。condition 在编译时被检查，因此condition必须是一个常量表达式。没有必要在开发和生产之间以不同的方式处理这个问题 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 前置条件和后置条件 断言的一个用例是前置条件和后置条件。这对于保持不变和契约式设计非常有用。例如，长度总是0或正的，因此该函数必须返回0或正的值。 int length2 (int *a, int count) { int i, result = 0; /* Precondition: */ /* NULL is an invalid vector */ assert (a != NULL); /* Number of dimensions can not be negative.*/ assert (count \u003e= 0); /* Calculation */ for (i = 0; i \u003c count; ++i) { result = result + (a[i] * a[i]); } /* Postcondition: */ /* Resulting length can not be negative. */ assert (result \u003e= 0); return result; } 简单断言 #include \u003cstdio.h\u003e /* Uncomment to disable `assert()` */ /* #define NDEBUG */ #include \u003cassert.h\u003e int main(void) { int x = -1; assert(x \u003e= 0); printf(\"x = %d\\n\", x); return 0; } 运行输出: a.out: main.c:9: main: Assertion `x \u003e= 0' failed. 静态断言(C11) 静态断言用于在编译代码时检查条件是否为真。如果不是，则需要编译器发出错误消息并停止编译过程。 #include \u003cassert.h\u003e enum {N = 5}; _Static_assert(N == 5, \"N does not equal 5\"); static_assert(N \u003e 10, \"N is not greater than 10\"); /* compiler error */ 静态断言(c99) 在C11之前，没有对静态断言的直接支持。但是，在C99中，可以使用宏模拟静态断言，如果编译时条件为假，则会触发编译失败。与_Static_assert不同，第二个参数需要是适当名称，以便可以使用它创建变量名称。如果断言失败，则在编译器错误中可以看到变量名，因为该变量是在语法不正确的数组声明中使用的 #define STATIC_MSG(msg, l) STATIC_MSG2(msg, l) #define STATIC_MSG2(msg,l) on_line_##l##__##msg #define STATIC_ASSERT(x, msg) extern char STATIC_MSG(msg, __LINE__) [(x)?1:-1] enum { N = 5 }; STATIC_ASSERT(N == 5, N_must_equal_5); STATIC_ASSERT(N \u003e 5, N_must_be_greater_than_5); /* compile error */ 在C99之前，不能在块中的任意位置声明变量，因此在使用这个宏时必须非常谨慎，确保它只出现在变量声明有效的地方 断言不可能到达的位置(switch-case语法) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"原子(Atomics) Atomics作为C语言的一部分是自C11以来可用的可选特性。它们的目的是确保对在不同线程之间共享的变量的无竞争访问。如果没有原子限定，如果两个线程并发访问一个共享变量，那么它的状态将是未定义的。例如，一个自增操作(++)可以被拆分为几个汇编指令、一个读取指令、加法本身和一个存储指令。如果另一个线程要执行相同的操作，它们的两个指令序列可能会交织在一起，导致不一致的结果。 Types: 除数组类型外，所有对象类型都可以限定为 _Atomic Operators: 它们上的所有读-修改-写操作符都保证是原子的 Operations: 还有其他一些被指定为类型泛型函数的操作，例如atomic_compare_exchange。 Threads: 当它们被不同的线程访问时，对它们的访问保证不会产生数据竞争。 Signal handlers: 如果对原子类型的所有操作都是无状态的，则称为无锁类型。在这种情况下，它们还可以用于处理正常控制流和信号处理程序之间的状态变化。 只有一种数据类型保证是无锁的:atomic_flag。这是一种最小类型，其操作旨在映射到有效的测试和设置硬件指令。 在C11的线程接口中还有其他避免竞争条件的方法，特别是一个互斥类型mtx_t，它可以相互排除线程访问关键数据或代码的关键部分。如果原子不可用，则必须使用它们来防止竞争。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:6:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #ifdef __STDC_NO_ATOMICS__ # error this implementation needs atomics• #endif• #include \u003cstdatomic.h\u003e unsigned _Atomic counter = ATOMIC_VAR_INIT(0); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:6:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 原子和操作 可以在不同的线程之间并发地访问原子变量，而不需要创建竞争条件。 static unsigned _Atomic active = ATOMIC_VAR_INIT(0); int myThread(void* a) { ++active; // increment active race free // do something --active; // decrement active race free return 0; } 基类型允许的所有左值操作(修改对象的操作)都是允许的，不会导致访问它们的不同线程之间的竞争条件。 对原子对象的操作通常比普通的算术操作慢几个数量级。这也包括简单的加载或存储操作。所以你应该只在关键的任务中使用它们。 通常的算术运算和赋值，如a = a+1;实际上在a上有三个操作:首先是加载，然后是加法，最后是存储。只有操作a += 1;和++;是这样的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:6:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"位域 C语言中大多数变量的大小都是字节的整数。位域是结构的一部分，不一定占用整数字节;它们可以使用任意数量的比特。多个位域可以被打包到一个存储单元中。它们是标准C的一部分，但有许多方面是实现定义的。它们是C语言中最不可移植的部分之一。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 type-specifier identifier : size; ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"参数 参数 描述 type-specifier signed、unsigned、int 或 _Bool identifier 名字 size 字段中使用的位数 位字段的可移植类型只有signed、unsigned或_Bool。也可以使用纯int类型，但标准规定对于位域，说明符int是否指定与signed int相同的类型或与unsigned int相同的类型由实现定义。特定的实现可能允许其他整数类型，但使用它们是不可移植的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 位域 一个简单的位域可以用来描述可能包含特定位数的事物。 struct encoderPosition { unsigned int encoderCounts : 23; unsigned int encoderTurns : 4; unsigned int _reserved : 5; }; 在这个例子中，我们考虑一个编码器，它有23位单精度，4位描述多匝。当与输出与特定位数相关联的数据的硬件连接时，经常使用位域。另一个例子可能是与FPGA通信，FPGA以32位段的形式将数据写入内存，允许硬件读取: struct FPGAInfo { union { struct bits { unsigned int bulb1On : 1; unsigned int bulb2On : 1; unsigned int bulb1Off : 1; unsigned int bulb2Off : 1; unsigned int jetOn : 1; }; unsigned int data; }; }; 对于这个示例，我们展示了一个常用的构造，它能够访问单个位的数据，或者将数据包作为一个整体写入(模拟FPGA可能做的事情)。然后我们可以像这样访问比特: FPGAInfo fInfo; fInfo.data = 0xFF34F; if (fInfo.bits.bulb1On) { printf(\"Bulb 1 is on\\n\"); } 这是有效的，但根据C99标准6.7.2.1，第10项:单位内位域的分配顺序(高阶到低阶或低阶到高阶)是由实现定义的 在以这种方式定义位域时，需要注意字节序。因此，可能需要使用一个预处理器指令来检查机器的字节顺序。下面是一个例子: typedef union { struct bits { #if defined(WIN32) || defined(LITTLE_ENDIAN) uint8_t commFailure :1; uint8_t hardwareFailure :1; uint8_t _reserved :6; #else uint8_t _reserved :6; uint8_t hardwareFailure :1; uint8_t commFailure :1; #endif }; uint8_t data; } hardwareStatus; 使用位域作为小整数 #include \u003cstdio.h\u003e int main(void) { /* define a small bit-field that can hold values from 0 .. 7 */ struct { unsigned int uint3: 3; } small; /* extract the right 3 bits from a value */ unsigned int value = 255 - 2; /* Binary 11111101 */ small.uint3 = value; /* Binary 101 */ printf(\"%d\", small.uint3); /* This is in effect an infinite loop */ for (small.uint3 = 0; small.uint3 \u003c 8; small.uint3++) { printf(\"%d\\n\", small.uint3); } return 0; } 位域对齐 位域提供了声明小于字符宽度的结构域的能力。位域通过字节级或字级掩码实现。下面的示例产生一个8字节的结构。 struct C { short s; /* 2 bytes */ char c; /* 1 byte */ int bit1 : 1; /* 1 bit */ int nib : 4; /* 4 bits padded up to boundary of 8 bits. Thus 3 bits are padded */ int sept : 7; /* 7 Bits septet, padded up to boundary of 32 bits. */ }; 注释描述了一种可能的布局，但由于标准说可寻址存储单元的对齐方式未指定，所以也可能有其他布局。 未命名位域可以是任何大小，但不能初始化或引用它们。 不能给零宽度位域指定名称并将下一个字段与位域的数据类型定义的边界对齐。这是通过在位域之间填充位来实现的。 struct A的大小是1字节。 struct A { unsigned char c1 : 3; unsigned char c2 : 4; unsigned char c3 : 1; }; 在struct B中，第一个未命名位域跳过2位;c2之后的零宽度位域导致c3从字符边界开始(因此在c2和c3之间跳过3位。c4之后有3个填充位。因此，该结构的大小为2字节。 struct B { unsigned char c1 : 1; unsigned char : 2; /* Skips 2 bits in the layout */ unsigned char c2 : 2; unsigned char : 0; /* Causes padding up to next container boundary */ unsigned char c3 : 4; unsigned char c4 : 1; }; 什么时候使用位域 位域用于将多个变量组合成一个对象，类似于结构。这允许减少内存使用，在嵌入式环境中尤其有用 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"Boolean 要使用预定义的类型_Bool和头文件\u003cstdbool.h\u003e，必须使用C99/C11版本的C语言。为了避免编译器警告和可能的错误，只有在使用C89和该语言以前的版本时，才应该使用typedef/define示例。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:8:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:8:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"命令行参数 int main(int argc, char *argv[]) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:9:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:9:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"注释 /* ... */ // c99 及其之后 // ... ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:10:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"常见的C编程习惯用法和开发人员实践 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:11:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"比较 // 不好 if ( i == 2) //Bad-way { doSomething; } // 好 if( 2 == i) //Good-way { doSomething; } ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:11:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"常见陷阱 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:12:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"编译 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:13:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"复合类型 像字符串字面量一样，const限定的复合字面量可以放在只读内存中，甚至可以共享。例如, (const char []) { \"abc\" } == \"abc\" ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:14:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 (type) { initializer-list } ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:14:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"头文件包含 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:15:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数据类型 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:16:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"声明与定义 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:17:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"错误处理 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:18:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #include \u003cerrno.h\u003e• int errno; /* implementation defined */• #include \u003cstring.h\u003e• char *strerror(int errnum);• #include \u003cstdio.h\u003e• void perror(const char *s); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:18:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"文件和 I/O 流 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:19:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #include \u003cstdio.h\u003e /* Include this to use any of the following sections */• FILE *fopen(const char *path, const char *mode); /* Open a stream on the file at path with the specified mode */ FILE *freopen(const char *path, const char *mode, FILE *stream); /* Re-open an existing stream on the file at path with the specified mode */ int fclose(FILE *stream); /* Close an opened stream */• size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); /* Read at most nmemb elements of size bytes each from the stream and write them in ptr. Returns the number of read elements. */ size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); /* Write nmemb elements of size bytes each from ptr to the stream. Returns the number of written elements. */ int fseek(FILE *stream, long offset, int whence); /* Set the cursor of the stream to offset, relative to the offset told by whence, and returns 0 if it succeeded. */ long ftell(FILE *stream); /* Return the offset of the current cursor position from the beginning of the stream. */ void rewind(FILE *stream); /* Set the cursor position to the beginning of the file. */• int fprintf(FILE *fout, const char *fmt, ...); /* Writes printf format string on fout */• FILE *stdin; /* Standard input stream */• FILE *stdout; /* Standard output stream */• FILE *stderr; /* Standard error stream */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:19:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"格式化输入/输出 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:20:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"函数参数 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:21:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"函数指针 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:22:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 - `returnType (*name)(parameters);` - `typedef returnType (*name)(parameters);` - `typedef returnType Name(parameters);` Name *name; - `typedef returnType Name(parameters);` `typedef Name *NamePtr;` ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:22:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"使用 typedef ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:23:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"上下文指针 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:24:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"标识符作用域 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:25:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"实现定义的行为 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:26:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"隐式转换和显示转换 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:27:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"初始化 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:28:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"内联汇编 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:29:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"内联 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:30:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"进程间通信(IPC) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:31:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"迭代语句/循环 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:32:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 /* all versions */• for ([expression]; [expression]; [expression]) one_statement• for ([expression]; [expression]; [expression]) { zero or several statements }• while (expression) one_statement• while (expression) { zero or several statements }• do one_statement while (expression);• do { one or more statements } while (expression);• // since C99 in addition to the form above• for (declaration; [expression]; [expression]) one_statement;• for (declaration; [expression]; [expression]) { zero or several statements } ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:32:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"跳转 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:33:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 return val; /* Returns from the current function. val can be a value of any type that is converts to the function's return type. */ return; /* Returns from the current void-function. */• break; /* Unconditionally jumps beyond the end (\"breaks out\") of an Iteration Statement (loop) or out of the innermost switch statement. */ continue; /* Unconditionally jumps to the beginning of an Iteration Statement (loop). */• goto LBL; /* Jumps to label LBL. */• LBL: statement /* any statement in the same function. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:33:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"链表 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:34:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数字、字符和字符串的字面值 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:35:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"内存管理 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:36:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 void *aligned_alloc(size_t alignment, size_t size); /* Only since C11 */• void *calloc(size_t nelements, size_t size);• void free(void *ptr);• void *malloc(size_t size);• void *realloc(void *ptr, size_t size);• void *alloca(size_t size); /* from alloca.h, not standard, not portable, dangerous. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:36:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"多字字符序列 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:37:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"多线程 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:38:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 thrd_t // Implementation-defined complete object type identifying a thread• int thrd_create( thrd_t *thr, thrd_start_t func, void *arg ); // Creates a thread• int thrd_equal( thrd_t thr0, thrd_t thr1 ); // Check if arguments refer to the same thread• thr_t thrd_current(void); // Returns identifier of the thread that calls it• int thrd_sleep( const struct timespec *duration, struct timespec *remaining ); // Suspend call thread execution for at least a given time void thrd_yield(void); // Permit other threads to run instead of the thread that calls it• _Noreturn void thrd_exit( int res ); // Terminates the thread the thread that calls it• int thrd_detatch( thrd_t thr; // Detaches a given thread from the current environment• int thrd_join( thrd_t thr, int *res ); // Blocks the current thread until the given thread finishes ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:38:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"操作符 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:39:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 expr1 operator• operator expr2• expr1 operator expr2• expr1 ? expr2 : expr3 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:39:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"将 2 维数组传给函数 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:40:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"指针 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:41:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 \u003cData type\u003e *\u003cVariable name\u003e;• int *ptrToInt;• void *ptrToVoid; /* C89+ */• struct someStruct *ptrToStruct;• int **ptrToPtrToInt;• int arr[length]; int *ptrToFirstElem = arr; /* For \u003cC99 'length' needs to be a compile time constant, for \u003e=C11 it might need to be one. */ int *arrayOfPtrsToInt[length]; /* For \u003cC99 'length' needs to be a compile time constant, for \u003e=C11 it might need to be one. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:41:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"预处理器和宏 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:42:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"随机数生成 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:43:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 arc4random() (available on OS X and BSD)• random() (available on Linux)• drand48() (available on POSIX) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:43:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"条件 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:44:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"信号处理 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:45:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"标准数学 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:46:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"字符串 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:47:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"结构体 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:48:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"Structure Padding and Packing ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:49:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"测试框架 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:50:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"CppUTest #include \u003cCppUTest/CommandLineTestRunner.h\u003e #include \u003cCppUTest/TestHarness.h\u003e TEST_GROUP(Foo_Group) {} TEST(Foo_Group, Foo_TestOne) {} /* Test runner may be provided options, such ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:50:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"线程(原生) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:51:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #ifndef __STDC_NO_THREADS__• # include \u003cthreads.h\u003e• #endif• void call_once(once_flag *flag, void (*func)(void));• int cnd_broadcast(cnd_t *cond);• void cnd_destroy(cnd_t *cond);• int cnd_init(cnd_t *cond);• int cnd_signal(cnd_t *cond);• int cnd_timedwait(cnd_t *restrict cond, mtx_t *restrict mtx, const struct timespec *restrict ts); int cnd_wait(cnd_t *cond, mtx_t *mtx);• void mtx_destroy(mtx_t *mtx);• int mtx_init(mtx_t *mtx, int type);• int mtx_lock(mtx_t *mtx);• int mtx_timedlock(mtx_t *restrict mtx, const struct timespec *restrict ts);• int mtx_trylock(mtx_t *mtx);• int mtx_unlock(mtx_t *mtx);• int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);• thrd_t thrd_current(void);• int thrd_detach(thrd_t thr);• int thrd_equal(thrd_t thr0, thrd_t thr1);• _Noreturn void thrd_exit(int res);• int thrd_join(thrd_t thr, int *res);• int thrd_sleep(const struct timespec *duration, struct timespec* remaining);• void thrd_yield(void);• int tss_create(tss_t *key, tss_dtor_t dtor);• void tss_delete(tss_t key);• void *tss_get(tss_t key);• int tss_set(tss_t key, void *val); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:51:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"类型限定符 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:52:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"typedef ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:53:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"未定义类型 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:54:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"联合体 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:55:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"Valgrind Valgrind是一个调试工具，可用于诊断C程序中有关内存管理的错误。Valgrind可用于检测诸如无效指针使用等错误，包括超出已分配空间的写入或读取，或对free()进行无效调用。它还可以通过执行内存分析的函数来改进应用程序。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:56:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"变量参数 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:57:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"X-macros x -宏是一种基于预处理程序的技术，用于最小化重复代码和维护数据/代码的对应关系。基于一组公共数据的多个不同的宏展开可以通过单个主宏来表示整个组展开，该宏的替换文本由内部宏展开的序列组成，每个数据对应一个。内部宏通常被命名为X()，这就是该技术的名称。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:58:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["linux"],"content":"C 各个版本说明 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:0","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C 语言早期 最早由丹尼斯·里奇（Dennis Ritchie）为了在PDP-11电脑上运行的Unix系统所设计出来的编程语言 第一次发展在1969年到1973年之间。 在PDP-11出现后，丹尼斯·里奇与肯·汤普逊着手将Unix移植到PDP-11上 1973年，Unix操作系统的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上。 1975年C语言开始移植到其他机器上使用。史蒂芬·强生实现了一套“可移植编译器” ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:1","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"K\u0026R c 1978年，丹尼斯·里奇和布莱恩·柯林汉合作出版了《C程序设计语言》的第一版。 “K\u0026R C”（柯里C）。 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:2","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C89/C90 1989年，C语言被美国国家标准协会（ANSI）标准化，这个版本又称为C89 标准化的一个目的是扩展 K\u0026R C，增加了一些新特性。 1990年，国际标准化组织（ISO）规定国际标准的C语言 通过对 ANSI 标准的少量修改，最终制定了 ISO 9899:1990，又称为C90。 随后，ANSI亦接受国际标准C，并不再发展新的C标准。 注意: C89和C90是一回事，C89是由ANSI(American National Standards Institute)美国国家标准协会制定，C90 是由国际标准协会根据ANSI C89 制定。 C89/C90对K\u0026R C改进点 增加了真正的标准库 新的预处理命令与特性 函数原型允许在函数申明中指定参数类型 一些新的关键字，包括 const、volatile 与 signed 宽字符、宽字符串与多字节字符 对约定规则、声明和类型检查的许多小改动与澄清 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:3","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C99 1994年为C语言创建了一个新标准，但是只修正了一些C89标准中的细节和增加更多更广的国际字符集支持。 不过，这个标准引出了1999年ISO 9899:1999的发表。它通常被称为C99。 C99被ANSI于2000年3月采用。 C99新特性(部分) 支持不定长的数组，声明时使用 int a[var] 的形式。 变量声明不必放在语句块的开头，for 语句提倡写成 for(int i=0;i\u003c100;++i) 的形式 允许采用（type_name）{xx,xx,xx} 类似于 C++ 的构造函数的形式构造匿名的结构体。 除了已有的 __line__ __file__ 以外，增加了 __func__ 得到当前的函数名。 取消了函数返回类型默认为 int 的规定。 增加和修改了一些标准头文件(定义bool的、定义复数的、里增加了 struct tmx，对 struct tm 做了扩展。) ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:4","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C11 2011年12月8日，ISO正式发布了新的C语言的新标准C11，之前被称为C1X 官方名称为ISO/IEC 9899:2011 新的标准提高了对C++的兼容性，并增加了一些新的特性。 这些新特性包括泛型宏、多线程、带边界检查的函数、匿名结构等。 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:5","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C18 C18没有引入新的语言特性，只对C11进行了补充和修正 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:6","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++ 各个版本说明 1998年是C++标准委员会成立的第一年，以后每5年视实际需要更新一次标准。 2009年，C++标准有了一次更新，一般称该草案为C++0x。 C++0x是C++11标准成为正式标准之前的草案临时名字。 后来，2011年，C++新标准标准正式通过，更名为ISO/IEC 14882:2011，简称C++11。 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:0","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++11 C++11，先前被称作C++0x，即ISO/IEC 14882:2011，是C++编程语言的一个标准。 它取代第二版标准ISO/IEC 14882:2003 （第一版ISO/IEC 14882:1998公开于1998年， 第二版于2003年更新，分别通称C++98以及C++03，两者差异很小），且已被C++14取代 C++11 新特性(部分) auto 关键字及用法 C++11 之前，auto 具有存储期说明符的语义。auto在C++98中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两个标准的auto，完全是两个概念。 nullptr 关键字及用法 引入nullptr，是因为重载函数处理 NULL 的时候会出问题，二义性 void foo(int); //(1) void foo(void*); //(2) foo(NULL); // 重载决议选择 (1)，但调用者希望是 (2) foo(nullptr); // 调用(2) for循环语法 for ( 范围声明 : 范围表达式 ) 循环语句 STL – std::array std::array 提供了静态数组，编译时确定大小、更轻量、更效率，当然也比 std::vector 有更多局限性。 STL – std::forward_list 单向链表 STL – unordered_map STL – unordered_set 多线程 – std::thread 在 C++11 以前，C++ 的多线程编程均需依赖系统或第三方接口实现，一定程度上影响了代码的移植性。C++11 中，引入了 boost 库中多线程的部分内容，形成标准后的接口与 boost 库基本没有变化，这样方便了使用者切换使用 C++ 标准接口。 多线程 – std::atomic 从实现上，可以理解为这些原子类型内部自己加了锁。 多线程 – std::condition_variable 智能指针 – std::shared_ptr 智能指针 – std::weak_ptr 其它 – std::function 其它 – std::bind lambda ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:1","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++14 C++14 旨在作为C++11的一个小扩展，主要提供漏洞修复和小的改进。2014年8月18日，经过C++标准委员投票，C++14标准获得一致通过。ISO/IEC 14882:2014 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:2","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++17 C++17 又称C++1z，是继 C++14 之后，C++ 编程语言 ISO/IEC 标准的下一次修订的非正式名称。官方名称 ISO/IEC 14882:2017 基于 C++ 11，C++ 17 旨在简化该语言的日常使用，使开发者可以更简单地编写和维护代码。 C++ 17是对 C++ 语言的重大更新 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:3","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["samba"],"content":"配置文件 配置文件 说明 /etc/samba/smb.conf samba的主要配置文件，可设置全局参数和共享目录的参数 /etc/samba/lmhosts 通过hostname来访问samba /etc/samba/smbusers 由于windows和linux里的管理员和访客账号名称不一致，可使用此配置文件来设置一个映射，比如administrator映射成root /etc/sysconfig/samba 配置smbd，nmbd启动时带的参数 /var/lib/samba/private/{passdb.tdb, secrets.tdb} 管理samba的用户账号/密码时，会用到的数据库档案 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:1:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"可用命令 命令 说明 smbd smbd提供文件和打印共享服务器 nmbd nmbd提供NetBIOS名称服务和浏览支持，帮助客户端定位服务器，处理所有基于UDP的协议 tdbdump,tdbtool samba使用了tdb数据库，可以使用tdb工具来查看数据库内容 smbstatus 查看samba的状态 smbpasswd, pdbedit 服务器功能，用于管理samba的用户账号和密码，早期是使用smbpasswd命令，后来因为使用了tdb数据库，所以推荐使用pdbedit命令来管理用户数据 mount.cifs 用来挂载分享目录 smbclient samba客户端命令 nmblookup 查找NetBIOS name smbtree 未知，可能是用来查找网络邻居的吧 testparm 验证smb.conf文件的内容是否合法 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:2:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"工作模式 samba 共有5种工作模式，分别为： share，用户对samba服务器的访问不需要身份验证，允许匿名访问，用户的访问权限仅由相应用户对共享文件的访问权限决定 user，使用用户名和密码访问samba服务器 server，使用另外一台服务器专门用来做身份验证，samba服务只提供文件和打印机共享服务 domain，域模式\u003c待补充\u003e ads，\u003c待补充\u003e 通过设置security选项即可设置samba的工作模式：security = share ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:3:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"配置项 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:4:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"全局配置 [global] workgroup = WORKGROUP dns proxy = no log file = /var/log/samba/%m.log max log size = 1000 client min protocol = SMB2 server role = standalone server passdb backend = tdbsam obey pam restrictions = yes unix password sync = yes passwd program = /usr/bin/passwd %u passwd chat = *New*UNIX*password* %n\\n *ReType*new*UNIX*password* %n\\n *passwd:*all*authentication*tokens*updated*successfully* pam password change = yes map to guest = Bad Password usershare allow guests = yes name resolve order = lmhosts bcast host wins security = user guest account = nobody usershare path = /var/lib/samba/usershare usershare max shares = 100 usershare owner only = yes force create mode = 0070 force directory mode = 0070 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:4:1","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"共享目录配置 不需要密码的共享 需要将全局参数中的security设置成share(暂不清楚，在user工作模式下通过设置guest ok好像也可以，需要验证) 最小化配置： [test] comment = test path = /tmp read only = no guest ok = yes create mask = 644 其中： read only默认为yes，表示只允许读，不允许写，所以需要修改 guest ok默认是no，表示不允许匿名访问 create mask默认是744，导致客户端创建的文件都是可执行文件，所以需要修改 注意： writable和writeable是同义词 writeable和read only是反义同义词 writeable默认为no read only默认为yes 完整配置需要配置available和browseable，不过这两个默认都是yes 用户名/密码方式的共享 需要将全局参数中的security设置成user [win] comment = win path = /home/win read only = yes create mask = 644 valid users = win 这种方式首先需要使用root权限添加一个账户，然后使用smbpasswd -a xxx在samba数据库添加此用户的samba密码 输入smbpasswd -a xxx 时会直接让用户设置这个账户的samba密码 这个用户信息保存在tdb数据库里 修改密码：root权限下输入smbpasswd user_name即可修改user_name的samba密码 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:4:2","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"配置文件验证 使用testparm可以验证smb.conf文件的内容是否合法 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:5:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"Samab密码设置对象 Samab密码设置对象(Password Settings Objects，简称PSOs)，开始于 Samba Version:4.9 密码设置对象(PSO)是一种 AD 功能，也称为细粒度密码策略(FGPP)。在 AD 中，密码设置控制以下几个方面： 用户更改密码时的最小密码长度和复杂性要求 密码历史时长：放置用户再次使用以前的密码 密码使用的最小和最大期限：用户必须更改密码的频率 账户锁定：在将用户锁定其账户之前登录尝试失败的阈值，以及他们被锁定的持续时间。 在支持 PSO 之前，Samba 管理员只能为域中的所有用户配置密码设置。例如。如果您想强制系统管理员拥有更长、更安全的密码，那么每个用户都必须遵守相同的密码要求。 PSO 允许 AD 管理员覆盖域的密码策略设置，并为特定用户或用户组配置更精细的密码设置。例如，PSO 可以强制某些用户使用更长的密码长度，或者放宽对其他用户的复杂性限制，等等。 PSO 可以应用于组或单个用户。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:1:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"如何配置 PSO 可以使用 samba-tool domain passwordsettings pso 命令设置。参看 samba-tool domain passwordsettings pso --help 获取更多使用细节。PSO 命令的功能： 自行管理 PSO，即使用 create 或 set 子命令配置密码设置。还有 delete、list 和 show 命令。 控制适用于特定用户的 PSO。使用 apply 和 unapply 将 PSO 链接到特定组或用户 许多不同的 PSO 可以应用于同一用户（直接或通过组）。当多个 PSO 应用于同一用户时，本质上是具有最低优先级的 PSO 生效。但是，直接应用于用户的 PSO 总是胜过通过组成员身份继承的 PSO。要查看对给定用户生效的 PSO，使用 samba-tool domain passwordsettings pso show-user。 如果没有 PSO 应用于用户，则应用域密码设置。您可以使用samba-tool domain passwordsettings show|set查看/修改这些配置。 注意： 请使用 samba-tool 创建密码设置对象，而不是使用手动 LDIF。 PSO 需要驻留在“密码设置容器”中，samba-tool 将自动对其进行排序。任何在别处创建的 PSO 都将被忽略。 内置组不包括在 PSO 计算中。任何应用于内置组的 PSO 都不会生效。 要使用 Windows GUI 创建 PSO，请打开 Active Directory 管理中心，然后导航到系统 -\u003e 密码设置容器，然后单击“新建”按钮将弹出一个向导。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:2:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"已知问题 当前 (v4.9) 配置 PSO 并将其应用于用户会导致性能下降。这是我们希望在未来解决的问题。 计算 PSO 涉及计算用户的组成员资格，这是一个相当昂贵的计算。更糟糕的是，我们可能需要多次查找 msDS-ResultantPSO，因此它可能会尝试多次计算组，仅针对一次用户身份验证操作。注意： 如果根本没有 PSO 对象，则不会影响性能。 我们尝试缓存 msDS-ResultantPSO 结果，因此每次用户身份验证操作只计算一次。但是，如果没有 msDS-ResultantPSO（即域默认值适用于用户），我们不会缓存结果。所以这将是最坏的情况：域中存在一些 PSO，但它们对大多数用户不起作用。 如果 PSO 直接应用于用户（而不是组），则跳过昂贵的组计算。但是，与将 PSO 应用于组相比，将 PSO 直接应用于用户会使 PSO 更难管理。 如果密码历史长度从零变为非零值，Windows 和 Samba 行为之间还有一个非常微不足道的错误 (#13431)。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:3:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"代码位置 主要 PSO 行为是使用构造属性控制的：msDS-ResultantPSO。这是为用户对象生成的，其值是适用于该用户的 PSO 的 DN。因此，确定适用于用户的正确 PSO 的逻辑存在于 operation.c 中，在那里生成构造的属性。 如果你 grep 'msDS-ResultantPSO' 的代码库，你应该找到所有尝试使用它的地方。基本上，无论代码检查密码设置属性（例如 lockOutObservationWindow），我们都必须检查 PSO 是否适用于该用户，如果是，则使用 PSO 属性（具有不同的名称，即 msDS-LockoutObservationWindow）。 samdb_result_effective_badPwdCount() 就是一个很好的例子。 get_pso_data_callback() 也值得注意，因为它用 PSO 的值覆盖了 dsdb_user_pwd_settings 结构的值（即域密码设置）。在密码哈希模块中使用此结构（作为结构 dsdb_control_password_change_status 的一部分）来检查密码更改操作。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:4:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"参考文档 MS-ADTS 记录了如何确定 msDS-ResultantPSO（第 3.1.1.4.5.36 节）。 MS-SAMR 记录了 msDS-ResultantPSO 如何用于确定应用于用户的有效密码设置，即 Effective-LockoutThreshold、Effective-MinimumPasswordLength 等。这在第 3.1.1.5 节用于发起更新约束的密码设置属性中记录，但这些 Effective-XYZ 值在整个文档的其他几个地方都被引用，例如在计算 userAccountControl 时。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:5:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["linux"],"content":"rfkill rfkill 是一个小型的用户空间工具，用于查询 rfkill 开关、按钮和子系统接口的状态。 Linux 内核通过 /dev/rfkill 设备文件公开了 rfkill 子系统一些控制功能，允许用户空间模拟/监听/控制硬件 rfkill 设备。 ","date":"2022-04-20","objectID":"/2022/04/0005-rfkill/:1:0","tags":["linux","rfkill","wlan","bluetooth"],"title":"rfkill —— 用户空间控制无线通讯命令","uri":"/2022/04/0005-rfkill/"},{"categories":["linux"],"content":"具体使用 rfkill --help ","date":"2022-04-20","objectID":"/2022/04/0005-rfkill/:2:0","tags":["linux","rfkill","wlan","bluetooth"],"title":"rfkill —— 用户空间控制无线通讯命令","uri":"/2022/04/0005-rfkill/"},{"categories":["linux"],"content":"参看 https://wireless.wiki.kernel.org/en/users/Documentation/rfkill ","date":"2022-04-20","objectID":"/2022/04/0005-rfkill/:3:0","tags":["linux","rfkill","wlan","bluetooth"],"title":"rfkill —— 用户空间控制无线通讯命令","uri":"/2022/04/0005-rfkill/"},{"categories":["字符编码"],"content":"字符编码基本概念 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:0","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符 字符（Character）：在计算机和电信技术中，一个字符是一个单位的字形、类字形单位或符号的基本信息。说的简单点字符是各种文字和符号的总称。一个字符可以是一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号、一个图形符号或者控制符号等。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:1","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符集 字符集（Character Set）：是指多个字符的集合。不同的字符集包含的字符个数不一样、包含的字符不一样、对字符的编码方式也不一样。例如GB2312是中国国家标准的简体中文字符集，GB2312收录简化汉字（6763个）及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。而ASCII字符集只包含了128字符，这个字符集收录的主要字符是英文字母、阿拉伯字母和一些简单的控制字符。 另外，还有其他常用的字符集有 GBK字符集、GB18030字符集、Big5字符集、Unicode字符集等。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:2","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符编码 字符编码（Character Encoding）：字符编码是指一种映射规则，根据这个映射规则可以将某个字符映射成其他形式的数据以便在计算机中存储和传输。例如ASCII字符编码规定使用单字节中低位的7个比特去编码所有的字符，在这个编码规则下字母A的编号是65（ASCII码），用单字节表示就是0x41，因此写入存储设备的时候就是二进制的 01000001。每种字符集都有自己的字符编码规则，常用的字符集编码规则还有 UTF-8编码、GBK编码、Big5编码等。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:3","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"码点 码点（Code Point）：有些地方翻译为码值或内码。是指在某个字符集中，根据某种编码规则将字符编码后得到的值。比如在ASCII字符集中，字母A经过ASCII编码得到的值是65，那么65就是字符A在ASCII字符集中的码点。 总结：通俗解释字符集就是把字符放到一起的一个集合。而这个集合的每一个字符都对应一个数字，叫做码点。那么，这样就建立起来数字和字符之间的索引关系。那么，某个字符在计算机中怎么表示，具体占用几个字节等等，这些就需要编码规则来解决了。这个就是字符编码，他来解决根据某个规则来将字符映射到相应的码点上面。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:4","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符编码 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:0","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"ASCII 码 ASCII 编码于 1967 年第一次发布，最后一次更新是在 1986 年，迄今为止共收录了 128 个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是 1234567890）、标点符号（,.!等）、特殊符号（@#$%^\u0026等）以及一些具有控制功能的字符（往往不会显示出来）。 ASCII 编码是美国人给自己设计的，他们并没有考虑欧洲那些扩展的拉丁字母，也没有考虑韩语和日语，我大中华几万个汉字更是不可能被重视。计算机也是美国人发明的，起初使用的就是 ASCII 码，只能显示英文字符。各个国家为了让本国公民也能正常使用计算机，开始效仿 ASCII 开发自己的字符编码，例如 ISO/IEC 8859（欧洲字符集）、shift_Jis（日语字符集）、GBK（中文字符集）等。 二进制 十进制 十六进制 字符/缩写 解释 00000000 0 00 NUL (NULL) 空字符 00000001 1 01 SOH (Start Of Headling) 标题开始 00000010 2 02 STX (Start Of Text) 正文开始 00000011 3 03 ETX (End Of Text) 正文结束 00000100 4 04 EOT (End Of Transmission) 传输结束 00000101 5 05 ENQ (Enquiry) 请求 00000110 6 06 ACK (Acknowledge) 回应/响应/收到通知 00000111 7 07 BEL (Bell) 响铃 00001000 8 08 BS (Backspace) 退格 00001001 9 09 HT (Horizontal Tab) 水平制表符 00001010 10 0A LF/NL(Line Feed/New Line) 换行键 00001011 11 0B VT (Vertical Tab) 垂直制表符 00001100 12 0C FF/NP (Form Feed/New Page) 换页键 00001101 13 0D CR (Carriage Return) 回车键 00001110 14 0E SO (Shift Out) 不用切换 00001111 15 0F SI (Shift In) 启用切换 00010000 16 10 DLE (Data Link Escape) 数据链路转义 00010001 17 11 DC1/XON (Device Control 1/Transmission On) 设备控制1/传输开始 00010010 18 12 DC2 (Device Control 2) 设备控制2 00010011 19 13 DC3/XOFF (Device Control 3/Transmission Off) 设备控制3/传输中断 00010100 20 14 DC4 (Device Control 4) 设备控制4 00010101 21 15 NAK (Negative Acknowledge) 无响应/非正常响应/拒绝接收 00010110 22 16 SYN (Synchronous Idle) 同步空闲 00010111 23 17 ETB (End of Transmission Block) 传输块结束/块传输终止 00011000 24 18 CAN (Cancel) 取消 00011001 25 19 EM (End of Medium) 已到介质末端/介质存储已满/介质中断 00011010 26 1A SUB (Substitute) 替补/替换 00011011 27 1B ESC (Escape) 逃离/取消 00011100 28 1C FS (File Separator) 文件分割符 00011101 29 1D GS (Group Separator) 组分隔符/分组符 00011110 30 1E RS (Record Separator) 记录分离符 00011111 31 1F US (Unit Separator) 单元分隔符 00100000 32 20 (Space) 空格 00100001 33 21 ! 00100010 34 22 \" 00100011 35 23 # 00100100 36 24 $ 00100101 37 25 % 00100110 38 26 \u0026 00100111 39 27 ' 00101000 40 28 ( 00101001 41 29 ) 00101010 42 2A * 00101011 43 2B + 00101100 44 2C , 00101101 45 2D - 00101110 46 2E . 00101111 47 2F / 00110000 48 30 0 00110001 49 31 1 00110010 50 32 2 00110011 51 33 3 00110100 52 34 4 00110101 53 35 5 00110110 54 36 6 00110111 55 37 7 00111000 56 38 8 00111001 57 39 9 00111010 58 3A : 00111011 59 3B ; 00111100 60 3C \u003c 00111101 61 3D = 00111110 62 3E \u003e 00111111 63 3F ? 01000000 64 40 @ 01000001 65 41 A 01000010 66 42 B 01000011 67 43 C 01000100 68 44 D 01000101 69 45 E 01000110 70 46 F 01000111 71 47 G 01001000 72 48 H 01001001 73 49 I 01001010 74 4A J 01001011 75 4B K 01001100 76 4C L 01001101 77 4D M 01001110 78 4E N 01001111 79 4F O 01010000 80 50 P 01010001 81 51 Q 01010010 82 52 R 01010011 83 53 S 01010100 84 54 T 01010101 85 55 U 01010110 86 56 V 01010111 87 57 W 01011000 88 58 X 01011001 89 59 Y 01011010 90 5A Z 01011011 91 5B [ 01011100 92 5C \\ 01011101 93 5D ] 01011110 94 5E ^ 01011111 95 5F _ 01100000 96 60 ` 01100001 97 61 a 01100010 98 62 b 01100011 99 63 c 01100100 100 64 d 01100101 101 65 e 01100110 102 66 f 01100111 103 67 g 01101000 104 68 h 01101001 105 69 i 01101010 106 6A j 01101011 107 6B k 01101100 108 6C l 01101101 109 6D m 01101110 110 6E n 01101111 111 6F o 01110000 112 70 p 01110001 113 71 q 01110010 114 72 r 01110011 115 73 s 01110100 116 74 t 01110101 117 75 u 01110110 118 76 v 01110111 119 77 w 01111000 120 78 x 01111001 121 79 y 01111010 122 7A z 01111011 123 7B { 01111100 124 7C | 01111101 125 7D } 01111110 126 7E ~ 01111111 127 7F DEL (Delete) 删除 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:1","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"GB2312(别名:EUC-CN) 《信息交换用汉字编码字符集》是由中国国家标准总局1980年发布，1981年5月1日开始实施的一套国家标准，标准号是GB 2312—1980。 GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。 GB2312(1980年)共收录 7445 个字符 –\u003e GBK1.0(1995年)共收录 21886 个字符 –\u003e GB18030(2000年)取代GBK1.0共收录 27484 个汉字包含了少数民族语言。 从 ASCII -\u003e GB2312 -\u003e GBK -\u003e GB18030，这些编码都是向下兼容的。区分中文编码的方法是最高字节的最高位不为 0。这些都属于双字节字符集。 GB2312 编码规则 GB2312 规定每个英文字符占1字节(只有这一个特例，为了兼容 ASCII)，中文字符采用两个字节表示 GB2312 整体分为 94 个区，每个区 94 位，01-09 特殊符号区；16-55一级汉字，按拼音排序；56-87二级汉字，部首/笔划排序；10-15与88-94未定义 GB2312 是区位编码，编码范围是 0XA1A1-0XFEFE，其中汉字编码范围是 0XB0A1-0XF7FE。 GB2312 01-09 符号和数字区，16-87是汉字区 GB2312 编码计算：[区号+0xA0][位号+0xA0] GB2312 编码识别 保存为demo-gb2312.c // // Created by dingjing on 3/28/22. // #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdint.h\u003e #include \u003cstdbool.h\u003e /** * 总共 94 个区 94 个位 */ bool is_gb2312 (const char* code) { int len = strlen (code); if (len != 2 \u0026\u0026 len != 1) { return false; } uint8_t codeH = code[0]; uint8_t codeL = code[1]; uint8_t area = codeH - 0xA0; uint8_t pos = codeL - 0xA0; if ((len == 1) \u0026\u0026 (0 == (codeL \u0026 0x80))) { printf (\"ascii code: '%-3c' hex code: 0x%-2X\\n\", *code, *code); return true; } if (area \u003e= 1 \u0026\u0026 area \u003c= 94 \u0026\u0026 pos \u003e= 1 \u0026\u0026 pos \u003c= 94) { printf (\"gb2312 code: '%-3s' -- area: %-2u, pos: %-2u hex code: 0x%-2X 0x%-2X\\n\", code, area, pos, codeH, codeL); return true; } } int main (int argc, char* argv[]) { /** * https://uic.io/en/charset/show_raw/gb2312 * http://tools.jb51.net/table/gb2312 * 1. '残' 十六进制: B2D0 * 2. '怖' 十六进制: B2C0 * 3. '惭' 十六进制: B2D1 * * 4. ascii 里显示的特殊符号 32(space) - 47(/) * 5. ascii 里数字 30(0) - 39(9) * 6. ascii 里显示的特殊符号 58(:) - 64(@) * 7. ascii 里显示的大写字母 65(A) - 90(Z) * 8. ascii 里显示的标号字符 91([) - 96(`) * 9. ascii 里显示的大写字母 97(a) - 122(z) * 10. ascii 其它可显示字符 123({) - 126(~) * * uint16_t 就足够了 */ const char* arr[] = { \"、\", \"∩\", \"〓\", /* 第一区 */ \"残\", \"怖\", \"惭\", \"庄\", \"丽\", \"君\", \"齄\", \" \", \"/\", \"0\", \"9\", \":\", \"@\", \"A\", \"Z\", \"[\", \"`\", \"a\", \"z\", \"{\", \"~\" }; printf (\"array: %lu/%lu\\n\\n\", sizeof arr[0], sizeof arr); int len = sizeof arr / sizeof arr[0]; for (int i = 0; i \u003c len; ++i) { const char* code = arr[i]; if (!is_gb2312 (code)) { printf (\"index: %d -- code '%-3s' is not gb2312\\n\", i, code); } } return 0; } 编译命令: gcc -O0 -finput-charset=utf8 -fexec-charset=gb2312 demo-gb2312.run demo-gb2312.c GB2312识别思路(后续补充) ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:2","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"Unicode 编码 Unicode 的使命就是为了统一世界上所有语言的编码，它包含了世界上所有字符的编码，规定了每个字符对应的码点值。 这里需要注意：Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 问题1: 如何才能区别unicode和ascii 问题2: 我们已经知道，英文字母只用一个字节表示就够了，如果 unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0， 这对于存储来说是极大的浪费，文本文件的大小会因此大出 2-3 倍，这是无法接受的。 另附unicode中汉字编码 字符集 字数 unicode 编码 基本汉字 20902字 4E00(一) - 9FA5(龥) 基本汉字扩充 90字 9FA6(龦) - 9FFF(\u003c无法显示\u003e) 这些看着不像汉字，先不管 扩展A 6592字 3400 - 4DBF，看着不像汉字 扩展B 42720字 20000-2A6DF 扩展C 4153字 2A700-2B738 扩展D 222字 2B740-2B81D 扩展E 5762字 2B820-2CEA1 扩展F 7473字 2CEB0-2EBE0 扩展G 4939字 30000-3134A 康熙部首 214字 2F00-2FD5 部首扩展 115字 2E80-2EF3 兼容汉字 477字 F900-FAD9 兼容扩展 542字 2F800-2FA1D PUA(GBK)部件 81字 E815-E86F 部件扩展 452字 E400-E5E8 PUA增补 207字 E600-E6CF 汉字笔画 36字 31C0-31E3 汉字结构 12字 2FF0-2FFB 汉语注音 43字 3105-312F 注音扩展 22字 31A0-31BA 〇 1字 3007 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:3","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"utf8 编码(unicode编码的一种实现) UTF-8 是一种变长字节编码方式，是 Unicode 的一种实现方式，使用 1-4 个字节表示一个符号， 对于某一个字符的 UTF-8 编码，如果只有一个字节则其最高二进制位为 0； 如果是多字节，其第一个字节从最高位开始，连续的二进制位值为 1 的个数决定了其编码的位数，其余各字节均以 10 开头。UTF-8 最多可用到 6 个字节。 注意：这里是utf8编码的核心，它规定了utf8最多可以使用多少字节编码 思考：为什么utf8最多只能使用6字节参与编码？ 实际上 utf-8 编码没用到 6 字节那么多，只用到了 4 字节 另外补充：另外补充 utf16，介于 utf8 与 utf32 之间，部分编码定长、部分编码不定长(只有两种) utf32 是定长的，用 4 字节表示一个字符 utf8中文汉字占3字节(这种结论不是一直不变的) 以下展示 utf8 分别为 1、2、3、4、5、6字节时候，理论上其它位的编码范围。 1字节 0xxxxxxx 2字节 110xxxxx 10xxxxxx 3字节 1110xxxx 10xxxxxx 10xxxxxx 4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 与上述等价 1字节, utf8-1 0x00-0x7F 2字节, utf8-2 0xC2-0XDF 0X80-0XBF 3字节, utf8-3 0xE0 0xA0-0XBF 0x80-0xBF 0xE1-0XEC 0x80-0XBF 0x80-0xBF 0xED 0x80-0x9F 0x80-0xBF 0xEE-0xEF 0x80-0xBF 0x80-0xBF 4字节, utf8-4 0xF0 0x90-0xBF 0x80-0xBF 0x80-0xBF 0xF1-0xF3 0x80-0xBF 0x80-0xBF 0x80-0xBF 0xF4 0x80-0x8F 0x80-0xBF 0x80-0xBF utf8 编码识别 保存为demo-utf8.c // // Created by dingjing on 3/28/22. // #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e #include \u003cstring.h\u003e #include \u003cstdbool.h\u003e bool is_utf8_1 (const char* code) { int len = strlen(code); if (len \u003c 1) { return false; } const uint8_t code1 = code[0]; if (!(0x80 \u0026 code1)) { return true; } return false; } bool is_utf8_2 (const char* code) { int len = strlen(code); if (len \u003c 2) { return false; } const uint8_t code1 = code[0]; const uint8_t code2 = code[1]; // printf (\"debug2: 0x%-4X\\n\", code); if (!is_utf8_1 (code) \u0026\u0026 (0xC0 == (0xE0 \u0026 code1)) \u0026\u0026 (0x80 == (0xE0 \u0026 code2))) { // printf (\"debug: is utf8-2\\n\"); if (code1 \u003e= 0xC0 \u0026\u0026 code1 \u003c= 0xDF \u0026\u0026 code2 \u003e= 0x80 \u0026\u0026 code2 \u003c= 0xBF) { return true; } } return false; } bool is_utf8_3 (const char* code) { /** * 0xE0 0xA0-0XBF 0x80-0xBF * 0xE1-0XEC 0x80-0XBF 0x80-0xBF * 0xED 0x80-0x9F 0x80-0xBF * 0xEE-0xEF 0x80-0xBF 0x80-0xBF */ int len = strlen(code); if (len \u003c 3) { return false; } const uint8_t code1 = code[0]; const uint8_t code2 = code[1]; const uint8_t code3 = code[2]; if ((0xE0 == code1) \u0026\u0026 ((code2 \u003e= 0xA0) \u0026\u0026 (code2 \u003c= 0XBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } else if (((code1 \u003e= 0xE1) \u0026\u0026 (code1 \u003c= 0xEC)) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } else if ((0xED == code1) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0x9F)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } else if (((code1 \u003e= 0xEE) \u0026\u0026 (code1 \u003c= 0xEF)) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } return false; } bool is_utf8_4 (const char* code) { /** * 0xF0 0x90-0xBF 0x80-0xBF 0x80-0xBF * 0xF1-0xF3 0x80-0xBF 0x80-0xBF 0x80-0xBF * 0xF4 0x80-0x8F 0x80-0xBF 0x80-0xBF */ int len = strlen(code); if (len \u003c 4) { return false; } const uint8_t code1 = code[0]; const uint8_t code2 = code[1]; const uint8_t code3 = code[2]; const uint8_t code4 = code[3]; // printf (\"debug4: 0x%-4X %-4X\\n\", code1H, code1L); if (!is_utf8_1 (code) \u0026\u0026 !is_utf8_2 (code) \u0026\u0026 !is_utf8_3 (code)) { if ((0xF0 == code1) \u0026\u0026 ((code2 \u003e= 0x90) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF)) \u0026\u0026 ((code4 \u003e= 0x80) \u0026\u0026 (code4 \u003c= 0xBF))) { return true; } else if (((code1 \u003e= 0xF1) \u0026\u0026 (code1 \u003c= 0xF3)) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF)) \u0026\u0026 ((code4 \u003e= 0x80) \u0026\u0026 (code4 \u003c= 0xBF))) { return true; } else if ((0xF4 == code1) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0x8F)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF)) \u0026\u0026 ((code4 \u003e= 0x80) \u0026\u0026 (code4 \u003c= 0xBF))) { return true; } } return false; } int main (int argc, char* argv[]) { // utf-8 1 - 4 字节 const char* arr[] = { \" \", \"/\", \"0\", \"9\", \":\", \"@\", \"A\", \"Z\", \"[\", \"`\", \"a\", \"z\", \"{\", \"~\", /* 以下都是 ASCII */ \"§\", \"©\", \"®\", \"Ą\", \"Ď\", \"Đ\", \"Ő\", /* 2 字节 utf8 编码 */ \"ᥕ\", \"一\", \"龥\", \"庄\", \"丽\", \"君\", /* 3 字节 */ \"契\", \"い\", \"龜\" }; printf (\"array: %lu/%lu\\n\\n\", sizeof arr[0], sizeof arr); char buf[128] = {0}; int len = sizeof arr / sizeof arr[0]; for (int i = 0; i \u003c len; ++i) { const char* code = arr[i]; if (is_utf8_1 (code)) { ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:4","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"utf16 编码(unicode编码的一种实现) 没用到，后续补充。 部分编码定长、部分编码不定长(只有两种) ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:5","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"utf32 编码(unicode编码的一种实现) utf32 是定长的，用 4 字节表示一个字符 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:6","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["linux"],"content":"说明 fstransform 命令可以将文件系统从一种类型转换为另一种类型而不丢失数据(即非破坏性的)。更重要的是它可以直接执行，而无需格式化或者复制数据。 tune2fs 命令可以把 ext2 转为 ext3 或 ext4；也可以把 ext3 转为 ext4 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:1:0","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"fstransform文件系统格式转换 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:2:0","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"需要注意的事 1. Linux内核必须支持转换前和转换后的文件系统 2. ext2升级到ext3、ext4无需 fstransform，要使用 tune2fs 3. 源文件系统的设备至少有5%的可用空间 4. 开始执行转换前卸载文件系统 5. 源文件系统存储的数据越多，转换时间越长。实际取决于设备 6. 虽然fstransform被证明是稳定的，但是也要备份好数据 7. 无法转换Linux根文件系统格式 8. 设备上的文件系统限制 必须支持 SPARSE 文件(即:带有孔的文件) 至少有两个系统调用\"ioctl\"(FS_IOC_FIEMAP和FIBMAP)中的一个 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:2:1","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"操作 fstransform /dev/xxx \u003c目标系统\u003e 亲测速度太慢，而且还有很高的失败率。建议如果是ext系列的文件系统使用tune2fs转换。 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:2:2","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"tune2fs 转换ext系列文件系统格式 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:0","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"ext2 转 ext3 tune2fs -j /dev/sda ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:1","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"ext2 转 ext4 tune2fs -O extents,uninit_bg,dir_index,has_journal /dev/sda1 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:2","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"ext3 转 ext4 tune2fs -O extents,uninit_bg,dir_index,has_journal /dev/sda1 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:3","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"wireshark 是什么 Wireshark(前称Ethereal)是一个网络封包分析软件。网络封包软件的功能主要是截取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用 WinPCAP 作为接口，直接与网卡进行数据报文交换。 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:1:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 使用 首先进入 wireshark，启动时候需要使用命令行以 root 启动 非root用户无法抓取网卡上所有的包 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"1. 选择网卡 选择菜单栏上 Capture -\u003e Option，选中使用的网卡，点击 start 开始抓包 选择网卡 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"2. 添加过滤条件 比如仅需要查看 www.baidu.com 的数据包，通过 ping 命令获取对应的 ip，在 wireshark 中设置 ip 过滤条件就可以看到。 ip.addr == 119.75.217.26 and icmp 表示只显示ICPM协议且源主机IP或者目的主机IP为119.75.217.26的数据包 添加过滤条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 界面说明 wireshark界面说明 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:3:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"数据详细区说明 Frame: 物理层的数据帧概况 Ethernet II: 数据链路层以太网帧头部信息 Internet Protocol Version 4: 互联网层IP包头部信息 Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP 之后的都属于应用层 wireshark界面说明 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:3:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 设置过滤条件 需要注意的是，wireshark 既可以设置抓包过滤条件，也可以设置显示过滤条件，前者限制大，用于减少捕获数据包的数量；后者用于在报文中隐藏某些报文。 抓包过滤器只能在抓包前设置，无法动态修改，显示过滤器则没有此限制 设置抓包过滤条件，(如果已经开始抓包，需要先停止…)菜单栏 Capture -\u003e Options -\u003e Input -\u003e Capture filter for selected interfaces 设置配置条件，同时选中要抓取的网卡，点击此页面右下角的 Start 即可开始抓包 设置显示过滤条件，在菜单栏下边有个文本输入框(Apply a display filter ... \u003cCtrl-/\u003e) 在这里配置显示过滤条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"抓取过滤类型(抓包过滤) 类型 说明 host 让wireshark只抓取源于或发往由标识符host所指定的主机名或IP地址的流量 net 让wireshark只抓取源于或发往由标识符net所标识的IPv4/IPv6网络号的流量 port 让wireshark只抓取源于或发往由标识符port指定端口号的流量包 portrange 让wireshark只抓取源于或发往由标识符portrange指定端口范围的流量包 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"过滤方向(显示/抓包过滤) 方向 说明 src 发送端条件 dst 目标端条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"过滤协议(显示过滤) 协议 说明 ether fddi tr wlan ip ip6 arp rarp decnet sctp tcp udp http … ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:3","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"逻辑运算符(显示过滤) 运算符 说明 \u0026\u0026 或 and 两者等价与逻辑 || 或 or 两者等价或逻辑 ! 或 not 两者等价非逻辑 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:4","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"比较操作符(显示过滤) 运算符 说明 == 等于 != 不等于 \u003e 大于 \u003c 小于 \u003e= 大于等于 \u003c= 小于等于 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:5","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"例子 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"抓包过滤条件 抓取百度的包 host www.baidu.com 或者使用 ping www.baidu.com 得到百度网站的ip (220.181.38.150)再使用命令 net 220.181.38.150 抓取指定ip范围内的包 net 192.168.0.0/24 或 net 192.168.0.0 mask 255.255.255.0 抓取从指定 IP 范围发出的包 src net 192.168.0.0/24 或 src net 192.168.0.0 mask 255.255.255.0 抓取发往目标 IP 范围的包 dst net 192.168.0.0/24 或 dst net 192.168.0.0 mask 255.255.255.0 抓取指定端口53的包(DNS服务) port 53 抓取指定服务器上非 HTTP 和非 SMTP 的包 host www.example.com and not (port 80 or port 25) host www.example.com and not port 80 and not port 25 抓取除了 ARP 和 DNS 的包 port not 53 and not arp 抓取指定端口范围的包 (tcp[0:2] \u003e 1500 and tcp[0:2] \u003c 1550) or (tcp[2:2] \u003e 1500 and tcp[2:2] \u003c 1550) 或 tcp portrange 1501-1549 值抓取EAPOL类型以太网的包 ether proto 0x888e 拒绝向链路层发现协议发送的以太网帧 not ether dst 01:80:c2:00:00:0e 仅捕获IPv4流量-最短的过滤器，但有时非常有用，以摆脱较低的层协议，如ARP和STP ip 仅捕获单播流量-如果你只想看到与你的机器之间的流量，而不捕获广播和多播 not broadcast and not multicast 捕获IPv6“所有节点”(路由器和邻居通告)流量。可以用来找到流氓RAs dst host ff02::1 捕获HTTP GET请求。这将查找TCP头后面的字节’G’、‘E’、‘T’和’ ‘(十六进制值47、45、54和20)。“tcp[12:1] \u0026 0xf0) » 2\"计算出tcp报头长度 port 80 and tcp[((tcp[12:1] \u0026 0xf0) \u003e\u003e 2):4] = 0x47455420 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"显示过滤器 仅显示 SMTP(25端口)和 ICMP 数据包 tcp.port eq 25 or icmp 只显示局域网(192.168.x.x)的流量，工作站和服务器之间-没有Internet: ip.src==192.168.0.0/16 and ip.dst==192.168.0.0/16 TCP buffer full - Source指示Destination停止发送数据 tcp.window_size == 0 \u0026\u0026 tcp.flags.reset != 1 参考：https://wiki.wireshark.org/DisplayFilters 参考: https://wiki.wireshark.org/Home ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"samba 挂载 目前有一个需求，系统重启时候需要自动挂载远程 samba 文件系统，起初使用 fstab 发现并不能成功挂载，考虑应该是和启动顺序有关系，当没有网络的时候是无法执行挂载操作的，或者说挂载会出错，后来发现 systemd 也提供自动挂载的功能，于是尝试了一下，发现是可以的。 ","date":"2022-03-18","objectID":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/:1:0","tags":["linux","samba","systemd"],"title":"systemd 自动挂载samba","uri":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/"},{"categories":["linux"],"content":"具体步骤 在 /etc/samba/ 下创建 credentials 文件夹 mkdir /etc/samba/crendentials 在/etc/samba/crendentials下创建比如名为share0的文件并加入如下配置 # vim /etc/samba/crendentials/share0 username=\u003csamba登录用户名\u003e password=\u003csamba对应的密码\u003e 创建systemd unit文件，内容如下 # vim /etc/systemd/system/mnt-share.mount Description= mount a samba share Requires=network-online.target After=network-online.target systemd-resolved.service Wants=network-online.target systemd-resolved.service [Mount] Name=mnt-share What=//\u003c远程samba-ip\u003e/\u003c远程samba路径\u003e Where=/mnt/share # \u003c本机挂载路径\u003e Type=cifs Options=x-systemd.automount,_netdev,credentials=/etc/samba/credentials/share,sec=ntlmssp,vers=1.0,rw,uid=1000,gid=1000,dir_mode=0777,file_mode=0777,iocharset=utf8 TimeoutSec=30 [Install] WantedBy=multi-user.target 测试是否可以挂载 systemctl start mnt-share.mount 如果有报错就需要尝试修改 5. 开机自动挂载 systemctl enable mnt-share.mount 注意：挂载路径(Where)必须和文件名(mnt-share0)对应，比如挂载到 /mnt/share，那么文件名必须是mnt-share0.mount 参考：arch linux samba https://wiki.archlinux.org/index.php/samba#As_systemd_unit ","date":"2022-03-18","objectID":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/:2:0","tags":["linux","samba","systemd"],"title":"systemd 自动挂载samba","uri":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/"},{"categories":["linux"],"content":"说明 dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:1:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"块大小可以使用的计量表 单元大小 表示 字节(1B) c 字节(2B) w 块(512B) b 千字节(1024B) k 兆字节(1024KB) M 吉字节(1024MB) G ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:2:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"参数解释 参数 说明 if=\u003c文件名\u003e 输入文件名，默认为stdin标准输入，用来指定读取的源文件 of=\u003c文件名\u003e 输出文件名，默认为stdout标准输出，用来指定输出的目的文件 ibs=\u003c字节\u003e 一次读入bytes个字节，即指定一个块大小为bytes个字节 obs=\u003c字节\u003e 一次输出bytes个字节，即指定一个块大小为bytes个字节 bs=\u003c字节\u003e 同事设置读入/读出的块大小为 bytes 个字节 cbs=\u003c字节\u003e 一次转换bytes个字节，即指定转换缓存区大小 skip=\u003c字节\u003e 从输入文件开头跳过blocks个块后再开始复制 seek=\u003c字节\u003e 从输出文件开头跳过blocks个块后再开始复制 count=\u003c字节\u003e 仅拷贝blocks个块，块大小等于ibs指定的字节数 conv=\u003c转换参数\u003e 用指定的参数转换文件。ascii:转换ebcdic为asciiebcdic:转换ascii为ebcdicibm:转换ascii为alternate ebcdicblock:把每一行转换为长度为cbs，不足部分用空格填充unblock:使没一行的长度都为cbs，不足部分用空格填充lcase:把大写字符转换为小写字符ucase:把小写字符转换为大写字符swab:交换输入的每对字节noerror:出错时不停止notrunc:不截断输出文件sync:将每个输入块填充到ibs个字节，不足部分也能够(NUL)字符补齐 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:3:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"dd应用实例 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"将本地 /dev/hdb 盘备份到 /dev/hdd dd if=/dev/hdb of=/dev/hdd ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:1","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"备份/dev/hdb全盘数据，并利用gzip工具进行压缩，保存到指定路径 dd if=/dev/hdb | gzip \u003e /root/image.gz ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:2","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"将压缩的备份文件恢复到指定盘 gzip -dc /root/image.gz | dd of=/dev/hdb ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:3","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"备份与恢复MBR 备份磁盘开始的512个字节大小的MBR信息到指定文件： dd if=/dev/hda of=/root/image count=1 bs=512 count=1指仅拷贝一个块；bs=512指块大小为512个字节 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:4","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"增加swap分区文件大小 第一步：创建一个大小为256M的文件： dd if=/dev/zero of=/swapfile bs=1024 count=262144 第二步：把这个文件变成swap文件： mkswap /swapfile 第三步：启用这个swap文件： swapon /swapfile 第四步：编辑/etc/fstab文件，使在每次开机时自动加载swap文件： /swapfile swap swap default 0 0 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:5","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"销毁磁盘数据 dd if=/dev/urandom of=/dev/hda1 注意：利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:6","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"测试硬盘的读写速度 dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file dd if=/root/1Gb.file bs=64k | dd of=/dev/null 通过以上两个命令输出的命令执行时间，可以计算出硬盘的读、写速度 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:7","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"确定硬盘的最佳块大小 dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file 通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:8","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"修复硬盘 dd if=/dev/sda of=/dev/sda # 或 dd if=/dev/hda of=/dev/hda 当硬盘较长时间(一年以上)放置不使用后，磁盘上会产生magnetic flux point，当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数 据起死回生。并且这个过程是安全、高效的 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:9","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"利用netcat远程备份 dd if=/dev/hda bs=16065b | netcat \u003c targethost-IP \u003e 1234 在源主机上执行此命令备份/dev/hda netcat -l -p 1234 | dd of=/dev/hdc bs=16065b 在目的主机上执行此命令来接收数据并写入/dev/hdc netcat -l -p 1234 | bzip2 \u003e partition.img netcat -l -p 1234 | gzip \u003e partition.img 以上两条指令是目的主机指令的变化分别采用bzip2、gzip对数据进行压缩，并将备份文件保存在当前目录 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:10","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"另附 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"/dev/null 和/dev/zero的区别 /dev/null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着。它是空设备，也称为位桶（bit bucket）。任何写入它的输出都会被抛弃。如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶 /dev/zero，是一个输入设备，你可你用它来初始化文件。该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:1","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"使用/dev/null 把/dev/null看作\"黑洞\"， 它等价于一个只写文件，所有写入它的内容都会永远丢失.，而尝试从它那儿读取内容则什么也读不到。然而， /dev/null对命令行和脚本都非常的有用 禁止标准输出 cat $filename \u003e/dev/null 禁止标准错误 #rm $badname 2\u003e/dev/null 禁止标准输出和标准错误的输出 cat $filename 2\u003e/dev/null \u003e/dev/null cat $filename \u0026\u003e/dev/null 自动清空日志文件的内容 cat /dev/null \u003e /var/log/messages # : \u003e /var/log/messages 有同样的效果， 但不会产生新的进程.（因为:是内建的） 隐藏cookie而不再使用 if [ -f ~/.netscape/cookies ] # 如果存在则删除. then rm -f ~/.netscape/cookies fi ln -s /dev/null ~/.netscape/cookies 现在所有的cookies都会丢入黑洞而不会保存在磁盘上了 使用/dev/zero 像/dev/null一样， /dev/zero也是一个伪文件， 但它实际上产生连续不断的null的流（二进制的零流，而不是ASCII型的）。 写入它的输出会丢失不见， 而从/dev/zero读出一连串的null也比较困难， 虽然这也能通过od或一个十六进制编辑器来做到。 /dev/zero主要的用处是用来创建一个指定长度用于初始化的空文件，就像临时交换文件。 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:2","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["system"],"content":"前言 致力于传统操作系统基本概念、基本技术、基本方法的阐述 把操作系统成熟的基本原理与当代具有代表性的具体实例紧密地结合起来 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:1:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"涉及内容 操作系统概论 介绍操作系统的基本概念、多道程序设计技术、操作系统的形成和发展，操作系统的分类；操作系统的服务、操作系统的功能、操作系统的接口；操作系统的结构 处理机管理 从处理器和中断技术开始，介绍了中断的概念、分类、处理、优先级和多重中断。接着，引入进程和线程的概念，介绍进程管理的实现模型、线程不同级别的实现方法，介绍处理机调度的三个层次，着重讨论了各种单处理机调度算法，也涉及到多处理机调度算法和实时调度算法 并发进程 介绍进程的顺序性和并发性，进程的协作和竞争，以进程交互、进程控制、进程通信和进程死锁问题为重点，讨论并发程序设计有关技术和各种进程互斥、同步、通信机制和工具 存储管理 讨论存储管理的基本功能、各种传统存储管理技术、虚拟存储管理技术和最新的存储管理技术，如多级页表、反置页表等 设备管理 讨论 I/O 硬件原理、I/O 控制方式、I/O 软件原理、I/O 缓冲技术，着重介绍磁盘驱动调度技术、RAID 技术以及设备分配/去配和虚拟设备技术。也介绍了具有通道的I/O系统管理 文件管理 讨论文件概念、文件目录、文件逻辑结构、文件物理结构、文件的保护和保密、文件存储空间管理以及文件的操作和使用原理。也讨论了文件系统的新概念：内存映射文件和虚拟文件系统。 操作系统安全性 讨论操作系统安全威胁和类型；操作系统保护的层次及保护的基本机制、策略和模型，其中着重讨论了身份认证机制、授权机制、加密机制和审计机制 网络和分布式操作系统 简要介绍网络和分布式操作系统的基本概念和技术，包括网络和数据通信基础、网络体系结构、网络操作系统；分布式进程通信、分布式资源管理、分布式进程同步、分布式文件系统和进程迁移等 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:1:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统概论 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统定义 操作系统是管理系统资源、控制程序执行、改善人机界面、提供各种服务，合理组织计算机工作流程和为用户有效使用计算机提供良好运行环境的一种系统软件。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"配置操作系统的主要目标 方便用户使用 OS 通过提供用户与计算机之间的友善接口来方便用户使用 扩大机器功能 OS 通过扩充改造硬件设施和提供新的服务来扩大机器功能 管理系统资源 OS 有效管理好系统中所有硬件软件资源，使之得到充分利用 提高系统效率 OS 合理组织好计算机的工作流程，以改进系统性能和提高系统效率 构筑开放环境 OS 遵循有关国际标准来设计和构造，以构筑出一个开放环境。含义主要是指：遵循有关国际标准（如开放的通信标准、开放的用户接口标准、开放的线程库标准等）；支持体系结构的可伸缩性和可扩展性；支持应用程序在不同平台上的可移植性和可互操作性 计算机系统包括硬件和软件两个组成部分。硬件是所有软件运行的物质基础，软件能充分发挥硬件潜能和扩充硬件功能，完成各种系统及应用任务，两者互相促进、相辅相成、缺一不可。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统的作用和功能 操作系统是用户与计算机硬件之间的接口 操作系统是计算机系统的资源管理者 处理器管理 处理器管理的第一项工作是处理中断事件。硬件只能发现中断事件，捕捉它并产生中断信号，但不能进行处理，配置了操作系统，就能对中断事件进行处理 处理器管理的第二项工作是处理器调度。处理器是计算机系统中一种稀有和宝贵的资源，应该最大限度地提高处理器的利用率。为了提高处理器的利用率，操作系统采用了多道程序设计技术。在多道程序或多用户的情况下，组织多个作业或任务执行时，就要解决处理器的调度、分配和回收等问题。为了实现处理器管理的功能，描述多道程序的并发执行，操作系统引入了进程的概念，处理器的分配和执行都是以进程为基本单位；随着并行处理技术的发展，为了进一步提高系统并行性，使并发执行单位的粒度变细，并发执行的代价降低，操作系统又引入了线程的概念。对处理器的管理和调度最终归结为对进程和线程的管理和调度，包括：（1）进程控制和管理；（2）进程同步和互斥；（3）进程通信；（4）进程死锁；（5）线程控制和管理；（6）处理器调度，又分高级调度，中级调度和低级调度。 正是由于操作系统对处理器的管理策略不同，其提供的作业处理方式也就不同，例如，批处理方式、分时处理方式、实时处理方式等等。从而，呈现在用户面前，成为具有不同处理方式和不同特点的操作系统。 存储管理 存储管理的主要任务是管理存储器资源，为多道程序运行提供有力的支撑，便于用户使用存储资源，提高存储空间的利用率。存储管理的主要功能包括： 存储分配。存储管理将根据用户程序的需要分配给它存储器资源，这是多道程序能并发执行的首要条件，当然程序运行结束时，还需回收存储资源。 存储共享。存储管理能让内存储器（又叫主存储器）中的多个用户程序实现存储资源的共享，以提高存储器的利用率。 地址转换与存储保护。存储管理负责把用户的逻辑地址转换成物理地址，同时要保证各个用户程序相互隔离起来互不干扰，更不允许用户程序访问操作系统的程序和数据，从而，保护系统和用户程序存放在存储器中的信息不被破坏。 存储扩充。由于受到处理器寻址能力的限制，一台计算机的物理内存容量总是有限的，难以满足用户大型程序的需求，而外存储器容量大且价格便宜。存储管理还应该能从逻辑上来扩充内存储器，把内存和外存混合起来使用，为用户提供一个比内存实际容量大得多的逻辑编程空间，方便用户的编程和使用。 设备管理 设备管理的主要任务是管理各类外围设备，完成用户提出的I/O请求，加快I/O信息的传送速度，发挥I/O设备的并行性，提高I/O设备的利用率，以及提供每种设备的设备驱动程序和中断处理程序，为用户隐蔽硬件细节，提供方便简单的设备使用方法。为实现这些任务，设备管理应该具有以下功能： 提供外围设备的控制与处理 提供缓冲区的管理 提供设备独立性 外围设备的分配和去配 实现共享型外围设备的驱动调度 实现虚拟设备 文件管理 文件管理则是针对系统中的信息资源的。在现代计算机中，通常把程序和数据以文件形式存储在外存储器（又叫辅存储器）上，供用户使用，这样，外存储器上保存了大量文件。 文件管理，它的主要任务是对用户文件和系统文件进行有效管理，实现按名存取；实现文件的共享、保护和保密，保证文件的安全性；并提供给用户一整套能方便使用文件的操作和命令。 具体来说，文件管理要完成以下任务： 提供文件的逻辑组织方法 提供文件的物理组织方法 提供文件的存取方法 提供文件的使用方法 实现文件的目录管理 实现文件的共享和存取控制 实现文件的存储空间管理 网络与通信管理 计算机网络源于计算机与通信技术的结合，联网操作系统至少应具有以下管理功能： 网上资源管理功能。计算机网络的主要目的之一是共享资源，网络操作系统应实现网上资源的共享，管理用户应用程序对资源的访问，保证信息资源的安全性和完整性。 数据通信管理功能。计算机联网后，结点之间可以互相传送数据，进行通信，通过通信软件，按照通信协议的规定，完成网络上计算机之间的信息传送。 网络管理功能。包括故障管理、安全管理、性能管理、记帐管理和配置管理等。 用户接口 为了使用户能灵活、方便地使用计算机和系统功能，操作系统还提供了一组友好的使用其功能的手段称用户接口，它包括两大类：程序接口和操作接口。用户通过这些接口能方便地调用操作系统功能，有效地组织作业及其工作和处理流程，并使整个系统能高效地运行。 操作系统的主要特性 并发性 并发性是指两个或两个以上的事件或活动在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在若干个运行着的程序，因此，它应该具有处理和调度多个程序同时执行的能力。 发挥并发性能够消除计算机系统中部件和部件之间的相互等待，有效地改善系统资源的利用率，改进系统的吞吐率，提高系统效率。 并发性虽然能有效改善系统资源的利用率，但却会引发一系列的问题，使操作系统的设计和实现变得复杂化。如：进程切换、进程调度、进程隔离保护、进程协作 在多处理器系统中，程序的并发性不仅体现在宏观上，而且体现在微观上，这称为并行的。并行性是指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同 CPU 上同时执行。而在分布式系统中，多台计算机的并存使程序的并发性得到了更充分的发挥，因为，同一时刻每台计算机上都可以有程序在执行。可见并行的事件或活动一定是并发的，但反之并发的事件或活动未必是并行的，并行性是并发性的特例，而并发性是并行性的扩展。由于并发技术的本质思想是：当一个程序发生事件（如等待 I/O）时出让其占用的 CPU 而由另一个程序运行，据此不难看出，实现并发技术的关键之一是如何对系统内的多个运行程序（进程）进行切换的技术。 共享性 共享指计算机系统中的资源（包括硬件资源和信息资源）可被多个并发执行的用户程序和系统程序共同使用，而不是被其中某一个程序所独占。 资源共享的方式可以分成两种： 互斥访问 系统中的某些资源如打印机、磁带机、卡片机，虽然它们可提供给多个程序使用，但在同一时间段内却只允许一个程序访问这些资源，即要求互相排斥地使用这些资源 同时访问 允许同一时间内多个程序对它们进行访问，这里“同时”是宏观上的说法，从微观上看多个程序访问资源仍然是交错的，只是这种交错访问的顺序对访问的结果没有影响罢了。典型的可供多个程序同时访问的资源是磁盘，各种可重入程序也可被同时访问 与共享性有关的问题是资源分配、信息保护、存取控制等，必须要妥善解决好这些问题。 共享性和并发性是操作系统两个最基本的特性，它们互为依存。一方面，资源的共享是因为程序的并发执行而引起的，若系统不允许程序并发执行，自然也就不存在资源共享问题。另一方面，若系统不能对资源共享实施有效管理，必然会影响到程序的并发执行，甚至程序无法并发执行，操作系统也就失去了并发性，导致整个系统效率低下。 异步性 在多道程序环境中，允许多个进程并发执行，由于资源有限而进程众多，多数情况下，进程的执行不是一贯到底，而是“走走停停”。 虚拟性 虚拟性是指操作系统中的一种管理技术，它是把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。显然，前者是实际存在的而后者是虚构假想的，采用虚拟技术的目的是为用户提供易于使用、方便高效的操作环境。比如：1个 CPU 被虚拟成两个、1台机器可以虚拟出多台的硬件 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统的形成和发展 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"人工操作阶段 初始操作系统尚未出现，由程序员采用手工方式直接控制和使用计算机硬件，程序员使用机器语言编程，并将事先准备好的程序和数据穿孔在纸带或卡片上，从纸带或卡片输入机将程序和数据输入计算机。然后，启动计算机运行程序，程序员可以通过控制台上的按钮、开关和氖灯来操纵和控制程序，运行完毕，取走计算输出的结果，才轮到下一个用户上机。 后来，汇编语言产生了，在汇编系统中，数字操作码被记忆码代替，程序按固定格式的汇编语言书写。系统程序员预先编制一个汇编程序，它把用汇编语言书写的“源程序”解释成计算机能直接执行的机器语言格式的目标程序。随后，一些高级程序设计语言相继出现进一步方便了编程。 执行时需要把汇编程序或编译系统以及源程序和数据，都穿在卡片或纸带上，然后，再装入和执行。 其大致过程为： 人工把源程序用穿孔机穿在卡片或纸带上 将准备好的汇编程序或编译系统装入计算机 汇编程序或编译系统读入人工装在输入机上的穿孔卡片或穿孔带上的源程序 执行汇编过程或编译过程，产生目标程序，并输出到目标卡片迭或纸带 通过引导程序把装在输入机上的目标程序读入计算机 执行目标程序，从输入机上读入人工装好的数据卡片或数据带上的数据 产生计算结果，把执行结果从打印机上或卡片机上输出 上述方式比直接用机器语言前进了一步，程序易于编制和读取，汇编程序或编译系统可执行存储、分配等辅助工作，从而，在一定程度上减轻了用户的负担。 人工操作方式存在严重缺点： 用户独占资源 人工干预较多 计算时间拉长 这种人工操作方式在慢速的计算机上还能容忍，但是随着计算机速度的提高，其缺点就更加暴露出来了。 此外，随着 CPU 速度迅速提高而 I/O 设备速度却提高不多，导致 CPU 与 I/O 设备之间的速度不匹配，矛盾越来越突出，需要妥善解决这些问题 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"管理程序阶段 早期批处理系统借助于作业控制语言变革了计算机的手工操作方式。用户不再通过开关和按钮来控制计算机的执行，而是通过脱机方式使用计算机，通过作业控制卡来描述对作业的加工和控制步骤，并把作业控制卡连同程序、数据一起提交给计算机的操作员，操作员收集到一批作业后一起把它们放到卡片机上输入计算机。计算机上则运行一个驻留在内存中的执行程序，以对作业进行自动控制和成批处理，自动进行作业转换以减少系统空闲和手工操作时间。其工作流程如下：执行程序将一批作业从纸带或卡片机输入到磁带上，每当一批作业输入完成后，执行程序自动把磁带上的第一个作业装入内存，并把控制权交给作业。当该作业执行完成后，执行程序收回控制权并再调入磁带上的第二个作业到内存执行。计算机在执行程序的控制下就这样连续地一个作业一个作业地执行，直至磁带上的作业全部做完。这种系统能实现作业到作业的自动转换，缩短作业的准备和建立时间，减少人工操作和干预，让计算机尽可能地连续运转。 早期的批处理系统中，一开始作业的输入和输出均是联机的，联机 I/O 的缺点是速度慢， I/O 设备和 CPU 仍然串行工作，CPU 时间浪费很大，为此，在批处理中引进了脱机 I/O 技术。除主机外，另设一台辅机，该机仅与 I/O 设备打交道，不与主机连接。输入设备上的作业通过辅机输到磁带上，这叫脱机输入；主机负责从磁带上把作业读入内存执行，作业完成后，主机负责把结果输出到磁带上，这叫脱机输出；然后，由辅机把磁带上的结果信息在打印机上打印输出。这称作脱机 I/O 技术。 为了发挥批处理系统的性能，缩短作业的准备和建立时间，驻留在内存工作的执行程序的功能得到了很大的扩充，进化到管理程序。FMS 和 IBSYS ）是这类系统的典型实例。 管理程序的内存组织如图所示，它的主要功能小结如下： 管理程序的内存组织 - 自动控制和处理作业流。管理程序把控制权传送给一个作业，当作业运行结束时，它又收回控制权，继续调度下一个作业执行，自动控制和处理作业流，减少了作业的准备和建立时间。作业流的自动控制和处理依靠作业控制语言，因而，促进了作业控制语言的发展。作业控制语言是由一些描述作业控制过程的语句组成的，每个语句附有一行作业或作业步信息编码，并以穿孔卡的形式提供。例如，$\\$JOB$ 卡表示启动一个新作业; $\\$FIN$ 卡表示调用 FORTRAN 编译系统; $\\$ASM$ 卡表示调用汇编程序；$\\$LOAD$ 卡表示调用装配程序；$\\$DATA$ 卡指定数据；$\\$RUN$ 卡执行用户程序；$\\$END$ 卡表示一个作业结束。管理程序通过输入、解释并执行嵌入用户作业的作业控制卡规定的功能，就能自动地处理用户作业流。每个作业完成后，管理程序又自动地从输入机上读取下一个作业运行，直到整批作业处理结束。 - 提供一套操作命令。操作员通过打字机输入命令，管理程序识别并执行命令，这样不仅速度快，操作员还可进行一些复杂的控制。输出信息也可由打字机输出，代替了早期的氖灯显示，易于理解。这种交互方式不仅提高了效率，也便于使用 - 提供设备驱动和 I/O 控制功能。系统提供标准 I/O 程序，用户通过管理程序获得和使用 I/O 设备，减轻了用户驱动物理设备的负担。管理程序还能处理某些特殊设备和设备故障，改进了设备的可靠性和可用性。 - 提供库程序和程序装配功能。库程序包括：汇编程序、FORTRAN 语言编译程序、标准 I/O 程序、标准子程序等。通常，用户程序必须调用库程序才能执行下去，装配工作由管理程序完成。所有程序都按相对地址编址，管理程序把相应库程序和用户程序进行装配，并转换成绝对地址形式的目标程序，以便执行。 - 提供简单的文件管理功能。用户通过输入设备输入程序和数据，为了反复使用，用户希望能把这些信息保存起来，以便随时使用，这就产生了文件系统。从此，用户可按文件名字，而不是信息的物理地址进行存取，方便灵活，安全可靠。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"多道程序设计与操作系统的形成 多道程序设计 在早期的单道批处理系统中，内存中仅有单个作业在运行，致使系统中仍有许多资源空闲，设备利用率低，系统性能较差。 单道算题运行时处理器的使用效率 当 CPU 工作时，外部设备不能工作；而外部设备工作时，CPU 必须等待。 20 世纪 60 年代初，有两项技术取得了突破：中断和通道，这两种技术结合起来为实现 CPU 和 I/O 设备的并行工作提供了基础，这时，多道程序的概念才变成了现实。 多道程序设计是指允许多个程序(作业)同时进入一个计算机系统的内存储器并启动进行交替计算的方法。也就是说，计算机内存中同时存放了多道（二个以上相互独立的）程序，它们均处于开始和结束点之间。从宏观上看是并行的，多道程序都处于运行过程中，但都未运行结束；从微观上看是串行的，各道程序轮流占用 CPU，交替地执行。引入多道程序设计技术的根本目的是提高 CPU 的利用率，充分发挥计算机系统部件的并行性，现代计算机系统都采用了多道程序设计技术。 操作系统的形成 第三代计算机的性能有了更大提高，机器速度更快，内外存容量增大，I/O 设备数量和种类增多，为软件的发展提供了有力支持。如何更好地发挥硬件功效，如何更好地满足各种应用的需要，这些都迫切要求扩充管理程序的功能。 中断技术 和 通道技术 的出现使得硬部件具有了较强的并行工作能力，从理论上来说，实现多道程序系统已无问题。但是，从半自动的管理程序方式过渡到能够自动控制程序执行的操作系统方式，对辅助存储器性能的要求增高。这个阶段虽然有个别的磁带操作系统出现，但操作系统的真正形成还期待着大容量高速辅助存储器的出现。 大约到 60 年代中期以后，随着磁盘的问世，相继出现了多道批处理操作系统和分时操作系统、实时操作系统，到这个时候标志着操作系统正式形成。 计算机配置操作系统后，其资源管理水平和操作自动化程度有了进一步提高，具体表现在： 操作系统实现了计算机操作过程的自动化。批处理方式更为完善和方便，作业控制语言有了进一步发展，为优化调度和管理控制提供了新手段 资源管理水平有了提高，实现了外围设备的联机同时操作, 进一步提高了计算机资源的利用率 提供虚存管理功能，由于多个用户作业同时在内存中运行，在硬件设施的支持下，操作系统为多个用户作业提供了存储分配、共享、保护和扩充的功能，导致操作系统步入实用化 支持分时操作，多个用户通过终端可以同时联机地与一个计算机系统交互 文件管理功能有改进，数据库系统开始出现 多道程序设计趋于完善，采用复杂的调度算法，充分利用各类资源，最大限度地提高计算机系统效率 操作系统的发展和分类 促使操作系统不断发展的主要动力有以下五个方面： 器件快速更新换代：CPU 性能快速提升 计算机体系结构不断发展：硬件的改进促使计算机技术的进步 提高计算机系统资源利用率的需要 让用户使用计算机越来越方便的需要 满足用户的新要求，提供给用户新服务 从操作系统形成以来，按照功能、特点和使用方式的不同，可把操作系统区分为三种基本类型： 批处理操作系统，特征如下： 用户脱机工作 成批处理作业 单/多个程序运行 分时操作系统，特征如下： 同时性。若干个终端用户同时联机使用计算机，分时就是指多个用户分享使用同一台计算机的 CPU 时间 独立性。终端用户彼此独立，互不干扰，每个终端用户感觉上好像他独占了这台计算机 及时性。终端用户的立即型请求（即不要求大量 CPU 时间处理的请求）能在足够快的时间之内得到响应（通常应该为 2 ~ 3 秒钟）。这一特性与计算机 CPU 的处理速度、分时系统中联机终端用户数目和时间片的长短密切相关 交互性。人机交互，联机工作，用户直接控制其程序的运行，便于程序的调试和排错。 分时操作系统和批处理操作系统虽然有共性，它们都基于多道程序设计技术，但存在下列不同点： 追求的目标不同。批处理系统以提高系统资源利用率和作业吞吐率为目标；分时系统则要满足多个联机用户立即型命令的快速响应。 适应的作业不同。批处理适应已经调试好的大型作业；而分时系统适应正在调试的小作业。 资源的利用率不同。批处理操作系统可合理安排不同负载的作业，使各种资源利用率较佳；分时操作系统中，多个终端作业使用相同类型编译系统、运行系统和公共子程序时，系统调用它们的开销较小。 作业控制的方式不同。批处理由用户通过 JCL 的语句书写作业控制流，预先提交，脱机工作；交互型作业，由用户从键盘输入操作命令控制，交互方式，联机工作。 实时操作系统；目前有三种典型的实时系统，过程控制系统、信息查询系统和事务处理系统。 微机操作系统；供个人使用 并行操作系统；计算机的应用经历了从数据处理到信息处理，从信息处理到知识处理，每前进一步都要求增加计算机的处理能力。 网络操作系统；计算机网络是通过通信设施将地理上分散的并具有自治功能的多个计算机系统互连起来的系统 分布式操作系统 操作系统提供的服务和用户接口 操作系统提供的基本服务 操作系统要为用户程序的执行提供一个良好的运行环境，它要为程序及其用户提供各种服务，当然不同的操作系统提供的服务不完全相同，但有许多共同点。 提供操作系统共性服务为程序员带来了方便，使编程任务变得更加容易，操作系统提供给程序和用户的共性服务大致有： 创建程序。提供各种工具和服务，程序的编辑工具和调试工具，帮助用户编程并生成高质量的源程序等服务 执行程序。将用户程序和数据装入主存，为其运行做好一切准备工作并启动和执行程序。当程序编译或运行出现异常时，应能报告发生的情况，终止程序执行或进行适当处理 数据I/O 信息存取。文件系统让用户按文件名来建立、读写、修改以及删除文件，使用方便，安全可靠。当涉及多用户访问或共享文件时，操作系统将提供信息保护机制 通信服务。在许多情况下，一个进程要与另外的进程交换信息，这种通信一般分为两种情况，一是在同一台计算机上执行的进程之间通信；二是在被网络连接在一起的不同计算机上执行的进程之间通信 错误检测和处理。操作系统能捕捉和处理各种硬件或软件造成的差错或异常，并让这些差错或异常造成的影响缩小在最小范围内，必要时及时报告给操作员或用户。 此外，操作系统除上述提供给用户的服务外，还具有另外一些功能，以保证它自身高效率、高质量地工作，从而，使得多个用户程序能够有效地共享系统资源，提高系统效率，这些功能有： 资源分配 统计 保护 操作系统提供的用户接口 操作系统可以通过程序接口和操作接口两种方式把它的服务和功能提供给用户，反过来也可以这样说，用户可以通过两个接口来调用操作系统提供的服务和功能 用户和操作系统间的两种接口 程序接口与系统调用 系统调用 系统调用的实现要点 系统调用与过程（函数）调用的区别 程序中执行系统调用或过程（函数）调用，虽然都是对某种功能或服务的需求，但两者从调用形式到具体实现都有很大区别。 调用形式不同。过程（函数）使用一般调用指令，其转向地址是固定不变的，包含在跳转语句中，但系统调用中不包含处理程序入口，而仅仅提供功能号，按功能号调用 被调用代码的位置不同。过程（函数）调用是一种静态调用，调用程序和被调用代码在同一程序内，经过连接编辑后作为目标代码的一部份。当过程（函数）升级或修改时，必须重新编译连接。而系统调用是一种动态调用，系统调用的处理代码在调用程序之外（在操作系统中），这样一来，系统调用处理代码升级或修改时，与调用程序无关。而且，调用程序的长度也大大缩短，减少了调用程序占用的存储空间。 提供方式不同。过程（函数）往往由编译系统提供，不同编译系统提供的过程（函数）可以不同；系统调用由操作系统提供，一旦操作系统设计好，系统调用的功能、种类与数量便固定不变了。 调用的实现不同。程序使用一般机器指令（跳转指令）来调用过程（函数），是在用户态运行的；程序执行系统调用，是通过中断机构来实现，需要从用户态转变到核心态，在管理状态执行。因此程序执行系统调用安全性好 Linux 的系统调用 每个系统调用由两部分组成： 核心函数：是实现系统调用功能的（内核）代码，它运行在核心态，数据也存放在内核空间，通常它不能再使用系统调用，也不能使用应用程序可用的库函数。 接口函数：是提供给应用程序的 API，以库函数形式存在，该库中存放了所有系统调用的接口函数的目标代码，用汇编语言书写。其主要功能是把系统调用号、入口参数地址传送给相应的核心函数，并使用户态下运行的应用程序陷入核心态（Linux内核陷入由 0X80 中断实现，调用流程：1. 取系统调用号，检验合法性；2. 建立调用堆栈，保护现场信息；3. 根据系统调用号定位核心函数地址；4. 根据通用寄存器内容，从用户栈中取入口参数；5. 核心函数执行，把结果返回应用程序； 6. 执行退栈操作，判别调度程序 scheduler 是否要被执行）。 操作接口与系统程序 作业控制方式 命令解释程序 系统程序 操作系统的结构设计 操作系统的构件 内核 进程 线程 管程 类程 整体式结构的操作系统 层次式结构的操作系统 虚拟机结构的操作系统 客户/服务器与微内核结构的操作系统 客户/服务器与微内核结构 微内核的设计 操作系统的运行模型 非进程内核模型 OS 功能（函数）在用户进程内执行的模型 OS 功能（函数）作为独立进程执行的模型 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"总结 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:4","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"处理器管理 处理器管理是操作系统的重要组成部分，它负责管理、调度和分派计算机系统的重要资源———处理器，并控制程序的执行。由于处理器管理是操作系统中最核心的组成部分，任何程序的执行都必须真正占有处理器，因此，处理器管理直接影响系统的性能。 操作系统的基本任务是对“进程”实施管理，操作系统必须有效控制进程的执行、给进程分配资源、允许进程之间共享和交换信息、保护每个进程在运行期间免受其他进程干扰、控制进程的互斥、同步和通信。为达到这些要求，操作系统的处理器管理必须为每一个进程维护一个数据结构，用以描述该进程的状态和分配到的资源，并允许操作系统行使对进程的控制权。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:4:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中央处理器 计算机系统的核心是中央处理器。如果一个计算机系统只包括一个运算处理器，称之为单处理器系统。如果有多个运算处理器，则称之为多处理器系统。 早期的计算机系统是基于单个处理器的顺序处理机器，每一条指令的执行也是串行的，为提高计算机处理的速度，首先发展起来的是联想存储器系统和流水线系统，前者提出了数据驱动的思想，后者解决了指令并行执行的问题，这两者都是最初计算机并行化发展的例子。 随着硬件技术的进步，并行处理技术得到了迅猛的发展，计算机系统不再局限于单处理器和单数据流，各种各样的并行结构得到了应用。 目前计算机系统可以分作以下四类： 单指令流单数据流（SISD）。一个处理器在一个存储器中的数据上执行单条指令流。 单指令流多数据流（SIMD）。单条指令流控制多个处理单元同时执行，每个处理单元包括处理器和相关的数据存储，一条指令事实上控制了不同的处理器对不同的数据进行了操作。向量机和阵列机是这类计算机系统的代表。 多指令流单数据流（MISD）。一个数据流被传送给一组处理器，通过这一组处理器上的不同指令操作最终得到处理结果 多指令流多数据流（MIMD）。多个处理器对各自不同的数据集同时执行不同的指令流。可以把 MIMD 系统划分为共享内存的紧密耦合 MIMD 系统和内存分布的松散耦合 MIMD 系统两大类。 根据处理器分配策略，紧密耦合 MIMD 系统可以分为主从式系统 MSP 和对称式系统 SMP 两类。 主从式系统的基本思想是：在一个特别的处理器上运行操作系统内核，其他处理器上则运行用户程序和操作系统例行程序，内核负责分配和调度各个处理器，并向其他程序提供各种服务（如输入输出）。这种方式实现简单，但是主处理器的崩溃会导致整个系统的崩溃，并且极可能在主处理器形成性能瓶颈。 在对称式多处理器系统中有两个或两个以上的处理器，操作系统内核可以运行在任意一个处理器上。每个处理器都可以自我调度运行的进程和线程，单个进程的多个线程可在不同处理器上同时运行，服务器进程可以使用多个线程去处理同时来自多个客户的请求，并且操作系统内核也被设计成多进程或多线程，内核的各个部分可以并行执行。 对称多处理器是迄今为止开发出的最为成功的两种并行机之一，有一种 SMP 机最多可支持 64 个处理器，多个处理器之间采用共享主存储器。SMP 机有对称性、单一地址空间、低通信延迟和一致的高速缓存等特点，具有高可靠性、可扩充性、易伸缩性。这一系统中任何处理器都可以访问任何存储单元及 I/O 设备；处理器之间通信代价很低，而并行度较高。 由于共享存储器中只要保存一个操作系统和数据库副本，既有利于动态负载平衡，又有利于保证数据的完整性和一致性。 在松散耦合 MIMD 系统中，每个处理单元都有一个独立的内存储器，各个处理单元之间通过设定的线路或网络通信，多计算机系统和集群系统都是松散耦合 MIMD 系统的例子。 集群系统是迄今为止开发出的另一种最为成功的并行机，它是一组互联的计算机系统。因此也是分布式系统的一种，集群操作系统也是分布式操作系统的一个品种。集群系统运行时构成统一的计算资源，给人以一台机器的感觉。集群系统的配置一般有两种方法，一是各个节点计算机自带磁盘，二是多个节点计算机共享 RAID 磁盘。 在集群系统中，每一台计算机都是一个完整的节点，离开集群后自己可以独立地工作，所以一个节点的失效并不意味着服务的失败，从而使集群系统具备很好的容错性。集群系统还具有很好的可伸缩性，可以用低成本的微机和以太网设备等产品构成。 寄存器 计算机系统的处理器包括一组寄存器，其个数根据机型（处理器型号）的不同而不同，它们构成了一级存储，虽然比主存储器容量要小的多，但是访问速度要快的多。这组寄存器所存储的信息与程序的执行有很大的关系，构成了处理器现场。 不同类型的处理器具有不同的寄存器组成。一般来说，这些寄存器可以分为以下几类： 通用寄存器。可由程序设计者指定许多功能，如存放操作数或用作寻址寄存器。 数据寄存器。用以存放操作数。它们作为内存数据的高速缓存，可以被系统程序和用户程序直接使用并进行计算。 地址寄存器。用于指明内存地址，如索引寄存器、段寄存器（基址/限长）、堆栈指针寄存器等。 I/O 地址寄存器。用于指定 I/O 设备 I/O 缓冲寄存器。用于处理器和 I/O 设备交换数据 控制寄存器。用于存放处理器的控制和状态信息，它至少应该包括程序计数器 PC 和指令寄存器 IR，中断寄存器以及用于存储器和 I/O 模块控制的寄存器。此外还有存放将被访问的存储单元地址的存储器地址寄存器，以及存放从存储器读出或欲写入的数据的存储器数据寄存器。 特权指令与非特权指令 计算机的基本功能是执行程序，而最终被执行的程序是存储在内存中的机器指令。处理器根据程序计数器（PC）内存中取一条指令到指令寄存器（IR）并执行它，PC 将自动地增长或改变为转移地址以指明下一条要执行的指令的入口地址。 每台计算机的机器指令的集合称指令系统，它反映了一台机器的功能和处理能力，可以分为以下五类： 数据处理类指令：用于执行算术和逻辑运算 转移类指令：如无条件转移、条件转移、计数转移等用于改变指令执行序列 数据传送类指令：用于在处理器的寄存器和寄存器、寄存器和存储器单元、存储器单元和存储器之间交换数据 移位与字符串指令，移位分算术、逻辑和循环移位。字符串处理有字符串的传送、比较、查询和转换。 I/O类指令：用于启动外围设备，让主存和外围设备之间交换数据 引入操作系统后，操作系统核心程序可以使用全部机器指令，但用户程序只能使用机器指令系统的一个子集。这是因为，用户程序执行一些有关资源管理的机器指令时很容易导致系统混乱，造成系统或用户信息的破坏。 因此，在多道程序设计环境中，从资源管理和控制程序执行的角度出发，必须把指令系统中的指令分作两类：特权指令和非特权指令。 所谓特权指令是指那些只能提供给操作系统的核心程序使用的指令，如启动输入 % 输出设备、设置时钟、控制中断屏蔽位、清内存、建立存储键，加载 PSW 等。只有操作系统才能执行全部指令（特权指令和非特权指令），如果一般用户执行特权指令，会导致非法执行而产生保护中断，转交给操作系统的“用户非法执行特权指令”的特殊处理程序处理。 处理器状态 那么，中央处理器怎么知道当前是操作系统还是一般用户在其上运行呢？这将依赖于处理器状态的标志。在执行不同程序时，根据执行程序对资源和机器指令的使用权限把处理器设置成不同状态。 处理器状态又称为处理器的运行模式，有些系统把处理器状态划分为核心状态、管理状态和用户状态，而大多数系统把处理器状态简单划分为管理状态（又称特权状态、系统模式、特态或管态）和用户状态（又称目标状态、用户模式、常态或目态）。 当处理器处于管理状态时，程序可以执行全部指令，访问所有资源，并具有改变处理器状态的能力；当处理器处于用户状态时，程序只能执行非特权指令。 Intel 奔腾处理器由四种状态，支持 4 个特权级别，0 级权限最高，3 级权限最低。 0 级为操作系统内核级。处理 I/O 、存储管理和其他关键操作。 1 级为系统调用处理程序级。用户程序可以通过调用这里的过程执行系统调用，但是只有一些特定的和受保护的过程可以被调用。 2 级为共享库过程级。它可以被很多正在运行的程序共享，用户程序可以调用这些过程，读取它们的数据，但是不能修改它们。 3 级为用户程序级。它受到的保护最少。 当然，各个操作系统在实现过程中可以根据具体策略有选择地使用硬件提供的保护级别，如运行在 奔腾 上的 windows 操作系统只使用了 0 级 和 3 级。 下面两类情况会导致从用户态向管理状态转换 程序请求操作系统服务，执行一条系统调用 程序运行时，产生了一个中断事件，运行程序被中断，让中断处理程序工作 这两类情况都是通过中断机构才发生的，可以说中断是目态到管态转换的惟一途径。当系统中断响应交换程序状态字时，这个处理中断事件的处理程序的程序状态字的处理器状态位标志一定为“管态”。怎样实现管态到目态的转换呢？每台计算机通常会提供一条特权指令称作加载程序状态字 LPSW (Load PSW)，用来实现操作系统向用户程序的转换。 程序状态字寄存器 操作系统通过引入程序状态字 PSW (Program Status Word) 来区别不同的处理器工作状态。 ，程序状态字用来指示处理器状态、控制指令的执行顺序并且保留和指示与运行程序有关的各种信息，其主要作用是方便地实现程序状态的保护和恢复。每个正在执行的程序都有一个与其执行相关的 PSW ，而每个处理器都设置一个程序状态字寄存器。 一个程序占有处理器执行，它的 PSW 将占有程序状态字寄存器。 一般来说，程序状态字寄存器包括以下几类内容： 程序基本状态。包括： 程序计数器：指明下一条执行的指令地址； 条件码：表示指令执行的结果状态； 处理器状态位：指明当前的处理器状态，如目态或管态、运行或等待。 中断码。保存程序执行时当前发生的中断事件。 中断屏蔽位。指明程序执行中发生中断事件时，是否响应出现的中断事件。 由于不同处理器中的控制寄存器组织方式不同，所以在大多数计算机的处理器现场中可能找不到一个称为程序状态字寄存器的具体寄存器，但总是有一组控制与状态寄存器实际上起到这一作用。 在 Intel 奔腾中，程序状态字由标志寄存器 EFLAGS 和指令指针寄存器 EIP 组成，均为 32 位。EFLAGS 的低 16 位称 FLAGS，可当作一个单元来处理。标志可划分为三组：状态标志、控制标志、系统标志。 状态标志：它使得一条指令的执行结果影响后面的指令。算术运算指令使用 OF","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:4:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断技术 现代计算机中都配置了硬件中断装置，中断机制是操作系统的重要组成部分之一。 每当用户程序执行系统调用以求获得系统的服务和帮助、或操作系统管理 I/O 设备和处理形形色色的内部和外部事件时，都需要通过中断机制进行处理。所以，也有人说操作系统是由 “中断驱动” 的。 中断是指程序执行过程中，当发生某个事件时，中止 CPU 上现行程序的运行，引出处理该事件的服务程序执行的过程。 在提供中断装置的计算机系统中，在每两条指令或某些特殊指令执行期间都检查是否有中断事件发生，若无则立即执行下一条或继续执行，否则响应该事件并转去处理中断事件。 中断这种处理突发事件的能力是由硬件和软件协作完成的。首先，由硬件的中断装置发现产生的中断事件，然后，中断装置中止现行程序的执行，引出处理该事件的程序来处理。 计算机系统不仅可以处理由于硬件或软件错误而产生的事件，而且可以处理某种预见要发生的事件。例如，外围设备工作结束时，也发出中断请求，向系统报告它已完成任务，系统根据具体情况做出相应处理。 引起中断的事件称为中断源。发现中断源并产生中断的硬件称中断装置。在不同的硬件结构中，通常有不同的中断源和不同的中断装置，但它们有一个共性，即当中断事件发生后，中断装置能改变处理器内操作执行的顺序，可见中断是现代操作系统实现并发性的基础之一。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:5:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断源分类 从中断事件的性质和激活的手段来说，可以分成强迫性中断事件和自愿性中断事件两大类。 强迫性中断事件不是正在运行的程序所期待的，而是由于随机发生的某种事故或外部请求信息所引起的。这类中断事件大致有以下几种： 机器故障中断事件。例如电源故障、主存储器出错等 程序性中断事件。例如定点溢出、除数为0、地址越界等。由于这类中断反映程序执行中发现的例外情况，所以又称异常 外部中断事件。例如时钟的定时中断、控制台发控制信息等 输入输出中断事件。例如设备出错、传输结束等 自愿性中断事件是正在运行的程序所期待的事件。这种事件是由于执行了一条访管指令而引起的，它表示正在运行的程序对操作系统有某种需求，一旦机器执行到一条访管指令时，便自愿停止现行程序的执行而转入访管中断处理程序处理。例如，要求操作系统协助启动外围设备工作。 两类中断事件的响应过程略有不同，详见图： 两类中断事件 还可以按照中断信号的来源，把中断分为外中断和内中断两类： 外中断。一般又称中断，是指来自处理器和主存储器之外的中断，包括电源故障中断、时钟中断、控制台中断、它机中断和 I/O 中断等。每个不同的中断具有不同的中断优先级，在处理高一级中断时，往往会屏蔽部分或全部低级中断。 内中断。是指来自处理器和主存内部的中断，一般又称异常，包括通路校验错、主存奇偶错、非法操作码、地址越界、页面失效、调试指令、访管中断、算术操作溢出等各种程序性中断。其中访管中断是由机器指令提供的特殊指令，该指令执行时将会引起内中断。异常是不能被屏蔽的，一旦出现应立即响应并加以处理。 中断和异常的区别如下： 中断：中断是由与现行指令无关的中断信号触发的，所以它是异步的，而且中断的发生与 CPU 处在用户模式或内核模式无关，通常在两条机器指令之间才可以响应中断，一般来说，中断处理程序提供的服务不是为当前进程所需要的，如时钟中断、硬盘读写服务请求中断 异常：异常则是由处理器正在执行现行指令而引起的。因而一条指令执行期间允许响应陷入。通常，异常处理程序提供的服务是为当前进程所用的。异常包括很多方面，有出错，也有陷入。出错和陷入的主要一点区别是：它们发生时保存的返回指令地址不同，出错保存指向触发异常的那条指令，而陷入保存指向触发异常的那条指令的下一条指令。因此，当从异常返回时，出错会重新执行那条指令，而陷入就不会重新执行那条指令。 上述的内中断与外中断（中断和异常）要通过硬件设施来产生中断请求，可以看作硬中断。与其相对应的不必由硬件发信号而能引发的一种中断称为软中断，软中断是利用硬件中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。它通常是由内核或进程对某个进程发出的中断信号，可以看作内核与进程或进程与进程之间用来模拟硬中断的一种信号通信方式。 软中断和硬中断两者的共同点是：当中断源产生中断请求或发出软中断信号后，CPU 或者接收进程在适当的时机自动进行中断处理或完成软中断信号所对应的功能。这里所说适当时机表示接收的硬中断会及时获得中断处理程序的处理，但接收软中断信号的进程不一定正好在接到此信号时占有处理器，而相应的软中断信号处理必需等到该接收进程获得处理器后才能进行，通常会有一定时间的延迟。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断装置 发现中断源并产生中断的硬件称中断装置，这些硬件包括中断逻辑线路和中断寄存器。 迄今为止，所有的计算机系统都采用硬件和软件（硬件中断装置和软件中断处理程序）结合的方法实现中断处理。 一般来说，硬件中断装置主要做以下三件事： 发现中断源，响应中断请求。当发现多个中断源时，它将根据规定的优先级，先后发出中断请求。 保护现场。将运行程序中断点在处理器中某些寄存器内的现场信息（又称运行程序的执行上下文）存放于内存储器。使得中断处理程序运行时，不会破坏被中断程序的有用信息，以便在中断处理结束后能够返回被中断程序继续运行。 启动处理中断事件的中断处理程序，处理器状态已从目态被切换到管态。 中断来源于正在执行的程序以及计算机系统的各个部件，甚至计算机的外部环境。当一个具体的中断事件发生时，计算机的硬件中断装置必须把它记录下来。中断寄存器是用来记录中断事件的寄存器，中断寄存器的内容称中断字，中断字的每一位对应一个中断事件。每当一条机器指令执行结束的时刻，中断控制部件扫描中断字，查看是否有中断事件发生，若是则处理器便响应这个中断请求。 当中断发生后，中断字的相应位会被置位。由于同一时刻可能有多个中断事件发生，中断装置将根据中断屏蔽要求和中断优先级选取一个，然后把中断寄存器的内容送入程序状态字寄存器的中断码字段，且把中断寄存器的相应位清“0”当处理中断事件的程序执行时就可以读出中断信息进行分析，从而知道发生了什么中断事件。 紧接着中断装置进行必要的保护现场工作。此时并不一定要将处理器中所有寄存器中的信息全部存于（写回）存储器中，但是，对程序状态字寄存器中的那些信息一定要保护起来。最后，将中断处理程序的程序状态字送入现行程序状态字寄存器，这就引出了相应的中断事件处理程序。 IBM中大型机中断响应过程 如果把被中断的程序的程序状态字称为旧程序状态字，而把中断处理程序的程序状态字称为新程序状态字的话，如何来实现新旧程序状态字的交换呢？通常，系统为每一种中断都开辟了主存的固定单元存放新的和旧的程序状态字。 下图是 IBM 中大型机中断响应过程，主存中开辟了专用的双字单元（用16进制标出），用于存放各类中断的旧的和新的 PSW（分别为旧的和新的外中断、访管中断、程序中断、机器故障中断和 I/O 中断），CPU 中还有硬件程序状态字寄存器保存运行程序的现行 PSW。 IBM PC 中断的响应过程 当响应中断时，由硬件执行 1 把中断码装配到现行 PSW 中，然后，执行 2 把现行 PSW 保存到中断类相应的旧 PSW 单元；同时，执行 3 把中断类相应的新 PSW 加载到现行 PSW ，这就引出了相应中断类的中断处理程序。中断事件处理结束后，如果执行 4 便可从断点返回继续执行被中断的程序。 在 IBM PC 机上，为了方便地找到中断处理程序，通常在计算机内存的低地址处开辟了一个称为中断向量表的区域。表中每一项称为一个中断向量，其中存放了一个中断处理程序的入口地址及相关信息，不同中断源需要用不同的中断处理程序处理，也就对应了不同的中断向量。 另外，采用堆栈方式保存被中断程序的状态信息，当发现中断源并响应中断时，中断装置将把现行 PSW 内容压进堆栈，接着再把指令指针 IP 和代码段基地址内容也压进堆栈，这就保存了原运行程序的状态。处理器根据硬件中断装置提供的中断向量号，获得被接受的中断请求的中断向量地址，再按照中断向量地址把中断处理程序的 PSW 送入现行程序状态字寄存器，加载新的程序状态字。从而，就引出了处理特定中断事件的中断处理程序。返回原程序时，只要把栈顶内容弹出送入现行 IP、CS和PSW中。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断处理程序 处理中断事件的程序称为中断处理程序。它的主要任务是处理中断事件和恢复正常操作。由于不同中断源对应不同中断处理程序，故快速找到中断处理程序的入口地址是一个关键问题。寻找入口地址可用如下办法：在主存储器(常在低地址区)设置一张向量地址表，存储单元的地址对应向量地址，存储单元的内容为入口地址。CPU 响应中断后，根据预先规定的次序找到相应向量地址，便可获得该中断事件处理程序的入口地址。 一个操作系统设计者将根据中断的不同类型和不同的应用环境，来确定不同的处理原则。 具体地讲，一个中断处理程序主要做以下四项工作： 保护未被硬件保护的一些必需的处理状态。例如，将通用寄存器的内容保存到主存储器，从而使中断处理程序在运行中可以使用通用寄存器 识别各个中断源，分析产生中断的原因。 处理发生的中断事件。中断处理程序将根据不同的中断源，进行各种处理操作。有简单的操作，如置一个特征标志；也有相当复杂的操作，如重新启动磁带机倒带并执行重读操作。 恢复正常操作。恢复正常操作一般有几种情况：恢复中断前的程序按断点执行；重新启动一个新的程序或者甚至重新启动操作系统。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断事件的具体处理方案 机器故障中断事件的处理 一般来说，这种事件是由硬件的故障产生的，排除这种故障必须进行人工干预。中断处理能做的工作一般是保护现场，防止故障蔓延，报告给操作员并提供故障信息以便维修和校正，以及对程序中所造成的破坏进行估价和恢复。下面列举一些硬件失效中断事件的处理办法。 电源故障的处理 当电源发生故障，例如断电时，硬设备能保证继续正常工作一段时间。操作系统利用这段时间可以做以下三项工作： 将处理器中有关寄存器内的信息经主存储器送到磁盘保存起来，以便在故障排除后恢复现场，继续工作。 停止外围设备工作。有些外围设备（例如磁带机）不能立即停止，中断处理程序将把这些正在交换信息又不能立即停止的设备记录下来。 停止处理器工作。一般可以让主机处于停机状态，此时，整个系统既不执行指令又不响应中断。 当故障排除后，操作员可以从一个约定点启动操作系统以恢复工作。恢复程序做的主要工作是： 恢复中断前的有关现场 启动被停止的外围设备继续工作 如果发生故障时有不能立即停止的外围设备正在工作，那么，涉及这些外围设备的程序将被停止执行而等待操作员的干预命令 完成上述各项工作后，系统将选择可以运行的程序继续运行 主存储器故障的处理 主存储器的奇偶校验或海明校验装置发现主存储器读写错误时，就产生这种中断事件。中断处理程序首先停止与出现的中断事件有关的程序的运行。然后向操作员报告出错单元的地址和错误的性质。 程序性中断事件的处理 处理程序性中断事件大体上有两种办法。 对于那些纯属程序错误而又难以克服的事件，例如非法使用特权指令，企图访问一个不允许其使用的主存储器单元等，操作系统只能将出错程序的名字、出错地点和错误性质报告给操作员并请求干预。 对于其他一些程序性中断，例如定点溢出、阶码下溢等，不同的用户往往有不同的处理要求。所以，操作系统可以将这种程序性中断事件转交给用户程序自行处理。 如果用户程序对发生的中断事件没有提出处理办法，那么操作系统将进行标准处理。 用户怎样来编制处理中断事件的程序呢？有些语言提供了称之为 on 语句的调试语句，它的形式如下： on \u003c条件\u003e \u003c中断续元入口\u003e 比如： // 每当发生定点溢出时，转向以 LA 为标号的语句 on fixed overflow go to LA; // 对于发生在不同地方的同一种程序性中断事件允许用户采用不同的处理方法。 // 例如，在执行了上述调试语句后又执行调试语句： on fixed overflow go to LB; // 就表示今后再发生溢出时将转向 LB 而不是转向 LA 去处理了 有了调试语句后，用户用程序设计语言编制程序时，也就可以编写处理程序性中断事件的程序了。编译程序为每个用户设置一张中断续元入口表，且在编译源程序产生目标程序时，把调试语句翻译成一段程序。其功能是：将中断续元入口地址送入中断续元入口表中对应该语句的中断条件的那一栏。中断续元入口表的形式如图: 中断续元入口 对应每一个用户处理的中断事件，表格中有一栏用以填写处理该中断事件的中断续元入口地址。如果用户没有给出处理其中断事件的中断续元时，相应栏的内容为0。当程序运行执行到调试语句时，就将中断续元的入口地址送入相应栏内。 显然，对于同一中断事件，当执行第二次对应该事件的调试语句时，就将第二次规定的中断续元入口地址填入表内相应栏中而冲去了第一次填写的内容。这就是上面所说的，利用对同一条件多次使用调试语句时，可以做到对发生于不同地点的同一种中断事件采用不同的处理方法。 当发生程序中断事件后，操作系统是怎样转交给用户程序去处理的呢？操作系统只要根据中断事件查看表中对应栏，如果对应栏为“0”它表示用户未定义该类中断续元，此时系统将按规定的标准办法进行处理。例如，将程序停止下来，向操作员报告出错位置和性质，或者置之不顾，就好像什么事也没有发生一样。如果对应栏不为“0”，则强迫用户程序转向中断续元去处理。 如果在中断续元的执行中又发生中断事件时，就不能这样简单地处理了。首先，中断续元的嵌套一般应规定重数，在上面的表格中规定嵌套重数为2。表格第一栏的第 0 字节记录了第一次进入中断续元的事件号；第 1 个字节记录了第二次（嵌套）进入中断续元的事件号。其次，中断续元的嵌套不能递归，例如，处理定点溢出的中断续元，在执行时不允许又发生定点溢出程序性中断事件。 下面按步骤小结一下中断续元的处理过程和原则： 编译程序编译到 on 语句时，生成填写相应中断续元入口表的目标代码段； 程序运行执行到 on 语句时，根据中断条件号，将中断续元入口填入相应栏，这是通过执行上述代码段来实现的； 执行同一中断条件号的 on 语句时，中断续元入口被填入同一栏，从而，用户可在他的程序的不同部分对同一中断条件采用不同的处理方法； 每当一个中断条件发生时，检查中断续元入口表相应栏，或转入中断续元处理，或进行操作系统标准处理； 程序性中断处理允许嵌套，应预先规定嵌套重数，但不允许递归。 外部中断事件的处理 时钟定时中断以及来自控制台的信息都属外部中断事件，它们的处理原则如下： 时钟中断事件的处理 时钟是操作系统进行调度工作的重要工具，如让分时进程作时间片轮转、让实时进程定时发出或接收控制信号、系统定时唤醒或阻塞一个进程、对用户进程进行记账。 时钟可以分成绝对时钟和间隔时钟（即闹钟）两种。利用计时器能确保操作系统必要时获得控制权，例如，陷入死循环的进程最终因时间片耗尽会被迫出让处理器。 系统设置一个绝对时钟寄存器，计算机的绝对时钟定时地（例如每 10 ms）把该寄存器的内容加 1。如果开始时这个寄存器的内容为 0，那么，只要操作员告诉系统开机时的年、月、日、时、分、秒，以后就可推算出当前的年、月、日、时、分、秒了。当绝对时钟寄存器记满溢出时，就产生一次绝对时钟中断，操作系统处理这个中断时，只要在主存的固定单元上加 1 就行了。这个固定单元记录了绝对时钟中断的次数，这样就可保证有足够的计时量。计算当前时间时，只要按绝对时钟中断的次数和绝对时钟寄存器的内容推算就可得到。 间隔时钟是定时将一个间隔时钟寄存器的内容减 1，当间隔时钟寄存器的内容为 0 时，就产生一个间隔时钟中断。所以，只要在间隔时钟寄存器中放一个预定的值，那么就可起到闹钟的作用，每当产生一个间隔时钟中断，就意味着预定的时间到了。操作系统经常利用间隔时钟作控制调度。 时钟硬件做的工作仅仅是按已知时间间隔产生中断，其余与时间有关的任务必须由软件来做，不同的操作系统有关时钟的任务不同，但一般包括以下内容： 维护绝对日期和时间 防止进程的运行时间超出其允许值，发现陷入死循环的进程 对使用 CPU 的用户进程记账 处理进程的间隔时钟（闹钟) 对系统的功能或部件提供监视定时器 在 Intel x86/奔腾 微机中，Linux利用 CMOS 中记录的时间作为系统启动时的基准时间，在系统运行时，利用时钟滴答来维护系统的时间。Linux 使用一个全局变量称 jiffies(瞬时)作为所有系统时间的测量基准，系统启动时，CMOS 中记录的时间转化为从 1970年1月1日0时0分0秒(UNIX纪元)算起的 jiffies 值(累积秒数)。操作系统中需要有定时服务的机制，以实现准时调度任务或处理与时间相关的工作，这些都是通过定时器机制来实现的。 Linux定时器机制 Linux 中存在两种类型的系统定时器，这两种定时器都具有对应的处理例程，必须在到达给定的系统时间时被进程调用，但实现方法有些不同。第一类是老的定时器机制，有一个 CA 个指针的数组定义的定时器。每个指针可指向一个 timer-struct 结构，而 timer-active 是活动定时器的掩码，数组元素是静态定义的，在系统初始化时入口被加到该数组中。第二类是新的定时器机制，突破了 32 个定时器的限制，使用一个 timer-list 数据结构的链表，按定时器到期时间的升序排列。两类定时器中 expires 给出该定时器被激活的时间，而 *fn() 指出定时器激活后的处理函数。 两类定时器都使用 jiffies 值作为到期比较时间。例如，某个定时器要在 2s 之后到期，则必须将 2s 转换成对应的 jiffies 值，加上当前的系统时间(也是以 jiffies 为单位)后，得到的便是该定时器到期的系统时间 expires。每次系统时钟滴答到来时，定时器 bottom half 处理过程被标记为活动状态，这样当调度程序下次运行时，定时器队列能获得处理。定时器 buttom half 处理过程要处理两种类型的系统定时器。对于老的系统定时器，检查 timer-active 中被置位的位掩码，以便确定活动的定时器。如果一个活动的定时器到期，便调用对应的定时器例程，timer-active 对应位被清除。对于新的系统定时器，检查链表中的 timer-list 数据结构。每个到期的定时器将被从链表中移出，对应的定时器例程被调用。新的定时器机制的优点是能传递参数 data 到定时器例程中。 有了上述定时器，Linux 就可以统计用户的记账信息，它记录进程的创建时间及进程在生命周期占用的 CPU 时间。每个时钟滴答到来时，核心都修改当前进程在内核态和用户态占用的时间，这些时间称为记账信息。对于不同的时间，Linux 运行了不同的间隔定时器，这些间隔定时器的类型有三种： real 这种间隔定时器按实际时间计时，不管进程处在何种模式下运行（包括进程被挂起时），计时总在进行，当定时到达时发送给进程一个 SIGALRM 信号 virtual 这种间隔定时器仅当进程在用户态下执行时才计时，当定时到达时发送","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["linux"],"content":"imx6ull emmc镜像制作 ","date":"2022-03-16","objectID":"/2022/03/0004-imx6ull%E7%83%A7%E5%86%99%E9%95%9C%E5%83%8F/:1:0","tags":["linux","imx6ull"],"title":"Imx6ull烧写镜像","uri":"/2022/03/0004-imx6ull%E7%83%A7%E5%86%99%E9%95%9C%E5%83%8F/"},{"categories":["linux"],"content":"什么是buildroot buildroot 是一个简单、高效、易用的工具，能够利用交叉编译生成嵌入式linux系统 ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:1:0","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"buildroot 项目 ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:2:0","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"拉取buildroot源码 https://github.com/imx6ull-pro/buildroot.git buildroot 配置编译选项 查询可用目标系统 make list-defconfigs 选定目标系统 make imx6ullevk_defconfig 打开配置菜单 make menuconfig # 或 make nconfig 查看帮助 make help ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:2:1","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"gvfs 介绍 gvfs 是 GNOME 用户空间虚拟文件系统的缩写，从 GLib 2.15.1 开始加入系统，主要是对 I/O 的一层抽象。gvfs 提供了一些模块，这些模块由使用 libgio 的 API 应用程序自动使用。也通过 fuse，允许不适用 gio 的应用程序可以访问 gvfs 文件系统。 访问虚拟文件系统的前提是挂载文件系统，gvfs 提供了一个守护进程——gvfsd来协调处理模块，每个模块都与 gvfsd 通过 gio 进行通信信。gvfs带有一些后端，这些后端实现了回收站、sftp、ftp、webdav、以及本地数据相关支持，都是作为 gvfs 功能实现的一部分。 gvfs 还包括用于 gio 实现卷监视器。 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:1:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfs守护进程说明 守护进程 功能 gvfsd 是gvfs主要守护程序。它通过org.gtk.vfs.Daemon名连接到dbus会话总线上，当gvfsd没有启动时候，可以通过gio客户端自动拉起gvfsd守护进程。gvfsd主要任务是充当模块的安装器和跟踪器。在需要的时候，它会产生新的后端，并跟踪它们的生命周期，维护已挂载的列表并创建与它们的直接连接。gvfsd还将启动gvfsd-fuse 并向其提供应在其中安装 fuse 文件系统的安装点 gvfsd-fuse gvfsd-fuse维护FUSE(用户空间的文件系统)挂载，以使gvfs后端可用于 POSIX 应用程序。fuse文件系统的挂载点由 [PATH] 参数提供。其主要由 gvfsd 启动 gvfsd-metadata gvfsd-metadata是一个守护进程，充当内部 gvfs 元数据存储的写入序列化程序。它是在 gio 客户端更改元数据时候自动启动。读取操作直接由客户端 gio 完成，并不需要运行守护程序 gvfs-goa-volume-monitor 支持 GNOME 在线账户 gvfs-gphoto2-volume-monitor 支持图片传输协议，如:gPhoto gvfs-mtp-volume-monitor 支持媒体传输协议 gvfs-udisks2-volume-monitor gvfs-udisks2-volume-monitor负责磁盘、介质、挂载和fstab桌面用户界面中显示的项目。特别的是gnome-shell以及使用 GLib API 的任何其它应用程序都在使用此过程中的信息。 请注意：不要把它与udisks软件包中的udisksd和udisksctl混淆 gvfs-afc-volume-monitor 苹果文件系统 gvfsd-afc 挂载IPhone/Ipod touch音量 gvfsd-afp 苹果文件协议卷 gvfsd-afp-browse 浏览apple归档协议卷 gvfsd-archive 挂载各种格式的归档文件 gvfsd-burn 提供刻录 CD 的位置 gvfsd-cdda 挂载音频 CD gvfsd-computer 提供计算机 computer:/// 支持 gvfsd-dav 挂载 DAV 文件系统 gvfsd-dnssd 浏览域名解析 gvfsd-ftp 挂载 FTP 文件系统 gvfsd-gphoto2 通过PTP挂载，这意味着gvfs通过libgphoto2通过 VFS 将相机上的照片显示给GNOME程序 gvfsd-http 通过 HTTP 挂载 gvfsd-localtest 测试后端 gvfsd-mtp 通过 mtp 挂载 gvfsd-network 提供 network:///支持 gvfsd-nfs 提供 nfs 协议支持 gvfsd-recent 提供最近访问支持 gvfsd-sftp 提供sftp支持 gvfsd-smb 提供samba支持 gvfsd-smb-browse 浏览windows共享文件系统的卷 gvfsd-trash 提供回收站支持 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:1:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd 代码模块功能梳理 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd 依赖文件及库分析 # 源码 daemon/main.c daemon/mount.c # 依赖库 gvfsddaemon gvfsd 代码梳理 解析命令行，是否使用 fuse、是否debug、是否仅仅打印版本信息 … 创建gvfs daemon g_vfs_daemon_new (TRUE, \u003creplace\u003e) gvfs_get_socket_dir()创建文件夹 监听 daemon 的 shutdown 信号 session dbus总线上注册，名字为：org.gtk.vfs.Daemon 如果需要 fuse 支持则启动 gvfsd-fuse 进程 session 上 dbus 注册成功就会调用 gboolean mount_init() gvfsd 结束执行 mount_finalize() g_vfs_daemon_new (TRUE, \u003creplace\u003e) g_vfs_daemon_new () 声明与定义位于daemon/gvfsdaemon.[hc]文件里 创建线程: g_thread_pool_new() 初始化互斥锁: g_mutex_init() 挂载数量初始化0、jobs初始化NULL、registered_paths(hash)、client_connections(hash)、session dbus的conn g_dbus_auth_observer_new() allow-mechanism authorize-authenticated-peer gvfs_dbus_daemon_skeleton_new() handle-get-connection handle-cancel handle-list-monitor-implementations gvfs_dbus_mountable_skeleton_new() handle-mount gboolean mount_init () gboolean mount_init ()声明与定义在daemon/mount.[hc]文件里 read_mountable_config () 获取环境变量 GVFS_MOUNTABLE_EXTENSION(默认是.mount文件)、GVFS_MOUNTABLE_DIR 读取 GVFS_MOUNTABLE_DIR 文件名需要有 .mount 后缀，文件夹是：/usr/share/gvfs/mounts/ /sys/fs/cgroup/ 解析 xxx.mount并保存到链表 mountables 全局变量 创建管道 pipe(reload_pipes) (其中 reload_pipes 是全局的static int reload_pipes[2];) 监控管道，当管道有数据读入就会重新执行第一步流程read_mountable_config () 获取SESSION bus 的实例 conn = g_bus_get_sync(SESSION, NULL, NULL) mount_tracker = gvfs_dbus_mount_tracker_skeleton_new () 并分别监听信号(这些信号分别对应相应dbus功能) handle-register-fuse handle-register-mount handle-mount-location handle-lookup-mount handle-lookup-mount-by-fuse-path handle-list-mounts handle-list-mounts2 handle-list-mountable-info handle-list-mount-types handle-unregister-mount g_dbus_interface_skeleton_export(mount_tracker,conn,G_VFS_DBUS_MOUNTTRACKER_PATH,NULL) G_VFS_DBUS_MOUNTTRACKER_PATH 是 /org/gtk/vfs/mounttracker 通过d-feet查看，此dbus提供了一系列接口，主要功能包括：支持的挂载类型、挂载信息、挂载点、通过 fuse 挂载的位置；同时也提供了挂载和卸载信号 gvfs_dbus_mount_tracker_skeleton_new() 一系列dbus对应的操作及一些接口声明 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:2","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"udisks2 gvfs-udisks2-monitor 进程负责磁盘、media、挂载点和fstab在桌面环境挂载、访问。尤其是 gnome-shell 和文件管理器程序 (nautilus)以及其它使用 GLib 的 API 程序。 通常，只会显示可挂载文件系统的测盘或媒体，这些媒体在下边统称为 “设备”。 如果设备挂载点在 /media/、$HOME、/run/media/$USER 之外的文件夹，那么设备可能不会显示在用户界面。或者如果设备挂载点在 /media/、$HOME、/run/media/$USER 这些目录之下，但是挂载点是以 . 开头的，那么也不会显示。这需要使用使用挂载选项 x-gvfs-show 来强制显示，当然 x-gvfs-hide 也可以使挂载点隐藏。 设备的名称、图标、符号图标是根据某些特征选择的，比如：设备的文件系统标签、x-gvfs-name=\u003cvalue\u003e、x-gvfs-icon=\u003cvalue\u003e 和 x-gvfs-symbolic-icon=\u003cvalue\u003e 在 /etc/fstab 添加自动挂载点时候，建议用户使用 /dev/disk 层次结构中稳定的符号连接，而不是内核名称 sda、sdb 等 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"热插拔 通过 eSATA 或 USB 连接的设备在物理机器上是可热插拔的。当物理设备连接到机器上或从机器上移除时候 linux内核 会把通知事件发送到用户空间，系统接受到此类事件并根据其配置对它们进行响应 设备驱动加载后会在 devfs (/dev) 下生成对应的设备节点，如果设备连接后 systemd-udevd 会根据配置对 /dev/ 下的设备节点进行增加 如果是块设备，systemd-udevd 通知 udisksd 和 gvfsd 以及 gvfs-udisks2-volume-monitor ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"一些 fstab 例子 强制在用户界面隐藏设备 /dev/disk/by-id/ata-HITACHI_HTS723232A7A364_E3834563KRG2HN-part1 /home/davidz/Data auto defaults,x-gvfs-hide 0 0 强制在用户界面显示设备(显示名字为 ‘My Movies’) /dev/disk/by-uuid/4CAE8E5B5AF47502 /Movies auto defaults,x-gvfs-show,x-gvfs-name=My%20Movies 0 0 自定义设备图标 /dev/disk/by-uuid/4CAE8E5B5AF47502 /Movies auto defaults,x-gvfs-show,x-gvfs-name=My%20Movies,x-gvfs-icon=folder-videos,x-gvfs-symbolic-icon=folder-videos-symbolic 0 0 强制在用户空间显示 NFS 挂载点 10.200.0.210:/tank/media /mnt/Filer nfs4 default,users,noauto,x-gvfs-show 0 0 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:2","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"一些udev例子 不自动挂载金士顿U盘 SUBSYSTEMS==\"usb\", ENV{ID_VENDOR}==\"*Kingston*\", ENV{ID_MODEL}==\"*DataTraveler*\", ENV{UDISKS_AUTO}=\"0\" 自动挂载某设备但是不要求admin权限 ENV{ID_SERIAL}==\"WDC_WD1002FAEX-00Y9A0_WD-WCAW30039835\", ENV{UDISKS_AUTO}=\"1\", ENV{UDISKS_SYSTEM}=\"0\" 给特殊设备特殊名字和图标 ENV{ID_MEDIA_PLAYER}==\"apple-ipod\", ENV{UDISKS_NAME}=\"David's iPod\", ENV{UDISKS_ICON_NAME}=\"multimedia-player-ipod\", ENV{UDISKS_SYMBOLIC_ICON_NAME}=\"multimedia-player-ipod-symbolic\" 确保此特殊设备不出现在用户界面 ENV{ID_SERIAL}==\"HITACHI_HTS723232A7A364_E3834563KRG2HN\", ENV{UDISKS_IGNORE}=\"1\" ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:3","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux","qemu"],"content":"在Linux宿主机上挂载 qemu 虚拟盘 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:0","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"下载 qemu-nbd 工具 pacman -S qemu 或 apt-get install qemu-utils 或 yum install qemu-img ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:1","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"加载nbd模块并挂载 modprobe nbd max_part=8 qemu-nbd --connect=/dev/nbd0 \u003cxxx.qcow2\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:2","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"开始挂载nbd磁盘到文件系统 mount /dev/nbd0xx \u003c挂载点\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:3","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"卸载nbd qemu-nbd --disconnect /dev/nbd0 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:4","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"将vmware的vmdk虚拟盘转为qemu支持的qcow2虚拟盘 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:0","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"合并vmware虚拟磁盘 如果vmware下虚拟机的磁盘是分块的，比如:xxx-s001.vmdk、xxx-s002.vmdk… 需要先合并为一个vmdk文件 vmware-vdiskmanager.exe -r \u003c虚拟盘的路径\u003e -t 0 \u003c合并后盘的名字\u003e vmware-vdiskmanager.exe 在vmware安装路径下 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:1","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"vmdk转qcow2 在linux下执行(确保执行前安装有qemu环境和工具包) qemu-img convert -f vmdk -O qcow2 \u003cxxx.vmdk\u003e \u003cxxx.qcow2\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:2","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux"],"content":"ARM 简史 ARM公司既不生产芯片也不销售芯片，它只出售芯片技术授权。却做到了在手持设备市场上占有90%以上的份额。 软银在2016年耗资320亿美元拿下ARM，使得本来就大红大紫的ARM公司，再一次窜到了业界人士的面前。ARM这家不生产芯片却也能数钱数到手抽筋的公司到底有着怎样的发展史？ 1978 年诞生 ARM公司既不生产芯片也不销售芯片，它只出售芯片技术授权。却做到了在手持设备市场上占有90%以上的份额。 软银在2016年耗资320亿美元拿下ARM，使得本来就大红大紫的ARM公司，再一次窜到了业界人士的面前。ARM这家不生产芯片却也能数钱数到手抽筋的公司到底有着怎样的发展史？ CPU公司的全称：Cambridge Processor Unit，字面意思是“剑桥处理器单元”。 CPU公司的创始人：奥地利籍物理学博士Hermann Hauser和他的朋友，英国工程师Chris Curry。 不过，CPU公司成立之后，主要从事电子设备设计和制造的业务。他们接到的第一份订单，是制造赌博机的微控制器系统。这个微控制器系统被开发出来后，称之为Acorn System 1。 1979 年公司改名 1979年，这家公司给自己换了个名字——Acorn Computer Ltd。 Acorn是什么意思？橡子。 Acorn Computer Ltd公司的商标里面就有一个橡子。 关于Acorn，还有一个有趣的说法，就是因为他们想在电话黄页里排在Apple（苹果）公司的前面… 在Acorn System 1之后，他们又陆续开发了System 2、3、4，还有面向消费者的盒式计算机 —— Acorn Atom。 1981 年迎来BBC订单 到了1981年，公司迎来了一个难得的机遇 —— 英国广播公司BBC打算在整个英国播放一套提高电脑普及水平的节目，他们希望Acorn能生产一款与之配套的电脑。 这个计划非常宏大，英国政府也参与其中（购机费的一半将由政府资助），电脑一旦采购，将进入英国的每一间教室。 接下这个任务之后，Acorn就开始干了起来。 结果，很快他们就发现，自己产品的硬件设计并不能满足需求。当时，中央处理器的发展潮流，正在从8位变成16位。Acorn并没有合适的芯片可以用。 起初，他们打算使用美国国家半导体和摩托罗拉公司的16位芯片。但是，经过评估后，他们发现了两个缺陷： 芯片的执行速度有点慢，中断的响应时间太长。 售价太贵，一台500英镑的电脑，处理器芯片就占到100英镑。 他们打算去找当时如日中天的英特尔（Intel），希望对方提供一些80286处理器的设计资料和样品。但是，却遭到了拒绝。 备受打击的Acorn公司，一气之下决定自己干，自己造芯片。 当时，Acorn公司的研发人员从美国加州大学伯克利分校找到了一个关于新型处理器的研究——简化指令集，恰好可以满足他们的设计要求。 在此基础上，经过多年的艰苦奋斗，来自剑桥大学的计算机科学家Sophie Wilson和Steve Furber最终完成了微处理器的设计。 对于这块芯片，Acorn给它命名为Acorn RISC Machine。 嗯，这就是大名鼎鼎的“ARM”三个字母的由来。 Acorn是公司名称，Machine是机器，那RISC是什么意思呢？ RISC的全称是\"精简指令集计算机\"（reduced instruction set computer），它支持的指令比较简单，所以功耗小、价格便宜，特别适合移动设备。早期使用ARM芯片的典型设备，就是苹果公司的牛顿PDA。 这里解释一下，到底“简化指令集”有什么意义。 它是相对于“复杂指令集（CISC，complex instruction set computer）”的一个概念。 早期的处理器都是CISC架构（包括英特尔的处理器），随著时间推移，有越来越多的指令集加入。由于当时编译器的技术并不纯熟，程序都会直接以机器码或是组合语言写成，为了减少程序的设计时间，逐渐开发出单一指令，复杂操作的程序代码。设计师只需写下简单的指令，再交给CPU去执行。 但是后来有人发现，整个指令集中，只有约20％的指令常常会被使用到，大约占了整个程序的80％；剩余80％的指令，只占了整个程序的20％。（典型的二八原则） 于是，1979年美国加州大学伯克利分校的David Patterson教授提出了RISC的想法，主张硬件应该专心加速常用的指令，较为复杂的指令则利用常用的指令去组合。 1985年10月，英特尔发布了80386。在80386面前，ARM1就只有被吊打的份了。 intel 80386 32位，27.5万个晶体管，频率为12.5MHz，后提高到33MHz 让ARM直接在性能上和x86系列硬杠，显然是不现实的。ARM有意无意地选择了与Intel不同的设计路线——Intel持续迈向x86高效能设计，ARM则专注于低成本、低功耗的研发方向。 BBC在1981年就提出需求，如果等到1985年ARM1出来，那岂不是黄花菜都凉了？ 所以，在ARM1问世之前，Acorn其实已经提供了解决方案给BBC。 当时，Acorn的电脑，临时采用了MOS 6502处理器（由MOS科技研发的8位微处理器）。 MOS 6502处理器 1982 年推出 BBC Micro计算机 1982 年Acorn计算机公司推出了BBC Micro计算机，这是欧洲第一台畅销的个人计算机。 BBC Micro 1984 BBC Micro 被大量使用 到了 1984 年，大约80%的英国学校都配有这款电脑。Acorn公司彻底在大英帝国老百姓面前刷了一把存在感。 后来，ARM处理器被研发出来之后，用在了BBC Micro的后续型号中。 BBC Micro电脑里面的ARM芯片 1985 年推出 ARM1 芯片 1985 年Acorn与合作伙伴推出了ARM1芯片，以此作为其未来个人计算机的中枢。 在ARM1之后，Acorn陆续推出了好几个系列，例如ARM2，ARM3。 1990 年得到苹果公司投资 1990 年11月27日，Acorn公司正式改组为ARM计算机公司。苹果公司出资150万英镑，芯片厂商VLSI出资25万英镑，Acorn本身则以150万英镑的知识产权和12名工程师入股。 在成立后的那几年，ARM业绩平平，工程师们人心惶惶，害怕随时失业。 在这个情况下，ARM决定改变他们的产品策略——他们不再生产芯片，转而以授权的方式，将芯片设计方案转让给其他公司，即“Partnership”开放模式。 没想到正是这种模式，开创了属于ARM的全新时代。 ARM 32位嵌入式RISC(Reduced lnstruction Set Computer)处理器扩展到世界范围，占据了低功耗、低成本和高性能的嵌入式系统应用领域的领先地位。 ARM所采取的是IP（Intellectual Property，知识产权）授权的商业模式，收取一次性技术授权费用和版税提成。 具体来说，ARM有三种授权方式：处理器、POP以及架构授权。 处理器授权是指授权合作厂商使用ARM设计好的处理器，对方不能改变原有设计，但可以根据自己的需要调整产品的频率、功耗等。 POP（processor optimization pack，处理器优化包）授权是处理器授权的高级形式， ARM出售优化后的处理器给授权合作厂商，方便其在特定工艺下设计、生产出性能有保证的处理器。 架构授权是ARM会授权合作厂商使用自己的架构，方便其根据自己的需要来设计处理器（例如后来高通的Krait架构和苹果的Swift架构，就是在取得ARM的授权后设计完成的）。 所以，授权费和版税就成了ARM的主要收入来源。除此之外，就是软件工具和技术支持服务的收入。 对于半导体公司来说，授权费和版税到底有多少呢？一次性技术授权费用在100万-1000万美元之间，版税提成比例一般在1%-2%之间。 正是ARM的这种授权模式，极大地降低了自身的研发成本和研发风险。它以风险共担、利益共享的模式，形成了一个以ARM为核心的生态圈，使得低成本创新成为可能。 苹果公司投资ARM，是为了保证其Newton手持计算机的芯片供应，这个不切实际的设备以失败而告终。 注意：这里的ARM是公司名称，不是芯片名称。这个ARM的完全拼写也不一样，是Advanced RISC Machines。 前面的芯片名称：Acorn RISC Machine 现在的公司名称：Advanced RISC Machines 1998 年诺基亚基于ARM设计并畅销 1998 年诺基亚基于ARM设计的畅销帮助它成了全世界最大的手机生产商。 1991 年ARM将产品授权给英国GEC Plessey半导体公司 1993 年ARM将产品授权给Cirrus Logic和德州仪器（Texas Instruments，TI） 与德州仪器的合作，给ARM公司带来了重要的突破。而且，也给ARM公司树立了声誉，证实了授权模式的可行性。 此后，越来越多的公司参与到这种授权模式中，与ARM建立了合作关系。其中就包括三星、夏普等公司。 在此基础上，ARM坚定了授权模式的决心，并着手设计更多性价比高的产品。 1993年，苹果公司推出了一款新型掌上电脑产品——Newton。ARM公司开发的ARM6芯片被用于该产品之中。 Apple Newton Message Pad 现在被认为是PDA和智能手机的鼻祖 但是很遗憾，因为Newton技术过于超前，加上一些用户体验上的缺陷，所以未能被市场接受，后来以失败告终。 但ARM积累了经验，继续改良技术。没过多久，ARM迎来了自己的黄金机遇——","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:1:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"硬件相关概念 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"电平 在数字电路中，分为高电平和低电平，分别用1和0表示。一个数字电路的管脚，总是存在一个电平的，要么高要么低，或者说要么1要到0(其实还有一种，高阻) ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:1","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"总线 在嵌入式系统中一定会有一块处理器芯片，此外，还有其它的芯片作为外部设备（后面简称外设），这些芯片与处理器协作实现产品的功能。复杂的产品往往是由大量的芯片组成的。那么不可避免的是我们需要将所有的外设与处理器进行相连，最为简单的是将所有的外设都采用独立（注意是独立）的信号线连接至处理器，这样的好处是容易理解，但问题是：不可行。 因为处理器芯片需要引出太多的线了，从芯片的生产和产品的生产角度来看都不实际。加之，处理器（在此我们假设处理器是单核的，而不是多核的）处理事务在微观上是串行的，也就是说在某一时刻如果要对外设进行读写操作，那只可能是对大量外设中的一个进行，即多个外设不可能在微观上被处理器同时访问。需要注意的是，这里提出了微观这一概念，这是为了区别于宏观。 从宏观上来讲，一个处理器中可以有多个任务同时运行，但这些任务在微观上却是一个一个运行的（后面会用串行来描述这里所说的“一个一个”），多任务的串行运行实现是由操作系统扮演着重要的角色来实现的。回到我们的话题，即然将每个外设采用独立的信号线连到处理器不可行，且处理器在单一时间内只会对一个外设进行访问，那我们能不能采用共享的信号线将所有的芯片连在一起呢？这就是总线概念的由来。 通俗的说，如果我们周围有十个家庭，为了让这十个家庭每两个之间都能往来，我们并不需要为每两个家庭修一条单独（注意是单独）的路（如果这样，要修45条路），而是可以修一条大路，然后，每个家都与大路相连。 对于总线，我们往往说总线是处理器的，而其它的外设是挂在总线上的。那有一个问题，我们每一时间只能访问挂在总线上的一个外设，那如何区分这些外设呢？和我们的路一样，我们需要用地址来区分每一个家庭，在总线上，也是采用地址来进行区分的。这样，总线就根据其功能分为两类了。一类是地址总线，这一总线上的数据只会是从处理器向外设“流”，是单向的。 另一类则是数据总线，用来将数据从处理器传送到外设（从处理器的角度来说是写操作）或者是将数据从外设传送到处理器（从处理器的角度来说是读操作），显然，数据总线是双向的。也就是说，在我们的嵌入式系统中同时存在地址总线和数据总线将所有需要与处理器进行通讯的芯片连在一起的。 总线是有宽度的，正如我们的路分为“三车道”或是“四车道”，我们说32位处理器，是指其数据总线宽度是32位，也就是“有32辆车能同时跑”，显然，宽度越是宽我们的处理器速度就越是快，因为我们从外设芯片存取数据的速度会更快，这就是为什么我们的计算机向64位发展的原因。同样的，地址总线也是有宽度的，对于32位处理器其最大宽度也就是32位。 总线的概念有了，那接下来的一个问题是，即使是每一个外设都有一个地址，那这一地址记在哪里呢？是放在外设芯片上吗？如果这样的话，那就有一个问题，每一类外设的地址必须是不能重叠的，而当一个产品中需要两块一样的芯片的话，两块芯片的地址就无法区分了，看来这样操作存在问题。还有，如果这样的话每一个外设也得与（比如，32根）数据总线完全相连，并监听数据线以了解处理器是不是在“叫”自己，这样很是复杂。 此外，地址也有可能因为外设种类的增多而用光。总的来说地址不能存放在外设芯片，那如何让外设知道，此时它是被处理器招换从而需要进行读写访问的呢？答案就是芯片的片选（CS， chip select）信号，或者又叫使能（ENable）信号。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:2","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"片选(CS或EN) 片选信号对于外设芯片来讲，就是一个（也是一根）通知信号，告诉芯片“嘿，请开门，我要放些东西进来，或是拿些东西走”，这里的东西只能是数据，不可能是玉米棒什么的。那有个问题，这个信号源从哪里来呢？显然，只能从处理器来。那是不是也是像总线那样，每一个芯片都共用一根线连在一起呢？如果这样，可能处理器“一叫开门”所有的芯片都将“门”打开了。如果是处理器写数据，那可能所有的芯片都被写入同样的数据。 而取数据时，每个外设芯片都向外“扔”数据，这一定会造成数据总线冲突，因为有的芯片向总线上“扔”1，有的则“扔”0，这种情况下处理器一定会“发疯”的，因为它不知道应当得到1还是0。 既然这样，显然不能将所有的片选信号连在一起了，只能是各芯片的片选信号独立。前面提到了地址总线，我们是采用一根地址线连一个外设芯片呢？还是采用其它的方法。如果采用一根地址线连一个外设芯片，那可能最多只能挂接32个芯片了，这显然不行。其实，在现实中，是采用32位的数字来表示一个外设芯片的地址的，比如1可以表示芯片A，而6534可以表示另外一个芯片B， 等等。由此看来，理论上我们可以表示2的32次方（4294967296）个设备，之所以说理论上，是因为有的设备要占用大量的地址。即然这样，那还有一个问题，如果将32位的地址总线转换成芯片的一根片选信号呢？这需要引入译码（器）的概念。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:3","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"译码器 译码器将一个数据转换成一根信号线上的信号，比如3/8译码器，可以将一个位宽是3位的数据转换成8根（2的3次方）完全独立的信号线，当向数据侧写入二进制的011时，对应的是8根线的第3根，当输入二进制的111时，对应的是8根线中的最后一根。有了译码器，处理器的地址线就简化了，只要32根地址线加上外面的译码器，就可以访问大量的外设芯片了。外部设备的选择问题，我们已经解决了，现在还得回头看一看数据总线。 3/8译码器 在嵌入式系统中，所有芯片的数据总线可以理解成是直接相连的。之所以用了“可以理解”一词，是因为为了提高总线的负载能力，其中会加入总线驱动器。为了理解，我们看一看我们生活中的自来水，比如，在北京理论上可能所有的水管是连在一起的，但中间可能为了提高水压，存在很多小的水站用来增加供水压力，而不可能全北京所有的自来水自接来自一个水厂。 既然所有的数据总线是连在一起的，那就可能会有问题。当向外部设备写数据时，处理器先向地址总线输送目标外设的地址，地址译码器将其转换成一根信号的片选信号送到了目标外设，目标外设收到这一信号后，将“门”打开。接下来处理器将要传送到外设的数据往数据总线上一放，由于只有目标外设芯片打开了“门”，所以数据只会进入到目标外设，而其它的外设什么也不会收到。 很好！处理器向外写数据应当没有问题，我们接下来看一看读。读的话，由于数据是从外设输送到处理器的，尽管我们采用和写一样的方法打开目标外设的“门”，但此时，其它的外设也在数据总线上，它们有可能处于1也可能处于0，是不是会影响处理器读取目标外设的数据呢？结果当然不会，但我们得引入另一个概念：高阻态。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:4","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"高阻态 很显然，当处理器从目标外设读数据时，我们希望其它没有被选上的芯片的数据总线不会对目标外设所要传送的数据有影响，那怎么办呢？实际上，当芯片没有被选中时，其数据总线都处于高阻态。所谓的高阻态，我们可以理解成这一管脚在外设芯片内部是断开的，如此一来，显然不会对处理器从目标外设读取数据造成任何的影响了。 我们说当一个芯片没有被选中或是没有被使能时，其数据总线一定是处于高阻态的。前面用了“门”的开和关来打比方，那“门”是指什么呢？是指外设的数据总线，片选信号的作用就是控制将外设的数据总线与处理器的数据总线相连或是断开。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:5","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"驱动 总线上的数据是谁放上去的我们就说谁是那一时刻的驱动者。也就是说，当处理器向外设写数据时，它是在驱动数据总线的，而当处理器从目标外设读取数据时，目标外设是在驱动数据总线的。对于地址总线，因为只可能从处理器向目标外设写，所以地址总线永远是由处理器驱动的。当一个芯片没有被选中时，我们说它并不驱动数据总线。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:6","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"三态门 前面我们说到外设芯片的数据总线在没有被选中时其处于高阻态，当被选中时，其电平可能是高（1）或是低（0）。如此一来，我们说外设的数据总线其芯片管脚是属于三态门的，即存在高电平、低电平和高阻态，三个状态。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:7","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"电平特效 前面我们了解了什么是片选信号，也讲到了三态门，需要指出的是片选信号通常不是三态门，其只存在两个状态，即高电平或是低电平。前面我们也说了，片选信号是用来“开门”的，而片选信号又有高和低电平，那到底是高电平表示“开门”呢？还是低电平？对于这一问题，我们称如果一个电平对于一个片选信号表示“开门”那么它就是这一信号的有效电平。 比如，对于一个片选信号，如果低电平表示“开门”，那么我们说这个片选信号是低电平有效的。虽然，在这里我们用片选信号来解释电平的有效性，但是很多信号都存在有效性的问题，比如，后面我们将要谈的读信号和写信号都存在有效性问题。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:8","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"时序 在前面我们说到当处理器要向外设芯片写数据时，需要先将所需访问的外设的地址放在地址总线上，然后，由译码器将地址总线上的数据转换成片选信号，片选信号则使能目标外设芯片，接下来处理器写数据到数据总线上，从而完成一个写操作。显然，在处理器将数据写到数据总线之前地址线上的数据必须一直保留一段时间，否则的话译码器不能长时间的使片选信号有效。 当完成了数据的写操作后，处理器就不需要保证地址总线上的地址有效了。我们可以看出，这一系列的操作都有一定严格的时间顺序的，这称之为时序。时序描述了处理器与外部设备的交互信号 “规程”，大家只有按照这一“规程”来操作，才能保证处理器与外部设备之间能正常的通讯。 这好比，我们的道路上的红绿灯，如果我们行人和车辆不按照其指示来通行的话，就会出现事故。通常，采用时序图来描述芯片之间通讯的信号“规程”。 读时序图 读时序图 从图中我们可以看出ADDRESS是表示地址总线的，DQ是表示数据总线的,CE是片选信号，且是低电平有效，其宽度要保证在进行读操作时总是有效的。学会看时序图对于做嵌入式系统开发非常有帮助，因为我们不可避免的要与芯片打交道。在时序图中，通常会标识很多的时间需求信息。 在写启动代码时需要初始化各地址空间的片选地址寄存器和读写时序，时序的配置依据就是来自于外设芯片的时间需求，这是芯片手册很重要的一部分内容。当一个地址空间中存在多个外设芯片时，我们需要考虑到其中最慢的外设芯片的时间需求，否则的话有的芯片就不能正常工作。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:9","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"读信号 当处理器需要从外设芯片读取信号时，除了需要产生片选信号外，还需要告诉外设芯片这是一个读操作，而不是一个写操作，这是通过读信号来实现的。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:10","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"写信号 前面讲了读信号，我想对于写信号也就不难理解了，这个信号用于告诉外设芯片，这是一个向外设芯片写数据的操作。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:11","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"I/O端口 前面提到了外设（芯片）)，现在是对外设进行分类的时候了。大体上外设分为两类，一类是存储器外设，而另一类是非存储器外设，后者常被称之为I/O设备，这里的I/O是Input/Output的简写，即输入、输出。可见，I/O外设是一个非常宽泛的概念。对于存储器外设，其特点是，它所占用的空间是连续的一片。比如，SDRAM内存就是属于存储器外设，如果其容量是8M字节，那么其占用的地址空间也会是8M的。 与存储器外设所不同的是，I/O外设所点用的地址一般都很少。比如一个I/O外设可能存在多个控制寄存器，这些控制寄存器从处理器来看就是多个I/O端口（地址），向这个地址写数据就是向外设所对应的寄存器写数据，反之，也可以是读。 比如，一个串口芯片可能存在多个寄存器，一个用来查询芯片的状态，一个用来设置芯片的功能，另一个用来读取芯片从串口线所收到的数据，最后，还有一个用来向芯片写数据以向串口线上发送数据。对于这一串口芯片的寄存器，从处理器的角度来看，都是独立的I/O端口。 I/O端口存在读、写性问题，有的端口是只读的，有的端口是只写的，还有的端口是即可读也可写，其读写性是由外设芯片的寄存器所决定的，在芯片的数据手册中能找到。需要指出的是，有些存储器外设也存在I/O端口，以对其进行一定的控制。从I/O端口这一名字来看，对于处理器来说，就是对从外面读入数据或是向外面输出数据的一个接口总称。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:12","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"中断 中断从硬件的角度来看就是一个能产生高、低电平的一根信号线，但理解它需要从处理器的角度出发。我们说过了，处理器从微观上看，所做的工作是按顺序进行的，其对程序的处理只能是一条指令一条指令的执行。如果存在需要对外设芯片进行访问，而有可能从处理器发出读、写命令后，由于外设通常比处理器慢很多，所以外设芯片需要一些时间来准备好所需的数据。 在这种情况下，如果处理器一直等外设芯片的返回数据再执行后续的指令的话，将耗费宝贵的时间，这些时间完全可以用来做其它的工作。别忘了，从宏观上看来处理器常常是多任务的，任务是指操作系统所提供的调度单位。当一个任务因为等待外设芯片的数据而阻塞时，我们可以切换到另外的任务，从而提高处理效率。 这就有一个问题，当处理器去处理另一个任务时，如果外设芯片的数据好了的话，如果告诉处理器呢？对了！就是通过中断信号。中断信号的高、低电平可以用来表示是否有中断需要处理器注意以处理特定的事件（比如，外设数据准备好了的事件）。 由此看来，中断的引入能大大的提高处理器的运用效率。为了使用处理器上的中断，一开始我们需要初始化好处理器的中断控制器，比如安装好所需的中断服务程序或称之为ISR（Interrupt Service Routine），然后，打开中断屏蔽位。中断服务程序中需要做如下的操作： 从外设读入或向外设写数据。读还是写通常需要读取外设的中断状态寄存器来决定。 清除外设的中断信号。我们知道，中断信号是由外设芯片驱动的，为了告诉外设芯片，处理器已经处理完了所需做的工作，那么处理器需要通过一定的方式通知外设芯片。这种方式就是向外设芯片的寄存器中的某一位写入一个数据，比如，可能是写入1表示清中断，也可能是写入0表示清中断，这通常在外设的数据手册中能查到。 当外设收到了处理器的清中断请求后，其就会驱动中断线使其无效。比如，一个外设的中断线是当其为低电平表示有中断，将其从低电平变为高电平就是驱动为无效。 清除处理器的中断信号标识。处理器中往往也会保存外部中断信号是否发生过，当我们处理完了外设芯片的中断时，我们也需要清除处理器上的标识，从而为下一次中断做准备。需要注意的是，清外设的中断必须发生在请处理器中断标识之前！ 中断还存在一个触发方式问题。有两种触发方式 ，一种是电平触发，另一种是沿触发。电平触发是指电平的高低表示外设是否有中断，而沿触发则是能过中断线上的电平的升或降来表示的，显然，存在两种沿触发方式。 一种是中断线从低电平变为高电平，我们称之为上升沿触发，另一处是中断线从高电平转换为低电平，我们称之为下降沿触发。总的来说中断的触发方式有电平触发、上升沿触发和下降沿触发。电平触发方式中处理中中断设置很重要的一个步骤。 ROM ROM(Read Only Memory)和RAM(Random Access Memory)指的都是半导体存储器，ROM在系统停止供电的时候仍然可以保持数据，而RAM通常是在掉电之后就丢失数据，典型的RAM就是计算机的内存。 ROM有很多种，PROM是可编程的ROM，它和EPROM(可擦除可编程ROM)的区别是，PROM是一次性的，也就是软件灌入后，就无法修改了，这是早期的产品，现在已经不再使用，而EPROM是通过紫外光的照射擦出原先的程序的一种通用存储器。另外一种EEPROM是通过电子擦除，价格很高，写入时间很长，写入慢。 举个例子，手机软件一般放在EEPROM中，我们打电话，有些最后拨打的号码，暂时存在SRAM中，不是马上写入通话记录(通话记录保存在EEPROM中)，因为当时有很重要工作(通话)要做，如果写入，漫长的等待用户无法忍受。 RAM RAM有两大类，一种称为静态RAM(Static RAM/SRAM)，SRAM速度非常快，是目前读写最快的存储设备了，它也非常昂贵，所以只在要求很苛刻的地方使用，譬如CPU的一级缓冲，二级缓冲。 另一种称为动态RAM(Dynamic RAM/DRAM)，DRAM保留数据的时间很短，速度也比SRAM慢，不过它还是比任何的ROM都要快，但从价格上来说DRAM相比SRAM要便宜很多，计算机内存就是DRAM的。 DRAM DRAM分为很多种，常见的主要有FPRAM/FastPage、EDORAM、SDRAM、DDR RAM、RDRAM、SGRAM以及WRAM等，这里介绍其中的一种DDR RAM。 DDR RAM DDR RAM(Date-Rate RAM)也称作DDR SDRAM，这种改进型的RAM和SDRAM是基本一样的，不同之处在于它可以在一个时钟读写两次数据，这样就使得数据传输速度加倍了。 这是目前电脑中用得最多的内存，而且它有着成本优势，击败了Intel的另外一种内存标准-Rambus DRAM。在很多高端的显卡上，也配备了高速DDR RAM来提高带宽，这可以大幅度提高3D加速卡的像素渲染能力。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:13","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"内存原理解析 内存是用来存放当前正在使用的(即执行中)的数据和程序，我们平常所提到的计算机的内存指的是动态内存(即DRAM)，动态内存中所谓的“动态”，指的是当我们将数据写入DRAM后，经过一段时间，数据会丢失，因此需要一个额外设电路进行内存刷新操作。 具体的工作过程是这样的：一个DRAM的存储单元存储的是0还是1取决于电容是否有电荷，有电荷代表1，无电荷代表0。但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，这就是数据丢失的原因; 刷新操作定期对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电; 若电量小于1/2，则认为其代表0，并把电容放电，藉此来保持数据的连续性。 NAND Flash和NOR Flash的比较 常用的Flash类型有：NOR Flash和NAND Flash两种。NOR Flash由Intel公司在1988年发明，以替代当时在市场上占据主要地位的EPROM和EEPROM。NANDFlash由Toshiba公司在1989年发明。两者的主要差别如下表所示。 NOR Flash支持XIP，即代码可以直接在NOR Flash上执行，无需拷贝到内存中。这是由于NOR Flash的接口与RAM完全相同，可以随机访问任意地址的数据。在NOR Flash上进行读操作的效率非常高，但是擦除和写操作的效率很低；另外，NOR Flash的容量一般比较小。 NAND Flash进行擦除和写操作的效率更高，并且容量更大。一般而言，NOR Flash用于存储程序，NAND Flash用于存储数据。基于NAND Flash的设备通常也要搭配NOR Flash以存储程序。 Flash存储器件由擦除单元(也称为块)组成，当要写某个块时，需要确保这个块已经被擦除。NOR Flash的块大小范围为64KB～128KB；NAND Flash的块大小范围为8KB～64KB，擦/写一个NOR Flash块需4S，而擦/写一个NAND Flash块仅需2ms。 NOR Flash的块太大，不仅增加了擦写时间，对于给定的写操作，NOR Flash也需要更多的擦除操作——特别是小文件，比如一个文件只有1KB，但是为了保存它却需要擦除大小为64KB～128KB的NOR Flash块。 NOR Flash的接口与RAM完全相同，可以随意访问任意地址的数据。而NAND Flash的接口仅仅包含几个I/O引脚，需要串行地访问。NAND Flash一般以512字节为单位进行读写。这使得NOR Flash适合于运行程序，而NAND Flash更适合于存储数据。 容量相同的情况下，NAND Flash的体积更小，对于空间有严格要求的系统，NAND Flash可以节省更多空间。市场上NOR Flash的容量通常为1~4MB(也有32MB的NOR Flash)，NANDFlash的容量为8~512MB。容量的差别也使得NOR Flash多用于存储程序，NAND Flash多用于存储数据。 对于Flash存储器件的可靠性需要考虑3点：位反转、坏块和可擦除次数。所有Flash器件都遭遇位反转的问题：由于FLASH固有的电器特性，在读写数据过程中，偶然会产生一位或几位数据错误——这种概率很低，而NAND Flash出现的概率远大于NOR Flash。当位反转发生在关键的代码、数据上时，有可能导致系统崩溃。 当仅仅是报告位反转，重新读取即可；如果确实发生了位反转，则必须有相应的错误检测/恢复措施。在NAND Flash上发生位反转的概率更高，推荐使用EDC/ECC进行错误检测和恢复。 NAND Flash上面会有坏块随机分布，在使用前需要将坏块扫描出来，确保不再使用它们，否则会使产品含有严重的故障。NAND Flash每块的可擦除次数通常在100000次左右，是NOR Flash的10倍。另外，因为NAND Flash的块大小通常是NOR Flash的1/8，所以NAND Flash的寿命远远超过NOR Flash。 linux对NOR、NAND Flash的软件支持都很成熟。在NOR Flash上常用jffs2文件系统，而在NAND Flash上常用yaffs文件系统。在更底层，有MTD驱动程序实现对它们的读、写、擦除操作，它也实现了EDC/ECC校验。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:14","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"工具 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"万用表 万用表通常是用来查看电平的高低、电阻的大小等的，是常用且必不可少的工具之一。在嵌入式系统开发中，我们常用的是数字万用表。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:1","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"示波器 在嵌入式系统开发中，我们不可避免的要与外设芯片打交道。调试驱动程序时，除了需要完全看明白芯片的数据手册，且在软件高度的过程中，还需要看我们所期望的信号电平是否发生在芯片上。比如，我们在写驱动程序时，需要通过写I/O端口来对外设芯片进行操作，当写相应的I/O端口时，我们知道所对应芯片的片选信号应当有效，有时，我们需要验证是否按预期发生了，这就需要用到示波器。 一般的示波器是能同时观测两个信号线的信号状态的。示波器都提供一定的功能，比如设置信号扑捉的方式等等。示波器很重要的一个参数据是其采集频率，根据Nyquist采集定理，如果我们想用示波器查看频率是100M赫兹的信号，那么其采样频率必须至少是其两倍，即200M赫兹。有人可能会问：为什么不用万用表来看呢？因为万用表的采集频率很底，无法采集到很快的信号变化。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:2","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"逻辑分析仪 简单的说逻辑分析器就是具有很多信号通道的示波器。通过逻辑分析仪，我们可以看到地址总线和数据总线上的数据。逻辑分析仪都提供一定的编程能力，用于编程什么时候开始对总线上的数据进行采集。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:3","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"环境搭建目标 pc 可以通过 串口 连接到 开发板，并能查看输出日志 pc 可以通过 ssh 连接到 开发板。开发板默认登录用户名: root，无密码 在 pc 上配置好 arm 交叉编译工具链 准备好常用的源码: uboot源码、linux源码、buildroot源码 我使用 manjaro 作为开发环境；使用 imx6ull pro 作为运行/学习环境，开发板下载的工具里没有linux平台的，因此需要从下载资料的 ubuntu 虚拟机里提取。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发板展示 各标号硬件含义 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发板启动方式（上图表号16对应状态） boot sw1(lcd_data5) sw2(lcd_data11) sw3(boot_mode0) sw4(boot_mode1) emmc OFF OFF ON OFF sd ON ON ON OFF usb X X OFF ON 注意：当设为 USB 启动时候，不能插上SD卡、TF卡；上电之后才可以插卡。刚出厂的板子在 emmc 上烧写了系统，开发板启动方式需要设置为 emmc 启动。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"第一次启动开发板 设置开发板的打开方式为 emmc，打开电源开关 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"接串口 下载 linux 串口驱动程序 https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers 并编译之后在源码目录执行insmod ./xxx.ko，插入编译生成的内核模块(xxx.ko文件) 连接开发板电源线并打开开关，插拔 usb 线观察 /dev/ 下设备变化，发现插入 usb 后会多出 ttyUSB0 这一设备 执行 pacman -S minicom 下载 minicom 打开串口 minicom -D /dev/ttyUSB0 然后重启开发板(直接断点和上电)，后续就可以通过 minicom 看到串口日志了（需要开发板默认打开串口输出） ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"ssh 连接到开发板 给开发板联网并重启，在系统选项里设置网络(ip、子网掩码、网关)并用 PC ssh 连接上去 接上串口，用 minicom 来观察日志输出 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:4","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"搭建环境 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"下载开相关源码及工具 百度网盘下载,提取码:root ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"配置 arm gcc 交叉编译环境(使用imx6ull资料配置) 解压缩 ubuntu 的虚拟机文件（如果压缩文件是多个，需要都选中然后解压） 查看解压后的文件有几个 *.vmdk 文件，如果是多个则需要使用 vdiskmanager 合并为一个 使用 qemu-img 把 xxx.vmdk 文件转为 qemu 支持的 qcow2 文件 我的 linux 工作机用 qemu 而不是 vmware 挂载转换后的文件系统 使用mount挂载虚拟硬盘的家目录，大概是 /dev/nb0p4 挂载后可以通过 ls 命令看到book文件夹，这就是家目录，然后把文件 100ask_imx6ull-sdk 复制出来，在这个文件夹的ToolChain目录下有需要的arm编译链，具体目录是 100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot 配置环境变量，修改 ~/.bashrc 添加如下配置: export ARCH=arm export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- PATH=\u003carm交叉编译根目录\u003e/bin:${PATH} export PATH=$(echo ${PATH} | sed 's/:/\\n/g' | sort | uniq | tr -s '\\n' ':' | sed 's/:$//g') 配置好后重新打开终端或执行source ~/.bashrc 之后打开终端，运行 arm-buildroot-linux-gnueabihf-gcc -v，查看是否有如下信息输出(如果没有，重新执行这一步): Using built-in specs. COLLECT_GCC=/data/environment/gcc-arm/bin/arm-buildroot-linux-gnueabihf-gcc.br_real COLLECT_LTO_WRAPPER=/data/environment/gcc-arm/bin/../libexec/gcc/arm-buildroot-linux-gnueabihf/7.5.0/lto-wrapper Target: arm-buildroot-linux-gnueabihf Configured with: ./configure --prefix=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --sysconfdir=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/etc --enable-static --target=arm-buildroot-linux-gnueabihf --with-sysroot=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/arm-buildroot-linux-gnueabihf/sysroot --enable-__cxa_atexit --with-gnu-ld --disable-libssp --disable-multilib --disable-decimal-float --with-gmp=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-mpc=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-mpfr=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-pkgversion='Buildroot 2020.02-gee85cab' --with-bugurl=http://bugs.buildroot.net/ --disable-libquadmath --enable-tls --enable-plugins --enable-lto --enable-threads --with-isl=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-abi=aapcs-linux --with-cpu=cortex-a7 --with-fpu=neon-vfpv4 --with-float=hard --with-mode=arm --enable-languages=c,c++,fortran --with-build-time-tools=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/arm-buildroot-linux-gnueabihf/bin --enable-shared --enable-libgomp Thread model: posix gcc version 7.5.0 (Buildroot 2020.02-gee85cab) 上述2、3、4步相关教程可以查看qcow2虚拟分区挂载 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"配置arm gcc交叉编译环境(这个留备后续使用，不需要配置) arm 交叉编译工具下载地址: arm 交叉编译工具下载地址，或者复制到浏览器下载(这个包宿主机是x86，目标代码编译成arm的): https://armkeil.blob.core.windows.net/developer/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-arm-none-linux-gnueabihf.tar.xz 下载并解压之后放置指定目录并改名为 gcc-arm，比如: /data/envrionment/gcc-arm/ 配置环境变量，编辑 ~/.bashrc，在末尾加入如下代码: export ARCH=arm export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- PATH=\u003carm交叉编译根目录\u003e/bin:${PATH} export PATH=$(echo ${PATH} | sed 's/:/\\n/g' | sort | uniq | tr -s '\\n' ':' | sed 's/:$//g') 配置好后重新打开终端或执行source ~/.bashrc 之后打开终端，运行 arm-none-linux-gnueabihf-gcc -v，查看是否有如下信息输出(如果没有，重新执行这一步): Using built-in specs. COLLECT_GCC=arm-none-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER=/data/environment/gcc-arm/bin/../libexec/gcc/arm-none-linux-gnueabihf/11.2.1/lto-wrapper Target: arm-none-linux-gnueabihf Configured with: /data/jenkins/workspace/GNU-toolchain/arm-11/src/gcc/configure --target=arm-none-linux-gnueabihf --prefix= --with-sysroot=/arm-none-linux-gnueabihf/libc --with-build-sysroot=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/install//arm-none-linux-gnueabihf/libc --with-bugurl=https://bugs.linaro.org/ --enable-gnu-indirect-function --enable-shared --disable-libssp --disable-libmudflap --enable-checking=release --enable-languages=c,c++,fortran --with-gmp=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-mpfr=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-mpc=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-isl=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-arch=armv7-a --with-fpu=neon --with-float=hard --with-mode=thumb --with-arch=armv7-a --with-pkgversion='GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)' Thread model: posix Supported LTO compression algorithms: zlib gcc version 11.2.1 20220111 (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 这里需要注意的是，如果下载的 arm 编译工具链与开发板文件系统的编译工具链 gcc 不一致，则会导致在 pc 上用跨平台编译工具链编译出来的程序无法在 arm 开发板上运行。解决办法：1. 重新编译开发板根文件系统、内核并烧写；2. 使用官方提供的交叉编译工具链 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"安装 make 项目管理命令 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:4","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"cortexA7 烧写工具 imx6ull 官方烧写工具是 mfgtools 操作简单，一键烧写整个镜像\u003c用这个就可以\u003e nxp 提供的 uuu (Universal Update Utility) 又名 mfgtools 3.0 这块具体使用后续会有介绍 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:5","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"4. mkimage 工具 这一工具来源于 u-boot，用来给一个 bin 文件添加头部信息，芯片固件需要根据头部信息把 bin 文件放到内存中去执行 执行 pacman -S u-boot 命令后，再次执行 mkimage -h 查看是否正确安装: mkimage: invalid option -- 'h' Error: Invalid option Usage: mkimage -l image -l ==\u003e list image header information mkimage [-x] -A arch -O os -T type -C comp -a addr -e ep -n name -d data_file[:data_file...] image -A ==\u003e set architecture to 'arch' -O ==\u003e set operating system to 'os' -T ==\u003e set image type to 'type' -C ==\u003e set compression type 'comp' -a ==\u003e set load address to 'addr' (hex) -e ==\u003e set entry point to 'ep' (hex) -n ==\u003e set image name to 'name' -d ==\u003e use image data from 'datafile' -x ==\u003e set XIP (execute in place) mkimage [-D dtc_options] [-f fit-image.its|-f auto|-F] [-b \u003cdtb\u003e [-b \u003cdtb\u003e]] [-E] [-B size] [-i \u003cramdisk.cpio.gz\u003e] fit-image \u003cdtb\u003e file is used with -f auto, it may occur multiple times. -D =\u003e set all options for device tree compiler -f =\u003e input filename for FIT source -i =\u003e input filename for ramdisk file -E =\u003e place data outside of the FIT structure -B =\u003e align size in hex for FIT structure and header Signing / verified boot options: [-k keydir] [-K dtb] [ -c \u003ccomment\u003e] [-p addr] [-r] [-N engine] -k =\u003e set directory containing private keys -K =\u003e write public keys to this .dtb file -G =\u003e use this signing key (in lieu of -k) -c =\u003e add comment in signature node -F =\u003e re-sign existing FIT image -p =\u003e place external data at a static position -r =\u003e mark keys used as 'required' in dtb -N =\u003e openssl engine to use for signing mkimage -V ==\u003e print version information and exit Use '-T list' to see a list of available image types ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:6","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"最后来一个例子 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"在开发机上编写一个例子 #include \u003cstdio.h\u003e int main (int argc, char* argv[]) { printf (\"Hello World!\\n\"); return 0; } ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发机上的Makefile CC = arm-buildroot-linux-gnueabihf-gcc CUR_DIR = $(shell pwd) SRC = $(strip $(subst $(CUR_DIR), ., $(wildcard $(CUR_DIR)/*.c))) TARGET = $(strip $(patsubst %.c, %.run, $(SRC))) all:${TARGET} %.run:%.c ${CC} -o $@ $\u003c clean: rm -f *.run rm -f *.o ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"编译 分别保存上述代码为 hello-world.c、makefile脚本为 Makefile，两个文件放在同级目录，执行 make 会在当前目录下生成 hello-world.run，使用 scp ./hello-world.run root@\u003c开发机ip\u003e:~ 把编译好的二进制文件传输到开发机，最后使用 ssh 登录到开发机上家目录执行 ./hello-world.run 即可看到输出结果。 至此，开发环境和开发板打通。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["database"],"content":"数据库 实现数据持久化 使用完整的管理系统统一管理，易于查询 补充一句: 使用数据库并不比把数据保存到文件性能好，数据库的优点在于其结构化的数据存储和管理查询引擎，解决数据增、删、改、查中的同步问题以及为表的权限管理等问题。 数据库概念： DB(数据库)：存储数据的仓库，保存一系列有组织的数据 DBMS(数据库管理系统)：数据库通过 DBMS 创建和操作的容器 SQL(结构化查询语言)：专门用来与数据库通信的语言 常见数据库：MySQL、Oracle、DB2、SqlServer 等 ","date":"2017-06-28","objectID":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/:1:0","tags":["db","sql","mysql","数据库"],"title":"Sql语句整理","uri":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/"},{"categories":["database"],"content":"SQL SQL (Structural query language) —— 结构查询语言，其具有以下优点： 不是某个特定数据库供应商专用语言，几乎所有 DBMS 都支持 SQL 简单易学、语言灵活 SQL 语句可以分为以下三种类型： DML(Data Manipulation Language) 数据操纵语言 DDL (Data Definition Language) 数据定义语言 dcl (Data Control Language) 数据控制语言 ","date":"2017-06-28","objectID":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/:2:0","tags":["db","sql","mysql","数据库"],"title":"Sql语句整理","uri":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/"},{"categories":["database"],"content":"DML 用于查询与修改数据记录，包括如下 SQL 语句： INSERT: 添加数据到数据库中 UPDATE: 修改数据库中的数据 DELETE: 删除数据库中的数据 SELECT: 选择数据库中的数据 ","date":"2017-06-28","objectID":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/:2:1","tags":["db","sql","mysql","数据库"],"title":"Sql语句整理","uri":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/"},{"categories":["database"],"content":"DDL DDL 用于定义数据库的结构，比如创建、修改、删除数据库对象，包括以下SQL语句 CREATE TABLE: 创建数据库表 ALTER TABLE: 更改表结构、添加、删除、修改列长度 DROP TABLE: 删除表 CREATE INDEX: 在表上建立索引 DROP INDEX: 删除索引 ","date":"2017-06-28","objectID":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/:2:2","tags":["db","sql","mysql","数据库"],"title":"Sql语句整理","uri":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/"},{"categories":["database"],"content":"DCL DCL 用来控制数据库的访问，包括如下 SQL 语句： GRANT: 授予访问权限 REVOKE: 撤销访问权限 COMMIT: 提交事务处理 ROLLBACK: 事务处理回退 SAVEPOINT: 设置保存点 LOCK: 对数据库的特定部分进行锁定 ","date":"2017-06-28","objectID":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/:2:3","tags":["db","sql","mysql","数据库"],"title":"Sql语句整理","uri":"/2017/06/0001-sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/"},{"categories":null,"content":"01：001-010 当编译发现大量错误的时候，从第一个看起，一个一个的解决，不要急着去看下一个错误，往往后面的错误都是由于前面的错误引起的，第一个解决后很可能都解决了。比如我们可能就写错了一行代码，编译提示几百个错误，你只要把这一行纠正了，其他错误也就没了。 定时器是个好东西，学会好使用它，有时候用QTimer::singleShot单次定时器和QMetaObject::invokeMethod可以解决意想不到的问题。比如在窗体初始化的时候加载一个耗时的操作，很容易卡主界面的显示，要在加载完以后才会显示界面，这就导致了体验很卡不友好的感觉，此时你可以将耗时的加载（有时候这些加载又必须在主线程，比如用QStackWidget堆栈窗体加载一些子窗体），延时或者异步进行加载，这样就会在界面显示后去执行，而不是卡住主界面。 //异步执行load函数 QMetaObject::invokeMethod(this, \"load\", Qt::QueuedConnection); //延时10毫秒执行load函数 QTimer::singleShot(10, this, SLOT(load())); 默认QtCreator是单线程编译，可能设计之初考虑到尽量不过多占用系统资源，而现在的电脑都是多核心的，默认msvc编译器是多线程编译的不需要手动设置，而对于其他编译器，需要手动设置才行。 方法一：在每个项目的构建设置中（可以勾选一个 shadow build 的页面地方）的build步骤，make arguments增加一行 -j16 即可，此设置会保存在pro.user文件中，一旦删除就需要重新设置，不建议此方法； 方法二：在构建套件的环境中增加，工具-\u003e选项-\u003e构建套件(kits)-\u003e选中一个构建套件-\u003eenvironment-\u003e右侧change按钮-\u003e打开的输入框中填入 MAKEFLAGS=-j4 ， 这样就可以不用每次设置多线程编译，只要是应用该构件套件的项目都会加上这个编译参数； 注意：-j后面接的是电脑的核心数，写多了不会有效果，要自己看下电脑的参数，或者填个-j4就行，毕竟现在电脑4核心应该是最基本的； 大概从2019年开始的新版本的QtCreator默认已经会根据电脑的核心自动设置多线程编译，比如识别到你的电脑是16核心的就会默认设置-j16参数进行编译； 如果你想顺利用QtCreator部署安卓程序，首先你要在 Android Studio 里面配置成功，编译一个程序能够在手机上或者模拟器中跑起来，把坑全部趟平。 很多时候找到Qt对应封装的方法后，记得多看看该函数的重载，多个参数的，你会发现不一样的世界，有时候会恍然大悟，原来Qt已经帮我们封装好了，比如QString、QColor的重载参数极其丰富，很多你做梦都想要的功能就在里面。 可以在pro文件中写上版本号、程序图标、产品名称、版权所有、文件说明等信息（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件。对于早期的Qt4版本你可以手动写rc文件实现。 #程序版本 VERSION = 2025.10.01 #程序图标 RC_ICONS = main.ico #产品名称 QMAKE_TARGET_PRODUCT = quc #版权所有 QMAKE_TARGET_COPYRIGHT = feiyangqingyun #文件说明 QMAKE_TARGET_DESCRIPTION = QQ: 517216493 WX: feiyangqingyun 管理员运行程序，限定在MSVC编译器，在项目pro文件中增加如下代码。 QMAKE_LFLAGS += /MANIFESTUAC:\"level='requireAdministrator' uiAccess='false'\" #以管理员运行 QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,\"5.01\" #VS2013 在XP运行 运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上一行CONFIG += console，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，一般没法正常运行的程序都会打印一些提示信息缺啥之类的。 TEMPLATE = app MOC_DIR = temp/moc RCC_DIR = temp/rcc UI_DIR = temp/ui OBJECTS_DIR = temp/obj #就是下面这行用来设置运行文件附带调试输出窗口 CONFIG += console 绘制平铺背景QPainter::drawTiledPixmap，绘制圆角矩形QPainter::drawRoundedRect()，而不是QPainter::drawRoundRect()，这两个函数非常容易搞混。 指定控件移除旧的样式。 //移除原有样式 style()-\u003eunpolish(ui-\u003ebtn); //必须要有下面这行不然还是不会卸载 ui-\u003ebtn-\u003esetStyleSheet(\"\"); //重新设置新的该控件的样式。 style()-\u003epolish(ui-\u003ebtn); ","date":"0001-01-01","objectID":"/1/01/qt/:0:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"02：011-020 获取类的属性和方法 //拿到控件元对象 const QMetaObject *metaObject = widget-\u003emetaObject(); //所有属性的数量 int propertyCount = metaObject-\u003epropertyCount(); //propertyOffset是自定义的属性开始的位置 int propertyOffset = metaObject-\u003epropertyOffset(); //循环取出控件的自定义属性, int i = 0 表示所有属性 for (int i = propertyOffset; i \u003c propertyCount; ++i) { QMetaProperty metaProperty = metaObject-\u003eproperty(i); const char *name = metaProperty.name(); const char *type = metaProperty.typeName(); QVariant value = widget-\u003eproperty(name); qDebug() \u003c\u003c name \u003c\u003c type \u003c\u003c value; } //所有方法的数量 int methodCount = metaObject-\u003emethodCount(); //methodOffset是自定义的方法开始的位置 int methodOffset = metaObject-\u003emethodOffset(); //循环取出控件的自定义方法, int i = 0 表示所有方法 for (int i = methodOffset; i \u003c methodCount; ++i) { QMetaMethod metaMethod = metaObject-\u003emethod(i); const char *name = metaMethod.name(); const char *type = metaMethod.typeName(); qDebug() \u003c\u003c name \u003c\u003c type; } Qt内置图标封装在QStyle中，大概七十多个图标，可以直接拿来用。 SP_TitleBarMenuButton, SP_TitleBarMinButton, SP_TitleBarMaxButton, SP_TitleBarCloseButton, SP_MessageBoxInformation, SP_MessageBoxWarning, SP_MessageBoxCritical, SP_MessageBoxQuestion, ... //下面这样取出来使用就行 QPixmap pixmap = this-\u003estyle()-\u003estandardPixmap(QStyle::SP_TitleBarMenuButton); ui-\u003elabel-\u003esetPixmap(pixmap); 根据操作系统位数判断加载 win32 { contains(DEFINES, WIN64) { DESTDIR = $$PWD/../bin64 } else { DESTDIR = $$PWD/../bin32 } } Qt5增强了很多安全性验证，如果出现setGeometry: Unable to set geometry，请将该控件的可见移到加入布局之后。 可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可。 QPushButton *btn = new QPushButton; btn-\u003eresize(30, ui-\u003elineEdit-\u003eheight()); QHBoxLayout *layout = new QHBoxLayout(ui-\u003elineEdit); layout-\u003esetMargin(0); layout-\u003eaddStretch(); layout-\u003eaddWidget(btn); 对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果。 巧妙的使用 findChildren 可以查找该控件下的所有子控件。 findChild 为查找单个。 //查找指定类名objectName的控件 QList\u003cQWidget *\u003e widgets = fatherWidget.findChildren\u003cQWidget *\u003e(\"widgetname\"); //查找所有QPushButton QList\u003cQPushButton *\u003e allPButtons = fatherWidget.findChildren\u003cQPushButton *\u003e(); //查找一级子控件,不然会一直遍历所有子控件 QList\u003cQPushButton *\u003e childButtons = fatherWidget.findChildren\u003cQPushButton *\u003e(QString(), Qt::FindDirectChildrenOnly); 巧妙的使用inherits判断是否属于某种类。 QTimer *timer = new QTimer; // QTimer inherits QObject timer-\u003einherits(\"QTimer\"); // returns true timer-\u003einherits(\"QObject\"); // returns true timer-\u003einherits(\"QAbstractButton\"); // returns false 使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-\u003edynamicPropertyNames()列出所有弱属性名称，然后通过widget-\u003eproperty(“name”)取出对应的弱属性的值。 在开发时, 无论是出于维护的便捷性, 还是节省内存资源的考虑, 都应该有一个 qss 文件来存放所有的样式表, 而不应该将 setStyleSheet 写的到处都是。如果是初学阶段或者测试阶段可以直接UI上右键设置样式表，正式项目还是建议统一到一个qss样式表文件比较好，统一管理。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"03：021-030 如果出现Z-order assignment: is not a valid widget.错误提示，用记事本打开对应的ui文件，找到为空的地方，删除即可。 善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来。特别注意的是第二个参数是QVariant类型，这就不要太灵活了，意味着可以附带万能的数据比如结构体，这样就可以带一堆数据了，而不是一个数据。比如下拉框选择学号，对应元素可以附带该学生的姓名、班级、成绩等。很多人以为只能附带QString、int之类的数据，因为通常的用法也是那两种。 QStringList listVideoOpenInterval, listVideoOpenIntervalx; listVideoOpenInterval \u003c\u003c \"0.0 秒\" \u003c\u003c \"0.1 秒\" \u003c\u003c \"0.3 秒\" \u003c\u003c \"0.5 秒\" \u003c\u003c \"1.0 秒\" \u003c\u003c \"2.0 秒\"; listVideoOpenIntervalx \u003c\u003c \"0\" \u003c\u003c \"100\" \u003c\u003c \"300\" \u003c\u003c \"500\" \u003c\u003c \"1000\" \u003c\u003c \"2000\"; for (int i = 0; i \u003c listVideoOpenInterval.count(); ++i) { ui-\u003ecboxVideoOpenInterval-\u003eaddItem(listVideoOpenInterval.at(i), listVideoOpenIntervalx.at(i)); } //取出对应的值 int indexVideoOpenInterval = ui-\u003ecboxVideoOpenInterval-\u003ecurrentIndex(); indexVideoOpenInterval = ui-\u003ecboxVideoOpenInterval-\u003eitemData(indexVideoOpenInterval).toInt(); 如果用了webengine模块，发布程序的时候带上QtWebEngineProcess.exe、translations文件夹、resources文件夹，不然无法正常运行。 在MFC程序或者VB/C#等窗体程序中，每个控件都有一个句柄，而且用句柄工具移过去会自动识别，但是在Qt程序中默认Qt是一个窗体一个句柄，如果要让每个控件都拥有独立的句柄，在main函数中要做如下设置。 int main(int argc, char *argv[]) { QApplication a(argc, argv); a.setAttribute(Qt::AA_NativeWindows); } Qt编写的Android程序防止程序被关闭。 #if defined(Q_OS_ANDROID) QAndroidService a(argc, argv); return a.exec() #else QApplication a(argc, argv); return a.exec(); #endif 可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置， *::down-arrow{} *::menu-indicator{} *::up-arrow:disabled{} *::up-arrow:off{} 可以指定位置设置背景图片。 QMainWindow \u003e .QWidget { background-color: gainsboro; background-image: url(:/images/xxoo.png); background-position: top right; background-repeat: no-repeat } 嵌入式linux运行Qt程序 //Qt4写法 ./HelloQt -qws \u0026 //Qt5写法 xcb 可以改成 linuxfb eglfs vnc wayland 等,有哪个就用哪个挨个测试 ./HelloQt --platform xcb ./HelloQt --platform linuxfb ./HelloQt --platform wayland 如果发现QtCreator中的构建套件不正常了或者坏了（比如不能正确识别环境中的qmake或者编译器、打开项目不能正常生成影子构建目录），请找到两个目录（C:\\Users\\Administrator\\AppData\\Local\\QtProject、C:\\Users\\Administrator\\AppData\\Roaming\\QtProject）删除即可，删除后重新打开QtCreator进行构建套件的配置就行。 QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV Filters安装即可（k-lite或者LAV Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer，并未完整验证，报错提示 Your GStreamer installation is missing a plug-in，需要命令安装 sudo apt-get install ubuntu-restricted-extras）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:3","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"04：031-040 判断编译器类型、编译器版本、操作系统。 //GCC编译器 #ifdef __GNUC__ #if __GNUC__ \u003e= 3 // GCC3.0 以上 //MSVC编译器 #ifdef _MSC_VER #if _MSC_VER \u003e=1000 // VC++4.0 以上 #if _MSC_VER \u003e=1100 // VC++5.0 以上 #if _MSC_VER \u003e=1200 // VC++6.0 以上 #if _MSC_VER \u003e=1300 // VC2003 以上 #if _MSC_VER \u003e=1400 // VC2005 以上 #if _MSC_VER \u003e=1500 // VC2008 以上 #if _MSC_VER \u003e=1600 // VC2010 以上 #if _MSC_VER \u003e=1700 // VC2012 以上 #if _MSC_VER \u003e=1800 // VC2013 以上 #if _MSC_VER \u003e=1900 // VC2015 以上 //Visual Studio版本与MSVC版本号的对应关系 MSC 1.0 _MSC_VER == 100 MSC 2.0 _MSC_VER == 200 MSC 3.0 _MSC_VER == 300 MSC 4.0 _MSC_VER == 400 MSC 5.0 _MSC_VER == 500 MSC 6.0 _MSC_VER == 600 MSC 7.0 _MSC_VER == 700 MSVC++ 1.0 _MSC_VER == 800 MSVC++ 2.0 _MSC_VER == 900 MSVC++ 4.0 _MSC_VER == 1000 (Developer Studio 4.0) MSVC++ 4.2 _MSC_VER == 1020 (Developer Studio 4.2) MSVC++ 5.0 _MSC_VER == 1100 (Visual Studio 97 version 5.0) MSVC++ 6.0 _MSC_VER == 1200 (Visual Studio 6.0 version 6.0) MSVC++ 7.0 _MSC_VER == 1300 (Visual Studio .NET 2002 version 7.0) MSVC++ 7.1 _MSC_VER == 1310 (Visual Studio .NET 2003 version 7.1) MSVC++ 8.0 _MSC_VER == 1400 (Visual Studio 2005 version 8.0) MSVC++ 9.0 _MSC_VER == 1500 (Visual Studio 2008 version 9.0) MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010 version 10.0) MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012 version 11.0) MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013 version 12.0) MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015 version 14.0) MSVC++ 14.1 _MSC_VER == 1910 (Visual Studio 2017 version 15.0) MSVC++ 14.11 _MSC_VER == 1911 (Visual Studio 2017 version 15.3) MSVC++ 14.12 _MSC_VER == 1912 (Visual Studio 2017 version 15.5) MSVC++ 14.13 _MSC_VER == 1913 (Visual Studio 2017 version 15.6) MSVC++ 14.14 _MSC_VER == 1914 (Visual Studio 2017 version 15.7) MSVC++ 14.15 _MSC_VER == 1915 (Visual Studio 2017 version 15.8) MSVC++ 14.16 _MSC_VER == 1916 (Visual Studio 2017 version 15.9) MSVC++ 14.2 _MSC_VER == 1920 (Visual Studio 2019 Version 16.0) MSVC++ 14.21 _MSC_VER == 1921 (Visual Studio 2019 Version 16.1) MSVC++ 14.22 _MSC_VER == 1922 (Visual Studio 2019 Version 16.2) //Borland C++ #ifdef __BORLANDC__ //Cygwin #ifdef __CYGWIN__ #ifdef __CYGWIN32__ //mingw #ifdef __MINGW32__ //windows #ifdef _WIN32 //32bit #ifdef _WIN64 //64bit #ifdef _WINDOWS //图形界面程序 #ifdef _CONSOLE //控制台程序 //Windows（95/98/Me/NT/2000/XP/Vista）和Windows CE都定义了 #if (WINVER \u003e= 0x030a) // Windows 3.1以上 #if (WINVER \u003e= 0x0400) // Windows 95/NT4.0以上 #if (WINVER \u003e= 0x0410) // Windows 98以上 #if (WINVER \u003e= 0x0500) // Windows Me/2000以上 #if (WINVER \u003e= 0x0501) // Windows XP以上 #if (WINVER \u003e= 0x0600) // Windows Vista以上 //_WIN32_WINNT 内核版本 #if (_WIN32_WINNT \u003e= 0x0500) // Windows 2000以上 #if (_WIN32_WINNT \u003e= 0x0501) // Windows XP以上 #if (_WIN32_WINNT \u003e= 0x0600) // Windows Vista以上 在pro中判断Qt版本及构建套件位数 #打印版本信息 message(qt version: $$QT_VERSION) #判断当前qt版本号 QT_VERSION = $$[QT_VERSION] QT_VERSION = $$split(QT_VERSION, \".\") QT_VER_MAJ = $$member(QT_VERSION, 0) QT_VER_MIN = $$member(QT_VERSION, 1) #下面是表示 Qt5.5及以上版本 greaterThan(QT_VER_MAJ, 4) { greaterThan(QT_VER_MIN, 4) { #自己根据需要做一些处理 }} #QT_ARCH是Qt5新增的,在Qt4上没效果 #打印当前Qt构建套件的信息 message($$QT_ARCH) #表示arm平台构建套件 contains(QT_ARCH, arm) {} #表示32位的构建套件 contains(QT_ARCH, i386) {} #表示64位的构建套件 contains(QT_ARCH, x86_64) {} #其实Qt内置了主版本号和子版本号变量 #判断当前qt版本号 message($$QT_ARCH : $$QT_VERSION -\u003e $$QT_MAJOR_VERSION . $$QT_MINOR_VERSION) #下面的含义是如果版本 \u003c 4.8 lessThan(QT_MAJOR_VERSION, 5) { lessThan(QT_MINOR_VERSION, 8) { #这里放要做的处理 }} #下面的含义是如果版本 \u003c 5.12.0 REQ_QT_MAJOR = 5 REQ_QT_MINOR = 12 REQ_QT_PATCH = 0 lessThan(QT_MAJOR_VERSION, $$REQ_QT_MAJOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_MINOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_PATCH) { #这里放要做的处理 } #下面的含义是如果版本 \u003e= 5.5 greaterThan(QT_MAJOR_VERSION, 4) { greaterThan(QT_MINOR_VERSION, 4) { #这里放要做的处理 }} //代码中判断版本不要太简单 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) //这里放要做的处理 #endif //下面表示 \u003e= 5.0.0 #if QT_VERSION \u003e= 0x050000 ... #endif //下面表示 \u003c 5.12.10 #if QT_VERSION \u003c 0x050C0A ... #endif Qt最小化后恢复界面可能会出现假死冻结现象，加上代码 void showEvent(QShowEvent *e) { setAttribute(Qt::","date":"0001-01-01","objectID":"/1/01/qt/:0:4","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"05：041-050 如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库。 QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\"); db.setDatabaseName(\":memory:\"); 清空数据表并重置自增ID，sql = truncate table table_name。 QtChart模块从Qt5.7开始自带，最低编译要求Qt5.4。在安装的时候记得勾选，默认不勾选。使用该模块需要引入命名空间。 #include \u003cQChartView\u003e QT_CHARTS_USE_NAMESPACE class CustomChart : public QChartView QPushButton左对齐文字，需要设置样式表QPushButton{text-align:left;} QLabel有三种设置文本的方法，掌握好Qt的属性系统，举一反三，可以做出很多效果。 //常规办法 ui-\u003elabel-\u003esetText(\"hello\"); //取巧办法 ui-\u003elabel-\u003esetProperty(\"text\", \"hello\"); //属性大法 ui-\u003elabel-\u003esetStyleSheet(\"qproperty-text:hello;\"); 巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行。 QEventLoop loop; connect(reply, SIGNAL(finished()), \u0026loop, SLOT(quit())); loop.exec(); 多种预定义变量 #if (defined webkit) || (defined webengine)，去掉生成空的debug和release目录，在pro文件中加一行 CONFIG -= debug_and_release。 新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About Plugins。也可以设置代码检查级别，Tools》Options 》C++ 》Code Model。 QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据。 如果数据量很小，也可以采用如下方法： //主动加载所有数据,不然获取到的行数\u003c=256 while(model-\u003ecanFetchMore()) { model-\u003efetchMore(); } 如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，比如自由拉伸边框，可以使用 setWindowFlags(Qt::CustomizeWindowHint)，这样会保留一个系统白边框。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:5","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"06：051-060 在某些http post数据的时候，如果采用的是\u0026字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码。 QString content = \"测试中文\"; QString note = content.toUtf8().toPercentEncoding(); Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启。 CONFIG += resources_big Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一。 方法一：设置属性 this-\u003esetAttribute(Qt::WA_StyledBackground, true); 方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。 方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。 void Widget::paintEvent(QPaintEvent *) { QStyleOption option; option.initFrom(this); QPainter painter(this); style()-\u003edrawPrimitive(QStyle::PE_Widget, \u0026option, \u0026painter, this); } 有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的。 在使用QFile的过程中，不建议频繁的打开文件写入然后再关闭文件，比如间隔5ms输出日志，IO性能瓶颈很大，这种情况建议先打开文件不要关闭，等待合适的时机比如析构函数中或者日期变了需要重新变换日志文件的时候关闭文件。不然短时间内大量的打开关闭文件会很卡，文件越大越卡。 在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接。 int fd = tcpSocket-\u003esocketDescriptor(); int keepAlive = 1; //开启keepalive属性,缺省值:0(关闭) int keepIdle = 5; //如果在5秒内没有任何数据交互,则进行探测,缺省值:7200(s) int keepInterval = 2; //探测时发探测包的时间间隔为2秒,缺省值:75(s) int keepCount = 2; //探测重试的次数,全部超时则认定连接失效,缺省值:9(次) setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)\u0026keepAlive, sizeof(keepAlive)); setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, (void *)\u0026keepIdle, sizeof(keepIdle)); setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, (void *)\u0026keepInterval, sizeof(keepInterval)); setsockopt(fd, SOL_TCP, TCP_KEEPCNT, (void *)\u0026keepCount, sizeof(keepCount)); 如果程序打包好以后弹出提示 This application failed to start because it could not find or load the Qt platform plugin 一般都是因为platforms插件目录未打包或者打包错了的原因导致的。 非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的（后面发现我在刚学Qt的时候也发布了一些demo到网上也是tr包含中文的，当时就狠狠的打了自己一巴掌），tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理。 很多人Qt和Qt Creator傻傻分不清楚，经常问Qt什么版本结果发一个Qt Creator的版本过来，Qt Creator是使用Qt编写的集成开发环境IDE，和宇宙第一的Visual Studio一样，他可以是msvc编译器的（WIN对应的Qt集成安装环境中自带的Qt Cerator是msvc的），也可以是mingw编译的，还可以是gcc的。如果是自定义控件插件，需要集成到Qt Creator中，必须保证该插件的动态库文件（dll或者so等文件）对应的编译器和Qt版本以及位数和Qt Creator的版本完全一致才行，否则基本不大可能集成进去。特别注意的是Qt集成环境安装包中的Qt版本和Qt Creator版本未必完全一致，必须擦亮眼睛看清楚，有些是完全一致的。 超过两处相同处理的代码，建议单独写成函数。代码尽量规范精简，比如 if(a == 123) 要写成 if (123 == a)，值在前面，再比如 if (ok == true) 要写成 if (ok)，if (ok == false) 要写成 if (!ok)等。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:6","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"07：061-070 很多人问Qt嵌入式平台用哪个好，这里统一回答（当前时间节点2018年）：imx6+335x比较稳定，性能高就用RK3288 RK3399，便宜的话就用全志H3，玩一玩可以用树莓派香橙派。 对于大段的注释代码，建议用 #if 0 #endif 将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是 #if 0则只要把0改成1即可，开发效率提升很多。 Qt打包发布，有很多办法，Qt5以后提供了打包工具windeployqt（linux上为linuxdeployqt，mac上为macdeployqt）可以很方便的将应用程序打包，使用下来发现也不是万能的，有时候会多打包一些没有依赖的文件，有时候又会忘记打包一些插件尤其是用了qml的情况下，而且不能识别第三方库，比如程序依赖ffmpeg，则对应的库需要自行拷贝，终极大法就是将你的可执行文件复制到Qt安装目录下的bin目录，然后整个一起打包，挨个删除不大可能依赖的组件，直到删到正常运行为止。 Qt中的动画，底层用的是QElapsedTimer定时器来完成处理，比如产生一些指定规则算法的数据，然后对属性进行处理。 在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致。 QRect rect(-radius, -radius, radius * 2, radius * 2); //以下两种方法二选一,其实绘制360度的圆弧=绘制无背景的圆形 painter-\u003edrawArc(rect, 0, 360 * 16); painter-\u003edrawEllipse(rect); 不要把d指针看的很玄乎，其实就是在类的实现文件定义了一个私有类，用来存放局部变量，个人建议在做一些小项目时，没有太大必要引入这种机制，会降低代码可读性，增加复杂性，新手接受项目后会看的很懵逼。 很多人在绘制的时候，设置画笔以为就只可以设置个单调的颜色，其实QPen还可以设置brush，这样灵活性就提高不知道多少倍，比如设置QPen的brush以后，可以使用各种渐变，比如绘制渐变颜色的进度条和文字等，而不再是单调的一种颜色。 很多控件都带有viewport，比如QTextEdit/QTableWidget/QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport()设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-\u003eviewport()-\u003esetStyleSheet(“background-color:transparent;”);而不是scrollArea-\u003esetStyleSheet(“QScrollArea{background-color:transparent;}”); 有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置 setAttribute(Qt::WA_Hover, true); Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等。 QDateTime dateTime; QString dateTime_str = dateTime.currentDateTime().toString(\"yyyy-MM-dd hh:mm:ss\"); //从字符串转换为毫秒（需完整的年月日时分秒） datetime.fromString(\"2011-09-10 12:07:50:541\", \"yyyy-MM-dd hh:mm:ss:zzz\").toMSecsSinceEpoch(); //从字符串转换为秒（需完整的年月日时分秒） datetime.fromString(\"2011-09-10 12:07:50:541\", \"yyyy-MM-dd hh:mm:ss:zzz\").toTime_t(); //从毫秒转换到年月日时分秒 datetime.fromMSecsSinceEpoch(1315193829218).toString(\"yyyy-MM-dd hh:mm:ss:zzz\"); //从秒转换到年月日时分秒（若有zzz，则为000） datetime.fromTime_t(1315193829).toString(\"yyyy-MM-dd hh:mm:ss[:zzz]\"); ","date":"0001-01-01","objectID":"/1/01/qt/:0:7","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"08：071-080 在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用 at() 取值而不是 [] 操作符，在官方书籍《C++ GUI Qt 4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用 at() 与使用 [] 操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用 at() 函数而不用 [] 操作符，因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而 at() 函数则不被允许出现在一个赋值的左边。 如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息。 QDialog dialog; dialog.setWindowModality(Qt::WindowModal); dialog.exec(); 安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns); 在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制。 将 QApplication::style() 对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication::style()-\u003edrawControl 的第4个参数如果不设置，则绘制出来的控件不会应用样式表。 心中有坐标，万物皆painter，强烈建议在学习自定义控件绘制的时候，将qpainter.h头文件中的函数全部看一遍、试一遍、理解一遍，这里边包含了所有Qt内置的绘制的接口，对应的参数都试一遍，你会发现很多新大陆，会一定程度上激发你的绘制的兴趣，犹如神笔马良一般，策马崩腾遨游代码绘制的世界。 在使用setItemWidget或者setCellWidget的过程中，有时候会发现设置的控件没有居中显示而是默认的左对齐，而且不会自动拉伸填充，对于追求完美的程序员来说，这个可不大好看，有个终极通用办法就是，将这个控件放到一个widget的布局中，然后将widget添加到item中，这样就完美解决了，而且这样可以组合多个控件产生复杂的控件。 //实例化进度条控件 QProgressBar *progress = new QProgressBar; //增加widget+布局巧妙实现居中 QWidget *widget = new QWidget; QHBoxLayout *layout = new QHBoxLayout; layout-\u003esetSpacing(0); layout-\u003esetMargin(0); layout-\u003eaddWidget(progress); widget-\u003esetLayout(layout); ui-\u003etableWidget-\u003esetCellWidget(0, 0, widget); 很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色。 //根据背景色自动计算合适的前景色 double gray = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255; QColor textColor = gray \u003e 0.5 ? Qt::black : Qt::white; 对QTableView、QTableWidget、QTreeView、QTreeWidget禁用列拖动。 #if (QT_VERSION \u003c QT_VERSION_CHECK(5,0,0)) ui-\u003etableView-\u003ehorizontalHeader()-\u003esetResizeMode(0, QHeaderView::Fixed); ui-\u003etreeView-\u003eheader()-\u003esetResizeMode(0, QHeaderView::Fixed); #else ui-\u003etableView-\u003ehorizontalHeader()-\u003esetSectionResizeMode(0, QHeaderView::Fixed); ui-\u003etreeView-\u003eheader()-\u003esetSectionResizeMode(0, QHeaderView::Fixed); #endif 从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0 ","date":"0001-01-01","objectID":"/1/01/qt/:0:8","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"09：081-090 Qt中的QColor对颜色封装的很完美，支持各种转换，比如rgb、hsb、cmy、hsl，对应的是toRgb、toHsv、toCmyk、toHsl，还支持透明度设置，颜色值还能转成16进制格式显示。 QColor color(255, 0, 0, 100); qDebug() \u003c\u003c color.name() \u003c\u003c color.name(QColor::HexArgb); //输出 #ff0000 #64ff0000 QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法。 if (variant.typeName() == \"QColor\") { QColor color = variant.value\u003cQColor\u003e(); QFont font = variant.value\u003cQFont\u003e(); QString nodeValue = color.name(QColor::HexArgb); } Qt中的QString和const char *之间转换，最好用toStdString().c_str()而不是toLocal8Bit().constData()，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常。 Qt的信号槽机制非常牛逼，也是Qt的独特的核心功能之一，有时候我们在很多窗体中传递信号来实现更新或者处理，如果窗体层级比较多，比如窗体A的父类是窗体B，窗体B的父类是窗体C，窗体C有个子窗体D，如果窗体A一个信号要传递给窗体D，问题来了，必须先经过窗体B中转到窗体C再到窗体D才行，这样的话各种信号关联信号的connect会非常多而且管理起来比较乱，可以考虑增加一个全局的单例类AppEvent，公共的信号放这里，然后窗体A对应信号绑定到AppEvent，窗体D绑定AppEvent的信号到对应的槽函数即可，干净清爽整洁。 QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets.qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突。 Qt中有个全局的焦点切换信号focusChanged，可以用它做自定义的输入法。Qt4中默认会安装输入法上下文，比如在main函数打印a.inputContext会显示值，这个默认安装的输入法上下文，会拦截两个牛逼的信号QEvent::RequestSoftwareInputPanel和QEvent::CloseSoftwareInputPanel，以至于就算你安装了全局的事件过滤器依然识别不到这两个信号，你只需要在main函数执行a.setInputContext(0)即可，意思是安装输入法上下文为空。Qt5.7以后提供了内置的输入法，可以通过在main函数最前面加上 qputenv(“QT_IM_MODULE”, QByteArray(“qtvirtualkeyboard”)); 来启用。 在Qt5.10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-\u003etableView-\u003ehorizontalHeader()-\u003esetMinimumSectionSize(0); Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT += gui-private才能使用。 #include \"QtGui/private/qzipreader_p.h\" #include \"QtGui/private/qzipwriter_p.h\" QZipReader reader(dirPath); QString path(\"\"); //解压文件夹到当前目录 reader.extractAll(path); //文件夹名称 QZipReader::FileInfo fileInfo = reader.entryInfoAt(0); //解压文件 QFile file(filePath); file.open(QIODevice::WriteOnly); file.write(reader.fileData(QString::fromLocal8Bit(\"%1\").arg(filePath))); file.close(); reader.close(); QZipWriter *writer = new QZipWriter(dirPath); //添加文件夹 writer-\u003eaddDirectory(unCompress); //添加文件 QFile file(filePath); file.open(QIODevice::ReadOnly); writer-\u003eaddFile(data, file.readAll()); file.close(); writer-\u003eclose(); 理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理。 在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:9","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"10：091-100 数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题。 新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写。 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,0,0)) void incomingConnection(qintptr handle); #else void incomingConnection(int handle); #endif Qt支持所有的界面控件比如QPushButton、QLineEdit自动关联 on_控件名_信号(参数) 信号槽，比如按钮的单击信号 on_pushButton_clicked()，然后直接实现槽函数即可。 QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染。 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,4,0)) //下面两种方法都可以,Qt默认采用的是AA_UseDesktopOpenGL QCoreApplication::setAttribute(Qt::AA_UseOpenGLES); //QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL); #endif QApplication a(argc, argv); 另外一个方法解决 全屏+QWebEngineView控件一起会产生右键菜单无法弹出的bug,需要上移一个像素 QRect rect = qApp-\u003edesktop()-\u003egeometry(); rect.setY(-1); rect.setHeight(rect.height()); this-\u003esetGeometry(rect); QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值。 QStyle::sliderValueFromPosition(minimum(), maximum(), event-\u003ex(), width()); 用QFile读写文件的时候，推荐用QTextStream文件流的方式来读写文件，速度快很多，基本上会有30%的提升，文件越大性能区别越大。 //从文件加载英文属性与中文属性对照表 QFile file(\":/propertyname.txt\"); if (file.open(QFile::ReadOnly)) { //QTextStream方法读取速度至少快百分之30 #if 0 while(!file.atEnd()) { QString line = file.readLine(); appendName(line); } #else QTextStream in(\u0026file); while (!in.atEnd()) { QString line = in.readLine(); appendName(line); } #endif file.close(); } 用QFile.readAll()读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果。 void frmMain::initStyle() { //加载样式表 QString qss; //QFile file(\":/qss/psblack.css\"); //QFile file(\":/qss/flatwhite.css\"); QFile file(\":/qss/lightblue.css\"); if (file.open(QFile::ReadOnly)) { #if 1 //用QTextStream读取样式文件不用区分文件编码 带bom也行 QStringList list; QTextStream in(\u0026file); //in.setCodec(\"utf-8\"); while (!in.atEnd()) { QString line; in \u003e\u003e line; list \u003c\u003c line; } qss = list.join(\"\\n\"); #else //用readAll读取默认支持的是ANSI格式,如果不小心用creator打开编辑过了很可能打不开 qss = QLatin1String(file.readAll()); #endif QString paletteColor = qss.mid(20, 7); qApp-\u003esetPalette(QPalette(QColor(paletteColor))); qApp-\u003esetStyleSheet(qss); file.close(); } } QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可。 QString s1, s2; s1 = \"666.5567124\"; s2.setNum(888.5632123, 'f', 7); qDebug() \u003c\u003c qSetRealNumberPrecision(10) \u003c\u003c s1.toDouble() \u003c\u003c s2.toDouble(); 用QScriptValueIterator解析数据的时候，会发现总是会多一个节点内容，并且内容为空，如果需要跳过则增加一行代码。 while (it.hasNext()) { it.next(); if (it.flags() \u0026 QScriptValue::SkipInEnumeration) continue; qDebug() \u003c\u003c it.name(); } setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:10","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"11：101-110 如果需要在尺寸改变的时候不重绘窗体，则设置属性即可 this-\u003esetAttribute(Qt::WA_StaticContents, true); 这样可以避免对已经显示区域的重新绘制。 默认程序中获取焦点以后会有虚边框，如果看着觉得碍眼不舒服可以去掉，设置样式即可：setStyleSheet(\"*{outline:0px;}\"); Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget。 void QUIHelper::initTableView(QTableView *tableView, int rowHeight, bool headVisible, bool edit) { //奇数偶数行颜色交替 tableView-\u003esetAlternatingRowColors(false); //垂直表头是否可见 tableView-\u003everticalHeader()-\u003esetVisible(headVisible); //选中一行表头是否加粗 tableView-\u003ehorizontalHeader()-\u003esetHighlightSections(false); //最后一行拉伸填充 tableView-\u003ehorizontalHeader()-\u003esetStretchLastSection(true); //行标题最小宽度尺寸 tableView-\u003ehorizontalHeader()-\u003esetMinimumSectionSize(0); //行标题最大高度 tableView-\u003ehorizontalHeader()-\u003esetMaximumHeight(rowHeight); //默认行高 tableView-\u003everticalHeader()-\u003esetDefaultSectionSize(rowHeight); //选中时一行整体选中 tableView-\u003esetSelectionBehavior(QAbstractItemView::SelectRows); //只允许选择单个 tableView-\u003esetSelectionMode(QAbstractItemView::SingleSelection); //表头不可单击 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,0,0)) tableView-\u003ehorizontalHeader()-\u003esetSectionsClickable(false); #else tableView-\u003ehorizontalHeader()-\u003esetClickable(false); #endif //鼠标按下即进入编辑模式 if (edit) { tableView-\u003esetEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked); } else { tableView-\u003esetEditTriggers(QAbstractItemView::NoEditTriggers); } } 在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则。 TEMPLATE = subdirs #设置ordered参数以后会依次编译 projA projB projC CONFIG += ordered SUBDIRS += projA SUBDIRS += projB SUBDIRS += projC #还可以通过设置depends指定某个项目依赖 比如下面指定projB依赖projA projB.depends = projA projC.depends = projA projD.depends = projC MSVC编译器的选择说明 如果是32位的Qt则编译器选择x86开头的 如果是64位的Qt则编译器选择amd64开头的 具体是看安装的Qt构建套件版本以及目标运行平台的系统位数和架构 一般现在的电脑默认以64位的居多，选择amd64即可 如果用户需要兼容32位的系统则建议选择32位的Qt，这样即可在32位也可以在64位系统运行 诸葛大佬补充：x86/x64都是编译环境和运行环境相同，没有或。带下划线的就是交叉编译，前面是编译环境，后面是运行环境。 名称 说明 x86 32/64位系统上编译在32/64位系统上运行 x86_amd64 32/64位系统上编译在64位系统上运行 x86_arm 32/64位系统上编译在arm系统上运行 amd64 64位系统上编译在64位系统上运行 amd64_x86 64位系统上编译在32/64位系统上运行 amd64_arm 64位系统上编译在arm系统上运行 很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置。 QDialog dialog; dialog.setWindowModality(Qt::WindowModal); 很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源。 如果你没有使用wait***函数的话，大部分的界面卡都出在数据处理和展示中，比如传过来的是一张图片的数据，你需要将这些数据转成图片，这个肯定是耗时的； 还有就是就收到的数据曲线绘制出来，如果过于频繁或者间隔过短，肯定会给UI造成很大的压力的，最好的办法是解决如何不要频繁绘制UI比如合并数据一起绘制等； 如果是因为绘制UI造成的卡，那多线程也是没啥用的，因为UI只能在主线程； 串口和网络的数据收发默认都是异步的，由操作系统调度的，如果数据处理复杂而且数据量大，你要做的是将数据处理放到多线程中； 如果没有严格的数据同步需求，根本不需要调用wait***之类的函数来立即发送和接收数据，实际需求中大部分的应用场景其实异步收发数据就足够了； 有严格数据同步需求的场景还是放到多线程会好一些，不然你wait***就卡在那边了； 多线程是需要占用系统资源的，理论上来说，如果线程数量超过了CPU的核心数量，其实多线程调度可能花费的时间更多，各位在使用过程中要权衡利弊； 再次强调，不要指望Qt的网络通信支持高并发，最多到1000个能正常工作就万事大吉，一般建议500以内的连接数。有大量高并发的需求请用第三方库比如swoole等。 在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行。 //这种方式设置的无边框窗体在嵌入式设备上无法产生焦点 setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint); //需要在show以后主动激活窗体 w-\u003eshow(); w-\u003eactivateWindow(); QString的replace函数会改变原字符串，切记，他在返回替换后的新字符串的同时也会改变原字符串，我的乖乖！ QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:11","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"12：111-120 在不同的平台上文件路径的斜杠也是不一样的，比如linux系统一般都是 / 斜杠，而在windows上都是 \\ 两个反斜杠，Qt本身程序内部无论在win还是linux都支持 / 斜杠的路径，但是一些第三方库的话可能需要转换成对应系统的路径，这就需要用到斜杠转换，Qt当然内置类方法。 QString path = \"C:/temp/test.txt\"; path = QDir::toNativeSeparators(path); //输出 C:\\\\temp\\\\test.txt QString path = \"C:\\\\temp\\\\test.txt\"; path = QDir::toNativeSeparators(path); //输出 C:/temp/test.txt 巧用QMetaObject::invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, “fun”, Qt::QueuedConnection); 这种方式来就可以。 invokeMethod函数有很多重载参数，可以传入返回值和执行方法的参数等。 invokeMethod函数不仅支持槽函数还支持信号，而且这逼居然是线程安全的，可以在线程中放心使用，牛逼！ 测试下来发现只能执行signals或者slots标识的方法。 默认可以执行private(protected/public) slots下的函数，但是不能执行private(protected/public)下的函数。 毛总补充：前提必须是slots或者signals标注的函数，不是标注的函数不在元信息导致无法查找，执行之后会提示No such method。 2021-11-06补充：如果要执行private(protected/public)下的函数，需要函数前面加上 Q_INVOKABLE 关键字，今天又学到了，必须加鸡腿。 其实这样看下来，就是任何方法函数都能执行了，这就超越了private(protected/public)的权限限定了，相当于一个类的私有函数用了 Q_INVOKABLE 关键字修饰也可以被 invokeMethod 执行，哇咔咔。 //头文件声明信号和槽函数 signals: void sig_test(int type,double value); private slots: void slot_test(int type, double value); private: Q_INVOKABLE void fun_test(int type, double value); //构造函数关联信号槽 connect(this, SIGNAL(sig_test(int, double)), this, SLOT(slot_test(int, double))); //单击按钮触发信号和槽,这里是同时举例信号槽都可以 void MainWindow::on_pushButton_clicked() { QMetaObject::invokeMethod(this, \"sig_test\", Q_ARG(int, 66), Q_ARG(double, 66.66)); QMetaObject::invokeMethod(this, \"slot_test\", Q_ARG(int, 88), Q_ARG(double, 88.88)); QMetaObject::invokeMethod(this, \"fun_test\", Q_ARG(int, 99), Q_ARG(double, 99.99)); } //会打印 66 66.66、88 88.88 void MainWindow::slot_test(int type, double value) { qDebug() \u003c\u003c type \u003c\u003c value; } //会打印 99.99 void MainWindow::fun_test(int type, double value) { qDebug() \u003c\u003c type \u003c\u003c value; } Qt5中的信号是public的，可以在需要的地方直接emit即可，而在Qt4中信号是protected的，不能直接使用，需要定义一个public函数来emit。 Qt5.15版本开始官方不再提供安装包，只提供源码，可以自行编译或者在线安装，估计每次编译各种版本太麻烦，更多的是为了统计收集用户使用信息比如通过在线安装，后期可能会逐步加大商业化力度。 有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有 QT += 的方式添加的模块，可以用 contains来判断。 qtHaveModule(webenginewidgets) { message(\"当前Qt库有找到 webenginewidgets 模块\") } !qtHaveModule(webkit) { message(\"当前Qt库没有找到 webkit 模块\") } contains(QT, network) { message(\"当前项目已经引入 network 模块\") } !contains(QT, widgets) { message(\"当前项目没有引入 widgets 模块\") } c++11新引入了原始字符串格式，用户避免在字符串中加入转义字符\\，可以用于表示json字符串等场景。 QString s1 = R\"(test\\001.jpg)\"; s1.replace(\"\\\\\", \"#\"); qDebug()\u003c\u003c s1; //结果 test#001.jpg 安卓上打印信息建议使用 qInfo() 而不是 qDebug() ，qInfo()才有效果。 Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置 setTimerType(Qt::PreciseTimer)。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用 startTimer(interval, Qt::PreciseTimer); Qt::PreciseTimer 精确的定时器，尽量保持毫秒精度。 Qt::CoarseTimer 粗略的定时器，尽量保持精度在所需的时间间隔5%范围内。 Qt::VeryCoarseTimer 很粗略的定时器，只保留完整的第二精度。 精度再高，也依赖对应的操作系统中断，假设中断需要 5ms，则定时器精度不可能高于5毫秒。 QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用。 用QSettings设置注册表，如果不是管理员身份运行会打印 QSettings: failed to set subkey “xxx” (拒绝访问。)，你需要手动鼠标右键管理员身份运行就可以。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:12","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"13：121-130 QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途。 限制输入只能输入IP地址。 限制输入范围，强烈推荐使用 QRegExpValidator 正则表达式来处理。 //正在表达式限制输入 QString str = \"\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b\"; ui-\u003elineEdit-\u003esetValidator(new QRegExpValidator(QRegExp(str))); //用于占位 ui-\u003elineEdit-\u003esetInputMask(\"000.000.000.000\"); #if 0 //下面代码设置浮点数范围限制失败 ui-\u003elineEdit-\u003esetValidator(new QDoubleValidator(20, 50, 1)); #else //下面代码设置浮点数范围限制成功 QDoubleValidator *validator = new QDoubleValidator(20, 50, 1); validator-\u003esetNotation(QDoubleValidator::StandardNotation); ui-\u003elineEdit-\u003esetValidator(validator); #endif //下面代码设置整数范围限制成功 ui-\u003elineEdit-\u003esetValidator(new QIntValidator(10, 120)); //其实上面的代码缺陷很多，只能限制只输入小数，无法设定数值范围，很操蛋 //需要来个万能的牛逼的 QRegExpValidator //限制浮点数输入范围为[-180,180] QRegExp regexp(\"^-?(180|1?[0-7]?\\\\d(\\\\.\\\\d+)?)$\"); //限制浮点数输入范围为[-90,90]并限定为小数位后4位 QRegExp regexp(\"^-?(90|[1-8]?\\\\d(\\\\.\\\\d{1,4})?)$\"); QRegExpValidator *validator = new QRegExpValidator(regexp, this); ui-\u003elineEdit-\u003esetValidator(validator); 在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5.14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串 rtmp://58.200.131.2:1935/livetv/cctv1，会显示成 rtmp://… ，而在旧版本的Qt中会显示成 rtmp://58.200.131… ，很多时候我们并不想看到烦人的省略号，可以设置取消。 //取消自动换行 tableView-\u003esetWordWrap(false); //超出文本不显示省略号 tableView-\u003esetTextElideMode(Qt::ElideNone); QVideoWidget播放视频，可能会遇到画面闪烁的情况，播放视频的窗体需要设置个属性。 QVideoWidget *videoWidget = new QVideoWidget; videoWidget-\u003esetAttribute(Qt::WA_OpaquePaintEvent); Qt bug成千上万，这个不用大惊小怪，也基本上遇不到，大部分都是特殊极端情况特定应用场景出现，甚至你会遇到有些是debug可以release报错，有些release可以debug却报错的情况，最神奇的还有先是debug报错，然后release正常，再返回去用debug又正常，需要用release激活一下！学习编程的路本来就是一条坑坑洼洼的路，不断填坑，尽量规避坑！很多时候很多看起来的坑其实是自己没有注意细节导致的。 Qt视图中默认排序是按照字符串的ASCII排序的，如果是IP地址的话会出现192.168.1.117排在192.168.1.2前面的情况，如果要规避这种情况，一种做法是取末尾的地址转成整型再比较大小，缺点是跨网段就歇菜了，又会出现192.168.2.65出现在192.168.1.70前面，终极大法是将IP地址转成整型再比较大小。 QString QUIHelper::ipv4IntToString(quint32 ip) { QString result = QString(\"%1.%2.%3.%4\").arg((ip \u003e\u003e 24) \u0026 0xFF).arg((ip \u003e\u003e 16) \u0026 0xFF).arg((ip \u003e\u003e 8) \u0026 0xFF).arg(ip \u0026 0xFF); return result; } quint32 QUIHelper::ipv4StringToInt(const QString \u0026ip) { int result = 0; if (isIP(ip)) { QStringList list = ip.split(\".\"); int ip0 = list.at(0).toInt(); int ip1 = list.at(1).toInt(); int ip2 = list.at(2).toInt(); int ip3 = list.at(3).toInt(); result = ip3 | ip2 \u003c\u003c 8 | ip1 \u003c\u003c 16 | ip0 \u003c\u003c 24; } return result; } 在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致。 Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出。 #禁用qdebug打印输出 DEFINES += QT_NO_DEBUG_OUTPUT 在使用 QT_NO_DEBUG_OUTPUT 关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实 QT_NO_DEBUG_OUTPUT 禁用的 qdebug 的输出，Qt还有其他几种打印信息比如 qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用 qInfo 来输出信息就好。特别注意：qFatal 打印完信息程序会自动结束。 qDebug() \u003c\u003c \"qDebug\"; qInfo() \u003c\u003c \"qInfo\"; qWarning() \u003c\u003c \"qWarning\"; qCritical() \u003c\u003c \"qCritical\"; qDebug(\"qDebug\"); qWarning(\"qWarning\"); qCritical(\"qCritical\"); Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去。 #禁用qdebug打印输出 DEFINES += QT_NO_DEBUG_OUTPUT #自定义define变量 可以在整个项目中使用 #pro文件可以这样判断 contains(DEFINES, videovlc) {} #代码文件可以这样判断 #ifdef videovlc DEFINES += videovlc1 videoffmpeg #关闭编译警告提示 眼不见为净 CONFIG += warn_off #指定编译生成的文件到temp目录 分门别类存储 MOC_DIR = temp/moc RCC_DIR = temp/rcc UI_DIR = temp/ui OBJECTS_DIR = temp/obj #指定编译生成的可执行文件到bin目录 DESTDIR = bin Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理。 //主窗体头文件 protected: bool nativeEvent(const QByteArray \u0026eventType, void *message, long *result); #ifdef Q_OS_WIN bool winEvent(MSG *message, long *result); #endif //主窗体实现函数 #ifdef Q_OS_WIN #include \"Windows.h\" #endif bool frmMain::nativeEvent(const QByteArray \u0026eventType, void *message, long *result) { if (eventType == \"windows_g","date":"0001-01-01","objectID":"/1/01/qt/:0:13","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"14：131-140 Qt新版本往往会带来一些头文件的更新，比如以前使用QPainter绘制，不需要额外包含QPainterPath头文件，而5.15版本开始就需要显示主动引入#include “qpainterpath.h\"才行。 Qt6.0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件 QT += core5compat 才能用， 具体说明在https://doc.qt.io/qt-6/qtcore5-index.html。 qDebug输出打印信息，默认会完整打印转义字符，例如：\\ \" \\t \\n” 等，所以当你发现你明明设置了转义字符以后打印确还是转义前的字符，这就懵逼了，其实这是qdebug为了方便调试将各种字符都打印输出。无可否认，很多时候，我们极其兴奋的享受着Qt带来的各种轮子各种便利，但是偶尔，稍不留意，这些便利可能也会坑你一把。要做的就是擦亮眼睛，时刻谨慎，一步一个脚印踏踏实实码代码。 QString s1 = R\"(\\:device0)\"; //TNND居然输出的是 \\\\:device0 qDebug() \u003c\u003c s1; //这次终于正确的输出 \\:device0 qDebug().noquote() \u003c\u003c s1; 很多人有疑问为何qss对浏览器控件中的网页样式没法控制，其实用屁股想想也知道，那玩意是html css去控制的，和Qt一毛钱关系也没有，根本管不着，如果想要对滚动条样式设置，可以在网页代码中设置样式就行。 \u003cstyle type=\"text/css\"\u003e ::-webkit-scrollbar{width:0.8em;} ::-webkit-scrollbar-track{background:rgb(241,241,241);} ::-webkit-scrollbar-thumb{background:rgb(188,188,188);} \u003c/style\u003e Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件。 //设置了编码以后配置文件内容为 Company=上海物联网技术研究中心 //没有设置编码则配置文件内容为 Company=\\xe4\\xb8\\x8a\\xe6\\xb5\\xb7\\xe7\\x89\\xa9\\xe8\\x81\\x94\\xe7\\xbd\\x91\\xe6\\x8a\\x80\\xe6\\x9c\\xaf\\xe7\\xa0\\x94\\xe7\\xa9\\xb6\\xe4\\xb8\\xad\\xe5\\xbf\\x83 void App::readConfig() { QSettings set(App::ConfigFile, QSettings::IniFormat); set.setIniCodec(\"utf-8\"); set.beginGroup(\"AppConfig1\"); App::Company = set.value(\"Company\", App::Company).toString(); set.endGroup(); } void App::writeConfig() { QSettings set(App::ConfigFile, QSettings::IniFormat); set.setIniCodec(\"utf-8\"); set.beginGroup(\"AppConfig1\"); set.setValue(\"Company\", App::Company); set.endGroup(); } 用Qt做安卓开发都会遇到权限的问题，早期的安卓版本可以直接通过 AndroidManifest.xml 配置文件来添加需要的权限，这样在安装app的时候就会提示该app需要哪些权限让用户同意，现在的安卓版本都改成了动态权限，需要在app运行的时候弹出提示让用户确认再有权限，Qt迎合了这种策略内置了动态申请权限的方法 QtAndroid::requestPermissionsSync。 //动态设置权限 bool checkPermission(const QString \u0026permission) { #ifdef Q_OS_ANDROID #if (QT_VERSION \u003e= QT_VERSION_CHECK(5, 10, 0)) QtAndroid::PermissionResult result = QtAndroid::checkPermission(permission); if (result == QtAndroid::PermissionResult::Denied) { QtAndroid::requestPermissionsSync(QStringList() \u003c\u003c permission); result = QtAndroid::checkPermission(permission); if (result == QtAndroid::PermissionResult::Denied) { return false; } } #endif #endif return true; } int main(int argc, char *argv[]) { QApplication a(argc, argv); //请求权限 checkPermission(\"android.permission.READ_EXTERNAL_STORAGE\"); checkPermission(\"android.permission.WRITE_EXTERNAL_STORAGE\"); return a.exec(); } Qt重载qDebug输出自定义的信息。 struct FunctionInfo { QString function; QString name; QString groupEnabled; QString action; QString group; friend QDebug operator \u003c\u003c (QDebug debug, const FunctionInfo \u0026functionInfo) { QString info = QString(\"功能: %1 名称: %2 启用: %3 方法: %4 分组: %5\") .arg(functionInfo.function).arg(functionInfo.name).arg(functionInfo.groupEnabled) .arg(functionInfo.action).arg(functionInfo.group); debug \u003c\u003c info; return debug; } }; 对高分屏不同缩放比例的自适应处理方法。 //方法1：在main函数的最前面加上下面这句 5.6版本才开始有这个函数 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,6,0)) QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling); //开启高缩放支持以后图片可能发虚还要开启下面这个属性 QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps); #endif //方法2：在可执行文件同目录下新建文件 qt.conf 填入下面内容 [Platforms] WindowsArguments = dpiawareness=0 //下面这行用来解决Qt高DPI下文字显示有锯齿的问题 WindowsArguments = fontengine=freetype //方法3：在main函数最前面设置Qt内部的环境变量 qputenv(\"QT_AUTO_SCREEN_SCALE_FACTOR\", \"1.5\"); //方法4：新版本的Qt比如Qt5.14修正了对高分屏的处理支持不是整数的缩放 qputenv(\"QT_ENABLE_HIGHDPI_SCALING\", \"1\"); QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough); //禁用缩放 //测试发现AA_Use96Dpi属性在Qt5.9以上版本完全正常，以下版本比如5.7有部分控件在175%缩放不正常比如QTextEdit，需要外层套个widget才行。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) QApplication::setAttribute(Qt::AA_Use96Dpi); #endif #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,14,0)) QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要","date":"0001-01-01","objectID":"/1/01/qt/:0:14","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"15：141-150 QImage支持xpm图标，查看Qt内置的QStyle风格的代码中可以发现大量的xpm图标定义，通过代码的形式来产生图标，哇咔咔好牛逼。 static const char * const imgData[] = { \"15 11 6 1\", \" c None\", \"+ c #979797\", \"@ c #C9C9C9\", \"$ c #C1C1C1\", \"b c None\", \"d c None\", \" $++++++++$ \", \"$+bbbbbbbb+$ \", \"+b $$ +$ \", \"+b $@ +$ \", \"+b +$\", \"+b d+\", \"+b d+$\", \"+b $$ d+$ \", \"+b $@ d+$ \", \"$+dddddddd+$ \", \" $++++++++$ \"}; //这样就能直接显示一个箭头的图形 QImage img(imgData); QLabel lab; lab.setPixmap(QPixmap::fromImage(img)); lab.show(); 在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文。 int main(int argc, char *argv[]) { //需要设置共享上下文不然停靠窗体从正常到浮动后QOpenGLWidget窗体会失效 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,4,0)) QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts); #endif QApplication a(argc, argv); ... } 关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99%以上的Qt版本的乱码问题。 第一步：代码文件选择用utf8编码带bom。 第二步：在有中文汉字的代码文件顶部加一行（一般是cpp文件） #pragma execution_character_set(“utf-8”) 可以考虑放在head.h中，然后需要的地方就引入head头文件就行，而不是这行代码写的到处都是；这行代码是为了告诉msvc编译器当前代码文件用utf8去编译。 第三步：main函数中加入设置编码的代码，以便兼容Qt4，如果没有Qt4的场景可以不用，从Qt5开始默认就是utf8编码。 void QUIHelper::setCode() { #if (QT_VERSION \u003c= QT_VERSION_CHECK(5,0,0)) #if _MSC_VER QTextCodec *codec = QTextCodec::codecForName(\"gbk\"); #else QTextCodec *codec = QTextCodec::codecForName(\"utf-8\"); #endif QTextCodec::setCodecForLocale(codec); QTextCodec::setCodecForCStrings(codec); QTextCodec::setCodecForTr(codec); #else QTextCodec *codec = QTextCodec::codecForName(\"utf-8\"); QTextCodec::setCodecForLocale(codec); #endif } 关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论。 Qt在二进制兼容这块，已经做了最大的努力，通过将各种代码细节隐藏，Q指针+D指针技巧，尽量保持了接口的统一； 是否兼容最主要考虑编译器的因素，毕竟任何Qt版本都是需要通过编译器编译成对应的二进制文件，由他说了算。如果两个Qt版本采用的编译器版本一样，极大概率可执行文件是兼容的，比如 Qt5.10+msvc2015 32 位 和 Qt5.11+msvc2015 32位 编译出来的可执行文件，都用Qt5.11的库是可行的； mingw编译器的Qt版本也是如此，就是因为Qt官方安装包集成的mingw编译器一直在更新（极少附近版本没有更新mingw编译器版本除外），比如5.7用的mingw53，5.12用的mingw73，5.15用的mingw81，因为带的Qt库也是这个编译器编译出来的，所以导致看起来全部不兼容； 如果想要完全兼容，还有一个注意要素，那就是对应代码使用的类的头文件接口是否变了，按道理原有的接口极少会变，一般都是新增加，或者大版本才会改变，比如Qt4-Qt5-Qt6这种肯定没法兼容的，接口和模块都变了； 大胆的猜测：如果Qt5.6到Qt5.15你全部用一种编译器比如mingw73或者msvc2015重新编译生成对应的Qt运行库，然后在此基础上开发程序，最后生成的可执行文件用Qt5.15的库是都可以的，这样就轻松跨越了多个版本兼容； 大胆的建议：在附近的几个版本统一编译器，比如5.6-5.12之间就统一用mingw53或者msvc2015,5.12-5.15统一用msvc2017，要尝鲜其他编译器的可以自行源码编译其他版本，这样最起码附近的一大段版本（大概2-3年的版本周期）默认就兼容了。 本人测试的是widget部分，qml未做测试，不清楚是否机制一样； 通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4.7到5.15任意版本，通过查看对应函数的源码可以看到内部会检查是否是 ‘file:///’ 开头，是的话则自动读取样式表文件进行设置，无需手动读取。 //以前都是下面的方法 QFile file(\":/qss/psblack.css\"); if (file.open(QFile::ReadOnly)) { QString qss = QLatin1String(file.readAll()); qApp-\u003esetStyleSheet(qss); file.close(); } //其实一行代码就行 qApp-\u003esetStyleSheet(\"file:///:/qss/psblack.css\"); //特别说明，只支持qApp-\u003esetStyleSheet 不支持其他比如widget-\u003esetStyleSheet Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板 QCalendarWidget 就是 QToolButton+QSpinBox+QTableView 等组成，妙用 findChildren 可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等。 //打印子类类名集合 void printObjectChild(const QObject *obj, int spaceCount) { qDebug() \u003c\u003c QString(\"%1%2 : %3\") .arg(\"\", spaceCount) .arg(obj-\u003emetaObject()-\u003eclassName()) .arg(obj-\u003eobjectName()); QObjectList childs = obj-\u003echildren(); foreach (QObject *child, childs) { printObjectChild(child, spaceCount + 2); } } //拿到对话框进行设置和美化 QFileDialog *fileDialog = new QFileDialog(this); fileDialog-\u003esetOption(QFileDialog::DontUseNativeDialog, true); QLabel *lookinLabel = fileDialog-\u003efindChild\u003cQLabel*\u003e(\"lookInLabel\"); lookinLabel-\u003esetText(QString::fromLocal8Bit(\"文件目录：\")); lookinLabel-\u003esetStyleSheet(\"color:red;\"); //设置日期框默认值为空 QLineEdit *edit = ui-\u003edateEdit-\u003efindChild\u003cQLineEdit *\u003e(\"qt_spinbox_lineedit\"); if (!edit-\u003etext().isEmpty()) { edit-\u003eclear(); } Qt内置了各种对话框，比如文件对话框-QFileDialog ，颜色对话框-QColorDialog ，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理。 QFileDialog *fileDialog = new QFileDialog(this); //不设置此属性根本查找不到任何子元素,因为默认采用的系统对话框 fileDialog-\u003esetOption(QFileDialog::DontUseNativeDialog, true); qDebug() \u003c\u003c fileDialog-\u003efindChildren\u003cQLabel *\u003e(); //打印","date":"0001-01-01","objectID":"/1/01/qt/:0:15","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"16：151-160 当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载。 //Qt中使用二进制资源文件方法如下 //将qrc编译为二进制文件rcc，在控制台执行下列命令 rcc -binary main.qrc -o main.rcc //在应用程序中注册资源，一般在main函数启动后就注册 QResource::registerResource(qApp-\u003eapplicationDirPath() + \"/main.rcc\"); 关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有。 //假设窗体中有子控件，默认字体12px，父类类型是QWidget，父类类名是Widget //下面几种方法只会设置主窗体的字体，子控件不会应用，需要按个调用setFont QFont font; font.setPixelSize(20); this-\u003esetFont(font); this-\u003esetStyleSheet(\"{font:26px;}\"); this-\u003esetStyleSheet(\"QWidget{font:26px;}\"); this-\u003esetStyleSheet(\"Widget{font:26px;}\"); //下面才是通过样式表设置整个控件+子控件的字体 this-\u003esetStyleSheet(\"font:26px;\"); this-\u003esetStyleSheet(\"*{font:26px;}\"); this-\u003esetStyleSheet(\"QWidget\u003e*{font:26px;}\"); this-\u003esetStyleSheet(\"Widget\u003e*{font:26px;}\"); //下面设置全局字体 qApp-\u003esetFont(font); Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format_ARGB32或者Format_RGBA8888。 //pixel 函数获取像素点的颜色 setPixel 函数设置像素点的颜色 此函数任意Qt版本都有 //pixelColor 函数获取像素点的颜色 setPixelColor 函数设置像素点的颜色 此函数Qt5.6以后才有 //pixel函数取出来的是QRgb格式需要用 qRed qGreen qBlue qAlpha 进行转换 QImage image(\"1.png\"); image = image.convertToFormat(QImage::Format_ARGB32); int width = image.width(); int height = image.height(); //遍历图像的每一个像素 for (int x = 0; x \u003c width; ++x) { for (int y = 0; y \u003c height; ++y) { QString name = image.pixelColor(x, y).name(); //将白色以外的颜色全部替换成红色 if (name != \"#ffffff\") { image.setPixelColor(x, y, Qt::red); } } } //保存文件 image.save(\"2.png\"); 在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论。 Qt天生内置了sqlite数据库，只需要发布的时候带上插件就行（可以看到插件动态库文件比其他几种都要大，那是因为直接将数据库的源码都编译进去了，而其他只编译了中间通信交互的插件源码），其他数据库要么还要带上动态库，要么还需要创建数据源； 速度上，绝对无与伦比的出类拔萃，同样的数据库结构（表结构、索引等完全一致），查询速度和批量更新速度、数据库事务等，速度都是其他几种的至少3倍以上，而且随着数据量的增大对比越发明显； 几千万的数据量完全没问题，而且速度和性能都还可以，不要以讹传讹网上部分菜鸡说的不支持百万以上的数据量，本人亲测亿级别，数据量建议千万级别以下，着重注意数据库表和索引的设计； 其他数据库还要注意版本的区别，ODBC数据源形式还容易出错和执行失败； sqlite数据库也有几个重大缺点：不支持加密，不支持网络访问，不支持部分数据库高级特性，不支持海量数据（亿级别以上），但是对于绝大部分Qt项目还是足够； 数据库支持友好度大致是 sqlite \u003e postgresql \u003e mysql \u003e odbc ; 以上都是在Qt环境中个人测试得出的结论，结果未必正确，作为参考即可，其他编程环境比如C#、JAVA请忽略，也许差别可能在中间通信的效率造成的； Qt5.10以后提供了新的类 QRandomGenerator QRandomGenerator64 管理随机数，使用更方便，尤其是取某个区间的随机数。 //早期处理办法 先初始化随机数种子然后取随机数 qsrand(QTime::currentTime().msec()); //取 0-10 之间的随机数 qrand() % 10; //取 0-1 之间的浮点数 qrand() / double(RAND_MAX); //新版处理办法 支持5.10以后的所有版本包括qt6 QRandomGenerator::global()-\u003ebounded(10); //生成一个0和10之间的整数 QRandomGenerator::global()-\u003ebounded(10.123); //生成一个0和10.123之间的浮点数 QRandomGenerator::global()-\u003ebounded(10, 15); //生成一个10和15之间的整数 //兼容qt4-qt6及以后所有版本的方法 就是用标准c++的随机数函数 srand(QTime::currentTime().msec()); rand() % 10; rand() / double(RAND_MAX); //通用公式 a是起始值,n是整数的范围 int value = a + rand() % n; //(min, max)的随机数 int value = min + 1 + (rand() % (max - min - 1)); //(min, max]的随机数 int value = min + 1 + (rand() % (max - min + 0)); //[min, max)的随机数 int value = min + 0 + (rand() % (max - min + 0)); //[min, max]的随机数 int value = min + 0 + (rand() % (max - min + 1)); //如果在线程中取随机数，线程启动的时间几乎一样，很可能出现取到的随机数一样的问题，就算设置随机数为当前时间啥的也没用，电脑太快很可能还是一样的时间，同一个毫秒。 //取巧办法就是在run函数之前最前面将当前线程的id作为种子设置。时间不可靠，线程的id才是唯一的。 //切记 void * 转换到数值必须用 long long，在32位是可以int但是在64位必须long，确保万一直接用quint64最大 srand((long long)currentThreadId()); qrand((long long)currentThreadId()); Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下。 void frmMain::on_btnMenu_Max_clicked() { ...... //最大化以后有个BUG,悬停样式没有取消掉,需要主动模拟鼠标动一下 QEvent event(QEvent::Leave); QApplication::sendEvent(ui-\u003ebtnMenu_Max, \u0026event); } 项目中启用c++11语法支持。 greaterThan(QT_MAJOR_VERSION, 4): CONFIG += c++11 lessThan(QT_MAJOR_VERSION, 5): QMAKE_CXXFLAGS += -std=c++11 Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多。 ui-\u003etextEdit-\u003esetUndoRedoEnabled(false); 其他几点常规小经验，本人在这几个地方摔跤过很多次。 有返回值的函数，一定要主动return返回值，有部分编译器在没有返回值的情况下也能正常编译通过，但是运行的时候会出问题，得不到想要的结果，因为没有return对应的值。 定义的局部变量，主动给定个初始值，是个必须养成的好习惯，不然编译器给的初始值很可能不是你想要的，比如int变量默认0，有时候随机变成一个很大的数值，bool变量的初始值不同编译器不同值，有些是true有些是false，主动给一个初始值更可靠。 某些函数参数很多，而且后期可能还会修改","date":"0001-01-01","objectID":"/1/01/qt/:0:16","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"17：161-170 经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条。 Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5.9以前需要拿到原有的窗体属性做运算，后面可以用新的方法。 //增加一个无边框属性 setWindowFlags(windowFlags() | Qt::FramelessWindowHint); //移除无边框属性 setWindowFlags(windowFlags() \u0026 ~Qt::FramelessWindowHint); //下面是5.9以后新增的方法 //增加一个无边框属性到窗体属性链表 setWindowFlag(Qt::FramelessWindowHint, true); //从窗体属性链表中移除无边框属性 setWindowFlag(Qt::FramelessWindowHint, false); 如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸。 setMinimumSize(0, 0); setMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX); Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-\u003emouseButtons()，全局的鼠标坐标可以用QCursor::pos()。 //在鼠标右键的地方弹出菜单，如果菜单是QMenu而不是QAction则只能通过下面的方式弹出 if (qApp-\u003emouseButtons() == Qt::RightButton) { videoMenu-\u003eexec(QCursor::pos()); } //全局剪切板 qApp-\u003eclipboard(); //顶层控件对象集合 qApp-\u003etopLevelWidgets() //当前焦点所在控件 qApp-\u003efocusWidget() //当前平台名称 qApp-\u003eplatformName() //调用系统蜂鸣器 qApp-\u003ebeep() //打印当前Qt版本信息 qApp-\u003eaboutQt() //设置全局的鼠标样式 qApp-\u003esetOverrideCursor() //不使用系统的标准颜色字体等 QGuiApplication::setDesktopSettingsAware(bool on); QApplication app(argc, argv); //更多的全局对象属性等可以查阅 qguiapplication.h 头文件，你会发现新大陆。 Qt对区分不同的编译器也做了非常细致的处理。 #pro文件可以这样判断 msvc { //要做的处理 } mingw { //要做的处理 } //代码中可以这样判断 #ifdef Q_CC_MINGW //mingw编译器 #elif Q_CC_MSVC //msvc编译器 #endif //判断编译器和编译器版本 #if defined Q_CC_MSVC \u0026\u0026 _MSC_VER \u003c 1300 #if defined(Q_CC_GNU) \u0026\u0026 (__GNUC__ \u003c 4) //代码中判断ARM平台 #ifdef QT_ARCH_ARM //多个条件判断 #if defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE) 有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用 blockSignals 方法。 //方法1：先 disconnect 掉信号，处理好以后再 connect 信号，缺点很明显，很傻，如果信号很多，每个型号都要这么来一次。 disconnect(ui-\u003ecbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int))); for (int i = 0; i \u003c= 100; i++) { ui-\u003ecbox-\u003eaddItem(QString::number(i)); } connect(ui-\u003ecbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int))); //方法2：先调用 blockSignals(true) 阻塞信号，处理号以后再调用 blockSignals(false) 恢复所有信号。 //如果需要指定某个信号进行断开那就只能用 disconnect 来处理。 ui-\u003ecbox-\u003eblockSignals(true); for (int i = 0; i \u003c= 100; i++) { ui-\u003ecbox-\u003eaddItem(QString::number(i)); } ui-\u003ecbox-\u003eblockSignals(false); 项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2。 //方法1：pro文件直接全部引入，而不是每个都添加一次，省心省力。 HEADERS += *.h SOURCES += *.cpp //方法2：分模块文件夹存放，不同模块用pri包含代码文件，比如界面可以放在ui文件夹，下面搞个ui.pri，然后pro项目文件只需要引入这个pri文件即可。 include($$PWD/ui/ui.pri) //还可以加上一句包含路径这样可以省去在使用代码的时候不用写文件夹 INCLUDEPATH += $$PWD/ui //加上上面这行，在使用头文件的时候可以直接 include \"form.h\"，没有加则需要 include \"ui/form.h\"。 在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农名工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的。 //tcp客户端 QTcpSocket *socket = new QTcpSocket(this); //断开所有连接和操作 socket-\u003eabort(); //绑定网卡和端口 socket-\u003ebind(QHostAddress(\"192.168.1.2\"), 6005); //连接服务器 socket-\u003econnectToHost(\"192.168.1.3\", 6000); //打印通信用的本地绑定地址和端口 qDebug() \u003c\u003c socket-\u003elocalAddress() \u003c\u003c socket-\u003elocalPort(); //打印通信服务器对方的地址和端口 qDebug() \u003c\u003c socket-\u003epeerAddress() \u003c\u003c socket-\u003epeerPort() \u003c\u003c socket-\u003epeerName(); //udp客户端 QUdpSocket *socket = new QUdpSocket(this); //绑定网卡和端口,没有绑定过才需要绑定 //采用端口是否一样来判断是为了方便可以直接动态绑定切换端口 if (socket-\u003elocalPort() != 6005) { socket-\u003eabort(); socket-\u003ebind(QHostAddress(\"192.168.1.2\"), 6005); } //指定地址和端口发送数据 socket-\u003ewriteDatagram(buffer, QHostAddress(\"192.168.1.3\"), 6000); //上面是Qt5可以使用bind，","date":"0001-01-01","objectID":"/1/01/qt/:0:17","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"18：171-180 在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen_s函数，比如fmod中也是这个情况。这个时候就需要转码处理。 QString fileName = \"c:/测试目录/1.txt\"; //如果应用程序main函数中没有设置编码则默认采用系统的编码，可以直接通过toLocal8Bit转成正确的数据 const char *name = fileName.toLocal8Bit().constData(); //如果设置过了下面两句则需要主动转码 QTextCodec *codec = QTextCodec::codecForName(\"utf-8\"); QTextCodec::setCodecForLocale(codec); QTextCodec *code = QTextCodec::codecForName(\"gbk\"); const char *name = code-\u003efromUnicode(fileName).constData(); //推荐方式2以防万一保证绝对的正确，哪怕是设置过主程序的编码 //切记一旦设置过QTextCodec::setCodecForLocale会影响toLocal8Bit //有时候可能还有下面这种情况 #ifdef Q_OS_WIN #if defined(_MSC_VER) \u0026\u0026 (_MSC_VER \u003e= 1400) QTextCodec *code = QTextCodec::codecForName(\"utf-8\"); #else QTextCodec *code = QTextCodec::codecForName(\"gbk\"); #endif const char *name = code-\u003efromUnicode(fileName).constData(); #else const char *name = fileName.toUtf8().constData(); #endif 在查阅和学习Qt源码的过程中，发现了一些趋势和改变。 数据类型这块尽量用Qt内部的数据类型，哪怕是重定义过的比如quint8其实unsigned char，qreal就是double，以前翻看源码的时候可能还有些是double，现在慢慢改成了qreal。 循环结构用 for(;;) 替代 while(1)，因为转成汇编指令后 for(;;) 只有一条指令而 while(1) 确有4条，指令少不占用寄存器而且不用跳转，理论上速度要更快。 其实Qt中就重定义了 forever 关键字表示 for(;;) ，我的乖乖，想的真周到。 自动c++11以及后续的标准都支持auto万能数据类型，发现Qt的源码中也慢慢的改成了auto，这样加快了编写代码的效率，不用自己去指定数据类型而是让编译器自己推导数据类型。而且其实也不影响编译器编译的速度，因为无论指定和没有指定数据类型，编译器都要推导右侧的数据类型进行判断。不过有个缺点就是影响了阅读代码的成本，很多时候需要自己去理解推导。 Qt中设置或者打开加载本地文件需要用到QUrl类，本地文件建议加上 file:/// 前缀。 QString url = \"file:///c:/1.html\"; //浏览器控件打开本地网页文件 webView-\u003esetUrl(QUrl(url)); //打开本地网页文件，下面两种方法都可以 QDesktopServices::openUrl(QUrl::fromLocalFile(url)); QDesktopServices::openUrl(QUrl(url, QUrl::TolerantMode)); 在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5.15开始内置了setTransferTimeout来设置超时时间，非常好用。 //局部的事件循环,不卡主界面 QEventLoop eventLoop; //设置超时 5.15开始自带了超时时间函数 默认30秒 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,15,0)) manager-\u003esetTransferTimeout(timeout); #else QTimer timer; connect(\u0026timer, SIGNAL(timeout()), \u0026eventLoop, SLOT(quit())); timer.setSingleShot(true); timer.start(timeout); #endif QNetworkReply *reply = manager-\u003eget(QNetworkRequest(QUrl(url))); connect(reply, SIGNAL(finished()), \u0026eventLoop, SLOT(quit())); eventLoop.exec(); if (reply-\u003ebytesAvailable() \u003e 0 \u0026\u0026 reply-\u003eerror() == QNetworkReply::NoError) { //读取所有数据保存成文件 QByteArray data = reply-\u003ereadAll(); QFile file(dirName + fileName); if (file.open(QFile::WriteOnly | QFile::Truncate)) { file.write(data); file.close(); } } Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick/qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。 //如果是控制台程序则下面的QApplication换成QCoreApplication //如果是quick/qml程序则下面的QApplication换成QGuiApplication int main(int argc, char *argv[]) { //可以用下面这行测试Qt自带的输入法 qtvirtualkeyboard qputenv(\"QT_IM_MODULE\", QByteArray(\"qtvirtualkeyboard\")); //设置不应用操作系统设置比如字体 QApplication::setDesktopSettingsAware(false); #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) //设置高分屏缩放舍入策略 QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif #if (QT_VERSION \u003e QT_VERSION_CHECK(5,6,0)) //设置启用高分屏缩放支持 //要注意开启后计算到的控件或界面宽度高度可能都不对,全部需要用缩放比例运算下 QApplication::setAttribute(Qt::AA_EnableHighDpiScaling); //设置启用高分屏图片支持 QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps); #endif #if (QT_VERSION \u003e QT_VERSION_CHECK(5,4,0)) //设置opengl模式 AA_UseDesktopOpenGL(默认) AA_UseOpenGLES AA_UseSoftwareOpenGL //在一些很旧的设备上或者对opengl支持很低的设备上需要使用AA_UseOpenGLES表示禁用硬件加速 //如果开启的是AA_UseOpenGLES则无法使用硬件加速比如ffmpeg的dxva2 //QApplication::setAttribute(Qt::AA_UseOpenGLES); //设置opengl共享上下文 QApplication::setAttribute(Qt::AA_ShareOpenGLContexts); #endif QApplication a(argc, argv); QWidget w; w.show(); return a.exec(); } QCamera中获取设备的配置参数比如支持的分辨率集合等，需要先调用load后才能正确获取，或者关联stateChanged信号中判断状态是否是ActiveState，然后再读取。 //方法1：调用load后获取 camera = new QCamera(this); //先需要载入才能获取到对应参数 camera-\u003eload(); //输出当前设备支持的分辨率 QList\u003cQSize\u003e sizes = camera-\u003esupportedViewfinderResolutions(); emit resolutions(sizes); //","date":"0001-01-01","objectID":"/1/01/qt/:0:18","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"19：181-190 Qt天生就是linux的，从linux开始发展起来的，所以不少Qt程序员经常的开发环境是linux，比如常用的ubuntu等系统，整理了一点常用的linux命令。 命令 功能 sudo -s 切换到管理员，如果是 sudo -i 切换后会改变当前目录。 apt install g++ 安装软件包（要管理员权限），另一个派系的是 yum install。 cd /home 进入home目录。 ls 罗列当前所在目录所有目录和文件。 ifconfig 查看网卡信息包括IP地址，windows上是 ipconfig。 tar -zxvf bin.tar.gz 解压文件到当前目录。 tar -jxvf bin.tar.xz 解压文件到当前目录。 tar -zxvf bin.tar.gz -C /home 解压文件到/home目录，记住是大写的C。 tar -zcvf bin.tar.gz bin 将bin目录压缩成tar.gz格式文件（压缩比一般）。 tar -jcvf bin.tar.xz bin 将bin目录压缩成tar.xz格式文件（压缩比高，推荐）。 tar -… j z 表示不同的压缩方法，x表示解压，c表示压缩。 gedit 1.txt 用记事本打开文本文件。 vim 1.txt 用vim打开文件，很多时候可以缩写用vi。 ./configure make -j4 make install 通用编译源码命令，第一步./configure执行配置脚本，第二步make -j4启用多线程编译，第三步make install安装编译好的文件。 ./configure -prefix /home/liu/Qt-5.9.3-static -static -sql-sqlite -qt-zlib -qt-xcb -qt-libpng -qt-libjpeg -fontconfig -system-freetype -iconv -nomake tests -nomake examples -skip qt3d -skip qtdoc Qt通用编译命令。 ./configure -static -release -fontconfig -system-freetype -qt-xcb -qt-sql-sqlite -qt-zlib -qt-libpng -qt-libjpeg -nomake tests -nomake examples -prefix /home/liu/qt/Qt5.6.3 Qt静态带中文。 ./configure -prefix /home/liu/Qt-5.9.3-static -static -release -nomake examples -nomake tests -skip qt3d 精简编译命令。 ./configure –prefix=host –enable-static –disable-shared –disable-doc ffmpeg编译命令。 Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等。 //Qt5开始提供了日志上下文信息输出，比如输出当前打印消息所在的代码文件、行号、函数名等。 //如果是release还需要在pro中加上 DEFINES += QT_MESSAGELOGCONTEXT 才能输出上下文，默认release关闭的。 //切记不要在日志钩子函数中再写qdebug之类的，那样就死循环了。 //日志重定向一般就三种处理 //1: 输出到日志文件比如txt文本文件。 //2: 存储到数据库，可以分类存储，以便相关人员查询分析。 //3: 重定向到网络，对方用小工具连接程序后，所有打印信息通过tcp发过去。 //日志重定向 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) void Log(QtMsgType type, const QMessageLogContext \u0026context, const QString \u0026msg) #else void Log(QtMsgType type, const char *msg) #endif { //加锁,防止多线程中qdebug太频繁导致崩溃 static QMutex mutex; QMutexLocker locker(\u0026mutex); QString content; //这里可以根据不同的类型加上不同的头部用于区分 switch (type) { case QtDebugMsg: content = QString(\"%1\").arg(msg); break; case QtWarningMsg: content = QString(\"%1\").arg(msg); break; case QtCriticalMsg: content = QString(\"%1\").arg(msg); break; case QtFatalMsg: content = QString(\"%1\").arg(msg); break; } //加上打印代码所在代码文件、行号、函数名 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) if (SaveLog::Instance()-\u003egetUseContext()) { int line = context.line; QString file = context.file; QString function = context.function; if (line \u003e 0) { content = QString(\"行号: %1 文件: %2 函数: %3\\n%4\").arg(line).arg(file).arg(function).arg(content); } } #endif //将内容传给函数进行处理 SaveLog::Instance()-\u003esave(content); } //安装日志钩子,输出调试信息到文件,便于调试 void SaveLog::start() { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) qInstallMessageHandler(Log); #else qInstallMsgHandler(Log); #endif } //卸载日志钩子 void SaveLog::stop() { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) qInstallMessageHandler(0); #else qInstallMsgHandler(0); #endif } 自从c++11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记。 代码格式：capture mutable -\u003ereturn-type {statement} [capture]：捕捉列表，捕捉列表总是出现在Lambda函数的开始处，实际上，[]是Lambda引出符，编译器根据该引出符判断接下来的代码是否是Lambda函数，捕捉列表能够捕捉上下文中的变量以供Lambda函数使用。 (parameters)：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以连同括号 () 一起省略。 mutable：mutable修饰符，默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。 -\u003ereturn-type：返回类型，用追踪返回类型形式声明函数的返回类型，我们可以在不需要返回值的时候也可以连同符号 -\u003e 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。 {statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。 捕捉列表有以下几种形式： [var]表示值传递方式捕捉变量var。 [=]表示值传递方式捕捉所有父作用域的变量（包括this）。 [\u0026var]表示引用传递捕捉变量var。 [\u0026]表示引用传递方式捕捉所有父作用域的变量（包括this）。 [this]表示值传递方式捕捉当前的this指针。 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-\u003esetupUi(this); //按钮单击不带参数 connect(ui-\u003epushButton, \u0026QPushButton::clicked, [] { qDebug() \u003c\u003c \"hello lambda\"; }); //按钮单击带参数 connect(ui-\u003epushButton, \u0026QPushButton::clicked, [] (bool isCheck) { qDebug() \u003c\u003c \"hello lambda\" \u003c\u003c isCheck; }); //自定义信号带参数 connect(this, \u0026MainWindow::sig_test, [] (int i, int j) { qDebug() \u003c\u003c \"hello lambda\" \u003c\u003c i ","date":"0001-01-01","objectID":"/1/01/qt/:0:19","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"20：191-200 关于QList队列的处理中，我们最常用的就是调用append函数添加item，往前插入item很多人第一印象就是调用insert(0,xxx)来插入，其实QList完全提供了往前追加item的函数prepend、push_front。 QStringList list; list \u003c\u003c \"aaa\" \u003c\u003c \"bbb\" \u003c\u003c \"ccc\"; //往后追加 等价于 append list.push_back(\"ddd\"); //往前追加 等价于 prepend list.push_front(\"xxx\"); //往后追加 list.append(\"ddd\"); //往前追加 list.prepend(\"xxx\"); //指定第一个位置插入 等价于 prepend list.insert(0, \"xxx\"); //输出 QList(\"xxx\", \"aaa\", \"bbb\", \"ccc\", \"ddd\") qDebug() \u003c\u003c list; Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型。 //qwindowdefs.h typedef QList\u003cQWidget *\u003e QWidgetList; typedef QList\u003cQWindow *\u003e QWindowList; typedef QHash\u003cWId, QWidget *\u003e QWidgetMapper; typedef QSet\u003cQWidget *\u003e QWidgetSet; //qmetatype.h typedef QList\u003cQVariant\u003e QVariantList; typedef QMap\u003cQString, QVariant\u003e QVariantMap; typedef QHash\u003cQString, QVariant\u003e QVariantHash; typedef QList\u003cQByteArray\u003e QByteArrayList; Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值。 Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5.6开始提供了 AA_EnableHighDpiScaling 的属性设置开启高分屏，到了5.14以后还可以指定缩放的策略 HighDpiScaleFactorRoundingPolicy 比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了 AA_EnableHighDpiScaling 属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放。 //永远不应用高分屏及缩放 int main(int argc, char *argv[]) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) QApplication::setAttribute(Qt::AA_Use96Dpi); #endif #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,14,0)) QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif QApplication a(argc, argv); .... return a.exec(); } //自动应用高分屏及缩放 //方法很多，综合对比下来还是采用配置文件指定缩放策略最适中。 //新建qt.conf文件放到可执行文件同一目录 [Platforms] WindowsArguments = dpiawareness=0 //有时候想让用户去选择何种策略，需要开启高分屏的之后只需要将qt.conf文件放到可执行文件同一目录即可，就算代码中设置了不应用高分屏及缩放，也无效，也是优先取qt.conf文件的策略。 关于QSS要注意的坑。 qss源自css，相当于css的一个子集，主要支持的是css2标准，很多网上的css3的标准的写法在qss这里是不生效的，所以不要大惊小怪。 qss也不是完全支持所有的css2，比如text-align官方文档就有说明，只支持 QPushButton and QProgressBar，务必看清楚。 有时候偷懒直接来一句 *{xxx}，你会发现大部分是应用了，也有小部分或者极个别没有应用，你可能需要在对应的窗体中 this-\u003esetStyleSheet() 来设置。 qss的执行是有优先级的，如果没有指定父对象，则对所有的应用，比如在窗体widget中 {color:#ff0000;} 这样会对widget以及widget的所有子对象应用该样式，这种问题各大群每周都有人问，你会发现各种奇奇怪怪的异样不正常，怎么办呢，你需要指定类名或者对象名，比如 #widget{color:#ff0000;} 这样就只会对widget对象应用该样式，另一种写法 QWidget#widget{color:#ff0000;}，只想对窗体本身而不是子控件按钮标签等 .QWidget{color:#ff0000;} ，具体详细规则参见官方说明。 qss整体来说还是可以的，解析速度性能在Qt5高版本后期比Qt4好很多，尤其是修复了不少qss中的解析绘制BUG。尽管有这样那样的BUG，怀着包容的心对待它。 qss官方学习地址1：http://47.100.39.100/qtwidgets/stylesheet-reference.html qss官方学习地址2：http://47.100.39.100/qtwidgets/stylesheet-examples.html 关于Qt延时的几种方法。 void QUIHelperCore::sleep(int msec) { if (msec \u003c= 0) { return; } #if 1 //非阻塞方式延时,现在很多人推荐的方法 QEventLoop loop; QTimer::singleShot(msec, \u0026loop, SLOT(quit())); loop.exec(); #else #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) //阻塞方式延时,如果在主线程会卡住主界面 QThread::msleep(msec); #else //非阻塞方式延时,不会卡住主界面,据说可能有问题 QTime endTime = QTime::currentTime().addMSecs(msec); while (QTime::currentTime() \u003c endTime) { QCoreApplication::processEvents(QEventLoop::AllEvents, 100); } #endif #endif } 随着国产化的兴起，各种国产系统和国产数据库等逐渐进入开发者的世界，罗列几个要点。 中标麒麟neokylin基于centos。 银河麒麟kylin早期版本比如V2基于freebsd，新版本V4、V10基于ubuntu。 优麒麟ubuntukylin就是ubuntu的汉化版本，加了点农历控件啥的。 deepin基于debian。 uos基于deepin或者说是deepin的商业分支。 ubuntu基于debian。 linux界主要分两种发行版本，debian（ubuntu、deepin、uos、银河麒麟kylin等）和redhat（fedora、centos、中标麒麟neokylin、中兴新支点newstart等），分别对应apt-get和yum安装命令。绝大部分的linux系统都基于或者衍生自这两种发行版本。 理论上基于同一种系统内核的，在其上编译的程序可以换到另外的系统运行，前提是编译器版本一致，比如都是gcc4.9，在ubuntu14.04 64位用gcc4.9编译的Qt程序，是能够在uos 64位上运行的。 高版本编译器的系统一般能够兼容低版本的，比如你用gcc4.9编译的程序是能够在gcc7.0上运行，反过来不行。 意味着如果你想尽可能兼容更多的系统，尽量用低版本的编译器编译你的程序，当然要你的程序代码语法支持，比如c++11就要从gcc4.7开始才支持，如果你的代码用了c++11则必须至少选择gcc4.7版本及以上。 用Qt编写linux程序为了发布后的可执行文件可以兼容各种linux系统，只要在这两种内核（debian、redhat）的系统上用低版本的编译器比如gcc4.7编译qt程序发布即可。 2022-01-27补充：根据Qt官方安装包，发现基于redhat的gcc4.9编译器发布的，通用各种linux系统（亲测ubuntu各个版本、fedora、centos、deepin、uos、银河麒麟kylin、中标麒","date":"0001-01-01","objectID":"/1/01/qt/:0:20","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"21：201-210 编译生成debug版本动态库，文件末尾自动加上d结尾。 CONFIG(debug, debug|release) { win32: TARGET = $$join(TARGET,,,d) mac: TARGET = $$join(TARGET,,,_debug) unix:!mac: TARGET = $$join(TARGET,,,d) } QtCreator中pro项目文件格式说明。 名称 说明 QT += core gui 添加本项目中需要的模块，影响后面代码文件include的时候自动弹出下拉选择，如果pro文件没有引入该模块则无法自动语法提示，一般打包发布的时候对应动态库文件比如 Qt5Core.dll。 TARGET = xxx 生成最后目标文件的名字，可以是可执行文件或者库文件。 TEMPLATE = app 项目程序的生成模式，默认是app表示生成可执行文件程序，如果是动态库项目就是 TEMPLATE = lib。 CONFIG += qaxcontainer 引入一些配置，在Qt4的时候还用来引入一些模块，其中有部分改成了QT += 方式引入，比如Qt5引入本地activex控件支持改成了QT += qaxcontainer。 DEFINES += xxx 项目中自定义的一些定义，可以在代码文件中识别，通常用来定义一些不同平台的处理，根据项目需要自己定义任何标识。 HEADERS += head.h 项目中用到的头文件，一般拓展名是.h，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。 SOURCES += main.cpp 项目中用到的实现文件，一般拓展名是.cpp，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。 FORMS += Form.ui 项目中用到的UI文件，一般拓展名是.ui，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。 RESOURCES += main.qrc 项目中用到的资源文件，可以多个，写代码使用对应资源文件中的文件时候务必记得资源文件中的前缀。 LIBS += -L$$PWD/ -lavformat -lavcodec 项目中编译时候链接依赖的库，一般是 .lib .a .dylib 文件，可以写在一行，省略文件名的lib打头部分，也可以分多行绝对路径和全名称。 DESTDIR += $$PWD/bin 目标生成路径，$$PWD表示当前目录，一般建议生成的最终文件重定向到另外目录存放，好找，不然一堆临时文件在里面有时候文件太多好难找。 INCLUDEPATH += $$PWD/include 工程需要的头文件，指定整个目录，写代码的时候找到的话会自动下拉。 DEPENDPATH += 工程的依赖路径，用的比较少，一般涉及到引入链接库的时候可能需要。 include($$PWD/3rd.pri) 引入pri模块文件，pri最大的好处就是分目录管理文件，通用的轮子模块可以放到一个目录下，然后用pri统一管理，可以给多个项目公用。 官方详细地址https://doc.qt.io/qt-5/qmake-variable-reference.html 如果发现之前编译正常，突然之间再编译就一直死循环的样子，停留在一行提示并疯狂不停的打印，或者提示文件时间在未来，这说明你很可能改过开发环境的时间（比如测试某个授权文件失效），导致有修改过文件的保存时间在未来，你只需要将时间调整回来，将最后更新时间不正确的代码文件重新保存下就行。Qt的增量编译是根据文件的最后修改时间来判定的，最后的修改时间比上一次的修改时间还要新则认为该文件被修改过，需要重新编译该文件。 Qt的构建套件一般是在安装Qt开发环境的时候自动设置的，当然也可以手动设置，手动设置的时候千万要注意编译器和Qt库必须一致，否则该构建套件是有问题的，千万不能乱设置，尤其是对构建套件命名的时候最好标明qt版本和编译器版本，最好也要一致，不要说名称叫msvc而编译器选择的确是mingw，这样尽管能正常使用该构建套件，但是会造成一种误解，还以为该套件是msvc的，其实里面是mingw的。有个qter说他的qt坏了，死活编译失败，远程一看，尼玛，构建套件名称写的qt_msvc2019 编译器选择的msvc2015（他电脑只安装了vs2015），qt库选择的mingw！差点狂扇自己八个耳光，太离谱了！ 当你编译Qt程序发现编译通不过提示报错，而且报错提示在Qt的头文件的时候，不要去尝试着修改Qt头文件来编译通过，那样没用的，你使用的Qt的库是已经根据原始的头文件编译好的。如果报错提示在编译生成的临时的moc等文件，你也不要尝试去修改他，那个是临时文件，这次你改好了也许编译通过了，你重新编一下又覆盖了还是旧的错误。总之你要从源头（你的代码）找问题。 有时候需要对文本进行分散对齐显示，相当于无论文字多少，尽可能占满整个空间平摊占位宽度，但是在对支持对齐方式的控件比如QLabel调用 setAlignment(Qt::AlignJustify | Qt::AlignVCenter) 设置分散对齐会发现没有任何效果，这个时候就要考虑另外的方式比如通过控制字体的间距来实现分散对齐效果。 QString text = \"测试分散对齐内容\"; //计算当前文本在当前字体下占用的宽度 QFont font = ui-\u003elabel-\u003efont(); int textWidth = ui-\u003elabel-\u003efontMetrics().width(text); //显示文本的区域宽度=标签的宽度-两边的边距 int width = ui-\u003elabel-\u003ewidth() - 12; //需要-1相当于中间有几个间隔 int count = text.count() - 1; //计算每个间距多少 qreal space = qreal(width - textWidth) / count; //设置固定间距 font.setLetterSpacing(QFont::AbsoluteSpacing, space); ui-\u003elabel-\u003esetFont(font); ui-\u003elabel-\u003esetText(text); 随着需求的不断增加，程序不断变大，用到的动态库也越来越多，到了发布程序的时候你会发现和可执行文件同一目录下文件数量真多，此时可能会考虑如何将一些库文件分门别类的存放，这样方便管理。 Qt提供的设置动态库路径的方法setLibraryPaths是用来搜索插件动态库的，而不是程序直接依赖的动态库。 很多人以为这个可以设置Qt的库或者程序中依赖的第三方库的路径，其实想想也知道，因为程序依赖这个库，找不到的话根本跑不起来，程序跑不起来怎么应用执行这个代码呢？ Qt默认是可用通过setLibraryPaths的方式设置Qt插件的动态库目录位置，比如数据库插件sqldrivers，因为这些库文件是真正在Qt程序跑起来以后通过插件形式去加载的。 还可以通过qt.conf文件设置 Plugins=“config” 指定所有插件在可执行文件下的config目录下。 要想设置程序直接依赖的动态库在其他目录，找遍全宇宙也只有一个办法，那就是设置环境变量，除此别无他法。 至于如何设置环境变量方式很多，比如手动在电脑上设置，或者搞个批处理文件执行命令行，在程序安装的时候自动执行，或者程序打包目录下用户手动运行这个批处理。 大神补充：设置插件的目录还可以通过在main函数最前面写 qputenv(“PATH”, QString(\"%1;%2”).arg(qgetenv(“PATH”), pluginFileInfo.path()).toLocal8Bit()); 来实现。 网友补充：最终找插件的路径其实就是这个 QT_PLUGIN_PATH 环境变量。 进度条控件如果设置的垂直方向，就算你设置了文本可见，会发现根本看不到进度文本，经过多方百折不挠的试探，以及和酷码大佬深入的探讨，发现只要设置下border样式（border:1px solid #ff0000、border:none、border-style:solid、border-radius:0px 任意一种）就行，就可以把文本显示出来，这TM就不知道Qt为什么总是不统一规则，这个BUG通用于任何版本，这个可能是因为边框的solid样式冲突了导致无法继续绘制，确切的说这必须是BUG，这个锅Qt必须背。 我们在使用QFileDialog::getOpenFileName、QFileDialog::getExistingDirectory等方法时，有时候会发现首次打开很卡，尤其是在默认目录很多文件的时候，此时你可以考虑设置这些函数最末尾的参数为QFileDialog::DontUseNativeDialog，表示不采用本地系统对话框，这样的话会采用Qt的对话框，速度快很多，估计系统的对话框在打开的时候会做很多初始化加载处理。 QFileDialog::getOpenFileName(this, \"\", \"\", \"\", 0, QFileDialog::DontUseNativeDialog); QFileDialog::getExistingDirectory(this, \"\", \"\", QFileDialog::DontUseNativeDialog); 滑块控件QSlider，如果设置的垂直样式，其进度颜色和剩余颜色，刚好和横向样式的颜色相反的，不确定这个是否是Qt的BUG，Qt456都是这个现象。 QSlider::groove","date":"0001-01-01","objectID":"/1/01/qt/:0:21","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"22：211-220 QMainWindow 在对停靠窗体进行排列的时候，有些不常用的设置容易遗忘，建议将 QMainWindow 的头文件函数过一遍一目了然。详细介绍各种停靠参数文章参见 https://zhuanlan.zhihu.com/p/388544168。 //设置允许各种嵌套比如上下排列左右排列非常灵活 //此设置会和下面的 setDockOptions 中的参数覆盖所以要注意顺序 //this-\u003esetDockNestingEnabled(true); //设置停靠参数,不允许重叠,只允许拖动和嵌套 this-\u003esetDockOptions(AnimatedDocks | AllowNestedDocks); //将底部左侧作为左侧区域，底部右侧作为右侧区域，否则底部区域会填充拉伸 this-\u003esetCorner(Qt::BottomLeftCorner, Qt::LeftDockWidgetArea); this-\u003esetCorner(Qt::BottomRightCorner, Qt::RightDockWidgetArea); 当我们在对QModelIndex取数据的时候，常规的角色的数据（QVariant类型支持to的比如toString、toInt、toDouble等）可以很方便的取出来，特定的数据类型需要用的万能取值模板函数 T value() 取出来。 //显示文本 QString text = index.data(Qt::DisplayRole).toString(); //文本对齐 int align = index.data(Qt::TextAlignmentRole).toInt(); //文字字体 QFont font = index.data(Qt::FontRole).value\u003cQFont\u003e(); //前景色 QColor color = index.data(Qt::ForegroundRole).value\u003cQColor\u003e(); //背景色 QColor color = index.data(Qt::BackgroundRole).value\u003cQColor\u003e(); 很多人以为拖曳只要在dropEvent事件就可以了，其实不行的，没有效果的，需要先在dragEnterEvent事件中执行event-\u003eaccept()才行，不然根本没有效果，很多人尤其是初学者都挂在这里，我就是在这里摔了一跤，好疼！ void frmMain::dropEvent(QDropEvent *event) { QList\u003cQUrl\u003e urls = event-\u003emimeData()-\u003eurls(); } void frmMain::dragEnterEvent(QDragEnterEvent *event) { if(event-\u003emimeData()-\u003ehasFormat(\"application/x-qabstractitemmodeldatalist\")) { event-\u003esetDropAction(Qt::MoveAction); event-\u003eaccept(); } else { event-\u003eignore(); } } Qt5.6以后内置的是webengine浏览器内核，如果需要做web交互的话必须用到 qwebchannel.js 这个文件，此文件是Qt官方提供的，所以不建议去改动其中的源码，要注意的是，由于官方对webengine的支持在不断更新，所以官方提供的对应Qt版本的 qwebchannel.js 文件也不同，意味着你要用对应提供的版本的 qwebchannel.js 文件才ok，该文件默认在 C:\\Qt\\Qt5.12.11\\Examples\\Qt-5.12.11\\webchannel\\shared 目录下。经过几十个Qt版本的测试发现，用高版本的 qwebchannel.js 放到低版本运行不行，低版本放到高版本可以，为了万无一失还是建议直接用对应版本的。 对于QString去除空格，有多种场景，可能需要去除左侧、右侧、所有等位置的空格。 //字符串去空格 -1=移除左侧空格 0=移除所有空格 1=移除右侧空格 2=移除首尾空格 3=首尾清除中间留一个空格 QString QUIHelperData::trimmed(const QString \u0026text, int type) { QString temp = text; QString pattern; if (type == -1) { pattern = \"^ +\\\\s*\"; } else if (type == 0) { pattern = \"\\\\s\"; //temp.replace(\" \", \"\"); } else if (type == 1) { pattern = \"\\\\s* +$\"; } else if (type == 2) { temp = temp.trimmed(); } else if (type == 3) { temp = temp.simplified(); } //调用正则表达式移除空格 if (!pattern.isEmpty()) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) temp.remove(QRegularExpression(pattern)); #else temp.remove(QRegExp(pattern)); #endif } return temp; } //测试代码 QString text = \" a b c d \"; //结果：a b c d QUIHelper::trimmed(text, -1); //结果：abcd QUIHelper::trimmed(text, 0); //结果： a b c d QUIHelper::trimmed(text, 1); //结果：a b c d QUIHelper::trimmed(text, 2); //结果：a b c d QUIHelper::trimmed(text, 3); Qt的网络库支持udp广播搜索和组播搜索，其中组播搜索可以跨网段搜索，有时候你会发现失灵，此时你可以尝试把本地的虚拟机的网卡禁用试试，估计就好了。还有就是在本地开启了代理啥的，先关掉试试。近期在使用tcpsocket连接的时候，发现在Qt4和Qt5中正常的程序，到了Qt6中就不行了，报错提示 The proxy type is invalid for this operation ，原来是本地设置了代理导致的，可能在Qt6以前会默认跳过去不处理。 //也可以通过代码设置跳过代理 #include \u003cQNetworkProxy\u003e QNetworkProxyFactory::setUseSystemConfiguration(false); //下面这样每次设置也可以 tcpSocket-\u003esetProxy(QNetworkProxy::NoProxy); //查阅到文章 https://www.cnblogs.com/cppskill/p/11730452.html //从5.8开始socket默认代理类型是DefaultProxy而不是NoProxy，不知道出于什么考虑。 关于交叉编译，对于初学者来说是个极难跨过去的砍（一旦跨过去了以后遇到需要交叉编译的时候都是顺水推舟信手拈来），因为需要搭建交叉编译环境，好在现在厂家提供的板子基本上都是测试好的环境，尤其是提供的编译器，不用自己再去折腾，按照官方手册来基本上不会有啥的的问题。 在linux系统上编译ffmpeg和qt都是非常简单的事情，初学者也会，前提只要本地的gcc g++编译器正常。 任何编译器包括嵌入式编译器，为了确保环境正常，你可以先查看对应的编译器版本是否ok，g++ -v 或者执行编译器所在目录的绝对路径。 交叉编译器查看版本 /opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux-g++ -v 编译器位数和操作系统位数有关，一般32位的编译器要在32位的系统上做交叉编译，虽然32位也可以安装依赖在64位系统做交叉编译，但是个人不建议，可能会出问题。64位的编译器只能在64位的系统。 设置环境变量只是为了编译的时候让自动寻找编译器，其实也完全可以不用设置环境变量，使用绝对路径指定编译器位置即可。 在linux上编译，无论是ffmpeg还是qt还是其他，都是通用的步骤，第一步：./configure 第二步：make 第三步：make install 。 至于具体configure后面有哪些参数，参照对应源码包的手册就行，搜索也一大堆。当然你用默认的就不带任何参数一般也可以，自动采用默认参数进行编译。 交叉编译ffmpeg命令：./configure –prefix=host –enable-static –disable-shared –disable-doc –cross-prefix=/opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux- –arch=arm –target-os=linux 交叉编译qt前提：修改mkspecs/qws/linux-arm-g++下面的qmake.conf，如果没有设置环境变量则设置对应编译器的绝对路径，并将编译器的名字改成你需要的。 比如修改gcc编译器：QMAKE_CC = /opt/FriendlyARM/toolscha","date":"0001-01-01","objectID":"/1/01/qt/:0:22","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"二、升级到Qt6 ","date":"0001-01-01","objectID":"/1/01/qt/:1:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"00：直观总结 增加了很多轮子，同时原有模块拆分的也更细致，估计为了方便拓展个管理。 把一些过度封装的东西移除了（比如同样的功能有多个函数），保证了只有一个函数执行该功能。 把一些Qt5中兼容Qt4的方法废弃了，必须用Qt5中对应的新的函数。 跟随时代脚步，增加了不少新特性以满足日益增长的客户需求。 对某些模块和类型及处理进行了革命性的重写，运行效率提高不少。 有参数类型的变化，比如 long * 到 qintptr * 等，更加适应后续的拓展以及同时对32 64位不同系统的兼容。 源码中的double数据类型全部换成了qreal，和Qt内部数据类型高度一致和统一。 我测试的都是QWidget部分，quick部分没有测试，估计quick部分更新可能会更多。 强烈建议暂时不要用Qt6.0到Qt6.2之间的版本，一些模块还缺失，相对来说BUG也比较多，推荐6.2.2版本开始正式迁移。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"01：01-10 万能方法：安装5.15版本，定位到报错的函数，切换到源码头文件，可以看到对应提示字样 QT_DEPRECATED_X(“Use sizeInBytes”) 和新函数。按照这个提示类修改就没错，一些函数是从Qt5.7 5.9 5.10等版本新增加的，可能你的项目还用的Qt4的方法，但是Qt6以前都兼容这些旧方法，到了Qt6就彻底需要用新方法了。PS：如果本身就是Qt6新增的功能函数则此方法无效 Qt6对core这个核心类进行了拆分，多出来core5compat，因此你需要在pro增加对应的模块已经代码中引入对应的头文件。 //pro文件引入模块 greaterThan(QT_MAJOR_VERSION, 4): QT += widgets greaterThan(QT_MAJOR_VERSION, 5): QT += core5compat //代码中引入头文件 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) #include \u003cQtWidgets\u003e #endif #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) #include \u003cQtCore5Compat\u003e #endif 默认Qt6开启了高分屏支持，界面会变得很大，甚至字体发虚，很多人会不习惯，因为这种模式如果程序很多坐标计算没有采用devicePixelRatio进行运算的话，100%会出现奇奇怪怪的问题，因为坐标不准确了。要取消这种效果可以设置高分屏缩放因子。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif 原有的随机数函数提示用QRandomGenerator替代，为了兼容所有qt版本，改动最小的办法是直接用c++中的随机数，比如qsrand函数换成srand，qrand函数换成rand，查看过源代码，其实封装的就是c++中的随机数，很多类似的封装比如qSin封装的sin。 QColor的 light 改成 lighter ，dark 改成 darker，其实 lighter、darker 这两个方法以前一直有。 QFontMetricsF 中的 fm.width 换成 fm.horizontalAdvance ，从5.11开始用新函数。 QPalette调色板枚举值，Foreground = WindowText, Background = Window，其中 Foreground 和 Background 没有了，要用 WindowText 和 Window 替代，以前就有。类似的还有 setTextColor 改成了 setForeground 。 QWheelEvent的 delta() 改成 angleDelta().y()，pos() 改成 position() 。 svg模块拆分出来了svgwidgets，如果用到了该模块则需要在pro增加 QT += svgwidgets ，同理opengl模块拆分出来了openglwidgets。 qlayout中的 margin() 函数换成 contentsMargins().left()，查看源码得知以前的 margin() 返回的就是 contentsMargins().left()，在四个数值一样的时候，默认四个数值就是一样。类似的还有setMargin移除了，统统用setContentsMargins。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"02：11-20 之前 QChar c = 0xf105 全部要改成强制转换 QChar c = (QChar)0xf105，不再有隐式转换，不然编译报错提示error: conversion from ‘int’ to ‘QChar’ is ambiguous 。 qSort等一些函数用回c++的 std::sort 。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) std::sort(ipv4s.begin(), ipv4s.end()); #else qSort(ipv4s); #endif Qt::WA_NoBackground 改成 Qt::WA_OpaquePaintEvent 。 QMatrix 类废弃了没有了，换成 QTransform ，函数功能基本一致，QTransform 类在Qt4就一直有。 QTime 计时去掉了，需要改成 QElapsedTimer ，QElapsedTimer 类在Qt4就一直有。 QApplication::desktop()废弃了， 换成了 QApplication::primaryScreen()。 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,0,0)) #include \"qscreen.h\" #define deskGeometry qApp-\u003eprimaryScreen()-\u003egeometry() #define deskGeometry2 qApp-\u003eprimaryScreen()-\u003eavailableGeometry() #else #include \"qdesktopwidget.h\" #define deskGeometry qApp-\u003edesktop()-\u003egeometry() #define deskGeometry2 qApp-\u003edesktop()-\u003eavailableGeometry() #endif 获取当前屏幕索引以及尺寸需要分别处理。 //获取当前屏幕索引 int QUIHelper::getScreenIndex() { //需要对多个屏幕进行处理 int screenIndex = 0; #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) int screenCount = qApp-\u003escreens().count(); #else int screenCount = qApp-\u003edesktop()-\u003escreenCount(); #endif if (screenCount \u003e 1) { //找到当前鼠标所在屏幕 QPoint pos = QCursor::pos(); for (int i = 0; i \u003c screenCount; ++i) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) if (qApp-\u003escreens().at(i)-\u003egeometry().contains(pos)) { #else if (qApp-\u003edesktop()-\u003escreenGeometry(i).contains(pos)) { #endif screenIndex = i; break; } } } return screenIndex; } //获取当前屏幕尺寸区域 QRect QUIHelper::getScreenRect(bool available) { QRect rect; int screenIndex = QUIHelper::getScreenIndex(); if (available) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) rect = qApp-\u003escreens().at(screenIndex)-\u003eavailableGeometry(); #else rect = qApp-\u003edesktop()-\u003eavailableGeometry(screenIndex); #endif } else { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) rect = qApp-\u003escreens().at(screenIndex)-\u003egeometry(); #else rect = qApp-\u003edesktop()-\u003escreenGeometry(screenIndex); #endif } return rect; } QRegExp类移到了core5compat模块，需要主动引入头文件 #include 。 //设置限制只能输入数字+小数位 QString pattern = \"^-?[0-9]+([.]{1}[0-9]+){0,1}$\"; //设置IP地址校验过滤 QString pattern = \"(2[0-5]{2}|2[0-4][0-9]|1?[0-9]{1,2})\"; //确切的说 QRegularExpression QRegularExpressionValidator 从5.0 5.1开始就有 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) QRegularExpression regExp(pattern); QRegularExpressionValidator *validator = new QRegularExpressionValidator(regExp, this); #else QRegExp regExp(pattern); QRegExpValidator *validator = new QRegExpValidator(regExp, this); #endif lineEdit-\u003esetValidator(validator); QWheelEvent构造参数和对应的计算方位函数变了。 //模拟鼠标滚轮 #if (QT_VERSION \u003c QT_VERSION_CHECK(6,0,0)) QWheelEvent wheelEvent(QPoint(0, 0), -scal, Qt::LeftButton, Qt::NoModifier); #else QWheelEvent wheelEvent(QPointF(0, 0), QPointF(0, 0), QPoint(0, 0), QPoint(0, -scal), Qt::LeftButton, Qt::NoModifier, Qt::ScrollBegin, false); #endif QApplication::sendEvent(widget, \u0026wheelEvent); //鼠标滚轮直接修改值 QWheelEvent *whellEvent = (QWheelEvent *)event; //滚动的角度,*8就是鼠标滚动的距离 #if (QT_VERSION \u003c QT_VERSION_CHECK(6,0,0)) int degrees = whellEvent-\u003edelta() / 8; #else int degrees = whellEvent-\u003eangleDelta().x() / 8; #endif //滚动的步数,*15就是鼠标滚动的角度 int steps = degrees / 15; qVariantValue 改成 qvariant_cast ，qVariantSetValue(v, value) 改成了 v.setValue(val)。相当于退回到最原始的方法，查看qVariantValue源码封装的就是qvariant_cast。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:3","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"03：21-30 QStyleOption的init改成了initFrom。 QVariant::Type 换成了 QMetaType::Type ，本身以前的 QVariant::Type 封装的就是 QMetaType::Type 。 QStyleOptionViewItemV2 V3 V4 之类的全部没有了，暂时可以用 QStyleOptionViewItem 替代。 QFont的 resolve 的一个重载函数换成了 resolveMask。 QSettings的 setIniCodec 方法移除了，默认就是utf8，不需要设置。 qcombobox 的 activated(QString) 和 currentIndexChanged(QString) 信号删除了，用int索引参数的那个，然后自己通过索引获取值。个人觉得这个没必要删除。 qtscript模块彻底没有了，尽管从Qt5时代的后期版本就提示为废弃模块，一致坚持到Qt6才正式废弃，各种json数据解析全部换成qjson类解析。 QByteArray 的 append indexOf lastIndexOf 等众多方法的QString参数重载函数废弃了，要直接传 QByteArray，就在原来参数基础上加上 .toUtf8() 。查看源码也看得到以前的QString参数也是转成.toUtf8()再去比较。 QDateTime的时间转换函数 toTime_t + setTime_t 名字改了，对应改成了 toSecsSinceEpoch + setSecsSinceEpoch ，这两个方法在Qt5.8时候新增加的。 QLabel的 pixmap 函数之前是指针 *pixmap() 现在换成了引用 pixmap()。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:4","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"04：31-40 QTableWidget的 sortByColumn 方法移除了默认升序的方法，必须要填入第二个参数表示升序还是降序。 qtnetwork模块中（TCP/UDP相关的socket）的错误信号error换成了errorOccurred，就改了个名字，注意websocket那块居然没统一改过来依然是叫error。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) connect(udpSocket, SIGNAL(errorOccurred(QAbstractSocket::SocketError)), this, SLOT(error())); connect(tcpSocket, SIGNAL(errorOccurred(QAbstractSocket::SocketError)), this, SLOT(error())); #else connect(udpSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error())); connect(tcpSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error())); #endif //特别注意websocket中依然还是用error connect(webSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error())); XmlPatterns模块木有了，全部用xml模块重新解析。 nativeEvent的参数类型变了。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) bool nativeEvent(const QByteArray \u0026eventType, void *message, qintptr *result); #else bool nativeEvent(const QByteArray \u0026eventType, void *message, long *result); #endif QButtonGroup的buttonClicked信号中int参数的函数全部改名字叫idClicked。 QButtonGroup *btnGroup = new QButtonGroup(this); #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) connect(btnGroup, SIGNAL(idClicked(int)), ui-\u003exstackWidget, SLOT(setCurrentIndex(int))); #else connect(btnGroup, SIGNAL(buttonClicked(int)), ui-\u003exstackWidget, SLOT(setCurrentIndex(int))); #endif QWebEngineSettings之前是QWebEngineSettings::defaultSettings();现在改成了QWebEngineProfile::defaultProfile()-\u003esettings();通过查看之前的源码得知QWebEngineSettings::defaultSettings();封装的就是QWebEngineProfile::defaultProfile()-\u003esettings();因为Qt6去除了N多过度封装的函数。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) QWebEngineSettings *webSetting = QWebEngineProfile::defaultProfile()-\u003esettings(); #else QWebEngineSettings *webSetting = QWebEngineSettings::defaultSettings(); #endif Qt6将enterEvent的参数QEvent改成了QEnterEvent也不打个招呼。这种改变编译也不会提示的。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) void enterEvent(QEnterEvent *); #else void enterEvent(QEvent *); #endif //后面经过JasonWong大佬的指点，从父类重新实现的virtual修饰的函数，建议都加上override关键字。 //这样的话一旦父类的函数或者参数变了则会提示编译报错，而不是编译通过但是运行不正常会一脸懵逼茫然，从而把锅扣给Qt。 //下面是父类函数 virtual void enterEvent(QEvent *event); //子类建议加上override void enterEvent(QEvent *event) override; Qt6中多个类进行了合并，比如现在QVector就成了QList的别名，意味着这两个类是同一个类没有任何区别，可能Qt内部对两种的优点都集中在一起，并尽量重写算法或者其他处理规避缺点。同理QStringList现在也成了 QList 的别名，是同一个类，没有单独的类。 在Qt4时代默认QWidget构造函数父类是0，到了Qt5变成了Q_NULLPTR，到了Qt6居然用的是默认的c++标准中的nullptr而不是Qt自定义定义的Q_NULLPTR（同样的还有Q_DECL_OVERRIDE换成了用override等），可能是为了彻底抛弃历史包袱拥抱未来。 //下面依次是Qt4/5/6的写法 MainWindow(QWidget *parent = 0); MainWindow(QWidget *parent = Q_NULLPTR); MainWindow(QWidget *parent = nullptr); //查阅Qt源码查看Q_NULLPTR原来是根据编译器定义来选择 #ifdef Q_COMPILER_NULLPTR # define Q_NULLPTR nullptr #else # define Q_NULLPTR NULL #endif //Qt高版本兼容低版本写法比如Qt5/6都支持 *parent = 0 这种写法。 对于委托的进度条样式QStyleOptionProgressBar类的属性，在Qt4的时候不能设置横向还是垂直样式，默认横向样式，要设置orientation需要用另外的QStyleOptionProgressBarV2。从Qt5开始新增了orientation和bottomToTop属性设置。在Qt6的时候彻底移除了orientation属性，只有bottomToTop属性，而且默认进度是垂直的，很操蛋，理论上默认应该是横向的才对，绝大部分进度条场景都是横向的。这个时候怎么办呢，原来现在的处理逻辑改了，默认垂直的，如果要设置横向的直接设置 styleOption.state |= QStyle::State_Horizontal 这种方式设置才行，而Qt6以前默认方向是通过 orientation 值取得，这个State_Horizontal从Qt4就一直有，Qt6以后要主动设置下才是横向的就是。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:5","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"05：41-50 Qt6.2版本开始增加了对多媒体模块的支持，但是在mingw编译器下还是有问题，直到6.2.2才修复这个问题，官网解释是因为mingw编译器版本不支持，到6.2.2采用了新的mingw900_64，这个编译器版本才支持。所以理论上推荐从6.2.2开始使用新的Qt6。 QTextStream中的setCodec方法改成了setEncoding，参数变了，功能更强大。 QTextStream stream(\u0026file); #if (QT_VERSION \u003c QT_VERSION_CHECK(6,0,0)) stream.setCodec(\"gbk\"); #else stream.setEncoding(QStringConverter::System); #endif QModelIndex的查找子节点child函数去掉了，但是查找父节点parent函数保留，查阅代码得知之前的child函数就是封装的model-\u003eindex(row, column, QModelIndex)函数。 //下面两个函数等价 如果要兼容Qt456则用下面这个方法 QModelIndex index = indexParent.child(i, 0); QModelIndex index = model-\u003eindex(i, 0, indexParent); //下面两个函数等价 如果要兼容Qt456则用下面这个方法 QModelIndex indexChild = index.child(i, 0); QModelIndex indexChild = model-\u003eindex(i, 0, index); 之前QPixmap类中的静态函数grabWindow和grabWidget彻底废弃了，改成了用QApplication::primaryScreen()-\u003egrabWindow，其实这个从Qt5开始就建议用这个。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) QPixmap pixmap = QApplication::primaryScreen()-\u003egrabWindow(widget-\u003ewinId()); #else QPixmap pixmap = QPixmap::grabWidget(widget-\u003ewinId()); #endif ","date":"0001-01-01","objectID":"/1/01/qt/:1:6","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"三、Qt安卓经验 ","date":"0001-01-01","objectID":"/1/01/qt/:2:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"01：01-05 pro中引入安卓拓展模块 QT += androidextras 。 pro中指定安卓打包目录 ANDROID_PACKAGE_SOURCE_DIR = $$PWD/android 指定引入安卓特定目录比如程序图标、变量、颜色、java代码文件、jar库文件等。 AndroidManifest.xml 每个程序唯一的一个全局配置文件，里面xml格式的数据，标明支持的安卓版本、图标位置、横屏竖屏、权限等。这个文件是最关键的，如果没有这个文件则Qt会默认生成一个。 android/res/drawable-hdpi drawable-xxxhdpi 等目录下存放的是应用程序图标。 android/res/layout 目录下存放的布局文件。 android/res/values/libs.xml 存储的一些变量值。 android/libs 目录下存放的jar库文件。 android/src 目录下存放的java代码文件，可以是根据包名建立的一层层子目录，也可以直接在src目录下。 其他目录自行搜索安卓目录规范。 后面的说明统一用的android目录举例，其实你可以改成任意目录，比如你的代码目录下是xxoo存放的安卓相关的打包文件，你就写成 ANDROID_PACKAGE_SOURCE_DIR = $$PWD/xxoo 。 java类名必须和文件名完全一致，区分大小写。 java类必须在android/src目录下不然不会打包到apk文件，可以是子目录比如 android/src/com/qt 。 Qt代码中的QAndroidJniObject指定传入的java包名，必须严格和java文件package完全一致，不然程序执行到此处会因为找不到而崩溃。 android/scr/MainActivity.java 顶部 没有 package 则代码中必须是 QAndroidJniObject javaClass(“MainActivity”); android/scr/MainActivity.java 顶部 package com.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com/qandroid/MainActivity”); android/scr/com/example/MainActivity.java 顶部 package com.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com/qandroid/MainActivity”); android/scr/com/example/MainActivity.java 顶部 package com.example.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com/qandroid/example/MainActivity”); 总之这个包名是和代码中的package后面一段吻合，而不是目录路径。为了统一管理方便查找文件，建议包名和目录路径一致。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"02：06-10 Qt只能干Qt内部类的事情，做一些简单的UI交互还是非常方便，如果涉及到底层操作，还是需要熟悉java会如虎添翼，一般的做法就是写好java文件调试好，提供静态方法给Qt调用，这样通过QAndroidJniObject这个万能胶水可以做到Qt程序调用java中的函数并拿到执行结果，也可以接收java中的函数。 pro中通过 OTHER_FILES += android/AndroidManifest.xml OTHER_FILES += android/src/JniMessenger.java 引入文件其实对整个程序的编译打包没有任何影响，就是为了方便在QtCreator中查看和编辑。 在Qt中与安卓的java文件交互都是用万能的QAndroidJniObject，可以执行java类中的普通函数、静态函数，可以传类对象jclass、类名className、方法methodName、参数，也可以拿到执行结果返回值。 (I)V括号中的是参数类型，括号后面的是返回值类型，void返回值对应V，由于String在java中不是数据类型而是类，所以要用Ljava/lang/String;表示，其他类作为参数也是这样处理。 调用实例方法：callMethod、callObjectMethod。 调用静态方法：callStaticMethod、callStaticObjectMethod。 不带Object的函数名用来执行无返回值或者常规返回值int、float等的方法。 如果返回值是String或者类则需要用带Object的函数名来执行，返回QAndroidJniObject类型再转换处理拿到结果，比如toString拿到字符串。 各种参数和返回值示例。 package org.qt; import org.qt.QtAndroidData; public class QtAndroidTest { //需要通过实例来调用 测试发现不论 private public 或者不写都可以调用 我擦 private void printText() { System.out.println(\"printText\"); } public static void printMsg() { System.out.println(\"printMsg\"); } public static void printValue(int value) { System.out.println(\"printValue:\" + value); } public static void setValue(float value1, double value2, char value3) { System.out.println(\"value1:\" + value1 + \" value2:\" + value2 + \" value3:\" + value3); } public static int getValue() { return 65536; } public static int getValue(int value) { return value + 1; } public static void setMsg(String message) { System.out.println(\"setMsg:\" + message); } public static String getMsg() { return \"hello from java\"; } public static void setText(int value1, float value2, boolean value3, String message) { System.out.println(\"value1:\" + value1 + \" value2:\" + value2 + \" value3:\" + value3 + \" message:\" + message); } public static String getText(int value1, float value2, boolean value3, String message) { //同时演示触发静态函数发给Qt QtAndroidData.receiveData(\"message\", \"你好啊 java\"); //下面两种办法都可以拼字符串 return \"value1:\" + value1 + \" value2:\" + value2 + \" value3:\" + value3 + \" message:\" + message; //return \"value1:\" + String.valueOf(value1) + \" value2:\" + String.valueOf(value2) + \" value3:\" + String.valueOf(value3) + \" message:\" + message; } } #include \"androidtest.h\" //java类对应的包名+类名 #define className \"org/qt/QtAndroidTest\" void AndroidTest::test() { jint a = 12; jint b = 4; //可以直接调用java内置类中的方法 jint max = QAndroidJniObject::callStaticMethod\u003cjint\u003e(\"java/lang/Math\", \"max\", \"(II)I\", a, b); //jclass javaMathClass = \"java/lang/Math\"; jdouble value = QAndroidJniObject::callStaticMethod\u003cjdouble\u003e(\"java/lang/Math\", \"random\"); qDebug() \u003c\u003c \"111\" \u003c\u003c max \u003c\u003c value; } void AndroidTest::printText() { QAndroidJniEnvironment env; jclass clazz = env.findClass(className); QAndroidJniObject obj(clazz); obj.callMethod\u003cvoid\u003e(\"printText\"); } void AndroidTest::printMsg() { #if 0 //查看源码得知不传入jclass类的函数中内部会自动根据类名查找jclass QAndroidJniEnvironment env; jclass clazz = env.findClass(className); QAndroidJniObject::callStaticMethod\u003cvoid\u003e(clazz, \"printMsg\"); #else //没有参数和返回值可以忽略第三个参数 QAndroidJniObject::callStaticMethod\u003cvoid\u003e(className, \"printMsg\"); //QAndroidJniObject::callStaticMethod\u003cvoid\u003e(classNameTest, \"printMsg\", \"()V\"); #endif } void AndroidTest::printValue(int value) { QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"printValue\", \"(I)I\", (jint)value); } void AndroidTest::setValue(float value1, double value2, char value3) { QAndroidJniObject::callStaticMethod\u003cvoid\u003e(className, \"setValue\", \"(FDC)V\", (jfloat)value1, (jdouble)value2, (jchar)value3); } int AndroidTest::getValue(int value) { //java类中有两个 getValue 函数 一个需要传参数 //jint result = QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"getValue\"); jint result = QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"getValue\", \"(I)I\", (jint)value); return result; } void AndroidTest::setMsg(const QString \u0026msg) { QAndroidJniObject jmsg = QAndroidJniObject::fromString(msg); QAndroidJniObject::callStaticMethod\u003cvoid\u003e(className, \"setMsg\", \"(Ljava/lang/String;)V\", jmsg.object\u003cjstring\u003e()); } QString AndroidTest::getMsg() { QAndroidJniObject result = QAndroidJniObject::callStaticObjectMe","date":"0001-01-01","objectID":"/1/01/qt/:2:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"03：11-15 安卓中一个界面窗体对应一个Activity，多个界面就有多个Activity，而在Qt安卓程序中，Qt这边只有一个Activity那就是QtActivity（包名全路径 org.qtproject.qt5.android.bindings.QtActivity），这个QtActivity是固定的写好的，整个Qt程序都是在这个QtActivity界面中。你打开AndroidManifest.xml文件可以看到对应节点有个name=org.qtproject.qt5.android.bindings.QtActivity，所以如果要让Qt程序能够更方便通畅的与对应的java类进行交互（需要上下文传递Activity的，比如震动，消息提示等），建议新建一个java类，继承自QtActivity即可，这样相当于默认Qt启动的就是你java类中定义的Activity，可以很好的控制和交互。 由于AndroidManifest.xml文件每个程序都可能不一样，为了做成通用的组件，这就要求可能不能带上AndroidManifest.xml文件，这样的话每个Qt安卓程序都启动默认内置的Activity，如果依赖Activity上下文的执行函数需要传入Qt的Activity才行，这里切记Qt的Activity包名是 Lorg/qtproject/qt5/android/bindings/QtActivity; 之前顺手想当然的写的 Landroid/app/Activity; 发现死活不行，原来是包名错了。 一个Qt安卓程序中可以有多个Java类，包括继承自Activity的类（这样的Activity可以通过QtAndroid::startActivity函数来调用），但是只能有一个通过AndroidManifest.xml文件指定的Activity，不指定会默认一个。如果java类中不需要拿到Qt的Activity进行处理的，可以不需要继承任何Activity，比如全部是运算的静态函数。 在java类中如果上面没有主动引入包名，则下面需要写全路径，引入了则不需要全路径可以直接用（包括枚举值都可以直接写，比如 VIBRATOR_SERVICE 这种枚举值引入了包名后不需要写android.content.Context.VIBRATOR_SERVICE），建议引入包名，比如上面写了 import org.qtproject.qt5.android.bindings.QtActivity; 则下面继承类可以直接写 public class QtAndroidActivity extends QtActivity，如果没有引入则需要写成 public class QtAndroidActivity extends org.qtproject.qt5.android.bindings.QtActivity 。 建议搭配 android studio 工具开发，因为在 android studio 中写代码都有自动语法提示，包名会提示自动引入，可以查看有那些函数方法等，还可以校验代码是否正确，而如果在QtCreator中手写有时候可能会写错，尤其是某个字母写错，当然这种错误是编译通不过的，会提示错误在哪行。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:3","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"04：16-20 用Qt做安卓开发最大难点两个，第一个就是传参数这些奇奇怪怪的字符（Ljava/lang/String;）啥意思，如何对应，这也不是Qt故意为难初学者啥的，因为这套定义机制是安卓系统底层要求的，系统层面定义的一套规范，其实这个在帮助文档中写的很清楚，都有数据类型对照表，用熟悉了几次就很简单了。第二个难点就是用java写对应的类，如果是会安卓开发的人来说那不要太简单，尤其是搜索那么方便一大堆，没有搞过安卓开发的人来说就需要学习下，这个没有捷径，只是希望Qt能够尽可能最大化的封装一些可以直接使用的类，比如后期版本就提供了权限申请的类 QtAndroid::requestPermissionsSync 之类的，用起来就非常的爽，不用自己写个java类调来调去的。 理论上来说按照Qt提供的万能大法类QAndroidJniObject，可以不用写java类也能执行各种处理，拿到安卓库中的属性和执行方法，就是写起来太绕太费劲，在java类中一行代码，这里起码三行，所以终极大法就是熟悉安卓开发，直接封装好java类进行调用。 测试发现GetStringUTFChars方法对应的数据字符串中不能带有temp字样，否则解析有问题，不知什么原因。 数据类型参数和返回值类型必须完全一致，否则执行会提示找不到对应的函数，有返回值一定要写上返回值。 jar文件对包名的命名没有要求，只要放在android/libs目录下即可，安卓底层是通过包名去查找，而不是通过文件名，你甚至可以将原来的包名重新改成也可以正常使用，比如classes.jar改成test.jar也能正常使用。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:4","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"05：21-25 关于权限设置，在早期的安卓版本，所有权限都写在全局配置文件AndroidManifest.xml中，这种叫安装时权限，就是安装的时候告诉安卓系统当前app需要哪些权限。大概从安卓6开始，部分权限需要动态申请，这种叫动态权限，这种申请到的权限也可以动态撤销，就是要求程序再次执行代码去向系统申请权限，比如拍照、存储读写等。也不是所有的权限都改成了动态申请，意味着兼容安卓6以上的系统你既要在AndroidManifest.xml中写上要求的权限，也要通过checkPermission申请你需要的权限。 android studio 新建并生产jar包步骤。 第一步：文件（File）-》新建（new）-》项目（new project）-》空白窗体（empty activity）。 第二步：刚才新建好的项目鼠标右键新建（new）-》模块（new module）-》安卓库（android library）。 说明：如果选择的不是安卓库（android library）而是java库（Java Library），则直接编译出来的就是jar文件，默认包名 com.example.lib.MyClass。推荐选择java库，编译后不用去一堆文件中找jar文件。 第三步：写好库名字，根据项目需要选择好最低sdk版本-》完成。 第四步：在刚才新建好的库项目mylibrary，依次找到子节点src/main/java/com.example.mylibrary上鼠标右键新建-》class类。切记是这个节点不是java节点或者其他节点。 第五步：写好你的类方法函数等。 package com.example.mylibrary; public class Test { public static int add(int a, int b) { return a + b; } } 第六步：选中库项目mylibrary，菜单执行编译（build）-》编译库（make module xxx）。 第七步：此时在mylibrary/build目录下有outputs目录和intermediates目录，其中outputs/aar目录下是生成的Android库项目的二进制归档文件，包含所有资源，class以及res资源文件全部包含。有时候我们仅仅需要jar文件，只包含了class文件与清单文件 ，不包含资源文件，如图片等所有res中的文件。需要到intermediates/aar_main_jar/debug目录下，可以看到classes.jar，将这个拷贝出来使用即可。当然你也可以对刚才的aar文件用解压缩软件解压出来也能看到classes.jar，是同一个文件。 其他：调用jar包非常简单，只需要将jar文件放在你的项目的libs目录下即可，对应的包名和函数一般jar包提供者会提供，没有提供的话，可以在android studio中新建空白项目，切换到project视图，找到libs目录，鼠标右键最下面作为包动态库添加到项目，导入包完成以后会自动在libs目录列出，双击刚刚导入的包然后就自动列出对应的类和函数。 Qt安卓使用jar包步骤。 第一步：将classes.jar放到android/libs目录下，为啥是这个目录？因为这是安卓的规则约定，这个目录就是放库文件，放在这个目录下的文件会自动打包编译到apk文件中。 第二步：调用jar文件之前，前提是你知道jar文件中的函数详细信息，这个一般jar提供者会提供好手册，如果代码没有混肴的话，你可以在android studio中双击打开查阅具体的函数。 第三步：如果jar文件中的函数简单，直接拿到结果不需要绕来绕去，可以直接写Qt类来调用；如果还是很复杂，建议再去新建java类处理完再交给Qt，当然也可以让jar的作者尽可能封装函数的时候就做好，尽量提供最简单的接口返回需要的数据。比如返回图片数据可以做成jar内部存储好图片，然后返回图片路径即可，不然有些数据转换也挺烦。 第四步：编写最终的调用函数。 int AndroidJar::add(int a, int b) { #ifdef Q_OS_ANDROID const char *className = \"com/example/mylibrary/Test\"; jint result = QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"add\", \"(II)I\", (jint)a, (jint)b); return result; #endif } Qt6中对安卓支持部分做了大的改动，目前还不完善，如果是不涉及到与java交互的纯Qt项目，可以正常移植，涉及到的暂时不建议移植到Qt6，等所有类完善了再说。 移除了安卓插件androidextras，将其中部分功能类移到core模块中，不需要额外引入。 类名发生了变化，比如QAndroidJniObject改成了QJniObject、QAndroidJniEnvironment改成了QJniEnvironment，可能是为了统一移动开发平台类，弱化安卓的影响。 对应的安卓jdk要用jdk11而不是jdk1.8，Qt5.15两个都支持，建议就统一用jdk11。 对应封装的java类包名去掉了qt5标识，org.qtproject.qt5.android.bindings.QtActivity改成了org.qtproject.qt.android.bindings.QtActivity、org.qtproject.qt5.android.bindings.QtApplication改成了org.qtproject.qt.android.bindings.QtApplication。 对安卓最低sdk有要求，所以建议在配置AndroidManifest.xml文件的时候不要带上最低版本要求。 对AndroidManifest.xml文件内容有要求，之前Qt5安卓的不能在Qt6安卓下使用，具体内容参见示例下的文件。 对应示例demo在 C:\\Qt\\Examples\\Qt-6.3.0\\corelib\\platform 目录下，之前是 C:\\Qt\\Examples\\Qt-5.15.2\\androidextras ，目前就一个示例，可能因为其他类还没有移植好。 如果想要安卓全屏遮挡住顶部状态栏，可以在main函数中将show改成showFullScreen即可，当然也可以采用java的方式在onCreate函数中加一行 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); ","date":"0001-01-01","objectID":"/1/01/qt/:2:5","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"06：25-30 横竖屏切换的识别，在Qt中会同时反映到resizeEvent事件中，你可以在这个是尺寸变化后读取下当前屏幕是横屏还是竖屏，然后界面上做出调整，比如上下排列改成左右排列。 由于不同Qt版本对应的安卓配置文件 AndroidManifest.xml 内容格式不一样，高版本和低版本模板格式互不兼容，所以建议使用自己的Qt版本创建的 AndroidManifest.xml 文件，创建好以后如果使用的是自己重新定义的java文件的启动窗体则需要将 AndroidManifest.xml 文件中的 android:name=“org.qtproject.qt5.android.bindings.QtActivity” 换掉就行。 如果自己用android studio编译的jar文件放到Qt项目的libs目录下，导致编译通不过，提示 com.android.dx.cf.iface.ParseException: bad class file magic 之类的，那是因为jdk版本不一致导致的，你可能需要在android studio项目中找到模块编jdk版本设置的地方降低版本，比如你用的ndk是r14，则需要选择jdk1.6或者jdk1.7。一般来说高版本兼容低版本，因为ndk版本太低无法兼容jdk1.8。后面发现如果直接新建的是java库（Java Library）则不存在这个问题，如果选择的是安卓库（android library）就可能有这个问题。 安卓项目配置文件是固定的名字 AndroidManifest.xml ，改成其他名字就不认识，不要想当然改成其他名字导致无法正常识别。 AndroidManifest.xml文件中的package=“org.qtproject.example\"是包名，也是整个apk程序的内部唯一标识，如果多个apk这个包名一样，则会覆盖，所以一定要注意不同的程序记得把这个包名改成你自己的。这个包名也决定了java文件中需要使用资源文件时候的引入包名 import org.qtproject.example.R; 如果包名不一样则编译都通不过。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:6","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"四、Qt设计模式 读《c++ Qt设计模式》书籍整理的一点经验。此书和官方的《C++ GUI Qt4编程》一起的。 通常而言，好的做法是在包含了Qt头文件之后再包含非Qt头文件，由于Qt（为编译器和预处理器）定义了许多符号，这使得避免名称冲突变得更容易，也更容易找到文件。 #include \"frminput2019.h\" #include \"ui_frminput2019.h\" #include \"qdatetime.h\" #include \"qdebug.h\" #include \"input2019.h\" #include \"inputnumber.h\" 一种好的编程实践是在代码中使用const实体而不是嵌入数字型常量（有时称他们为“幻数”）。如果以后需要修改他的值时，就可以获得这种灵活性。一般而言，将常量“孤立”出来，可提高程序的可维护性。 //不推荐写法 for (int i = 0; i \u003c 100; ++i) { ... } //推荐下面的写法 const int count = 100; for (int i = 0; i \u003c count; ++i) { ... } 内存管理使程序员获得了强大的能力，但是，“权力越大，责任越大”。 只要有可能，就应当使用列表而不是数组，比如应该使用 QList 代替 int [] ，在c++中数组被看成是“邪恶的”。 在利用Qt编写程序的过程中，因为Qt的父子所有权继承关系，很少会用到智能指针，因为需要调用delete的情况很少。任何时候只要我们需要调用delete，或者是需要将某个指针设定为0时，应该考虑使用一个智能指针。 实际上，我们不能完全确定使用多线程就一定能够真正改善程序的性能，例如，如果增加使用线程的数量，使他与系统可用的内核数量成正比，这样做或许还会降低程序的性能，因为所获得的收益会因线程竞争的剧增而消失殆尽。有时候，单线程中最有效的算法在多线程中却不一定有效。因此，如果真的是想改进程序的性能，理想的做法是，使用不同的实现方法，并与他们的性能进行比较后加以分类，当然测试对比的前提是使用完全相同的硬件和软件配置环境。 在源代码中关于文件路径，使用 / 会更方便一些，因为无论是在何种平台上，Qt都能理解他，不需要对他进行转换。但是，当我们想为用户显示路径时，最好还是根据应用程序所在平台的正确形式来显示他。 当我们有很多项数据需要处理时，比如成千上万或者更多，那么为每个处理都创建一个线程可能导致大量的开销，这样来依次处理数据或许更快些。一种解决办法就是创建少量的辅助线程，并让每个线程只处理一组数据。 ","date":"0001-01-01","objectID":"/1/01/qt/:3:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"五、Qt大佬专区 ","date":"0001-01-01","objectID":"/1/01/qt/:4:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"5.1 酷码大佬 微信：Kuma-NPC 关于Qt事件传递的一个说明： 通常写win32程序，鼠标消息应该是直接发给指定窗口句柄的，指定窗口没有处理就会转化成透传消息，交给父窗口处理。你在一个普通文字label上点击，父窗口也能收到鼠标事件。 Qt应该是所有消息都发给了顶层窗口，所以事件分发逻辑是自己处理，主窗口收到鼠标事件然后Qt自己分发给指定子控件，QEvent会有ignore或者accept表示自己处理了没有，例如鼠标点击事件，事件分发器发现没有被处理，数据重新计算然后分发给父窗口。这样父窗口收到的事件坐标就是基于自己窗口内的。用eventFilter就需要自己计算坐标。 再比如，当使用QDialog，放一个QLineEdit并设置焦点，按Esc时QDialog也会自动关闭，本质上就是因为QLineEdit并不处理Esc的按键事件，透传给了QDialog。 ","date":"0001-01-01","objectID":"/1/01/qt/:4:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"5.2 小豆君 无论你是学Qt，Java，Python或其它，都需要明白一个道理：摒弃掉你的好奇心，千万不要去追求第三方类或工具是怎么实现的，这往往会让你收效甚微，其实，你只需要熟练掌握它的接口，知道类的目的即可，不可犯面向过程的毛病，刨根问底。记住，你的目标是让其它工具为你服务，你要踩在巨人的肩膀上创造世界。 Qt真正的核心：元对象系统、属性系统、对象模型、对象树、信号槽。往死里啃这五大特性，在你的项目中，逐渐的设法加入这些特性，多多练习使用它们，长此以往你会收获意想不到的效果。 一边请教别人，一边多多重构，其实编码这条路虽然有人给你指路，但真正走下去的是你自己，当你真正走完时，你的编码水平一定会有非常大的提升。也许别人1000行的代码，在你这里几十行就搞定了，这也正事Qt的魅力。 在阅读Qt的帮助文档时，要静下心来，不要放过每一句，记住在文档中没有废话，尤其是每段的开头。 ","date":"0001-01-01","objectID":"/1/01/qt/:4:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"六、其他经验 Qt界的中文乱码问题，版本众多导致的如何选择安装包问题，如何打包发布程序的问题，堪称Qt界的三座大山！ 在Qt的学习过程中，学会查看对应类的头文件是一个好习惯，如果在该类的头文件没有找到对应的函数，可以去他的父类中找找，实在不行还有爷爷类，肯定能找到的。通过头文件你会发现很多函数接口其实Qt已经帮我们封装好了，有空还可以阅读下他的实现代码。 Qt安装目录下的Examples目录下的例子，看完学完，月薪20K起步；Qt常用类的头文件的函数看完学完使用一遍并加以融会贯通，月薪30K起步。 Qt在开发阶段不支持中文目录（运行阶段可以，比如打包发布的程序放到中文目录运行是ok的），切记，这是无数人可能犯的错误，在安装Qt集成开发环境以及编译器的时候，务必记得目录必须英文，Qt项目源码也必须是英文目录，否则很可能不正常，建议尽量用默认的安装位置。 如果出现崩溃和段错误，80%都是因为要么越界，要么未初始化，死扣这两点，80%的问题解决了。 Qt一共有几百个版本，关于如何选择Qt版本的问题，我一般保留四个版本，为了兼容Qt4用4.8.7，最后的支持XP的版本5.7.0，最新的长期支持版本比如5.15，最高的新版本比如5.15.2。强烈不建议使用4.7以前和5.0到5.3之间的版本（Qt6.0到Qt6.2之间、不含6.2的版本也不建议，很多模块还没有集成），太多bug和坑，稳定性和兼容性相比于之后的版本相当差，能换就换，不能换睡服领导也要换。如果没有历史包袱建议用5.15.2，目前新推出的6.0版本也强烈不建议使用，官方还在整合当中，好多类和模块暂时没有整合，需要等到6.2.2版本再用。 Qt和msvc编译器常见搭配是Qt5.7+VS2013、Qt5.9+VS2015、Qt5.12+VS2017、Qt5.15+VS2019、Qt6.2+VS2019，按照这些搭配来，基本上常用的模块都会有，比如webengine模块，如果选用的Qt5.12+msvc2015，则很可能官方没有编译这个模块，只是编译了Qt5.12+msvc2017的，如果一定要用msvc2015不想换msvc2017则只能选择Qt5.9+msvc2015套件，或者自行源码重新编译（这个难度超大，初学者绕过）。 Qt默认有对应VS版本，在下载对应VS插件的时候心里要有个数，官方默认提供的是原配的插件，如果想要Qt4.8+VS2015的插件，需要自行编译。一般来说是Qt4.8原配VS2010，Qt5.6原配VS2013，Qt5.9原配VS2015，Qt5.12原配VS2017，Qt5.15原配VS2019，切记：原配最好。 用Qt做开发机器建议用win10，尤其是2021年以后新发布的Qt版本，比如Qt5.12.12、Qt5.15.2、Qt6.2.2等，因为很可能自带的QtCreator用的最新的版本，Qt6开始不再支持win7，或者由于其他的原因，对win7的支持不友好，会出现奇奇怪怪的问题等，所以又是没得选必须用win10。建议各位拥抱新时代的变化，这世上唯一不变的只有变化。 新版本Qt安装包安装的时候需要填写注册信息，如果不想填写，先禁用网卡，在运行安装包，可以直接跳过这一步进行安装。从Qt5.15开始不再提供离线安装包，意味着必须使用在线安装器安装Qt的后续版本，必须填写用户信息，没得选。 终极秘籍：如果遇到问题搜索Qt方面找不到答案，试着将关键字用JAVA C# android打头，你会发现别有一番天地，其他人其他语言其他领域很可能做过！ 如果Qt能从下面几个方面努力，相信会更有发展前景。 QWidget支持CSS3，具有诸多的牛逼的效果，目前支持的是CSS2。 QWidget支持GPU绘制，可选切换CPU或者GPU，提升绘制效率，利用现在强大的硬件。 Qml无缝支持js，可以利用现在各种js轮子，指数级提升qml的项目范围。 支持将程序转成web运行，比如转成cgi之类的程序，目前Qt for WebAssembly很鸡肋，功能极其有限，sql/network/本地访问等都不支持，首次加载速度超慢，大部分Qt类还不支持。 Qt自从4.7以后引入的QML。从此以后，Qt开发就分成了两种流派，一者使用原来的C++ 语言进行开发，另外一种使用QML语言进行开发。这下搞得嘞，经常吵吵不亦乐乎，在Qt界从此就有两大阵营产生激烈的纷争，那就是选用qml还是widget好，大量初学者也会问这个问题，有以下几点总结。 widget属于传统界面开发，和VB/VC/Delphi等拖曳控件开发类似，走CPU绘制，能最大化的兼容现有的硬件和过去的相对偏低性能的硬件。 qml属于新时代的产物，大概从2010年开始，和flutter/Electron等web开发框架及移动开发框架类似，为了适应各种移动端开发及动画流畅性触摸丝滑体验、充分利用和“榨干”现在的GPU性能，把CPU留出来给用户最大化发挥。 硬件性能越好，GPU越是强劲，qml的综合性能越是完爆widget，反之对比也是指数级的。除了极其省成本的嵌入式硬件领域或者国产CPU等，其他领域的硬件性能都是暴增。 widget主要集中在金融、军工、安防、航天、船舶、教育等领域，qml主要集中在汽车仪表、车机、直播等领域。 目前国内widget多于qml，国外可能偏向qml，这个不难看出，流行的移动端开发框架都是国外开发者居多。 可预见的十年内，这两者将长期并存，官方基本不再更新widget而是主推qml，意味着将来对qml的性能优化只增不减，未来趋势是qml。 没有编程经验的新手qml学习成本更低，而从VB/VC等传统软件开发转过来的从业者更适合学习widget。 有的时候不禁要问，既生widget何生qml，学习成本和选择又多了，其实这正是和这个世界的哲学一样：世界是简单的又是复杂的。为了适应各种需求和满足需要。 总之，无论qml还是widget，和找老婆一样，适合自己的就是最好的，自己擅长哪个就用哪个。 如果还不知道擅长哪个，有空就两个都学，学习过程中自己就会有切身感受和对比，能者多劳多多益善。能够顺利的最快的完成老板的任务给老板赚钱才是王道。 网友补充：如果你的软件最终是手指操作的多，就用qml，如果是鼠标操作的多，就选择widget。 写程序过程中发现问题，比如有些问题是极端特殊情况下出现，最好找到问题的根源，有时候肯定多多少少会怀疑是不是Qt本身的问题，怀疑是对的，但是99.9%的问题最终证实下来还是自己的代码写的不够好导致的，如果为了赶时间老板催的急，实在不行再用重启或者复位大法，比如搞个定时器、线程、网络通信啥的去检测程序是否正常，程序中某个模块或者功能是否正常，不正常就复位程序或者重启程序，在嵌入式上还可以更暴力一点就是系统重启和断电重启。 写程序过程中尤其要注意32位的库和64位的库互不兼容，比如32位的程序引用64位的库，64位的程序引用32位的库，都是编译通不过的，而在windows64位系统中是能够运行32位程序的，因为64位的系统提供了32位的运行环境，一般目录在Program Files(x86)，32位的程序在64位的环境中最终引用的还是32位的库。关于如何判断自己的Qt库是多少位，有个误区就是很多人要么看成了QtCreator的关于信息中列出的位数，要么以为自己是64位的系统就认为是64位的Qt，最终要在Qt构建套件中查看具体位数，大概从Qt5.14开始基本上很少提供32位的库，尤其是Qt6.0以后基本上默认就是只有64位的库了，这也是顺应时代潮流，毕竟不久的将来（个人预计2030年以前）基本上32位的系统占比不超过1%，放心大胆的用64位的库吧，抛弃烦人的32位以及XP系统。 关于程序中动态和静态的一点个人理解： 在Qt程序中，分动态库版本的Qt和静态库版本的Qt。 官方默认提供的二进制包就是动态库版本的Qt，如果自行编译则编译的时候对应参数 -shared。 静态库版本的Qt需要自行编译，编译的时候对应参数 -static，（理论上无论商业非商业使用Qt静态库需要收费，因为静态编译后都看不到Qt的相关库文件）。 使用动态库的Qt支持编译生成动态库和静态库（CONFIG += staticlib）的程序。 使用动态库的Qt程序支持动态库的引用（引用的时候 LIB += ，运行的时候需要动态库文件比如 .dll .so 文件支持）。 使用动态库的Qt程序支持静态库的引用（引用的时候 LIB += ，运行的时候无需库文件支持，可以理解为该文件已经和可执行文件合二为一，缺点是可执行文件体积变大）。 通过生成文件的个数和大小可以发现，静态库相当于把运行时需要的文件也一并合并到一个文件了，而动态库是拆分成两个文件，一个用于编译，一个用于运行。 上述动态库的规则也通用于静态库。 此规则应该是通用于其他语言框架。 很多人有个误区包括几年前的我，以为要用Qt编写静态库就必须用静态的Qt库，其实动态库的Qt也可以编写静态的库，只是该库不会生成动态库文件。 如果要将Qt程序编译成静态的可执行文件（单个文件无依赖），前提是所用的Qt库必须静态的。 后期的Qt版本，大致从5.15开始，就不在提供离线版本下载，需要自行通过在线安装器安装，由于默认服务器在国外，很多人反映下载的时候很慢，或者选择晚上的时候下载要快很多，为了解决这个烦人的问题，不至于时间都浪费在没有意义的等待上，有个极其简单的方法可以将速度提升几万倍，甚至冲坏你的硬盘。先下载 Fiddler5（尽量选择中文版本不然小白看不懂），双击打开程序后（可能win10自带的杀毒软件会报毒删除，","date":"0001-01-01","objectID":"/1/01/qt/:5:0","tags":null,"title":"","uri":"/1/01/qt/"}]