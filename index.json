[{"categories":["linux"],"content":"概述 虚拟文件系统(也称为虚拟文件系统交换机)是内核中的软件层，它为用户空间程序提供文件系统接口。它还在内核中提供了一个抽象，允许不同的文件系统实现共存。 VFS系统调用open(2)、stat(2)、read(2)、write(2)、chmod(2)等等都是从进程上下文中调用的。 文件系统锁在文档\"锁\"中进行了介绍。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:1:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"目录条目缓存(dcache) VFS实现了open(2)、stat(2)、chmod(2)和类似的系统调用。传递给它们的pathname参数由VFS用于搜索目录条目缓存(也称为dentry缓存或dcache)。这提供了一种非常快速的查找机制，可以将路径名(filename)转换为特定的dentry。dentry存储在RAM中，从不保存到磁盘:它们的存在只是为了性能。 dentry缓存是整个文件空间的视图。由于大多数计算机不能同时将所有dentry放入RAM中，所以缓存的一些位元会丢失。为了将路径名解析为dentry, VFS可能不得不在过程中创建dentry，然后加载inode。这是通过查找inode来完成的。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:2:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"inode 对象 单个dentry通常有一个指向inode的指针。inode是文件系统对象，比如普通文件、目录、fifo 和其他东西。它们要么存在于磁盘(对于块设备文件系统)，要么存在于内存(对于伪文件系统)。当需要时，将磁盘上的inode复制到内存中，并将对inode的更改写回磁盘。一个inode可以被多个dentry指向(例如，硬链接就是这样做的)。 要查找一个inode, VFS需要调用父目录inode的lookup()方法。该方法由inode所在的特定文件系统实现安装。一旦VFS拥有了所需的dentry(以及inode)，我们就可以执行所有无聊的操作，比如打开(2)文件或stat(2)文件以查看inode数据。stat(2)操作相当简单:一旦VFS有了dentry，它就会查看inode数据，并将其中一些数据传递回用户空间。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:3:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"File 对象 打开文件需要另一项操作:分配文件结构(这是文件描述符的内核端实现)。使用指向dentry的指针和一组文件操作成员函数初始化新分配的文件结构。这些数据来自inode数据。然后调用open()文件方法，这样特定的文件系统实现就可以完成它的工作。您可以看到，这是由VFS执行的另一个开关。文件结构被放置到进程的文件描述符表中。 读取、写入和关闭文件(以及其他各种VFS操作)是通过使用用户空间文件描述符来获取适当的文件结构，然后调用所需的文件结构方法来完成所需的操作。只要文件处于打开状态，它就保持使用dentry，这又意味着VFS inode仍在使用。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:4:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"注册和挂载文件系统 注册和注销文件系统，使用以下API函数: #include \u003clinux/fs.h\u003e extern int register_filesystem(struct file_system_type *); extern int unregister_filesystem(struct file_system_type *); 传递的struct file_system_type描述了文件系统。当需要将文件系统挂载到名称空间中的目录时，VFS将为特定的文件系统调用适当的mount()方法。新vfmount将把 -\u003emount() 返回的树形结构附加到挂载点，这样当路径名解析到达挂载点时，它将跳转到该vfmount的根目录。 您可以在文件/proc/filesystems中看到注册到内核的所有文件系统。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:5:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"struct file_system_type 这描述了文件系统。在2.6.39内核中，定义了以下成员: struct file_system_type { const char *name; int fs_flags; struct dentry *(*mount) (struct file_system_type *, int, const char *, void *); void (*kill_sb) (struct super_block *); struct module *owner; struct file_system_type * next; struct list_head fs_supers; struct lock_class_key s_lock_key; struct lock_class_key s_umount_key; }; name 文件系统类型的名称，例如“ext2”、“iso9660”、“msdos”等。 fs_flags 各种标志(例如:FS_REQUIRES_DEV, FS_NO_DCACHE等)。 mount 当应该安装该文件系统的新实例时调用的方法。mount()方法必须返回调用者请求的树的根dentry。对其超级块的激活引用必须被抓取，并且超级块必须被锁定。失败时，它应该返回ERR_PTR(错误)。 参数1(struct file_system_type *):描述由特定文件系统代码部分初始化的文件系统 参数2(int):挂载flag; 参数3(const char *): 要挂载的设备名； 参数4(void*)：任意的挂载选项，通常是ASCII字符串(参见“Mount Options”一节) kill_sb 当该文件系统的实例应该关闭时要调用的方法 owner 对于内部VFS使用:你应该在大多数情况下初始化THIS_MODULE。 next 对于内部VFS使用:你应该将其初始化为NULL s_lock_key, s_umount_key lockdep-specific… ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:5:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"superblock 对象 超级块对象表示一个挂载的文件系统。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"struct super_operations 这描述了VFS如何操作文件系统的超级块。在2.6.22内核中，定义了以下成员: struct super_operations { struct inode *(*alloc_inode)(struct super_block *sb); void (*destroy_inode)(struct inode *); void (*dirty_inode) (struct inode *, int flags); int (*write_inode) (struct inode *, int); void (*drop_inode) (struct inode *); void (*delete_inode) (struct inode *); void (*put_super) (struct super_block *); int (*sync_fs)(struct super_block *sb, int wait); int (*freeze_fs) (struct super_block *); int (*unfreeze_fs) (struct super_block *); int (*statfs) (struct dentry *, struct kstatfs *); int (*remount_fs) (struct super_block *, int *, char *); void (*clear_inode) (struct inode *); void (*umount_begin) (struct super_block *); int (*show_options)(struct seq_file *, struct dentry *); ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t); ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t); int (*nr_cached_objects)(struct super_block *); void (*free_cached_objects)(struct super_block *, int); }; 除非另有说明，否则所有方法都是在不持有任何锁的情况下调用的。这意味着大多数方法都可以安全地阻塞。所有方法只能从进程上下文中调用(即不能从中断处理程序或下半部调用)。 alloc_inode 该方法由alloc_inode()调用，为结构inode分配内存并对其进行初始化。如果未定义此函数，则分配一个简单的struct inode。通常，alloc_inode 会被用来分配一个更大的结构，其中包含一个struct inode嵌入其中。 destroy_inode destroy_inode()调用这个方法来释放分配给结构inode的资源。只有在定义了-\u003ealloc_inode时才需要它，它只是简单地撤销-\u003ealloc_inode所做的任何事情。 dirty_inode 当一个inode被标记为dirty时，VFS会调用这个方法。这是专门针对被标记为dirty的inode本身，而不是它的数据。如果fdatasync()需要持久化更新，则I_DIRTY_DATASYNC将在flags参数中设置。 write_inode 当VFS需要将一个inode写入磁盘时，调用此方法。第二个参数表示写是否应该是同步的，并不是所有的文件系统都检查这个标志。 drop_inode 在删除对inode的最后一次访问时调用，并保持inode-\u003ei_lock自旋锁。 此方法应该是NULL(普通UNIX文件系统语义)或generic_delete_inode(对于不希望缓存inode的文件系统-导致无论i_nlink的值如何，总是调用delete_inode) generic_delete_inode()行为相当于在put_inode()情况下使用force_delete的旧实践，但不具有force_delete()方法所具有的竞争。 delete_inode 当VFS想要删除一个inode时调用 put_super 当VFS希望释放超级块(即卸载)时调用。在超级块锁被持有时调用 sync_fs 当VFS写入与超级块关联的所有脏数据时调用。第二个参数指示方法是否应该等待直到写操作完成。可选的。 freeze_fs 当VFS锁定文件系统并强制其进入一致状态时调用。该方法目前由逻辑卷管理器(LVM)使用。 unfreeze_fs 当VFS解锁文件系统并使其重新可写时调用。 statfs 当VFS需要获取文件系统统计信息时调用。 remount_fs 当重新装载文件系统时调用。这是在内核锁被持有时调用的 clear_inode 调用，则VFS清除该inode。可选 umount_begin 当VFS卸载文件系统时调用。 show_options 由VFS调用，以显示/proc//mounts。(参见“安装选项”一节) quota_read 调用VFS来读取文件系统配额文件。 quota_write 调用VFS来写入文件系统的配额文件。 nr_cached_objects 由sb缓存收缩函数为文件系统调用，以返回它所包含的可释放缓存对象的数量。可选的。 free_cache_objects 由sb缓存收缩函数为文件系统调用，以扫描指定的尝试释放对象的数量。可选，但任何实现此方法的文件系统还需要实现-\u003enr_cached_objects才能正确调用它。 我们无法处理文件系统可能遇到的任何错误，因此返回类型为void。如果VM尝试在GFP_NOFS条件下回收，则永远不会调用该方法，该方法本身不需要处理这种情况。 实现必须包括已完成的任何扫描循环内的条件重调度调用。这使得VFS可以确定适当的扫描批处理大小，而不必担心实现是否会由于大的扫描批处理大小而导致延迟问题。 设置inode的人负责填充i_op字段。这是一个指向struct inode_operations的指针，该指针描述了可以在单个inode上执行的方法。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"struct xattr_handlers 在支持扩展属性(xattrs)的文件系统上，s_xattr超级块字段指向一个以null结尾的xattr处理程序数组。扩展属性是 key:value 对。 name 指示处理程序匹配具有指定名称的属性(例如system.posix_acl_access);prefix字段必须为NULL。 prefix 指示处理程序匹配所有具有指定名称前缀的属性(如“user.”);名称字段必须为NULL。 list 确定是否应该为特定dentry列出与这个xattr处理程序匹配的属性。用于一些listxattr实现，如generic_listxattr。 get 由VFS调用以获取特定扩展属性的值。该方法由getxattr(2)系统调用调用。 set 由VFS调用，以设置特定扩展属性的值。当新值为NULL时，调用该函数以删除特定的扩展属性。该方法由setxattr(2)和removexattr(2)系统调用调用。 当文件系统的xattr处理程序与指定的属性名不匹配或者文件系统不支持扩展属性时，所有*xattr(2)系统调用将返回-EOPNOTSUPP。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:2","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"inode 对象 inode对象表示文件系统中的一个对象 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"struct inode_operations 这描述了VFS如何操作文件系统中的inode。在2.6.22内核中，定义了以下成员: struct inode_operations { int (*create) (struct user_namespace *, struct inode *,struct dentry *, umode_t, bool); struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int); int (*link) (struct dentry *,struct inode *,struct dentry *); int (*unlink) (struct inode *,struct dentry *); int (*symlink) (struct user_namespace *, struct inode *,struct dentry *,const char *); int (*mkdir) (struct user_namespace *, struct inode *,struct dentry *,umode_t); int (*rmdir) (struct inode *,struct dentry *); int (*mknod) (struct user_namespace *, struct inode *,struct dentry *,umode_t,dev_t); int (*rename) (struct user_namespace *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int); int (*readlink) (struct dentry *, char __user *,int); const char *(*get_link) (struct dentry *, struct inode *, struct delayed_call *); int (*permission) (struct user_namespace *, struct inode *, int); struct posix_acl * (*get_acl)(struct inode *, int, bool); int (*setattr) (struct user_namespace *, struct dentry *, struct iattr *); int (*getattr) (struct user_namespace *, const struct path *, struct kstat *, u32, unsigned int); ssize_t (*listxattr) (struct dentry *, char *, size_t); void (*update_time)(struct inode *, struct timespec *, int); int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned open_flag, umode_t create_mode); int (*tmpfile) (struct user_namespace *, struct inode *, struct dentry *, umode_t); int (*set_acl)(struct user_namespace *, struct inode *, struct posix_acl *, int); int (*fileattr_set)(struct user_namespace *mnt_userns, struct dentry *dentry, struct fileattr *fa); int (*fileattr_get)(struct dentry *dentry, struct fileattr *fa); }; 同样，调用所有方法时不会持有任何锁，除非另有说明。 create 由open(2)和create(2)系统调用调用。只有在支持常规文件时才需要。你得到的dentry不应该有一个inode(即，它应该是一个负dentry)。在这里，您可能会使用dentry和新创建的inode调用d_instantiate() lookup 当VFS需要在父目录中查找一个inode时调用。要查找的名字在dentry中找到。这个方法必须调用d_add()来将找到的inode插入dentry。inode结构中的“i_count”字段应该递增。如果指定的inode不存在，则应该在dentry中插入一个NULL inode(这称为负dentry)。从这个例程返回错误代码必须只在真正发生错误时才可以，否则使用create(2)、mknod(2)、mkdir(2)等系统调用创建索引节点将会失败。如果你希望重载dentry方法，那么你应该初始化dentry中的“d_dop”字段;这是一个指向结构体“dentry_operations”的指针。在保存目录inode信号量的情况下调用此方法 link 由link(2)系统调用调用。只有在支持硬链接时才需要。您可能需要调用d_instantiate()，就像在create()方法中那样 unlink symlink 由symlink(2)系统调用调用。只有在希望支持符号链接时才需要。您可能需要调用d_instantiate()，就像在create()方法中那样 mkdir rmdir mknod 由mknod(2)系统调用来创建一个设备(char, block) inode或一个命名管道(FIFO)或套接字。只有在希望支持创建这些类型的索引节点时才需要。您可能需要调用d_instantiate()，就像在create()方法中那样 rename 由rename(2)系统调用调用，重命名对象，使其具有由第二个inode和dentry提供的父节点和名称。对于任何不支持或未知的标志，文件系统必须返回-EINVAL。目前实现了以下标志: (1) RENAME_NOREPLACE:该标志表示如果重命名目标存在，重命名将失败，使用-EEXIST代替目标。VFS已经检查是否存在，因此对于本地文件系统，RENAME_NOREPLACE实现等价于普通重命名。 (2) RENAME_EXCHANGE: exchange源和目标。必须存在;这由VFS检查。与普通重命名不同，源和目标可能具有不同的类型。 get_link 由VFS调用，以跟随到它所指向的inode的符号链接。只有在希望支持符号链接时才需要。这个方法返回要遍历的符号链接体(并可能使用nd_jump_link()重置当前位置)。如果在inode消失之前，主体不会消失，那么其他东西就不需要了;如果需要以其他方式固定它，通过让get_link(…，…，done)执行set_delayed_call(done, destructor, argument)来安排它的释放。在这种情况下，一旦VFS处理完您返回的函数体，就会调用estructor(argument)。可以在RCU模式下调用;由NULL dentry参数表示。如果请求不离开RCU模式就不能被处理，让它返回ERR_PTR(-ECHILD)。如果文件系统将符号链接目标存储在-\u003ei_link中，VFS可以直接使用它而不调用-\u003eget_link();但是，-\u003eget_link()仍然必须提供。—\u003ei_link必须在RCU宽限期后才能释放。 readlink 这现在只是readlink(2)在-\u003eget_link使用nd_jump_link()或object实际上不是符号链接的情况下使用的重载。通常文件系统应该只实现-\u003eget_link用于符号链接，readlink(2)将自动使用它。 permission 由VFS调用，以检查类posix文件系统上的访问权限。可以在rcu-walk模式下调用(mask \u0026 MAY_NOT_BLOCK)。如果在rcu-walk模式下，文件系统必须检查权限，而不能阻塞或存储到inode。如果遇到rcu-walk不能处理的情况，返回-ECHILD，它将在refwalk模式中再次被调用。 setattr getattr listxattr update_time atomic_open 对一个open的最后一个组件调用。使用这个可选的方法，文件系统可以在一个原子操作中查找、创建和打开文件。如果它想把实际打开留给调用者(例如，如果文件是一个符号链接、设备，或者只是文件系统不会原子打开的东西)，它可能通过返回finish_no_open(file, dentry)来发出信号。仅当最后一个组件为负数或需要查找时，才调用此方法。缓存的正向dentry仍然由f_op-\u003eopen()处理。如果文件已经创建，FMODE_CREATED标志应该设置在file-\u003ef_mode中。在O_EXCL的情况下，只有在文件不存在的情况下，该方法才会成功，因此FMODE_CREATED总是在成功时设置。 tmpfile 在O_TMPFILE open()的末尾调用。可选，相当于在给定目录中自动创建、打开和解链接文件。 fileattr_get 调用ioctl(FS_IO","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"地址空间对象(The Address Space Object) 地址空间对象用于对页缓存中的页进行分组和管理。它可以用来跟踪文件(或其他文件)中的页面，还可以跟踪文件各部分到进程地址空间的映射。 地址空间可以提供许多不同但相关的服务。这些方法包括通信内存压力、按地址查找页面以及跟踪标记为Dirty或Writeback的页面。 第一个可以单独用于其他的。VM可以尝试写入脏页以清除它们，也可以释放干净页以重用它们。为此，它可以在脏页面上调用-\u003ewritepage方法，在干净页面上调用-\u003ereleasepage方法，并设置pagprivate。没有PagePrivate和没有外部引用的干净页面将在不通知address_space的情况下被释放。 为了实现此功能，需要将页面放置在LRU上，并在使用页面时调用lru_cache_add和mark_page_active。 页面通常通过-\u003eindex保存在基数树索引中。该树维护每个页面的PG_Dirty和PG_Writeback状态信息，以便快速找到带有这两个标志的页面。 Dirty标记主要由mpage_writpages(默认的-\u003ewritpages方法)使用。它使用标记查找脏页并调用-\u003ewritepage。如果没有使用mpage_writepages(即地址提供了自己的-\u003ewritepages)，那么PAGECACHE_TAG_DIRTY标签几乎没有被使用。Write_inode_now和sync_inode使用它(通过__sync_single_inode)来检查-\u003ewritepages是否成功地写出了整个地址空间。 Writeback标记由filemap* wait*和sync_page*函数使用，通过filemap_fdatawait_range函数等待所有的Writeback完成。 address_space处理程序可以附加额外的信息到一个页面，通常使用’struct page‘中的’private‘字段。如果附加了这些信息，则应该设置PG_Private标志。这将导致各种VM例程对address_space处理程序进行额外调用来处理该数据。 地址空间充当存储和应用程序之间的中介。每次将整个页的数据读入地址空间，并通过复制页或对页进行内存映射的方式提供给应用程序。应用程序将数据写入地址空间，然后通常以整个页面的形式将数据写回存储，但是address_space可以更好地控制写大小。 read进程实际上只需要’readpage’。写过程更为复杂，使用write_begin/write_end或dirty_folio将数据写入address_space，使用writepage和writepage将数据回写到存储。 在地址空间中添加和删除页面由inode的i_mutex保护。 当数据写入一个页面时，应该设置PG_Dirty标志。它通常保持设置状态，直到writepage要求写入它。这应该清除PG_Dirty并设置PG_Writeback。它实际上可以在PG_Dirty被清除后的任何时候被写入。一旦知道它是安全的，就清除PG_Writeback。 Writeback利用writeback_control结构来指导操作。这为writepage和writpages操作提供了一些关于回写请求的性质和原因，以及在哪些约束条件下执行的信息。它还用于向调用者返回关于写页面或写页面请求结果的信息。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:8:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"处理回写期间的错误 大多数进行缓冲I/O的应用程序将定期调用文件同步调用(fsync、fdatasync、msync或sync_file_range)，以确保写入的数据已经到达后备存储。当回写过程中出现错误时，他们希望在文件同步请求时报告错误。在报告了一个请求的错误之后，对同一文件描述符的后续请求应该返回0，除非在上一次文件同步之后发生了进一步的回写错误。 理想情况下，内核只会在文件描述中报告错误，而这些文件描述的写操作后来又没有被写回。但是，通用的页面缓存基础设施不会跟踪已经污染每个单独页面的文件描述，因此不可能确定哪个文件描述符应该返回错误。 相反，内核中的通用回写错误跟踪基础设施解决了在错误发生时向fsync报告所有打开的文件描述的错误。在有多个写入器的情况下，所有写入器都会在后续的fsync中返回一个错误，即使通过特定文件描述符完成的所有写入都成功了(或者即使对该文件描述符根本没有写入)。 希望使用此基础结构的文件系统应该调用mapping_set_error，以便在发生错误时在address_space中记录错误。然后，在他们的-\u003efsync操作中从页面缓存写回数据后，他们应该调用file_check_and_advance_wb_err来确保struct file的错误游标已经前进到由备份设备发出的错误流中的正确点。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:9:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"struct address_space_operations 这描述了VFS如何操作文件到文件系统中页面缓存的映射。定义了以下成员: struct address_space_operations { int (*writepage)(struct page *page, struct writeback_control *wbc); int (*readpage)(struct file *, struct page *); int (*writepages)(struct address_space *, struct writeback_control *); bool (*dirty_folio)(struct address_space *, struct folio *); void (*readahead)(struct readahead_control *); int (*write_begin)(struct file *, struct address_space *mapping, loff_t pos, unsigned len, unsigned flags, struct page **pagep, void **fsdata); int (*write_end)(struct file *, struct address_space *mapping, loff_t pos, unsigned len, unsigned copied, struct page *page, void *fsdata); sector_t (*bmap)(struct address_space *, sector_t); void (*invalidate_folio) (struct folio *, size_t start, size_t len); int (*releasepage) (struct page *, int); void (*freepage)(struct page *); ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter); /* isolate a page for migration */ bool (*isolate_page) (struct page *, isolate_mode_t); /* migrate the contents of a page to the specified target */ int (*migratepage) (struct page *, struct page *); /* put migration-failed page back to right list */ void (*putback_page) (struct page *); int (*launder_folio) (struct folio *); bool (*is_partially_uptodate) (struct folio *, size_t from, size_t count); void (*is_dirty_writeback) (struct page *, bool *, bool *); int (*error_remove_page) (struct mapping *mapping, struct page *page); int (*swap_activate)(struct file *); int (*swap_deactivate)(struct file *); }; writepage 由VM调用，将脏页写入后备存储。这可能是由于数据完整性原因(即“同步”)，或为了释放内存(刷新)。这种差异可以从wbc-\u003esync_mode中看出。PG_Dirty标志已经清除，pagellocked为true。writepage应该启动writeout，应该设置PG_Writeback，并且应该确保在写操作完成时，页面是同步或异步解锁的。如果wbc-\u003esync_mode为WB_SYNC_NONE，如果出现问题，-\u003ewritepage处理起来不会太费劲；如果更容易的话，可以选择从映射中写出其他页面(例如由于内部依赖关系)。如果它选择不启动writeout，它应该返回AOP_WRITEPAGE_ACTIVATE，这样VM就不会一直调用该页上的-\u003ewritepage。 有关更多细节，请参阅文件“Locking”。 readpage 调用VM从后台存储读取页面。当readpage被调用时，该页面将被锁定，并且应该在读取完成后被解锁并标记为最新。如果-\u003ereadpage发现由于某些原因需要解锁页面，它可以这样做，然后返回AOP_TRUNCATED_PAGE。在这种情况下，页面将被重新定位并重新锁定，如果所有操作都成功，则将再次调用-\u003ereadpage。 writepages 由VM调用，以写出与address_space对象关联的页面。如果wbc-\u003esync_mode为WB_SYNC_ALL，则writeback_control将指定必须写入的页面范围。如果它是WB_SYNC_NONE，则给出一个nr_to_write，并且如果可能的话应该写入许多页。如果没有给出-\u003ewritpages，则使用mpage_writpages。这将从标记为DIRTY的地址空间中选择页面，并将它们传递给-\u003ewritepage。 dirty_folio VM调用，将对开本标记为dirty。如果地址空间将私有数据附加到一个 fifo，并且当 fifo 被污染时需要更新该数据，则特别需要这样做。例如，当内存映射页被修改时，就会调用这个函数。如果定义了，它应该在i_pages中设置folio dirty标志和PAGECACHE_TAG_DIRTY搜索标记。 readahead 由VM调用，以读取与address_space对象关联的页。在页缓存中，页是连续的，并且被锁定。实现应该在启动每个页面的I/O后减少页面引用计数。通常，该页面将由I/O完成处理程序解锁。页面集被分为一些同步页面和一些异步页面，rac-\u003era-\u003easync_size给出了异步页面的数量。文件系统应该尝试读取所有同步页面，但可能在到达异步页面时决定停止。如果它决定停止尝试I/O，它可以简单地返回。调用者将从地址空间中删除剩余的页，解锁它们并减小页引用计数。如果I/O成功完成，设置PageUptodate。在任何页面上设置PageError都将被忽略;如果发生I/O错误，只需解锁页面。 write_begin write_end bmap invalidate_folio releasepage freepage direct_IO isolate_page migrate_page putback_page launder_folio is_partially_uptodate is_dirty_writeback error_remove_page swap_activate swap_deactivate ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:9:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"File 对象 文件对象表示进程打开的文件。在POSIX术语中，这也称为“打开文件描述”。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:10:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"struct file_operations 这描述了VFS如何操作打开的文件。在4.18内核中，定义了以下成员: struct file_operations { struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iopoll)(struct kiocb *kiocb, bool spin); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); __poll_t (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f); #ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *); #endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, loff_t len, unsigned int remap_flags); int (*fadvise)(struct file *, loff_t, loff_t, int); }; 同样，调用所有方法时不会持有任何锁，除非另有说明。 llseek read read_iter write write_iter iopoll iterate iterate_shared poll unlocked_ioctl compat_ioctl mmap open flush release fsync fasync lock get_unmapped_area check_flags flock splice_write splice_read setlease fallocate copy_file_range remap_file_range fadvise 注意，文件操作是由inode所在的特定文件系统实现的。当打开一个设备节点(特殊字符或块)时，大多数文件系统将调用VFS中的特殊支持例程，它将定位所需的设备驱动程序信息。这些支持例程将文件系统文件操作替换为设备驱动程序的操作，然后继续为文件调用新的open()方法。这就是在文件系统中打开设备文件最终如何调用设备驱动程序open()方法的。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:10:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"目录条目缓存(dcache) ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"struct dentry_operations 这描述了文件系统如何重载标准dentry操作。dentry和dcache是VFS和各个文件系统实现的域。设备驱动程序在这里没有什么用。这些方法可以设置为NULL，因为它们要么是可选的，要么VFS使用默认值。在2.6.22内核中，定义了以下成员: struct dentry_operations { int (*d_revalidate)(struct dentry *, unsigned int); int (*d_weak_revalidate)(struct dentry *, unsigned int); int (*d_hash)(const struct dentry *, struct qstr *); int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *); int (*d_delete)(const struct dentry *); int (*d_init)(struct dentry *); void (*d_release)(struct dentry *); void (*d_iput)(struct dentry *, struct inode *); char *(*d_dname)(struct dentry *, char *, int); struct vfsmount *(*d_automount)(struct path *); int (*d_manage)(const struct path *, bool); struct dentry *(*d_real)(struct dentry *, const struct inode *); }; d_revalidate _weak_revalidate d_hash d_compare d_delete d_init d_release d_iput d_dname d_automount d_manage d_real 每个dentry都有一个指向其父dentry的指针，以及子dentry的散列列表。子dentry基本上就像目录中的文件。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"目录条目缓存API(Directory Entry Cache API) 定义了许多允许文件系统操作dentry的函数: dget 为现有的dentry打开一个新的句柄(这只是增加了使用计数) dput 关闭dentry的句柄(减少使用计数)。如果使用计数下降到0, dentry仍然在其父散列中，则调用\"d_delete“方法来检查是否应该缓存它。如果它不应该被缓存，或者dentry没有被散列，它就会被删除。否则，缓存的dentry将被放入LRU列表中，在内存不足时回收。 d_drop 这将从其父哈希列表中解算dentry。如果dentry的使用计数下降到0，则对dput()的后续调用将释放该dentry d_delete 删除一个dentry。如果没有对dentry的其他开放引用，则dentry被转换为负dentry(调用d_iput()方法)。如果有其他引用，则调用d_drop() d_add 添加一个dentry到它的父哈希列表，然后调用d_instantiate() d_instantiate 将dentry添加到inode的别名散列列表中，并更新“d_inode”成员。inode结构中的“i_count”成员应该设置/增加。如果inode指针为NULL, dentry称为“负dentry”。当为现有的负dentry创建一个inode时，通常会调用这个函数 d_lookup 它从dcache哈希表中查找指定名称的子元素。如果找到，引用计数将增加并返回dentry。调用者在使用完dentry后必须使用dput()来释放它。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:2","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"挂载操作(Mount Options) ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:0","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"解析挂载配置(Parsing options) 在挂载和重新挂载时，将向文件系统传递一个字符串，其中包含以逗号分隔的挂载选项列表。选项可以有以下两种形式:option 和 option=value \u003clinux/parser.h\u003e头文件定义了一个API来帮助解析这些选项。有很多关于如何在现有文件系统中使用它的示例。 ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:1","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"显示挂载配置(Showing options) 如果文件系统接受挂载选项，它必须定义show_options()来显示所有当前活动的选项。规则是: 选项必须显示哪些不是默认值，或者它们的值与默认值不同 选项可以显示为默认启用或具有默认值 仅在装入帮助程序和内核之间内部使用的选项(如文件描述符)，或者仅在装入过程中起作用的选项(如控制日志创建的选项)不受上述规则的约束。 使用上述规则的根本原因是确保可以根据在/proc/mounts.conf. 中找到的信息准确地复制一个挂载(例如，卸载和重新挂载) 5.x 内核没找到 /proc/mounts.conf ","date":"2022-05-18","objectID":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:2","tags":["linux","虚拟文件系统","Linux vfs","vfs"],"title":"Linux虚拟文件系统概述","uri":"/2022/05/0001-linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["linux"],"content":"linux虚拟文件系统概述 linux虚拟文件系统概述 ","date":"2022-05-18","objectID":"/2022/05/0000-linux%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:0","tags":["linux","文件系统","filesystem"],"title":"Linux内核文件系统","uri":"/2022/05/0000-linux%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["C"],"content":"C语言 C是一种通用的、命令式的计算机编程语言，支持结构化编程、词法变量作用域和递归，而静态类型系统可以防止许多意想不到的操作。通过设计，C提供了有效地映射到典型机器指令的构造，因此它在以前用汇编语言编写的应用程序中得到了持久的使用，包括操作系统，以及从超级计算机到嵌入式系统的各种应用程序软件。 尽管具有低级功能，但该语言的设计初衷是鼓励跨平台编程。一个符合标准的、可移植编写的C程序可以用于各种各样的计算机平台和操作系统，只需对其源代码进行很少的更改。从嵌入式微控制器到超级计算机，该语言已经在非常广泛的平台上可用。 C语言最初是由Dennis Ritchie于1969年至1973年在贝尔实验室开发的，用于重新实现Unix操作系统。它已经成为有史以来使用最广泛的编程语言之一，来自不同供应商的C编译器可用于大多数现有的计算机架构和操作系统。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"C编译器 GCC, GNU 编译器 clang, 是为LLVM项目提供了C语言家族(C, c++, Objective C/c++, OpenCL, CUDA和RenderScript)的编译器 MSCV, 微软C/C++编译器 gcc 编译器 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"编译器C版本支持 编译器不一定完全支持 C 所有特性，同时编译器也可能通过参数支持一些 C 标准没有的特性，使用时候具体参看 C编译器和对应版本说明。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"代码风格 GNU代码风格 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"C版本 版本 标准 发行时间 K\u0026E 无 1978-02-22 C89 ANSI X3.159-1989 1989-12-14 C90 ISO/IEC 9899:1990 1990-12-20 C95 ISO/IEC 9899/AMD1:1995 1995-03-30 C99 ISO/IEC 9899:1999 1999-12-16 C11 ISO/IEC 9899:2011 2011-12-15 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:4","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"hello world #include \u003cstdio.h\u003e int main(void) { puts(\"Hello, World\"); return 0; } 编译 gcc hello.c -o hello // 我们还可以使用警告选项-Wall -Wextra -Werror，这有助于识别可能导致程序失败或产生意外结果的问题 gcc -Wall -Wextra -Werror -o hello hello.c 对比 K\u0026R C 的Hello world #include \u003cstdio.h\u003e main() { printf(\"hello, world\\n\"); } 注意，在编写《The C programming language》的第一版(1978年)时，C编程语言还没有标准化，而且这个程序可能无法在大多数现代编译器上编译，除非它们被指示接受C90代码。 K\u0026R书中的第一个示例现在被认为质量很差，部分原因是它缺少main()的显式返回类型，部分原因是它缺少返回语句。 在C89中，main的类型默认为int，但K\u0026R示例不向环境返回定义的值。在C99和以后的标准中，返回类型是必需的，但是省略main的返回语句(而且只有main)是安全的，因为C99 5.1.2.2.3引入了一个特殊情况—它相当于返回0，表示成功。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:1:5","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"字符类型和转换 从流中读取字符类型 #include \u003cctype.h\u003e#include \u003cstdio.h\u003e typedef struct { size_t space; size_t alnum; size_t punct; } chartypes; chartypes classify(FILE *f) { chartypes types = { 0, 0, 0 }; int ch; while ((ch = fgetc(f)) != EOF) { types.space += !!isspace(ch); types.alnum += !!isalnum(ch); types.punct += !!ispunct(ch); } return types; } classify函数从流中读取字符并统计空格、字母数字和标点符号的数量。它需要注意以下几个问题： 当从流中读取一个字符时，结果被保存为int，因为读取EOF(文件结束标记)和具有相同位模式的字符之间会有歧义。 classify函数希望它们的参数可以表示为unsigned char，或者EOF宏的值。因为这正是fgetc返回的，所以这里不需要转换。 字符分类函数的返回值只区分零(false)和非零(true)。为了计算字符分类出现的次数，需要将该值转换为1或0，这可以通过双重否定实现 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:2:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"C标准库 – ctype.h int c = 'A'; isalpha(c); /* Checks if c is alphabetic (A-Z, a-z), returns non-zero here. */ isalnum(c); /* Checks if c is alphanumeric (A-Z, a-z, 0-9), returns non-zero here. */ iscntrl(c); /* Checks is c is a control character (0x00-0x1F, 0x7F), returns zero here. */ isdigit(c); /* Checks if c is a digit (0-9), returns zero here. */ isgraph(c); /* Checks if c has a graphical representation (any printing character except space), returns non-zero here. */ islower(c); /* Checks if c is a lower-case letter (a-z), returns zero here. */ isprint(c); /* Checks if c is any printable character (including space), returns non-zero here. */ ispunct(c); /* Checks if c is a punctuation character, returns zero here. */ isspace(c); /* Checks if c is a white-space character, returns zero here. */ isupper(c); /* Checks if c is an upper-case letter (A-Z), returns non-zero here. */ isxdigit(c); /* Checks if c is a hexadecimal digit (A-F, a-f, 0-9), returns non-zero here.*/ // C99 isblank(c); /* Checks if c is a blank character (space or tab), returns non-zero here. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:2:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"别名和有效类型 这里的别名是英文直译，可以理解为我们常见的类型转换 别名是指向同一个对象的两个指针a和b的属性，即a == b。 C使用数据对象的有效类型来确定可以对该对象执行哪些操作。具体来说，有效类型用于确定两个指针是否可以相互别名。 C语言的严格别名规则是指编译器可能假定哪些对象会(或不会)别名。对于数据指针，你应该记住两条经验法则: 除非另有说明，具有相同基类型的两个指针可以别名。 两个具有不同基类型的指针不能别名，除非两个类型中至少有一个是字符类型。 这里的基本类型指的是抛开类型限制，比如const，比如：double* a 和 const double* b，编译器通常必须假设对*a的修改可能会改变*b。 违反第二条规则会有灾难性后果，所以为了减少问题发生概率，除非源或目标类型为void，否则具有不同基类型的指针之间的所有指针转换都必须是显式的。 这里必须做的类型转换不包括添加限定符 const ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:3:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 不能通过非字符类型访问字符类型 int main( void ) { char a[100]; int* b = ( int* )\u0026a; *b = 1; static char c[100]; b = ( int* )\u0026c; *b = 2; _Thread_local char d[100]; b = ( int* )\u0026d; *b = 3; } 在例子中，一个char数组被重新解释为int类型，并且每次对int指针b解引用时，该行为都是未定义的。因为它违反了“有效类型”规则，具有有效类型的数据对象不能通过非字符类型的其他类型访问。因为这里的另一个类型是int，所以这是不允许的。 即使内存对齐和指针大小是已知的，这也不能免除此规则，行为仍然是未定义的。 这特别意味着，在标准C语言中不可能保留可以通过不同类型的指针使用的字符类型的缓冲区对象，因为您将使用由malloc或类似函数接收的缓冲区。 实现上述目标的正确方法是使用 union typedef union bufType bufType; union bufType { char c[sizeof(int[25])]; int i[25]; }; int main( void ) { bufType a = { .c = { 0 } }; // reserve a buffer and initialize int* b = a.i; // no cast necessary *b = 1; static bufType a = { .c = { 0 } }; int* b = a.i; *b = 2; _Thread_local bufType a = { .c = { 0 } }; int* b = a.i; *b = 3; } 这里，union确保编译器从一开始就知道缓冲区可以通过不同的方式访问。这样做的另一个好处是，现在缓冲区有一个a.i，它已经是int类型，不需要进行指针转换。 有效类型 数据对象的有效类型是与之关联的最后一个类型信息(如果有的话)。 // 有效类型是 uint32_t uint32_t a = 0.0; // *pa的有效类型是 uint32_t uint32_t* pa = \u0026a; // 目前 *q 并不是一个有效类型 void* q = malloc(sizeof uint32_t); // 这里的 q 仍然不是一个有效类型，因为还没有数据写入 uint32_t* qb = q; // *qb 目前是一个有效类型 uint32_t，因为一个 uint32_t 值被写入了 *qb = 37; // r 指向的对象尽管已经初始化了，但还不是有效类型 void* r = calloc(1, sizeof uint32_t); // 不是有效类型 uint32_t* rc = r; // *rc 已经是一个有效类型 uint32_t 因为一个值从它那读取了 // 因为使用 calloc 初始化了，所以读操作是合理的 // 此时尽管我们没有写它的值，但是 *rc 已经是一个有效类型了 uint32_t c = *rc; void* s = malloc(sizeof uint32_t); // 因为有 uint32_t 类型复制到指定对象里，所以 *s 已经是有效类型了 memcpy(s, r, sizeof uint32_t); 严重违反类型转换规则 在下面的代码中，让我们假设float和uint32_t有相同的内存大小 void fun(uint32_t* u, float* f) { float a = *f, *u = 22; float b = *f; print(\"%g should equal %g\\n\", a, b); } u 和 f 具有不同的基类型，因此编译器可以假定它们指向不同的对象。 在a和b的两次初始化之间*f不可能发生变化，因此编译器可能会优化代码，使其等价于: void fun(uint32_t* u, float* f) { float a = *f, *u = 22; print(\"%g should equal %g\\n\", a, a); } 即*f的二次加载操作可以完全优化出来。 如果这样调用: float fval = 4; uint32_t uval = 77; fun(\u0026uval, \u0026fval); // 输出: 4 should equal 4 但是如果这样调用： float fval = 4; uint32_t* up = (uint32_t*)\u0026fval; fun(up, \u0026fval); 我们违反了严格的混叠规则。然后这种行为就变得没有定义了。如果编译器优化了第二次访问，输出可能与上面一样，或者完全不同，从而使程序最终处于完全不可靠的状态。 限制条件 如果有两个相同类型的指针实参，编译器就不能做任何假设，必须总是假设对*e的修改可能会改变*f: void fun(float* e, float* f) { float a = *f *e = 22; float b = *f; print(\"is %g equal to %g?\\n\", a, b); } float fval = 4; float eval = 77; fun(\u0026eval, \u0026fval); 正常输出是 is 4 equal to 4? 如果我们通过一些外部信息知道e和f永远不会指向相同的数据对象，那么这可能是低效的。我们可以通过给指针形参添加限制限定符来反映这一点: void fan(float*restrict e, float*restrict f) { float a = *f *e = 22; float b = *f; print(\"is %g equal to %g?\\n\", a, b); } 那么编译器可能总是假设e和f指向不同的对象。 改变字节 一旦对象具有有效类型，就不应该试图通过其他类型的指针修改它，除非其他类型是字符类型、char、signed char或 unsigned char。 #include \u003cinttypes.h\u003e#include \u003cstdio.h\u003e int main(void) { uint32_t a = 57; // conversion from incompatible types needs a cast ! unsigned char* ap = (unsigned char*)\u0026a; for (size_t i = 0; i \u003c sizeof a; ++i) { /* set each byte of a to 42 */ ap[i] = 42; } printf(\"a now has value %\" PRIu32 \"\\n\", a); } 打印结果: a now has value 707406378 正常是因为： 使用unsigned char类型访问单个字节，因此每次修改都有很好的定义。 对象的两个视图，通过别名a和*ap，但由于ap是指向字符类型的指针，因此不适用严格的别名规则。因此，编译器必须假设a的值可能在for循环中被更改了。a的修改值必须从已更改的字节构造。 a的类型的uint32_t没有填充位。其表示的所有位都为值计数，这里是707406378，并且不能有陷阱表示。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:3:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数组 数组是派生数据类型，表示另一种类型的值(“元素”)的有序集合。C语言中的大多数数组都有固定数量的任意一种类型的元素，其表示形式是连续地将元素存储在内存中，没有间隔或填充。C允许多维数组，它的元素是其他数组，也可以是指针数组。 C支持动态分配数组，其大小在运行时确定。C99及以后版本支持可变长度数组或VLAs。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 type name[length]; int arr[10] = {0}; // 初始化所有元素为0 int arr[10] = {42}; // 初始化第一个元素为42，其它为0 int arr[] = {4, 2, 3, 1}; arr[n] = value; value = arr[n]; ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"为什么需要数组 数组提供了一种将对象组织成具有自身意义的聚合的方法。例如，C字符串是字符数组(chars)，而像“Hello, World!”这样的字符串具有聚合的意义，它不是单个字符固有的。类似地，数组通常用于表示数学向量和矩阵，以及多种类型的列表。此外，如果没有对元素进行分组的方法，就需要单独处理每个元素，比如通过单独的变量。它不仅笨重，而且不能方便地容纳不同长度的集合。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"大多数上下文数组隐式转为指针 除了 sizeof 操作，使用 _Alignof 操作、\u0026操作、迭代字符串，它都会转换为第一个元素首地址。 这个隐式转换与数组下标操作符([])的定义紧密耦合:表达式arr[idx]被定义为等价于*(arr + idx)。此外，由于指针算法是可交换的，*(arr + idx)也等价于*(idx + arr)，而*(idx + arr)又等价于idx[arr]。如果idx或arr是指针(或数组，可衰变为指针)，另一个是整数，且整数是指针所指向数组的有效索引，则所有这些表达式都是有效的，计算结果相同。 作为一个特例，观察\u0026(arr[0])等价于\u0026*(arr + 0)，简化为arr。所有的这些表达式都是可互换的(attr最衰减到指针)。这只是再次表示数组衰变为指向其第一个元素的指针。 相反，如果地址操作符应用于类型为T[N]的数组(即\u0026arr)，则结果类型为T (*)[N]并指向整个数组。这与指向数组第一个元素的指针不同，至少在指针算术方面是不同的，指针是根据指向类型的大小定义的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"函数参数不是数组 void foo(int a[], int n); void foo(int *a, int n); 尽管foo的第一个声明对参数a使用了类似数组的语法，但这种语法用于声明一个函数参数，将该参数声明为指向数组元素类型的指针。因此，foo()的第二个签名在语义上与第一个签名相同。这对应于数组值的衰减指针出现作为一个函数调用的参数,这样,如果一个变量和一个函数参数声明相同的数组类型,变量的值是适用于一个函数调用的参数与参数有关。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:4","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"特殊例子 特殊的初始化： int array[5] = {[2] = 5, [1] = 2, [4] = 9}; /* array is {0, 2, 5, 0, 9} */ int array[] = {[3] = 8, [0] = 9}; /* size is 4 */ 不允许声明零长度的数组 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:5","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"变长数组(C99/C11) 可变长度数组(简称VLA)是在C99中添加的，在C11中是可选的。它们与普通数组相同，但有一个重要的区别:在编译时不必知道长度。VLA具有自动存储期限。 size_t m = calc_length(); /* calculate array length at runtime */ int vla[m]; /* create array with calculated length */ 重要: VLA有潜在的危险。如果上面示例中的数组vla需要的堆栈空间大于可用空间，则堆栈将溢出。因此不建议使用VLA ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:6","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"清除数组内容 有时需要在初始化完成后将数组设置为零。 #include \u003cstdlib.h\u003e /* for EXIT_SUCCESS */ #define ARRLEN (10) int main(void) { int array[ARRLEN]; /* Allocated but not initialised, as not defined static or global. */ size_t i; for(i = 0; i \u003c ARRLEN; ++i) { array[i] = 0; } return EXIT_SUCCESS; } 或者使用 memset ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:7","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数组长度 sizeof(array) / sizeof(array[0]) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:8","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"设置数组值 array[4] = 5; 4[array] = 5; *(4 + array) = 5; // 获取值 val = 4[array]; ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:9","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"定义数组并访问元素 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:10","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"堆上动态分配空间并初始化数组 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:11","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"迭代数组 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:12","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"多维数组 type name[size1][size2]...[sizeN]; int arr[5][10][4]; // 初始化 3 维数组 double cprogram[3][2][4]={ {{-0.1, 0.22, 0.3, 4.3}, {2.3, 4.7, -0.9, 2}}, {{0.9, 3.6, 4.5, 4}, {1.2, 2.4, 0.22, -1}}, {{8.2, 3.12, 34.2, 0.1}, {2.1, 3.2, 4.3, -2.0}} }; ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:4:13","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"断言 在软件遇到断言时，提出的条件必须为真。最常见的是在执行时进行验证的简单断言。静态断言是在编译时检查的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 assert(expression); static_assert(expression, message); _Static_assert(expression, message); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"参数 参数 描述 expression 表达式，判断条件是否满足 message 诊断消息中包含的字符串字面值 assert 和 static_assert 都在 assert.h 中定义。 assert的定义依赖于宏NDEBUG，该宏没有被标准库定义。如果定义了NDEBUG，则assert为无操作: #ifdef NDEBUG # define assert(condition) ((void) 0) #else # define assert(condition) /* implementation defined */#endif 使用 assert 会导致程序退出，生产环境中不要用 assert，最好使用条件判断 static_assert扩展为_Static_assert，这是一个关键字。condition 在编译时被检查，因此condition必须是一个常量表达式。没有必要在开发和生产之间以不同的方式处理这个问题 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 前置条件和后置条件 断言的一个用例是前置条件和后置条件。这对于保持不变和契约式设计非常有用。例如，长度总是0或正的，因此该函数必须返回0或正的值。 int length2 (int *a, int count) { int i, result = 0; /* Precondition: */ /* NULL is an invalid vector */ assert (a != NULL); /* Number of dimensions can not be negative.*/ assert (count \u003e= 0); /* Calculation */ for (i = 0; i \u003c count; ++i) { result = result + (a[i] * a[i]); } /* Postcondition: */ /* Resulting length can not be negative. */ assert (result \u003e= 0); return result; } 简单断言 #include \u003cstdio.h\u003e/* Uncomment to disable `assert()` */ /* #define NDEBUG */ #include \u003cassert.h\u003eint main(void) { int x = -1; assert(x \u003e= 0); printf(\"x = %d\\n\", x); return 0; } 运行输出: a.out: main.c:9: main: Assertion `x \u003e= 0' failed. 静态断言(C11) 静态断言用于在编译代码时检查条件是否为真。如果不是，则需要编译器发出错误消息并停止编译过程。 #include \u003cassert.h\u003eenum {N = 5}; _Static_assert(N == 5, \"N does not equal 5\"); static_assert(N \u003e 10, \"N is not greater than 10\"); /* compiler error */ 静态断言(c99) 在C11之前，没有对静态断言的直接支持。但是，在C99中，可以使用宏模拟静态断言，如果编译时条件为假，则会触发编译失败。与_Static_assert不同，第二个参数需要是适当名称，以便可以使用它创建变量名称。如果断言失败，则在编译器错误中可以看到变量名，因为该变量是在语法不正确的数组声明中使用的 #define STATIC_MSG(msg, l) STATIC_MSG2(msg, l) #define STATIC_MSG2(msg,l) on_line_##l##__##msg #define STATIC_ASSERT(x, msg) extern char STATIC_MSG(msg, __LINE__) [(x)?1:-1] enum { N = 5 }; STATIC_ASSERT(N == 5, N_must_equal_5); STATIC_ASSERT(N \u003e 5, N_must_be_greater_than_5); /* compile error */ 在C99之前，不能在块中的任意位置声明变量，因此在使用这个宏时必须非常谨慎，确保它只出现在变量声明有效的地方 断言不可能到达的位置(switch-case语法) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:5:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"原子(Atomics) Atomics作为C语言的一部分是自C11以来可用的可选特性。它们的目的是确保对在不同线程之间共享的变量的无竞争访问。如果没有原子限定，如果两个线程并发访问一个共享变量，那么它的状态将是未定义的。例如，一个自增操作(++)可以被拆分为几个汇编指令、一个读取指令、加法本身和一个存储指令。如果另一个线程要执行相同的操作，它们的两个指令序列可能会交织在一起，导致不一致的结果。 Types: 除数组类型外，所有对象类型都可以限定为 _Atomic Operators: 它们上的所有读-修改-写操作符都保证是原子的 Operations: 还有其他一些被指定为类型泛型函数的操作，例如atomic_compare_exchange。 Threads: 当它们被不同的线程访问时，对它们的访问保证不会产生数据竞争。 Signal handlers: 如果对原子类型的所有操作都是无状态的，则称为无锁类型。在这种情况下，它们还可以用于处理正常控制流和信号处理程序之间的状态变化。 只有一种数据类型保证是无锁的:atomic_flag。这是一种最小类型，其操作旨在映射到有效的测试和设置硬件指令。 在C11的线程接口中还有其他避免竞争条件的方法，特别是一个互斥类型mtx_t，它可以相互排除线程访问关键数据或代码的关键部分。如果原子不可用，则必须使用它们来防止竞争。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:6:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #ifdef __STDC_NO_ATOMICS__ # error this implementation needs atomics• #endif• #include \u003cstdatomic.h\u003e unsigned _Atomic counter = ATOMIC_VAR_INIT(0); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:6:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 原子和操作 可以在不同的线程之间并发地访问原子变量，而不需要创建竞争条件。 static unsigned _Atomic active = ATOMIC_VAR_INIT(0); int myThread(void* a) { ++active; // increment active race free // do something --active; // decrement active race free return 0; } 基类型允许的所有左值操作(修改对象的操作)都是允许的，不会导致访问它们的不同线程之间的竞争条件。 对原子对象的操作通常比普通的算术操作慢几个数量级。这也包括简单的加载或存储操作。所以你应该只在关键的任务中使用它们。 通常的算术运算和赋值，如a = a+1;实际上在a上有三个操作:首先是加载，然后是加法，最后是存储。只有操作a += 1;和++;是这样的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:6:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"位域 C语言中大多数变量的大小都是字节的整数。位域是结构的一部分，不一定占用整数字节;它们可以使用任意数量的比特。多个位域可以被打包到一个存储单元中。它们是标准C的一部分，但有许多方面是实现定义的。它们是C语言中最不可移植的部分之一。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 type-specifier identifier : size; ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"参数 参数 描述 type-specifier signed、unsigned、int 或 _Bool identifier 名字 size 字段中使用的位数 位字段的可移植类型只有signed、unsigned或_Bool。也可以使用纯int类型，但标准规定对于位域，说明符int是否指定与signed int相同的类型或与unsigned int相同的类型由实现定义。特定的实现可能允许其他整数类型，但使用它们是不可移植的。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:2","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 位域 一个简单的位域可以用来描述可能包含特定位数的事物。 struct encoderPosition { unsigned int encoderCounts : 23; unsigned int encoderTurns : 4; unsigned int _reserved : 5; }; 在这个例子中，我们考虑一个编码器，它有23位单精度，4位描述多匝。当与输出与特定位数相关联的数据的硬件连接时，经常使用位域。另一个例子可能是与FPGA通信，FPGA以32位段的形式将数据写入内存，允许硬件读取: struct FPGAInfo { union { struct bits { unsigned int bulb1On : 1; unsigned int bulb2On : 1; unsigned int bulb1Off : 1; unsigned int bulb2Off : 1; unsigned int jetOn : 1; }; unsigned int data; }; }; 对于这个示例，我们展示了一个常用的构造，它能够访问单个位的数据，或者将数据包作为一个整体写入(模拟FPGA可能做的事情)。然后我们可以像这样访问比特: FPGAInfo fInfo; fInfo.data = 0xFF34F; if (fInfo.bits.bulb1On) { printf(\"Bulb 1 is on\\n\"); } 这是有效的，但根据C99标准6.7.2.1，第10项:单位内位域的分配顺序(高阶到低阶或低阶到高阶)是由实现定义的 在以这种方式定义位域时，需要注意字节序。因此，可能需要使用一个预处理器指令来检查机器的字节顺序。下面是一个例子: typedef union { struct bits { #if defined(WIN32) || defined(LITTLE_ENDIAN) uint8_t commFailure :1; uint8_t hardwareFailure :1; uint8_t _reserved :6; #else uint8_t _reserved :6; uint8_t hardwareFailure :1; uint8_t commFailure :1; #endif }; uint8_t data; } hardwareStatus; 使用位域作为小整数 #include \u003cstdio.h\u003eint main(void) { /* define a small bit-field that can hold values from 0 .. 7 */ struct { unsigned int uint3: 3; } small; /* extract the right 3 bits from a value */ unsigned int value = 255 - 2; /* Binary 11111101 */ small.uint3 = value; /* Binary 101 */ printf(\"%d\", small.uint3); /* This is in effect an infinite loop */ for (small.uint3 = 0; small.uint3 \u003c 8; small.uint3++) { printf(\"%d\\n\", small.uint3); } return 0; } 位域对齐 位域提供了声明小于字符宽度的结构域的能力。位域通过字节级或字级掩码实现。下面的示例产生一个8字节的结构。 struct C { short s; /* 2 bytes */ char c; /* 1 byte */ int bit1 : 1; /* 1 bit */ int nib : 4; /* 4 bits padded up to boundary of 8 bits. Thus 3 bits are padded */ int sept : 7; /* 7 Bits septet, padded up to boundary of 32 bits. */ }; 注释描述了一种可能的布局，但由于标准说可寻址存储单元的对齐方式未指定，所以也可能有其他布局。 未命名位域可以是任何大小，但不能初始化或引用它们。 不能给零宽度位域指定名称并将下一个字段与位域的数据类型定义的边界对齐。这是通过在位域之间填充位来实现的。 struct A的大小是1字节。 struct A { unsigned char c1 : 3; unsigned char c2 : 4; unsigned char c3 : 1; }; 在struct B中，第一个未命名位域跳过2位;c2之后的零宽度位域导致c3从字符边界开始(因此在c2和c3之间跳过3位。c4之后有3个填充位。因此，该结构的大小为2字节。 struct B { unsigned char c1 : 1; unsigned char : 2; /* Skips 2 bits in the layout */ unsigned char c2 : 2; unsigned char : 0; /* Causes padding up to next container boundary */ unsigned char c3 : 4; unsigned char c4 : 1; }; 什么时候使用位域 位域用于将多个变量组合成一个对象，类似于结构。这允许减少内存使用，在嵌入式环境中尤其有用 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:7:3","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"Boolean 要使用预定义的类型_Bool和头文件\u003cstdbool.h\u003e，必须使用C99/C11版本的C语言。为了避免编译器警告和可能的错误，只有在使用C89和该语言以前的版本时，才应该使用typedef/define示例。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:8:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:8:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"命令行参数 int main(int argc, char *argv[]) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:9:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"例子 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:9:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"注释 /* ... */ // c99 及其之后 // ... ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:10:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"常见的C编程习惯用法和开发人员实践 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:11:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"比较 // 不好 if ( i == 2) //Bad-way { doSomething; } // 好 if( 2 == i) //Good-way { doSomething; } ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:11:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"常见陷阱 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:12:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"编译 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:13:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"复合类型 像字符串字面量一样，const限定的复合字面量可以放在只读内存中，甚至可以共享。例如, (const char []) { \"abc\" } == \"abc\" ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:14:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 (type) { initializer-list } ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:14:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"头文件包含 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:15:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数据类型 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:16:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"声明与定义 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:17:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"错误处理 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:18:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #include \u003cerrno.h\u003e•int errno; /* implementation defined */• #include \u003cstring.h\u003e•char *strerror(int errnum);• #include \u003cstdio.h\u003e•void perror(const char *s); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:18:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"文件和 I/O 流 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:19:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #include \u003cstdio.h\u003e /* Include this to use any of the following sections */•FILE *fopen(const char *path, const char *mode); /* Open a stream on the file at path with the specified mode */ FILE *freopen(const char *path, const char *mode, FILE *stream); /* Re-open an existing stream on the file at path with the specified mode */ int fclose(FILE *stream); /* Close an opened stream */• size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); /* Read at most nmemb elements of size bytes each from the stream and write them in ptr. Returns the number of read elements. */ size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); /* Write nmemb elements of size bytes each from ptr to the stream. Returns the number of written elements. */ int fseek(FILE *stream, long offset, int whence); /* Set the cursor of the stream to offset, relative to the offset told by whence, and returns 0 if it succeeded. */ long ftell(FILE *stream); /* Return the offset of the current cursor position from the beginning of the stream. */ void rewind(FILE *stream); /* Set the cursor position to the beginning of the file. */• int fprintf(FILE *fout, const char *fmt, ...); /* Writes printf format string on fout */• FILE *stdin; /* Standard input stream */• FILE *stdout; /* Standard output stream */• FILE *stderr; /* Standard error stream */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:19:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"格式化输入/输出 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:20:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"函数参数 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:21:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"函数指针 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:22:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 - `returnType (*name)(parameters);` - `typedef returnType (*name)(parameters);` - `typedef returnType Name(parameters);` Name *name; - `typedef returnType Name(parameters);` `typedef Name *NamePtr;` ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:22:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"使用 typedef ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:23:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"上下文指针 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:24:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"标识符作用域 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:25:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"实现定义的行为 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:26:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"隐式转换和显示转换 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:27:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"初始化 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:28:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"内联汇编 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:29:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"内联 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:30:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"进程间通信(IPC) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:31:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"迭代语句/循环 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:32:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 /* all versions */• for ([expression]; [expression]; [expression]) one_statement• for ([expression]; [expression]; [expression]) { zero or several statements }• while (expression) one_statement• while (expression) { zero or several statements }• do one_statement while (expression);• do { one or more statements } while (expression);• // since C99 in addition to the form above• for (declaration; [expression]; [expression]) one_statement;• for (declaration; [expression]; [expression]) { zero or several statements } ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:32:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"跳转 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:33:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 return val; /* Returns from the current function. val can be a value of any type that is converts to the function's return type. */ return; /* Returns from the current void-function. */• break; /* Unconditionally jumps beyond the end (\"breaks out\") of an Iteration Statement (loop) or out of the innermost switch statement. */ continue; /* Unconditionally jumps to the beginning of an Iteration Statement (loop). */• goto LBL; /* Jumps to label LBL. */• LBL: statement /* any statement in the same function. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:33:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"链表 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:34:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"数字、字符和字符串的字面值 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:35:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"内存管理 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:36:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 void *aligned_alloc(size_t alignment, size_t size); /* Only since C11 */• void *calloc(size_t nelements, size_t size);• void free(void *ptr);• void *malloc(size_t size);• void *realloc(void *ptr, size_t size);• void *alloca(size_t size); /* from alloca.h, not standard, not portable, dangerous. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:36:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"多字字符序列 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:37:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"多线程 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:38:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 thrd_t // Implementation-defined complete object type identifying a thread• int thrd_create( thrd_t *thr, thrd_start_t func, void *arg ); // Creates a thread• int thrd_equal( thrd_t thr0, thrd_t thr1 ); // Check if arguments refer to the same thread• thr_t thrd_current(void); // Returns identifier of the thread that calls it• int thrd_sleep( const struct timespec *duration, struct timespec *remaining ); // Suspend call thread execution for at least a given time void thrd_yield(void); // Permit other threads to run instead of the thread that calls it• _Noreturn void thrd_exit( int res ); // Terminates the thread the thread that calls it• int thrd_detatch( thrd_t thr; // Detaches a given thread from the current environment• int thrd_join( thrd_t thr, int *res ); // Blocks the current thread until the given thread finishes ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:38:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"操作符 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:39:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 expr1 operator• operator expr2• expr1 operator expr2• expr1 ? expr2 : expr3 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:39:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"将 2 维数组传给函数 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:40:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"指针 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:41:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 \u003cData type\u003e *\u003cVariable name\u003e;• int *ptrToInt;• void *ptrToVoid; /* C89+ */• struct someStruct *ptrToStruct;• int **ptrToPtrToInt;• int arr[length]; int *ptrToFirstElem = arr; /* For \u003cC99 'length' needs to be a compile time constant, for \u003e=C11 it might need to be one. */ int *arrayOfPtrsToInt[length]; /* For \u003cC99 'length' needs to be a compile time constant, for \u003e=C11 it might need to be one. */ ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:41:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"预处理器和宏 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:42:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"随机数生成 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:43:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 arc4random() (available on OS X and BSD)• random() (available on Linux)• drand48() (available on POSIX) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:43:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"条件 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:44:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"信号处理 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:45:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"标准数学 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:46:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"字符串 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:47:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"结构体 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:48:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"Structure Padding and Packing ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:49:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"测试框架 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:50:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"CppUTest #include \u003cCppUTest/CommandLineTestRunner.h\u003e#include \u003cCppUTest/TestHarness.h\u003eTEST_GROUP(Foo_Group) {} TEST(Foo_Group, Foo_TestOne) {} /* Test runner may be provided options, such ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:50:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"线程(原生) ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:51:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"语法 #ifndef __STDC_NO_THREADS__• # include \u003cthreads.h\u003e• #endif• void call_once(once_flag *flag, void (*func)(void));• int cnd_broadcast(cnd_t *cond);• void cnd_destroy(cnd_t *cond);• int cnd_init(cnd_t *cond);• int cnd_signal(cnd_t *cond);• int cnd_timedwait(cnd_t *restrict cond, mtx_t *restrict mtx, const struct timespec *restrict ts); int cnd_wait(cnd_t *cond, mtx_t *mtx);• void mtx_destroy(mtx_t *mtx);• int mtx_init(mtx_t *mtx, int type);• int mtx_lock(mtx_t *mtx);• int mtx_timedlock(mtx_t *restrict mtx, const struct timespec *restrict ts);• int mtx_trylock(mtx_t *mtx);• int mtx_unlock(mtx_t *mtx);• int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);• thrd_t thrd_current(void);• int thrd_detach(thrd_t thr);• int thrd_equal(thrd_t thr0, thrd_t thr1);• _Noreturn void thrd_exit(int res);• int thrd_join(thrd_t thr, int *res);• int thrd_sleep(const struct timespec *duration, struct timespec* remaining);• void thrd_yield(void);• int tss_create(tss_t *key, tss_dtor_t dtor);• void tss_delete(tss_t key);• void *tss_get(tss_t key);• int tss_set(tss_t key, void *val); ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:51:1","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"类型限定符 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:52:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"typedef ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:53:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"未定义类型 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:54:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"联合体 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:55:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"Valgrind Valgrind是一个调试工具，可用于诊断C程序中有关内存管理的错误。Valgrind可用于检测诸如无效指针使用等错误，包括超出已分配空间的写入或读取，或对free()进行无效调用。它还可以通过执行内存分析的函数来改进应用程序。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:56:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"变量参数 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:57:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["C"],"content":"X-macros x -宏是一种基于预处理程序的技术，用于最小化重复代码和维护数据/代码的对应关系。基于一组公共数据的多个不同的宏展开可以通过单个主宏来表示整个组展开，该宏的替换文本由内部宏展开的序列组成，每个数据对应一个。内部宏通常被命名为X()，这就是该技术的名称。 ","date":"2022-05-14","objectID":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/:58:0","tags":["linux","C","C++","C/C++"],"title":"C语言","uri":"/2022/05/0002-c%E8%AF%AD%E8%A8%80/"},{"categories":["linux"],"content":"C 各个版本说明 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:0","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C 语言早期 最早由丹尼斯·里奇（Dennis Ritchie）为了在PDP-11电脑上运行的Unix系统所设计出来的编程语言 第一次发展在1969年到1973年之间。 在PDP-11出现后，丹尼斯·里奇与肯·汤普逊着手将Unix移植到PDP-11上 1973年，Unix操作系统的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上。 1975年C语言开始移植到其他机器上使用。史蒂芬·强生实现了一套“可移植编译器” ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:1","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"K\u0026R c 1978年，丹尼斯·里奇和布莱恩·柯林汉合作出版了《C程序设计语言》的第一版。 “K\u0026R C”（柯里C）。 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:2","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C89/C90 1989年，C语言被美国国家标准协会（ANSI）标准化，这个版本又称为C89 标准化的一个目的是扩展 K\u0026R C，增加了一些新特性。 1990年，国际标准化组织（ISO）规定国际标准的C语言 通过对 ANSI 标准的少量修改，最终制定了 ISO 9899:1990，又称为C90。 随后，ANSI亦接受国际标准C，并不再发展新的C标准。 注意: C89和C90是一回事，C89是由ANSI(American National Standards Institute)美国国家标准协会制定，C90 是由国际标准协会根据ANSI C89 制定。 C89/C90对K\u0026R C改进点 增加了真正的标准库 新的预处理命令与特性 函数原型允许在函数申明中指定参数类型 一些新的关键字，包括 const、volatile 与 signed 宽字符、宽字符串与多字节字符 对约定规则、声明和类型检查的许多小改动与澄清 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:3","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C99 1994年为C语言创建了一个新标准，但是只修正了一些C89标准中的细节和增加更多更广的国际字符集支持。 不过，这个标准引出了1999年ISO 9899:1999的发表。它通常被称为C99。 C99被ANSI于2000年3月采用。 C99新特性(部分) 支持不定长的数组，声明时使用 int a[var] 的形式。 变量声明不必放在语句块的开头，for 语句提倡写成 for(int i=0;i\u003c100;++i) 的形式 允许采用（type_name）{xx,xx,xx} 类似于 C++ 的构造函数的形式构造匿名的结构体。 除了已有的 __line__ __file__ 以外，增加了 __func__ 得到当前的函数名。 取消了函数返回类型默认为 int 的规定。 增加和修改了一些标准头文件(定义bool的、定义复数的、里增加了 struct tmx，对 struct tm 做了扩展。) ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:4","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C11 2011年12月8日，ISO正式发布了新的C语言的新标准C11，之前被称为C1X 官方名称为ISO/IEC 9899:2011 新的标准提高了对C++的兼容性，并增加了一些新的特性。 这些新特性包括泛型宏、多线程、带边界检查的函数、匿名结构等。 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:5","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C18 C18没有引入新的语言特性，只对C11进行了补充和修正 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:1:6","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++ 各个版本说明 1998年是C++标准委员会成立的第一年，以后每5年视实际需要更新一次标准。 2009年，C++标准有了一次更新，一般称该草案为C++0x。 C++0x是C++11标准成为正式标准之前的草案临时名字。 后来，2011年，C++新标准标准正式通过，更名为ISO/IEC 14882:2011，简称C++11。 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:0","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++11 C++11，先前被称作C++0x，即ISO/IEC 14882:2011，是C++编程语言的一个标准。 它取代第二版标准ISO/IEC 14882:2003 （第一版ISO/IEC 14882:1998公开于1998年， 第二版于2003年更新，分别通称C++98以及C++03，两者差异很小），且已被C++14取代 C++11 新特性(部分) auto 关键字及用法 C++11 之前，auto 具有存储期说明符的语义。auto在C++98中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两个标准的auto，完全是两个概念。 nullptr 关键字及用法 引入nullptr，是因为重载函数处理 NULL 的时候会出问题，二义性 void foo(int); //(1) void foo(void*); //(2) foo(NULL); // 重载决议选择 (1)，但调用者希望是 (2) foo(nullptr); // 调用(2) for循环语法 for ( 范围声明 : 范围表达式 ) 循环语句 STL – std::array std::array 提供了静态数组，编译时确定大小、更轻量、更效率，当然也比 std::vector 有更多局限性。 STL – std::forward_list 单向链表 STL – unordered_map STL – unordered_set 多线程 – std::thread 在 C++11 以前，C++ 的多线程编程均需依赖系统或第三方接口实现，一定程度上影响了代码的移植性。C++11 中，引入了 boost 库中多线程的部分内容，形成标准后的接口与 boost 库基本没有变化，这样方便了使用者切换使用 C++ 标准接口。 多线程 – std::atomic 从实现上，可以理解为这些原子类型内部自己加了锁。 多线程 – std::condition_variable 智能指针 – std::shared_ptr 智能指针 – std::weak_ptr 其它 – std::function 其它 – std::bind lambda ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:1","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++14 C++14 旨在作为C++11的一个小扩展，主要提供漏洞修复和小的改进。2014年8月18日，经过C++标准委员投票，C++14标准获得一致通过。ISO/IEC 14882:2014 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:2","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["linux"],"content":"C++17 C++17 又称C++1z，是继 C++14 之后，C++ 编程语言 ISO/IEC 标准的下一次修订的非正式名称。官方名称 ISO/IEC 14882:2017 基于 C++ 11，C++ 17 旨在简化该语言的日常使用，使开发者可以更简单地编写和维护代码。 C++ 17是对 C++ 语言的重大更新 ","date":"2022-05-14","objectID":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/:2:3","tags":["linux"],"title":"C 与 C++ 各个版本","uri":"/2022/05/0001-c%E4%B8%8Ec-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"},{"categories":["samba"],"content":"配置文件 配置文件 说明 /etc/samba/smb.conf samba的主要配置文件，可设置全局参数和共享目录的参数 /etc/samba/lmhosts 通过hostname来访问samba /etc/samba/smbusers 由于windows和linux里的管理员和访客账号名称不一致，可使用此配置文件来设置一个映射，比如administrator映射成root /etc/sysconfig/samba 配置smbd，nmbd启动时带的参数 /var/lib/samba/private/{passdb.tdb, secrets.tdb} 管理samba的用户账号/密码时，会用到的数据库档案 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:1:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"可用命令 命令 说明 smbd smbd提供文件和打印共享服务器 nmbd nmbd提供NetBIOS名称服务和浏览支持，帮助客户端定位服务器，处理所有基于UDP的协议 tdbdump,tdbtool samba使用了tdb数据库，可以使用tdb工具来查看数据库内容 smbstatus 查看samba的状态 smbpasswd, pdbedit 服务器功能，用于管理samba的用户账号和密码，早期是使用smbpasswd命令，后来因为使用了tdb数据库，所以推荐使用pdbedit命令来管理用户数据 mount.cifs 用来挂载分享目录 smbclient samba客户端命令 nmblookup 查找NetBIOS name smbtree 未知，可能是用来查找网络邻居的吧 testparm 验证smb.conf文件的内容是否合法 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:2:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"工作模式 samba 共有5种工作模式，分别为： share，用户对samba服务器的访问不需要身份验证，允许匿名访问，用户的访问权限仅由相应用户对共享文件的访问权限决定 user，使用用户名和密码访问samba服务器 server，使用另外一台服务器专门用来做身份验证，samba服务只提供文件和打印机共享服务 domain，域模式\u003c待补充\u003e ads，\u003c待补充\u003e 通过设置security选项即可设置samba的工作模式：security = share ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:3:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"配置项 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:4:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"全局配置 [global] workgroup = WORKGROUP dns proxy = no log file = /var/log/samba/%m.log max log size = 1000 client min protocol = SMB2 server role = standalone server passdb backend = tdbsam obey pam restrictions = yes unix password sync = yes passwd program = /usr/bin/passwd %u passwd chat = *New*UNIX*password* %n\\n *ReType*new*UNIX*password* %n\\n *passwd:*all*authentication*tokens*updated*successfully* pam password change = yes map to guest = Bad Password usershare allow guests = yes name resolve order = lmhosts bcast host wins security = user guest account = nobody usershare path = /var/lib/samba/usershare usershare max shares = 100 usershare owner only = yes force create mode = 0070 force directory mode = 0070 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:4:1","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"共享目录配置 不需要密码的共享 需要将全局参数中的security设置成share(暂不清楚，在user工作模式下通过设置guest ok好像也可以，需要验证) 最小化配置： [test] comment = test path = /tmp read only = no guest ok = yes create mask = 644 其中： read only默认为yes，表示只允许读，不允许写，所以需要修改 guest ok默认是no，表示不允许匿名访问 create mask默认是744，导致客户端创建的文件都是可执行文件，所以需要修改 注意： writable和writeable是同义词 writeable和read only是反义同义词 writeable默认为no read only默认为yes 完整配置需要配置available和browseable，不过这两个默认都是yes 用户名/密码方式的共享 需要将全局参数中的security设置成user [win] comment = win path = /home/win read only = yes create mask = 644 valid users = win 这种方式首先需要使用root权限添加一个账户，然后使用smbpasswd -a xxx在samba数据库添加此用户的samba密码 输入smbpasswd -a xxx 时会直接让用户设置这个账户的samba密码 这个用户信息保存在tdb数据库里 修改密码：root权限下输入smbpasswd user_name即可修改user_name的samba密码 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:4:2","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"配置文件验证 使用testparm可以验证smb.conf文件的内容是否合法 ","date":"2022-05-13","objectID":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/:5:0","tags":["samba","linux"],"title":"Samba 服务器配置","uri":"/2022/05/0002-samba-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"categories":["samba"],"content":"Samab密码设置对象 Samab密码设置对象(Password Settings Objects，简称PSOs)，开始于 Samba Version:4.9 密码设置对象(PSO)是一种 AD 功能，也称为细粒度密码策略(FGPP)。在 AD 中，密码设置控制以下几个方面： 用户更改密码时的最小密码长度和复杂性要求 密码历史时长：放置用户再次使用以前的密码 密码使用的最小和最大期限：用户必须更改密码的频率 账户锁定：在将用户锁定其账户之前登录尝试失败的阈值，以及他们被锁定的持续时间。 在支持 PSO 之前，Samba 管理员只能为域中的所有用户配置密码设置。例如。如果您想强制系统管理员拥有更长、更安全的密码，那么每个用户都必须遵守相同的密码要求。 PSO 允许 AD 管理员覆盖域的密码策略设置，并为特定用户或用户组配置更精细的密码设置。例如，PSO 可以强制某些用户使用更长的密码长度，或者放宽对其他用户的复杂性限制，等等。 PSO 可以应用于组或单个用户。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:1:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"如何配置 PSO 可以使用 samba-tool domain passwordsettings pso 命令设置。参看 samba-tool domain passwordsettings pso --help 获取更多使用细节。PSO 命令的功能： 自行管理 PSO，即使用 create 或 set 子命令配置密码设置。还有 delete、list 和 show 命令。 控制适用于特定用户的 PSO。使用 apply 和 unapply 将 PSO 链接到特定组或用户 许多不同的 PSO 可以应用于同一用户（直接或通过组）。当多个 PSO 应用于同一用户时，本质上是具有最低优先级的 PSO 生效。但是，直接应用于用户的 PSO 总是胜过通过组成员身份继承的 PSO。要查看对给定用户生效的 PSO，使用 samba-tool domain passwordsettings pso show-user。 如果没有 PSO 应用于用户，则应用域密码设置。您可以使用samba-tool domain passwordsettings show|set查看/修改这些配置。 注意： 请使用 samba-tool 创建密码设置对象，而不是使用手动 LDIF。 PSO 需要驻留在“密码设置容器”中，samba-tool 将自动对其进行排序。任何在别处创建的 PSO 都将被忽略。 内置组不包括在 PSO 计算中。任何应用于内置组的 PSO 都不会生效。 要使用 Windows GUI 创建 PSO，请打开 Active Directory 管理中心，然后导航到系统 -\u003e 密码设置容器，然后单击“新建”按钮将弹出一个向导。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:2:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"已知问题 当前 (v4.9) 配置 PSO 并将其应用于用户会导致性能下降。这是我们希望在未来解决的问题。 计算 PSO 涉及计算用户的组成员资格，这是一个相当昂贵的计算。更糟糕的是，我们可能需要多次查找 msDS-ResultantPSO，因此它可能会尝试多次计算组，仅针对一次用户身份验证操作。注意： 如果根本没有 PSO 对象，则不会影响性能。 我们尝试缓存 msDS-ResultantPSO 结果，因此每次用户身份验证操作只计算一次。但是，如果没有 msDS-ResultantPSO（即域默认值适用于用户），我们不会缓存结果。所以这将是最坏的情况：域中存在一些 PSO，但它们对大多数用户不起作用。 如果 PSO 直接应用于用户（而不是组），则跳过昂贵的组计算。但是，与将 PSO 应用于组相比，将 PSO 直接应用于用户会使 PSO 更难管理。 如果密码历史长度从零变为非零值，Windows 和 Samba 行为之间还有一个非常微不足道的错误 (#13431)。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:3:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"代码位置 主要 PSO 行为是使用构造属性控制的：msDS-ResultantPSO。这是为用户对象生成的，其值是适用于该用户的 PSO 的 DN。因此，确定适用于用户的正确 PSO 的逻辑存在于 operation.c 中，在那里生成构造的属性。 如果你 grep 'msDS-ResultantPSO' 的代码库，你应该找到所有尝试使用它的地方。基本上，无论代码检查密码设置属性（例如 lockOutObservationWindow），我们都必须检查 PSO 是否适用于该用户，如果是，则使用 PSO 属性（具有不同的名称，即 msDS-LockoutObservationWindow）。 samdb_result_effective_badPwdCount() 就是一个很好的例子。 get_pso_data_callback() 也值得注意，因为它用 PSO 的值覆盖了 dsdb_user_pwd_settings 结构的值（即域密码设置）。在密码哈希模块中使用此结构（作为结构 dsdb_control_password_change_status 的一部分）来检查密码更改操作。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:4:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["samba"],"content":"参考文档 MS-ADTS 记录了如何确定 msDS-ResultantPSO（第 3.1.1.4.5.36 节）。 MS-SAMR 记录了 msDS-ResultantPSO 如何用于确定应用于用户的有效密码设置，即 Effective-LockoutThreshold、Effective-MinimumPasswordLength 等。这在第 3.1.1.5 节用于发起更新约束的密码设置属性中记录，但这些 Effective-XYZ 值在整个文档的其他几个地方都被引用，例如在计算 userAccountControl 时。 ","date":"2022-05-13","objectID":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/:5:0","tags":["samba","PSOs","PSO"],"title":"Samba 密码设置对象(PSOs)","uri":"/2022/05/0001-samba-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1psos/"},{"categories":["linux"],"content":"rfkill rfkill 是一个小型的用户空间工具，用于查询 rfkill 开关、按钮和子系统接口的状态。 Linux 内核通过 /dev/rfkill 设备文件公开了 rfkill 子系统一些控制功能，允许用户空间模拟/监听/控制硬件 rfkill 设备。 ","date":"2022-04-20","objectID":"/2022/04/0005-rfkill/:1:0","tags":["linux","rfkill","wlan","bluetooth"],"title":"rfkill —— 用户空间控制无线通讯命令","uri":"/2022/04/0005-rfkill/"},{"categories":["linux"],"content":"具体使用 rfkill --help ","date":"2022-04-20","objectID":"/2022/04/0005-rfkill/:2:0","tags":["linux","rfkill","wlan","bluetooth"],"title":"rfkill —— 用户空间控制无线通讯命令","uri":"/2022/04/0005-rfkill/"},{"categories":["linux"],"content":"参看 https://wireless.wiki.kernel.org/en/users/Documentation/rfkill ","date":"2022-04-20","objectID":"/2022/04/0005-rfkill/:3:0","tags":["linux","rfkill","wlan","bluetooth"],"title":"rfkill —— 用户空间控制无线通讯命令","uri":"/2022/04/0005-rfkill/"},{"categories":["字符编码"],"content":"字符编码基本概念 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:0","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符 字符（Character）：在计算机和电信技术中，一个字符是一个单位的字形、类字形单位或符号的基本信息。说的简单点字符是各种文字和符号的总称。一个字符可以是一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号、一个图形符号或者控制符号等。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:1","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符集 字符集（Character Set）：是指多个字符的集合。不同的字符集包含的字符个数不一样、包含的字符不一样、对字符的编码方式也不一样。例如GB2312是中国国家标准的简体中文字符集，GB2312收录简化汉字（6763个）及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。而ASCII字符集只包含了128字符，这个字符集收录的主要字符是英文字母、阿拉伯字母和一些简单的控制字符。 另外，还有其他常用的字符集有 GBK字符集、GB18030字符集、Big5字符集、Unicode字符集等。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:2","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符编码 字符编码（Character Encoding）：字符编码是指一种映射规则，根据这个映射规则可以将某个字符映射成其他形式的数据以便在计算机中存储和传输。例如ASCII字符编码规定使用单字节中低位的7个比特去编码所有的字符，在这个编码规则下字母A的编号是65（ASCII码），用单字节表示就是0x41，因此写入存储设备的时候就是二进制的 01000001。每种字符集都有自己的字符编码规则，常用的字符集编码规则还有 UTF-8编码、GBK编码、Big5编码等。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:3","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"码点 码点（Code Point）：有些地方翻译为码值或内码。是指在某个字符集中，根据某种编码规则将字符编码后得到的值。比如在ASCII字符集中，字母A经过ASCII编码得到的值是65，那么65就是字符A在ASCII字符集中的码点。 总结：通俗解释字符集就是把字符放到一起的一个集合。而这个集合的每一个字符都对应一个数字，叫做码点。那么，这样就建立起来数字和字符之间的索引关系。那么，某个字符在计算机中怎么表示，具体占用几个字节等等，这些就需要编码规则来解决了。这个就是字符编码，他来解决根据某个规则来将字符映射到相应的码点上面。 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:1:4","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"字符编码 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:0","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"ASCII 码 ASCII 编码于 1967 年第一次发布，最后一次更新是在 1986 年，迄今为止共收录了 128 个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是 1234567890）、标点符号（,.!等）、特殊符号（@#$%^\u0026等）以及一些具有控制功能的字符（往往不会显示出来）。 ASCII 编码是美国人给自己设计的，他们并没有考虑欧洲那些扩展的拉丁字母，也没有考虑韩语和日语，我大中华几万个汉字更是不可能被重视。计算机也是美国人发明的，起初使用的就是 ASCII 码，只能显示英文字符。各个国家为了让本国公民也能正常使用计算机，开始效仿 ASCII 开发自己的字符编码，例如 ISO/IEC 8859（欧洲字符集）、shift_Jis（日语字符集）、GBK（中文字符集）等。 二进制 十进制 十六进制 字符/缩写 解释 00000000 0 00 NUL (NULL) 空字符 00000001 1 01 SOH (Start Of Headling) 标题开始 00000010 2 02 STX (Start Of Text) 正文开始 00000011 3 03 ETX (End Of Text) 正文结束 00000100 4 04 EOT (End Of Transmission) 传输结束 00000101 5 05 ENQ (Enquiry) 请求 00000110 6 06 ACK (Acknowledge) 回应/响应/收到通知 00000111 7 07 BEL (Bell) 响铃 00001000 8 08 BS (Backspace) 退格 00001001 9 09 HT (Horizontal Tab) 水平制表符 00001010 10 0A LF/NL(Line Feed/New Line) 换行键 00001011 11 0B VT (Vertical Tab) 垂直制表符 00001100 12 0C FF/NP (Form Feed/New Page) 换页键 00001101 13 0D CR (Carriage Return) 回车键 00001110 14 0E SO (Shift Out) 不用切换 00001111 15 0F SI (Shift In) 启用切换 00010000 16 10 DLE (Data Link Escape) 数据链路转义 00010001 17 11 DC1/XON (Device Control 1/Transmission On) 设备控制1/传输开始 00010010 18 12 DC2 (Device Control 2) 设备控制2 00010011 19 13 DC3/XOFF (Device Control 3/Transmission Off) 设备控制3/传输中断 00010100 20 14 DC4 (Device Control 4) 设备控制4 00010101 21 15 NAK (Negative Acknowledge) 无响应/非正常响应/拒绝接收 00010110 22 16 SYN (Synchronous Idle) 同步空闲 00010111 23 17 ETB (End of Transmission Block) 传输块结束/块传输终止 00011000 24 18 CAN (Cancel) 取消 00011001 25 19 EM (End of Medium) 已到介质末端/介质存储已满/介质中断 00011010 26 1A SUB (Substitute) 替补/替换 00011011 27 1B ESC (Escape) 逃离/取消 00011100 28 1C FS (File Separator) 文件分割符 00011101 29 1D GS (Group Separator) 组分隔符/分组符 00011110 30 1E RS (Record Separator) 记录分离符 00011111 31 1F US (Unit Separator) 单元分隔符 00100000 32 20 (Space) 空格 00100001 33 21 ! 00100010 34 22 \" 00100011 35 23 # 00100100 36 24 $ 00100101 37 25 % 00100110 38 26 \u0026 00100111 39 27 ' 00101000 40 28 ( 00101001 41 29 ) 00101010 42 2A * 00101011 43 2B + 00101100 44 2C , 00101101 45 2D - 00101110 46 2E . 00101111 47 2F / 00110000 48 30 0 00110001 49 31 1 00110010 50 32 2 00110011 51 33 3 00110100 52 34 4 00110101 53 35 5 00110110 54 36 6 00110111 55 37 7 00111000 56 38 8 00111001 57 39 9 00111010 58 3A : 00111011 59 3B ; 00111100 60 3C \u003c 00111101 61 3D = 00111110 62 3E \u003e 00111111 63 3F ? 01000000 64 40 @ 01000001 65 41 A 01000010 66 42 B 01000011 67 43 C 01000100 68 44 D 01000101 69 45 E 01000110 70 46 F 01000111 71 47 G 01001000 72 48 H 01001001 73 49 I 01001010 74 4A J 01001011 75 4B K 01001100 76 4C L 01001101 77 4D M 01001110 78 4E N 01001111 79 4F O 01010000 80 50 P 01010001 81 51 Q 01010010 82 52 R 01010011 83 53 S 01010100 84 54 T 01010101 85 55 U 01010110 86 56 V 01010111 87 57 W 01011000 88 58 X 01011001 89 59 Y 01011010 90 5A Z 01011011 91 5B [ 01011100 92 5C \\ 01011101 93 5D ] 01011110 94 5E ^ 01011111 95 5F _ 01100000 96 60 ` 01100001 97 61 a 01100010 98 62 b 01100011 99 63 c 01100100 100 64 d 01100101 101 65 e 01100110 102 66 f 01100111 103 67 g 01101000 104 68 h 01101001 105 69 i 01101010 106 6A j 01101011 107 6B k 01101100 108 6C l 01101101 109 6D m 01101110 110 6E n 01101111 111 6F o 01110000 112 70 p 01110001 113 71 q 01110010 114 72 r 01110011 115 73 s 01110100 116 74 t 01110101 117 75 u 01110110 118 76 v 01110111 119 77 w 01111000 120 78 x 01111001 121 79 y 01111010 122 7A z 01111011 123 7B { 01111100 124 7C | 01111101 125 7D } 01111110 126 7E ~ 01111111 127 7F DEL (Delete) 删除 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:1","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"GB2312(别名:EUC-CN) 《信息交换用汉字编码字符集》是由中国国家标准总局1980年发布，1981年5月1日开始实施的一套国家标准，标准号是GB 2312—1980。 GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。 GB2312(1980年)共收录 7445 个字符 –\u003e GBK1.0(1995年)共收录 21886 个字符 –\u003e GB18030(2000年)取代GBK1.0共收录 27484 个汉字包含了少数民族语言。 从 ASCII -\u003e GB2312 -\u003e GBK -\u003e GB18030，这些编码都是向下兼容的。区分中文编码的方法是最高字节的最高位不为 0。这些都属于双字节字符集。 GB2312 编码规则 GB2312 规定每个英文字符占1字节(只有这一个特例，为了兼容 ASCII)，中文字符采用两个字节表示 GB2312 整体分为 94 个区，每个区 94 位，01-09 特殊符号区；16-55一级汉字，按拼音排序；56-87二级汉字，部首/笔划排序；10-15与88-94未定义 GB2312 是区位编码，编码范围是 0XA1A1-0XFEFE，其中汉字编码范围是 0XB0A1-0XF7FE。 GB2312 01-09 符号和数字区，16-87是汉字区 GB2312 编码计算：[区号+0xA0][位号+0xA0] GB2312 编码识别 保存为demo-gb2312.c // // Created by dingjing on 3/28/22. // #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cstdint.h\u003e#include \u003cstdbool.h\u003e /** * 总共 94 个区 94 个位 */ bool is_gb2312 (const char* code) { int len = strlen (code); if (len != 2 \u0026\u0026 len != 1) { return false; } uint8_t codeH = code[0]; uint8_t codeL = code[1]; uint8_t area = codeH - 0xA0; uint8_t pos = codeL - 0xA0; if ((len == 1) \u0026\u0026 (0 == (codeL \u0026 0x80))) { printf (\"ascii code: '%-3c' hex code: 0x%-2X\\n\", *code, *code); return true; } if (area \u003e= 1 \u0026\u0026 area \u003c= 94 \u0026\u0026 pos \u003e= 1 \u0026\u0026 pos \u003c= 94) { printf (\"gb2312 code: '%-3s' -- area: %-2u, pos: %-2u hex code: 0x%-2X 0x%-2X\\n\", code, area, pos, codeH, codeL); return true; } } int main (int argc, char* argv[]) { /** * https://uic.io/en/charset/show_raw/gb2312 * http://tools.jb51.net/table/gb2312 * 1. '残' 十六进制: B2D0 * 2. '怖' 十六进制: B2C0 * 3. '惭' 十六进制: B2D1 * * 4. ascii 里显示的特殊符号 32(space) - 47(/) * 5. ascii 里数字 30(0) - 39(9) * 6. ascii 里显示的特殊符号 58(:) - 64(@) * 7. ascii 里显示的大写字母 65(A) - 90(Z) * 8. ascii 里显示的标号字符 91([) - 96(`) * 9. ascii 里显示的大写字母 97(a) - 122(z) * 10. ascii 其它可显示字符 123({) - 126(~) * * uint16_t 就足够了 */ const char* arr[] = { \"、\", \"∩\", \"〓\", /* 第一区 */ \"残\", \"怖\", \"惭\", \"庄\", \"丽\", \"君\", \"齄\", \" \", \"/\", \"0\", \"9\", \":\", \"@\", \"A\", \"Z\", \"[\", \"`\", \"a\", \"z\", \"{\", \"~\" }; printf (\"array: %lu/%lu\\n\\n\", sizeof arr[0], sizeof arr); int len = sizeof arr / sizeof arr[0]; for (int i = 0; i \u003c len; ++i) { const char* code = arr[i]; if (!is_gb2312 (code)) { printf (\"index: %d -- code '%-3s' is not gb2312\\n\", i, code); } } return 0; } 编译命令: gcc -O0 -finput-charset=utf8 -fexec-charset=gb2312 demo-gb2312.run demo-gb2312.c GB2312识别思路(后续补充) ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:2","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"Unicode 编码 Unicode 的使命就是为了统一世界上所有语言的编码，它包含了世界上所有字符的编码，规定了每个字符对应的码点值。 这里需要注意：Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 问题1: 如何才能区别unicode和ascii 问题2: 我们已经知道，英文字母只用一个字节表示就够了，如果 unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0， 这对于存储来说是极大的浪费，文本文件的大小会因此大出 2-3 倍，这是无法接受的。 另附unicode中汉字编码 字符集 字数 unicode 编码 基本汉字 20902字 4E00(一) - 9FA5(龥) 基本汉字扩充 90字 9FA6(龦) - 9FFF(\u003c无法显示\u003e) 这些看着不像汉字，先不管 扩展A 6592字 3400 - 4DBF，看着不像汉字 扩展B 42720字 20000-2A6DF 扩展C 4153字 2A700-2B738 扩展D 222字 2B740-2B81D 扩展E 5762字 2B820-2CEA1 扩展F 7473字 2CEB0-2EBE0 扩展G 4939字 30000-3134A 康熙部首 214字 2F00-2FD5 部首扩展 115字 2E80-2EF3 兼容汉字 477字 F900-FAD9 兼容扩展 542字 2F800-2FA1D PUA(GBK)部件 81字 E815-E86F 部件扩展 452字 E400-E5E8 PUA增补 207字 E600-E6CF 汉字笔画 36字 31C0-31E3 汉字结构 12字 2FF0-2FFB 汉语注音 43字 3105-312F 注音扩展 22字 31A0-31BA 〇 1字 3007 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:3","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"utf8 编码(unicode编码的一种实现) UTF-8 是一种变长字节编码方式，是 Unicode 的一种实现方式，使用 1-4 个字节表示一个符号， 对于某一个字符的 UTF-8 编码，如果只有一个字节则其最高二进制位为 0； 如果是多字节，其第一个字节从最高位开始，连续的二进制位值为 1 的个数决定了其编码的位数，其余各字节均以 10 开头。UTF-8 最多可用到 6 个字节。 注意：这里是utf8编码的核心，它规定了utf8最多可以使用多少字节编码 思考：为什么utf8最多只能使用6字节参与编码？ 实际上 utf-8 编码没用到 6 字节那么多，只用到了 4 字节 另外补充：另外补充 utf16，介于 utf8 与 utf32 之间，部分编码定长、部分编码不定长(只有两种) utf32 是定长的，用 4 字节表示一个字符 utf8中文汉字占3字节(这种结论不是一直不变的) 以下展示 utf8 分别为 1、2、3、4、5、6字节时候，理论上其它位的编码范围。 1字节 0xxxxxxx 2字节 110xxxxx 10xxxxxx 3字节 1110xxxx 10xxxxxx 10xxxxxx 4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 与上述等价 1字节, utf8-1 0x00-0x7F 2字节, utf8-2 0xC2-0XDF 0X80-0XBF 3字节, utf8-3 0xE0 0xA0-0XBF 0x80-0xBF 0xE1-0XEC 0x80-0XBF 0x80-0xBF 0xED 0x80-0x9F 0x80-0xBF 0xEE-0xEF 0x80-0xBF 0x80-0xBF 4字节, utf8-4 0xF0 0x90-0xBF 0x80-0xBF 0x80-0xBF 0xF1-0xF3 0x80-0xBF 0x80-0xBF 0x80-0xBF 0xF4 0x80-0x8F 0x80-0xBF 0x80-0xBF utf8 编码识别 保存为demo-utf8.c // // Created by dingjing on 3/28/22. // #include \u003cstdio.h\u003e#include \u003cstdint.h\u003e#include \u003cstring.h\u003e#include \u003cstdbool.h\u003e bool is_utf8_1 (const char* code) { int len = strlen(code); if (len \u003c 1) { return false; } const uint8_t code1 = code[0]; if (!(0x80 \u0026 code1)) { return true; } return false; } bool is_utf8_2 (const char* code) { int len = strlen(code); if (len \u003c 2) { return false; } const uint8_t code1 = code[0]; const uint8_t code2 = code[1]; // printf (\"debug2: 0x%-4X\\n\", code); if (!is_utf8_1 (code) \u0026\u0026 (0xC0 == (0xE0 \u0026 code1)) \u0026\u0026 (0x80 == (0xE0 \u0026 code2))) { // printf (\"debug: is utf8-2\\n\"); if (code1 \u003e= 0xC0 \u0026\u0026 code1 \u003c= 0xDF \u0026\u0026 code2 \u003e= 0x80 \u0026\u0026 code2 \u003c= 0xBF) { return true; } } return false; } bool is_utf8_3 (const char* code) { /** * 0xE0 0xA0-0XBF 0x80-0xBF * 0xE1-0XEC 0x80-0XBF 0x80-0xBF * 0xED 0x80-0x9F 0x80-0xBF * 0xEE-0xEF 0x80-0xBF 0x80-0xBF */ int len = strlen(code); if (len \u003c 3) { return false; } const uint8_t code1 = code[0]; const uint8_t code2 = code[1]; const uint8_t code3 = code[2]; if ((0xE0 == code1) \u0026\u0026 ((code2 \u003e= 0xA0) \u0026\u0026 (code2 \u003c= 0XBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } else if (((code1 \u003e= 0xE1) \u0026\u0026 (code1 \u003c= 0xEC)) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } else if ((0xED == code1) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0x9F)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } else if (((code1 \u003e= 0xEE) \u0026\u0026 (code1 \u003c= 0xEF)) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF))) { return true; } return false; } bool is_utf8_4 (const char* code) { /** * 0xF0 0x90-0xBF 0x80-0xBF 0x80-0xBF * 0xF1-0xF3 0x80-0xBF 0x80-0xBF 0x80-0xBF * 0xF4 0x80-0x8F 0x80-0xBF 0x80-0xBF */ int len = strlen(code); if (len \u003c 4) { return false; } const uint8_t code1 = code[0]; const uint8_t code2 = code[1]; const uint8_t code3 = code[2]; const uint8_t code4 = code[3]; // printf (\"debug4: 0x%-4X %-4X\\n\", code1H, code1L); if (!is_utf8_1 (code) \u0026\u0026 !is_utf8_2 (code) \u0026\u0026 !is_utf8_3 (code)) { if ((0xF0 == code1) \u0026\u0026 ((code2 \u003e= 0x90) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF)) \u0026\u0026 ((code4 \u003e= 0x80) \u0026\u0026 (code4 \u003c= 0xBF))) { return true; } else if (((code1 \u003e= 0xF1) \u0026\u0026 (code1 \u003c= 0xF3)) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0xBF)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF)) \u0026\u0026 ((code4 \u003e= 0x80) \u0026\u0026 (code4 \u003c= 0xBF))) { return true; } else if ((0xF4 == code1) \u0026\u0026 ((code2 \u003e= 0x80) \u0026\u0026 (code2 \u003c= 0x8F)) \u0026\u0026 ((code3 \u003e= 0x80) \u0026\u0026 (code3 \u003c= 0xBF)) \u0026\u0026 ((code4 \u003e= 0x80) \u0026\u0026 (code4 \u003c= 0xBF))) { return true; } } return false; } int main (int argc, char* argv[]) { // utf-8 1 - 4 字节 const char* arr[] = { \" \", \"/\", \"0\", \"9\", \":\", \"@\", \"A\", \"Z\", \"[\", \"`\", \"a\", \"z\", \"{\", \"~\", /* 以下都是 ASCII */ \"§\", \"©\", \"®\", \"Ą\", \"Ď\", \"Đ\", \"Ő\", /* 2 字节 utf8 编码 */ \"ᥕ\", \"一\", \"龥\", \"庄\", \"丽\", \"君\", /* 3 字节 */ \"契\", \"い\", \"龜\" }; printf (\"array: %lu/%lu\\n\\n\", sizeof arr[0], sizeof arr); char buf[128] = {0}; int len = sizeof arr / sizeof arr[0]; for (int i = 0; i \u003c len; ++i) { const char* code = arr[i]; if (is_utf8_1 (code)) { pri","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:4","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"utf16 编码(unicode编码的一种实现) 没用到，后续补充。 部分编码定长、部分编码不定长(只有两种) ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:5","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["字符编码"],"content":"utf32 编码(unicode编码的一种实现) utf32 是定长的，用 4 字节表示一个字符 ","date":"2022-03-29","objectID":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/:2:6","tags":["linux","中文字符编码","utf8","gb2312","unicode"],"title":"字符编码","uri":"/2022/03/0001-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"categories":["linux"],"content":"说明 fstransform 命令可以将文件系统从一种类型转换为另一种类型而不丢失数据(即非破坏性的)。更重要的是它可以直接执行，而无需格式化或者复制数据。 tune2fs 命令可以把 ext2 转为 ext3 或 ext4；也可以把 ext3 转为 ext4 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:1:0","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"fstransform文件系统格式转换 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:2:0","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"需要注意的事 1. Linux内核必须支持转换前和转换后的文件系统 2. ext2升级到ext3、ext4无需 fstransform，要使用 tune2fs 3. 源文件系统的设备至少有5%的可用空间 4. 开始执行转换前卸载文件系统 5. 源文件系统存储的数据越多，转换时间越长。实际取决于设备 6. 虽然fstransform被证明是稳定的，但是也要备份好数据 7. 无法转换Linux根文件系统格式 8. 设备上的文件系统限制 必须支持 SPARSE 文件(即:带有孔的文件) 至少有两个系统调用\"ioctl\"(FS_IOC_FIEMAP和FIBMAP)中的一个 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:2:1","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"操作 fstransform /dev/xxx \u003c目标系统\u003e 亲测速度太慢，而且还有很高的失败率。建议如果是ext系列的文件系统使用tune2fs转换。 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:2:2","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"tune2fs 转换ext系列文件系统格式 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:0","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"ext2 转 ext3 tune2fs -j /dev/sda ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:1","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"ext2 转 ext4 tune2fs -O extents,uninit_bg,dir_index,has_journal /dev/sda1 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:2","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"ext3 转 ext4 tune2fs -O extents,uninit_bg,dir_index,has_journal /dev/sda1 ","date":"2022-03-27","objectID":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/:3:3","tags":["linux","shell","fs","fstransform","tune2fs"],"title":"文件系统格式转换","uri":"/2022/03/0002-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"wireshark 是什么 Wireshark(前称Ethereal)是一个网络封包分析软件。网络封包软件的功能主要是截取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用 WinPCAP 作为接口，直接与网卡进行数据报文交换。 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:1:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 使用 首先进入 wireshark，启动时候需要使用命令行以 root 启动 非root用户无法抓取网卡上所有的包 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"1. 选择网卡 选择菜单栏上 Capture -\u003e Option，选中使用的网卡，点击 start 开始抓包 选择网卡 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"2. 添加过滤条件 比如仅需要查看 www.baidu.com 的数据包，通过 ping 命令获取对应的 ip，在 wireshark 中设置 ip 过滤条件就可以看到。 ip.addr == 119.75.217.26 and icmp 表示只显示ICPM协议且源主机IP或者目的主机IP为119.75.217.26的数据包 添加过滤条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:2:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 界面说明 wireshark界面说明 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:3:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"数据详细区说明 Frame: 物理层的数据帧概况 Ethernet II: 数据链路层以太网帧头部信息 Internet Protocol Version 4: 互联网层IP包头部信息 Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP 之后的都属于应用层 wireshark界面说明 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:3:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"wireshark 设置过滤条件 需要注意的是，wireshark 既可以设置抓包过滤条件，也可以设置显示过滤条件，前者限制大，用于减少捕获数据包的数量；后者用于在报文中隐藏某些报文。 抓包过滤器只能在抓包前设置，无法动态修改，显示过滤器则没有此限制 设置抓包过滤条件，(如果已经开始抓包，需要先停止…)菜单栏 Capture -\u003e Options -\u003e Input -\u003e Capture filter for selected interfaces 设置配置条件，同时选中要抓取的网卡，点击此页面右下角的 Start 即可开始抓包 设置显示过滤条件，在菜单栏下边有个文本输入框(Apply a display filter ... \u003cCtrl-/\u003e) 在这里配置显示过滤条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"抓取过滤类型(抓包过滤) 类型 说明 host 让wireshark只抓取源于或发往由标识符host所指定的主机名或IP地址的流量 net 让wireshark只抓取源于或发往由标识符net所标识的IPv4/IPv6网络号的流量 port 让wireshark只抓取源于或发往由标识符port指定端口号的流量包 portrange 让wireshark只抓取源于或发往由标识符portrange指定端口范围的流量包 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"过滤方向(显示/抓包过滤) 方向 说明 src 发送端条件 dst 目标端条件 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"过滤协议(显示过滤) 协议 说明 ether fddi tr wlan ip ip6 arp rarp decnet sctp tcp udp http … ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:3","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"逻辑运算符(显示过滤) 运算符 说明 \u0026\u0026 或 and 两者等价与逻辑 || 或 or 两者等价或逻辑 ! 或 not 两者等价非逻辑 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:4","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"比较操作符(显示过滤) 运算符 说明 == 等于 != 不等于 \u003e 大于 \u003c 小于 \u003e= 大于等于 \u003c= 小于等于 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:4:5","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"例子 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:0","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"抓包过滤条件 抓取百度的包 host www.baidu.com 或者使用 ping www.baidu.com 得到百度网站的ip (220.181.38.150)再使用命令 net 220.181.38.150 抓取指定ip范围内的包 net 192.168.0.0/24 或 net 192.168.0.0 mask 255.255.255.0 抓取从指定 IP 范围发出的包 src net 192.168.0.0/24 或 src net 192.168.0.0 mask 255.255.255.0 抓取发往目标 IP 范围的包 dst net 192.168.0.0/24 或 dst net 192.168.0.0 mask 255.255.255.0 抓取指定端口53的包(DNS服务) port 53 抓取指定服务器上非 HTTP 和非 SMTP 的包 host www.example.com and not (port 80 or port 25) host www.example.com and not port 80 and not port 25 抓取除了 ARP 和 DNS 的包 port not 53 and not arp 抓取指定端口范围的包 (tcp[0:2] \u003e 1500 and tcp[0:2] \u003c 1550) or (tcp[2:2] \u003e 1500 and tcp[2:2] \u003c 1550) 或 tcp portrange 1501-1549 值抓取EAPOL类型以太网的包 ether proto 0x888e 拒绝向链路层发现协议发送的以太网帧 not ether dst 01:80:c2:00:00:0e 仅捕获IPv4流量-最短的过滤器，但有时非常有用，以摆脱较低的层协议，如ARP和STP ip 仅捕获单播流量-如果你只想看到与你的机器之间的流量，而不捕获广播和多播 not broadcast and not multicast 捕获IPv6“所有节点”(路由器和邻居通告)流量。可以用来找到流氓RAs dst host ff02::1 捕获HTTP GET请求。这将查找TCP头后面的字节’G’、‘E’、‘T’和’ ‘(十六进制值47、45、54和20)。“tcp[12:1] \u0026 0xf0) » 2\"计算出tcp报头长度 port 80 and tcp[((tcp[12:1] \u0026 0xf0) \u003e\u003e 2):4] = 0x47455420 ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:1","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"显示过滤器 仅显示 SMTP(25端口)和 ICMP 数据包 tcp.port eq 25 or icmp 只显示局域网(192.168.x.x)的流量，工作站和服务器之间-没有Internet: ip.src==192.168.0.0/16 and ip.dst==192.168.0.0/16 TCP buffer full - Source指示Destination停止发送数据 tcp.window_size == 0 \u0026\u0026 tcp.flags.reset != 1 参考：https://wiki.wireshark.org/DisplayFilters 参考: https://wiki.wireshark.org/Home ","date":"2022-03-23","objectID":"/2022/03/0001-wireshark/:5:2","tags":["linux","tool"],"title":"Wireshark 使用初步","uri":"/2022/03/0001-wireshark/"},{"categories":["linux"],"content":"samba 挂载 目前有一个需求，系统重启时候需要自动挂载远程 samba 文件系统，起初使用 fstab 发现并不能成功挂载，考虑应该是和启动顺序有关系，当没有网络的时候是无法执行挂载操作的，或者说挂载会出错，后来发现 systemd 也提供自动挂载的功能，于是尝试了一下，发现是可以的。 ","date":"2022-03-18","objectID":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/:1:0","tags":["linux","samba","systemd"],"title":"systemd 自动挂载samba","uri":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/"},{"categories":["linux"],"content":"具体步骤 在 /etc/samba/ 下创建 credentials 文件夹 mkdir /etc/samba/crendentials 在/etc/samba/crendentials下创建比如名为share0的文件并加入如下配置 # vim /etc/samba/crendentials/share0 username=\u003csamba登录用户名\u003e password=\u003csamba对应的密码\u003e 创建systemd unit文件，内容如下 # vim /etc/systemd/system/mnt-share.mount Description= mount a samba share Requires=network-online.target After=network-online.target systemd-resolved.service Wants=network-online.target systemd-resolved.service [Mount] Name=mnt-share What=//\u003c远程samba-ip\u003e/\u003c远程samba路径\u003e Where=/mnt/share # \u003c本机挂载路径\u003e Type=cifs Options=x-systemd.automount,_netdev,credentials=/etc/samba/credentials/share,sec=ntlmssp,vers=1.0,rw,uid=1000,gid=1000,dir_mode=0777,file_mode=0777,iocharset=utf8 TimeoutSec=30 [Install] WantedBy=multi-user.target 测试是否可以挂载 systemctl start mnt-share.mount 如果有报错就需要尝试修改 5. 开机自动挂载 systemctl enable mnt-share.mount 注意：挂载路径(Where)必须和文件名(mnt-share0)对应，比如挂载到 /mnt/share，那么文件名必须是mnt-share0.mount 参考：arch linux samba https://wiki.archlinux.org/index.php/samba#As_systemd_unit ","date":"2022-03-18","objectID":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/:2:0","tags":["linux","samba","systemd"],"title":"systemd 自动挂载samba","uri":"/2022/03/0004-systemd%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDsamba/"},{"categories":["linux"],"content":"说明 dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:1:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"块大小可以使用的计量表 单元大小 表示 字节(1B) c 字节(2B) w 块(512B) b 千字节(1024B) k 兆字节(1024KB) M 吉字节(1024MB) G ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:2:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"参数解释 参数 说明 if=\u003c文件名\u003e 输入文件名，默认为stdin标准输入，用来指定读取的源文件 of=\u003c文件名\u003e 输出文件名，默认为stdout标准输出，用来指定输出的目的文件 ibs=\u003c字节\u003e 一次读入bytes个字节，即指定一个块大小为bytes个字节 obs=\u003c字节\u003e 一次输出bytes个字节，即指定一个块大小为bytes个字节 bs=\u003c字节\u003e 同事设置读入/读出的块大小为 bytes 个字节 cbs=\u003c字节\u003e 一次转换bytes个字节，即指定转换缓存区大小 skip=\u003c字节\u003e 从输入文件开头跳过blocks个块后再开始复制 seek=\u003c字节\u003e 从输出文件开头跳过blocks个块后再开始复制 count=\u003c字节\u003e 仅拷贝blocks个块，块大小等于ibs指定的字节数 conv=\u003c转换参数\u003e 用指定的参数转换文件。ascii:转换ebcdic为asciiebcdic:转换ascii为ebcdicibm:转换ascii为alternate ebcdicblock:把每一行转换为长度为cbs，不足部分用空格填充unblock:使没一行的长度都为cbs，不足部分用空格填充lcase:把大写字符转换为小写字符ucase:把小写字符转换为大写字符swab:交换输入的每对字节noerror:出错时不停止notrunc:不截断输出文件sync:将每个输入块填充到ibs个字节，不足部分也能够(NUL)字符补齐 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:3:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"dd应用实例 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"将本地 /dev/hdb 盘备份到 /dev/hdd dd if=/dev/hdb of=/dev/hdd ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:1","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"备份/dev/hdb全盘数据，并利用gzip工具进行压缩，保存到指定路径 dd if=/dev/hdb | gzip \u003e /root/image.gz ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:2","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"将压缩的备份文件恢复到指定盘 gzip -dc /root/image.gz | dd of=/dev/hdb ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:3","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"备份与恢复MBR 备份磁盘开始的512个字节大小的MBR信息到指定文件： dd if=/dev/hda of=/root/image count=1 bs=512 count=1指仅拷贝一个块；bs=512指块大小为512个字节 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:4","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"增加swap分区文件大小 第一步：创建一个大小为256M的文件： dd if=/dev/zero of=/swapfile bs=1024 count=262144 第二步：把这个文件变成swap文件： mkswap /swapfile 第三步：启用这个swap文件： swapon /swapfile 第四步：编辑/etc/fstab文件，使在每次开机时自动加载swap文件： /swapfile swap swap default 0 0 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:5","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"销毁磁盘数据 dd if=/dev/urandom of=/dev/hda1 注意：利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:6","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"测试硬盘的读写速度 dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file dd if=/root/1Gb.file bs=64k | dd of=/dev/null 通过以上两个命令输出的命令执行时间，可以计算出硬盘的读、写速度 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:7","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"确定硬盘的最佳块大小 dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file 通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:8","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"修复硬盘 dd if=/dev/sda of=/dev/sda # 或 dd if=/dev/hda of=/dev/hda 当硬盘较长时间(一年以上)放置不使用后，磁盘上会产生magnetic flux point，当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数 据起死回生。并且这个过程是安全、高效的 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:9","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"利用netcat远程备份 dd if=/dev/hda bs=16065b | netcat \u003c targethost-IP \u003e 1234 在源主机上执行此命令备份/dev/hda netcat -l -p 1234 | dd of=/dev/hdc bs=16065b 在目的主机上执行此命令来接收数据并写入/dev/hdc netcat -l -p 1234 | bzip2 \u003e partition.img netcat -l -p 1234 | gzip \u003e partition.img 以上两条指令是目的主机指令的变化分别采用bzip2、gzip对数据进行压缩，并将备份文件保存在当前目录 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:4:10","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"另附 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:0","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"/dev/null 和/dev/zero的区别 /dev/null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着。它是空设备，也称为位桶（bit bucket）。任何写入它的输出都会被抛弃。如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶 /dev/zero，是一个输入设备，你可你用它来初始化文件。该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:1","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["linux"],"content":"使用/dev/null 把/dev/null看作\"黑洞\"， 它等价于一个只写文件，所有写入它的内容都会永远丢失.，而尝试从它那儿读取内容则什么也读不到。然而， /dev/null对命令行和脚本都非常的有用 禁止标准输出 cat $filename \u003e/dev/null 禁止标准错误 #rm $badname 2\u003e/dev/null 禁止标准输出和标准错误的输出 cat $filename 2\u003e/dev/null \u003e/dev/null cat $filename \u0026\u003e/dev/null 自动清空日志文件的内容 cat /dev/null \u003e /var/log/messages # : \u003e /var/log/messages 有同样的效果， 但不会产生新的进程.（因为:是内建的） 隐藏cookie而不再使用 if [ -f ~/.netscape/cookies ] # 如果存在则删除. then rm -f ~/.netscape/cookies fi ln -s /dev/null ~/.netscape/cookies 现在所有的cookies都会丢入黑洞而不会保存在磁盘上了 使用/dev/zero 像/dev/null一样， /dev/zero也是一个伪文件， 但它实际上产生连续不断的null的流（二进制的零流，而不是ASCII型的）。 写入它的输出会丢失不见， 而从/dev/zero读出一连串的null也比较困难， 虽然这也能通过od或一个十六进制编辑器来做到。 /dev/zero主要的用处是用来创建一个指定长度用于初始化的空文件，就像临时交换文件。 ","date":"2022-03-18","objectID":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/:5:2","tags":["linux","shell","dd"],"title":"Linux 命令 —— dd","uri":"/2022/03/0003-%E5%91%BD%E4%BB%A4-dd/"},{"categories":["system"],"content":"前言 致力于传统操作系统基本概念、基本技术、基本方法的阐述 把操作系统成熟的基本原理与当代具有代表性的具体实例紧密地结合起来 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:1:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"涉及内容 操作系统概论 介绍操作系统的基本概念、多道程序设计技术、操作系统的形成和发展，操作系统的分类；操作系统的服务、操作系统的功能、操作系统的接口；操作系统的结构 处理机管理 从处理器和中断技术开始，介绍了中断的概念、分类、处理、优先级和多重中断。接着，引入进程和线程的概念，介绍进程管理的实现模型、线程不同级别的实现方法，介绍处理机调度的三个层次，着重讨论了各种单处理机调度算法，也涉及到多处理机调度算法和实时调度算法 并发进程 介绍进程的顺序性和并发性，进程的协作和竞争，以进程交互、进程控制、进程通信和进程死锁问题为重点，讨论并发程序设计有关技术和各种进程互斥、同步、通信机制和工具 存储管理 讨论存储管理的基本功能、各种传统存储管理技术、虚拟存储管理技术和最新的存储管理技术，如多级页表、反置页表等 设备管理 讨论 I/O 硬件原理、I/O 控制方式、I/O 软件原理、I/O 缓冲技术，着重介绍磁盘驱动调度技术、RAID 技术以及设备分配/去配和虚拟设备技术。也介绍了具有通道的I/O系统管理 文件管理 讨论文件概念、文件目录、文件逻辑结构、文件物理结构、文件的保护和保密、文件存储空间管理以及文件的操作和使用原理。也讨论了文件系统的新概念：内存映射文件和虚拟文件系统。 操作系统安全性 讨论操作系统安全威胁和类型；操作系统保护的层次及保护的基本机制、策略和模型，其中着重讨论了身份认证机制、授权机制、加密机制和审计机制 网络和分布式操作系统 简要介绍网络和分布式操作系统的基本概念和技术，包括网络和数据通信基础、网络体系结构、网络操作系统；分布式进程通信、分布式资源管理、分布式进程同步、分布式文件系统和进程迁移等 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:1:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统概论 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统定义 操作系统是管理系统资源、控制程序执行、改善人机界面、提供各种服务，合理组织计算机工作流程和为用户有效使用计算机提供良好运行环境的一种系统软件。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"配置操作系统的主要目标 方便用户使用 OS 通过提供用户与计算机之间的友善接口来方便用户使用 扩大机器功能 OS 通过扩充改造硬件设施和提供新的服务来扩大机器功能 管理系统资源 OS 有效管理好系统中所有硬件软件资源，使之得到充分利用 提高系统效率 OS 合理组织好计算机的工作流程，以改进系统性能和提高系统效率 构筑开放环境 OS 遵循有关国际标准来设计和构造，以构筑出一个开放环境。含义主要是指：遵循有关国际标准（如开放的通信标准、开放的用户接口标准、开放的线程库标准等）；支持体系结构的可伸缩性和可扩展性；支持应用程序在不同平台上的可移植性和可互操作性 计算机系统包括硬件和软件两个组成部分。硬件是所有软件运行的物质基础，软件能充分发挥硬件潜能和扩充硬件功能，完成各种系统及应用任务，两者互相促进、相辅相成、缺一不可。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统的作用和功能 操作系统是用户与计算机硬件之间的接口 操作系统是计算机系统的资源管理者 处理器管理 处理器管理的第一项工作是处理中断事件。硬件只能发现中断事件，捕捉它并产生中断信号，但不能进行处理，配置了操作系统，就能对中断事件进行处理 处理器管理的第二项工作是处理器调度。处理器是计算机系统中一种稀有和宝贵的资源，应该最大限度地提高处理器的利用率。为了提高处理器的利用率，操作系统采用了多道程序设计技术。在多道程序或多用户的情况下，组织多个作业或任务执行时，就要解决处理器的调度、分配和回收等问题。为了实现处理器管理的功能，描述多道程序的并发执行，操作系统引入了进程的概念，处理器的分配和执行都是以进程为基本单位；随着并行处理技术的发展，为了进一步提高系统并行性，使并发执行单位的粒度变细，并发执行的代价降低，操作系统又引入了线程的概念。对处理器的管理和调度最终归结为对进程和线程的管理和调度，包括：（1）进程控制和管理；（2）进程同步和互斥；（3）进程通信；（4）进程死锁；（5）线程控制和管理；（6）处理器调度，又分高级调度，中级调度和低级调度。 正是由于操作系统对处理器的管理策略不同，其提供的作业处理方式也就不同，例如，批处理方式、分时处理方式、实时处理方式等等。从而，呈现在用户面前，成为具有不同处理方式和不同特点的操作系统。 存储管理 存储管理的主要任务是管理存储器资源，为多道程序运行提供有力的支撑，便于用户使用存储资源，提高存储空间的利用率。存储管理的主要功能包括： 存储分配。存储管理将根据用户程序的需要分配给它存储器资源，这是多道程序能并发执行的首要条件，当然程序运行结束时，还需回收存储资源。 存储共享。存储管理能让内存储器（又叫主存储器）中的多个用户程序实现存储资源的共享，以提高存储器的利用率。 地址转换与存储保护。存储管理负责把用户的逻辑地址转换成物理地址，同时要保证各个用户程序相互隔离起来互不干扰，更不允许用户程序访问操作系统的程序和数据，从而，保护系统和用户程序存放在存储器中的信息不被破坏。 存储扩充。由于受到处理器寻址能力的限制，一台计算机的物理内存容量总是有限的，难以满足用户大型程序的需求，而外存储器容量大且价格便宜。存储管理还应该能从逻辑上来扩充内存储器，把内存和外存混合起来使用，为用户提供一个比内存实际容量大得多的逻辑编程空间，方便用户的编程和使用。 设备管理 设备管理的主要任务是管理各类外围设备，完成用户提出的I/O请求，加快I/O信息的传送速度，发挥I/O设备的并行性，提高I/O设备的利用率，以及提供每种设备的设备驱动程序和中断处理程序，为用户隐蔽硬件细节，提供方便简单的设备使用方法。为实现这些任务，设备管理应该具有以下功能： 提供外围设备的控制与处理 提供缓冲区的管理 提供设备独立性 外围设备的分配和去配 实现共享型外围设备的驱动调度 实现虚拟设备 文件管理 文件管理则是针对系统中的信息资源的。在现代计算机中，通常把程序和数据以文件形式存储在外存储器（又叫辅存储器）上，供用户使用，这样，外存储器上保存了大量文件。 文件管理，它的主要任务是对用户文件和系统文件进行有效管理，实现按名存取；实现文件的共享、保护和保密，保证文件的安全性；并提供给用户一整套能方便使用文件的操作和命令。 具体来说，文件管理要完成以下任务： 提供文件的逻辑组织方法 提供文件的物理组织方法 提供文件的存取方法 提供文件的使用方法 实现文件的目录管理 实现文件的共享和存取控制 实现文件的存储空间管理 网络与通信管理 计算机网络源于计算机与通信技术的结合，联网操作系统至少应具有以下管理功能： 网上资源管理功能。计算机网络的主要目的之一是共享资源，网络操作系统应实现网上资源的共享，管理用户应用程序对资源的访问，保证信息资源的安全性和完整性。 数据通信管理功能。计算机联网后，结点之间可以互相传送数据，进行通信，通过通信软件，按照通信协议的规定，完成网络上计算机之间的信息传送。 网络管理功能。包括故障管理、安全管理、性能管理、记帐管理和配置管理等。 用户接口 为了使用户能灵活、方便地使用计算机和系统功能，操作系统还提供了一组友好的使用其功能的手段称用户接口，它包括两大类：程序接口和操作接口。用户通过这些接口能方便地调用操作系统功能，有效地组织作业及其工作和处理流程，并使整个系统能高效地运行。 操作系统的主要特性 并发性 并发性是指两个或两个以上的事件或活动在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在若干个运行着的程序，因此，它应该具有处理和调度多个程序同时执行的能力。 发挥并发性能够消除计算机系统中部件和部件之间的相互等待，有效地改善系统资源的利用率，改进系统的吞吐率，提高系统效率。 并发性虽然能有效改善系统资源的利用率，但却会引发一系列的问题，使操作系统的设计和实现变得复杂化。如：进程切换、进程调度、进程隔离保护、进程协作 在多处理器系统中，程序的并发性不仅体现在宏观上，而且体现在微观上，这称为并行的。并行性是指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同 CPU 上同时执行。而在分布式系统中，多台计算机的并存使程序的并发性得到了更充分的发挥，因为，同一时刻每台计算机上都可以有程序在执行。可见并行的事件或活动一定是并发的，但反之并发的事件或活动未必是并行的，并行性是并发性的特例，而并发性是并行性的扩展。由于并发技术的本质思想是：当一个程序发生事件（如等待 I/O）时出让其占用的 CPU 而由另一个程序运行，据此不难看出，实现并发技术的关键之一是如何对系统内的多个运行程序（进程）进行切换的技术。 共享性 共享指计算机系统中的资源（包括硬件资源和信息资源）可被多个并发执行的用户程序和系统程序共同使用，而不是被其中某一个程序所独占。 资源共享的方式可以分成两种： 互斥访问 系统中的某些资源如打印机、磁带机、卡片机，虽然它们可提供给多个程序使用，但在同一时间段内却只允许一个程序访问这些资源，即要求互相排斥地使用这些资源 同时访问 允许同一时间内多个程序对它们进行访问，这里“同时”是宏观上的说法，从微观上看多个程序访问资源仍然是交错的，只是这种交错访问的顺序对访问的结果没有影响罢了。典型的可供多个程序同时访问的资源是磁盘，各种可重入程序也可被同时访问 与共享性有关的问题是资源分配、信息保护、存取控制等，必须要妥善解决好这些问题。 共享性和并发性是操作系统两个最基本的特性，它们互为依存。一方面，资源的共享是因为程序的并发执行而引起的，若系统不允许程序并发执行，自然也就不存在资源共享问题。另一方面，若系统不能对资源共享实施有效管理，必然会影响到程序的并发执行，甚至程序无法并发执行，操作系统也就失去了并发性，导致整个系统效率低下。 异步性 在多道程序环境中，允许多个进程并发执行，由于资源有限而进程众多，多数情况下，进程的执行不是一贯到底，而是“走走停停”。 虚拟性 虚拟性是指操作系统中的一种管理技术，它是把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。显然，前者是实际存在的而后者是虚构假想的，采用虚拟技术的目的是为用户提供易于使用、方便高效的操作环境。比如：1个 CPU 被虚拟成两个、1台机器可以虚拟出多台的硬件 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:2:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"操作系统的形成和发展 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"人工操作阶段 初始操作系统尚未出现，由程序员采用手工方式直接控制和使用计算机硬件，程序员使用机器语言编程，并将事先准备好的程序和数据穿孔在纸带或卡片上，从纸带或卡片输入机将程序和数据输入计算机。然后，启动计算机运行程序，程序员可以通过控制台上的按钮、开关和氖灯来操纵和控制程序，运行完毕，取走计算输出的结果，才轮到下一个用户上机。 后来，汇编语言产生了，在汇编系统中，数字操作码被记忆码代替，程序按固定格式的汇编语言书写。系统程序员预先编制一个汇编程序，它把用汇编语言书写的“源程序”解释成计算机能直接执行的机器语言格式的目标程序。随后，一些高级程序设计语言相继出现进一步方便了编程。 执行时需要把汇编程序或编译系统以及源程序和数据，都穿在卡片或纸带上，然后，再装入和执行。 其大致过程为： 人工把源程序用穿孔机穿在卡片或纸带上 将准备好的汇编程序或编译系统装入计算机 汇编程序或编译系统读入人工装在输入机上的穿孔卡片或穿孔带上的源程序 执行汇编过程或编译过程，产生目标程序，并输出到目标卡片迭或纸带 通过引导程序把装在输入机上的目标程序读入计算机 执行目标程序，从输入机上读入人工装好的数据卡片或数据带上的数据 产生计算结果，把执行结果从打印机上或卡片机上输出 上述方式比直接用机器语言前进了一步，程序易于编制和读取，汇编程序或编译系统可执行存储、分配等辅助工作，从而，在一定程度上减轻了用户的负担。 人工操作方式存在严重缺点： 用户独占资源 人工干预较多 计算时间拉长 这种人工操作方式在慢速的计算机上还能容忍，但是随着计算机速度的提高，其缺点就更加暴露出来了。 此外，随着 CPU 速度迅速提高而 I/O 设备速度却提高不多，导致 CPU 与 I/O 设备之间的速度不匹配，矛盾越来越突出，需要妥善解决这些问题 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"管理程序阶段 早期批处理系统借助于作业控制语言变革了计算机的手工操作方式。用户不再通过开关和按钮来控制计算机的执行，而是通过脱机方式使用计算机，通过作业控制卡来描述对作业的加工和控制步骤，并把作业控制卡连同程序、数据一起提交给计算机的操作员，操作员收集到一批作业后一起把它们放到卡片机上输入计算机。计算机上则运行一个驻留在内存中的执行程序，以对作业进行自动控制和成批处理，自动进行作业转换以减少系统空闲和手工操作时间。其工作流程如下：执行程序将一批作业从纸带或卡片机输入到磁带上，每当一批作业输入完成后，执行程序自动把磁带上的第一个作业装入内存，并把控制权交给作业。当该作业执行完成后，执行程序收回控制权并再调入磁带上的第二个作业到内存执行。计算机在执行程序的控制下就这样连续地一个作业一个作业地执行，直至磁带上的作业全部做完。这种系统能实现作业到作业的自动转换，缩短作业的准备和建立时间，减少人工操作和干预，让计算机尽可能地连续运转。 早期的批处理系统中，一开始作业的输入和输出均是联机的，联机 I/O 的缺点是速度慢， I/O 设备和 CPU 仍然串行工作，CPU 时间浪费很大，为此，在批处理中引进了脱机 I/O 技术。除主机外，另设一台辅机，该机仅与 I/O 设备打交道，不与主机连接。输入设备上的作业通过辅机输到磁带上，这叫脱机输入；主机负责从磁带上把作业读入内存执行，作业完成后，主机负责把结果输出到磁带上，这叫脱机输出；然后，由辅机把磁带上的结果信息在打印机上打印输出。这称作脱机 I/O 技术。 为了发挥批处理系统的性能，缩短作业的准备和建立时间，驻留在内存工作的执行程序的功能得到了很大的扩充，进化到管理程序。FMS 和 IBSYS ）是这类系统的典型实例。 管理程序的内存组织如图所示，它的主要功能小结如下： 管理程序的内存组织 - 自动控制和处理作业流。管理程序把控制权传送给一个作业，当作业运行结束时，它又收回控制权，继续调度下一个作业执行，自动控制和处理作业流，减少了作业的准备和建立时间。作业流的自动控制和处理依靠作业控制语言，因而，促进了作业控制语言的发展。作业控制语言是由一些描述作业控制过程的语句组成的，每个语句附有一行作业或作业步信息编码，并以穿孔卡的形式提供。例如，$\\$JOB$ 卡表示启动一个新作业; $\\$FIN$ 卡表示调用 FORTRAN 编译系统; $\\$ASM$ 卡表示调用汇编程序；$\\$LOAD$ 卡表示调用装配程序；$\\$DATA$ 卡指定数据；$\\$RUN$ 卡执行用户程序；$\\$END$ 卡表示一个作业结束。管理程序通过输入、解释并执行嵌入用户作业的作业控制卡规定的功能，就能自动地处理用户作业流。每个作业完成后，管理程序又自动地从输入机上读取下一个作业运行，直到整批作业处理结束。 - 提供一套操作命令。操作员通过打字机输入命令，管理程序识别并执行命令，这样不仅速度快，操作员还可进行一些复杂的控制。输出信息也可由打字机输出，代替了早期的氖灯显示，易于理解。这种交互方式不仅提高了效率，也便于使用 - 提供设备驱动和 I/O 控制功能。系统提供标准 I/O 程序，用户通过管理程序获得和使用 I/O 设备，减轻了用户驱动物理设备的负担。管理程序还能处理某些特殊设备和设备故障，改进了设备的可靠性和可用性。 - 提供库程序和程序装配功能。库程序包括：汇编程序、FORTRAN 语言编译程序、标准 I/O 程序、标准子程序等。通常，用户程序必须调用库程序才能执行下去，装配工作由管理程序完成。所有程序都按相对地址编址，管理程序把相应库程序和用户程序进行装配，并转换成绝对地址形式的目标程序，以便执行。 - 提供简单的文件管理功能。用户通过输入设备输入程序和数据，为了反复使用，用户希望能把这些信息保存起来，以便随时使用，这就产生了文件系统。从此，用户可按文件名字，而不是信息的物理地址进行存取，方便灵活，安全可靠。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"多道程序设计与操作系统的形成 多道程序设计 在早期的单道批处理系统中，内存中仅有单个作业在运行，致使系统中仍有许多资源空闲，设备利用率低，系统性能较差。 单道算题运行时处理器的使用效率 当 CPU 工作时，外部设备不能工作；而外部设备工作时，CPU 必须等待。 20 世纪 60 年代初，有两项技术取得了突破：中断和通道，这两种技术结合起来为实现 CPU 和 I/O 设备的并行工作提供了基础，这时，多道程序的概念才变成了现实。 多道程序设计是指允许多个程序(作业)同时进入一个计算机系统的内存储器并启动进行交替计算的方法。也就是说，计算机内存中同时存放了多道（二个以上相互独立的）程序，它们均处于开始和结束点之间。从宏观上看是并行的，多道程序都处于运行过程中，但都未运行结束；从微观上看是串行的，各道程序轮流占用 CPU，交替地执行。引入多道程序设计技术的根本目的是提高 CPU 的利用率，充分发挥计算机系统部件的并行性，现代计算机系统都采用了多道程序设计技术。 操作系统的形成 第三代计算机的性能有了更大提高，机器速度更快，内外存容量增大，I/O 设备数量和种类增多，为软件的发展提供了有力支持。如何更好地发挥硬件功效，如何更好地满足各种应用的需要，这些都迫切要求扩充管理程序的功能。 中断技术 和 通道技术 的出现使得硬部件具有了较强的并行工作能力，从理论上来说，实现多道程序系统已无问题。但是，从半自动的管理程序方式过渡到能够自动控制程序执行的操作系统方式，对辅助存储器性能的要求增高。这个阶段虽然有个别的磁带操作系统出现，但操作系统的真正形成还期待着大容量高速辅助存储器的出现。 大约到 60 年代中期以后，随着磁盘的问世，相继出现了多道批处理操作系统和分时操作系统、实时操作系统，到这个时候标志着操作系统正式形成。 计算机配置操作系统后，其资源管理水平和操作自动化程度有了进一步提高，具体表现在： 操作系统实现了计算机操作过程的自动化。批处理方式更为完善和方便，作业控制语言有了进一步发展，为优化调度和管理控制提供了新手段 资源管理水平有了提高，实现了外围设备的联机同时操作, 进一步提高了计算机资源的利用率 提供虚存管理功能，由于多个用户作业同时在内存中运行，在硬件设施的支持下，操作系统为多个用户作业提供了存储分配、共享、保护和扩充的功能，导致操作系统步入实用化 支持分时操作，多个用户通过终端可以同时联机地与一个计算机系统交互 文件管理功能有改进，数据库系统开始出现 多道程序设计趋于完善，采用复杂的调度算法，充分利用各类资源，最大限度地提高计算机系统效率 操作系统的发展和分类 促使操作系统不断发展的主要动力有以下五个方面： 器件快速更新换代：CPU 性能快速提升 计算机体系结构不断发展：硬件的改进促使计算机技术的进步 提高计算机系统资源利用率的需要 让用户使用计算机越来越方便的需要 满足用户的新要求，提供给用户新服务 从操作系统形成以来，按照功能、特点和使用方式的不同，可把操作系统区分为三种基本类型： 批处理操作系统，特征如下： 用户脱机工作 成批处理作业 单/多个程序运行 分时操作系统，特征如下： 同时性。若干个终端用户同时联机使用计算机，分时就是指多个用户分享使用同一台计算机的 CPU 时间 独立性。终端用户彼此独立，互不干扰，每个终端用户感觉上好像他独占了这台计算机 及时性。终端用户的立即型请求（即不要求大量 CPU 时间处理的请求）能在足够快的时间之内得到响应（通常应该为 2 ~ 3 秒钟）。这一特性与计算机 CPU 的处理速度、分时系统中联机终端用户数目和时间片的长短密切相关 交互性。人机交互，联机工作，用户直接控制其程序的运行，便于程序的调试和排错。 分时操作系统和批处理操作系统虽然有共性，它们都基于多道程序设计技术，但存在下列不同点： 追求的目标不同。批处理系统以提高系统资源利用率和作业吞吐率为目标；分时系统则要满足多个联机用户立即型命令的快速响应。 适应的作业不同。批处理适应已经调试好的大型作业；而分时系统适应正在调试的小作业。 资源的利用率不同。批处理操作系统可合理安排不同负载的作业，使各种资源利用率较佳；分时操作系统中，多个终端作业使用相同类型编译系统、运行系统和公共子程序时，系统调用它们的开销较小。 作业控制的方式不同。批处理由用户通过 JCL 的语句书写作业控制流，预先提交，脱机工作；交互型作业，由用户从键盘输入操作命令控制，交互方式，联机工作。 实时操作系统；目前有三种典型的实时系统，过程控制系统、信息查询系统和事务处理系统。 微机操作系统；供个人使用 并行操作系统；计算机的应用经历了从数据处理到信息处理，从信息处理到知识处理，每前进一步都要求增加计算机的处理能力。 网络操作系统；计算机网络是通过通信设施将地理上分散的并具有自治功能的多个计算机系统互连起来的系统 分布式操作系统 操作系统提供的服务和用户接口 操作系统提供的基本服务 操作系统要为用户程序的执行提供一个良好的运行环境，它要为程序及其用户提供各种服务，当然不同的操作系统提供的服务不完全相同，但有许多共同点。 提供操作系统共性服务为程序员带来了方便，使编程任务变得更加容易，操作系统提供给程序和用户的共性服务大致有： 创建程序。提供各种工具和服务，程序的编辑工具和调试工具，帮助用户编程并生成高质量的源程序等服务 执行程序。将用户程序和数据装入主存，为其运行做好一切准备工作并启动和执行程序。当程序编译或运行出现异常时，应能报告发生的情况，终止程序执行或进行适当处理 数据I/O 信息存取。文件系统让用户按文件名来建立、读写、修改以及删除文件，使用方便，安全可靠。当涉及多用户访问或共享文件时，操作系统将提供信息保护机制 通信服务。在许多情况下，一个进程要与另外的进程交换信息，这种通信一般分为两种情况，一是在同一台计算机上执行的进程之间通信；二是在被网络连接在一起的不同计算机上执行的进程之间通信 错误检测和处理。操作系统能捕捉和处理各种硬件或软件造成的差错或异常，并让这些差错或异常造成的影响缩小在最小范围内，必要时及时报告给操作员或用户。 此外，操作系统除上述提供给用户的服务外，还具有另外一些功能，以保证它自身高效率、高质量地工作，从而，使得多个用户程序能够有效地共享系统资源，提高系统效率，这些功能有： 资源分配 统计 保护 操作系统提供的用户接口 操作系统可以通过程序接口和操作接口两种方式把它的服务和功能提供给用户，反过来也可以这样说，用户可以通过两个接口来调用操作系统提供的服务和功能 用户和操作系统间的两种接口 程序接口与系统调用 系统调用 系统调用的实现要点 系统调用与过程（函数）调用的区别 程序中执行系统调用或过程（函数）调用，虽然都是对某种功能或服务的需求，但两者从调用形式到具体实现都有很大区别。 调用形式不同。过程（函数）使用一般调用指令，其转向地址是固定不变的，包含在跳转语句中，但系统调用中不包含处理程序入口，而仅仅提供功能号，按功能号调用 被调用代码的位置不同。过程（函数）调用是一种静态调用，调用程序和被调用代码在同一程序内，经过连接编辑后作为目标代码的一部份。当过程（函数）升级或修改时，必须重新编译连接。而系统调用是一种动态调用，系统调用的处理代码在调用程序之外（在操作系统中），这样一来，系统调用处理代码升级或修改时，与调用程序无关。而且，调用程序的长度也大大缩短，减少了调用程序占用的存储空间。 提供方式不同。过程（函数）往往由编译系统提供，不同编译系统提供的过程（函数）可以不同；系统调用由操作系统提供，一旦操作系统设计好，系统调用的功能、种类与数量便固定不变了。 调用的实现不同。程序使用一般机器指令（跳转指令）来调用过程（函数），是在用户态运行的；程序执行系统调用，是通过中断机构来实现，需要从用户态转变到核心态，在管理状态执行。因此程序执行系统调用安全性好 Linux 的系统调用 每个系统调用由两部分组成： 核心函数：是实现系统调用功能的（内核）代码，它运行在核心态，数据也存放在内核空间，通常它不能再使用系统调用，也不能使用应用程序可用的库函数。 接口函数：是提供给应用程序的 API，以库函数形式存在，该库中存放了所有系统调用的接口函数的目标代码，用汇编语言书写。其主要功能是把系统调用号、入口参数地址传送给相应的核心函数，并使用户态下运行的应用程序陷入核心态（Linux内核陷入由 0X80 中断实现，调用流程：1. 取系统调用号，检验合法性；2. 建立调用堆栈，保护现场信息；3. 根据系统调用号定位核心函数地址；4. 根据通用寄存器内容，从用户栈中取入口参数；5. 核心函数执行，把结果返回应用程序； 6. 执行退栈操作，判别调度程序 scheduler 是否要被执行）。 操作接口与系统程序 作业控制方式 命令解释程序 系统程序 操作系统的结构设计 操作系统的构件 内核 进程 线程 管程 类程 整体式结构的操作系统 层次式结构的操作系统 虚拟机结构的操作系统 客户/服务器与微内核结构的操作系统 客户/服务器与微内核结构 微内核的设计 操作系统的运行模型 非进程内核模型 OS 功能（函数）在用户进程内执行的模型 OS 功能（函数）作为独立进程执行的模型 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"总结 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:3:4","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"处理器管理 处理器管理是操作系统的重要组成部分，它负责管理、调度和分派计算机系统的重要资源———处理器，并控制程序的执行。由于处理器管理是操作系统中最核心的组成部分，任何程序的执行都必须真正占有处理器，因此，处理器管理直接影响系统的性能。 操作系统的基本任务是对“进程”实施管理，操作系统必须有效控制进程的执行、给进程分配资源、允许进程之间共享和交换信息、保护每个进程在运行期间免受其他进程干扰、控制进程的互斥、同步和通信。为达到这些要求，操作系统的处理器管理必须为每一个进程维护一个数据结构，用以描述该进程的状态和分配到的资源，并允许操作系统行使对进程的控制权。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:4:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中央处理器 计算机系统的核心是中央处理器。如果一个计算机系统只包括一个运算处理器，称之为单处理器系统。如果有多个运算处理器，则称之为多处理器系统。 早期的计算机系统是基于单个处理器的顺序处理机器，每一条指令的执行也是串行的，为提高计算机处理的速度，首先发展起来的是联想存储器系统和流水线系统，前者提出了数据驱动的思想，后者解决了指令并行执行的问题，这两者都是最初计算机并行化发展的例子。 随着硬件技术的进步，并行处理技术得到了迅猛的发展，计算机系统不再局限于单处理器和单数据流，各种各样的并行结构得到了应用。 目前计算机系统可以分作以下四类： 单指令流单数据流（SISD）。一个处理器在一个存储器中的数据上执行单条指令流。 单指令流多数据流（SIMD）。单条指令流控制多个处理单元同时执行，每个处理单元包括处理器和相关的数据存储，一条指令事实上控制了不同的处理器对不同的数据进行了操作。向量机和阵列机是这类计算机系统的代表。 多指令流单数据流（MISD）。一个数据流被传送给一组处理器，通过这一组处理器上的不同指令操作最终得到处理结果 多指令流多数据流（MIMD）。多个处理器对各自不同的数据集同时执行不同的指令流。可以把 MIMD 系统划分为共享内存的紧密耦合 MIMD 系统和内存分布的松散耦合 MIMD 系统两大类。 根据处理器分配策略，紧密耦合 MIMD 系统可以分为主从式系统 MSP 和对称式系统 SMP 两类。 主从式系统的基本思想是：在一个特别的处理器上运行操作系统内核，其他处理器上则运行用户程序和操作系统例行程序，内核负责分配和调度各个处理器，并向其他程序提供各种服务（如输入输出）。这种方式实现简单，但是主处理器的崩溃会导致整个系统的崩溃，并且极可能在主处理器形成性能瓶颈。 在对称式多处理器系统中有两个或两个以上的处理器，操作系统内核可以运行在任意一个处理器上。每个处理器都可以自我调度运行的进程和线程，单个进程的多个线程可在不同处理器上同时运行，服务器进程可以使用多个线程去处理同时来自多个客户的请求，并且操作系统内核也被设计成多进程或多线程，内核的各个部分可以并行执行。 对称多处理器是迄今为止开发出的最为成功的两种并行机之一，有一种 SMP 机最多可支持 64 个处理器，多个处理器之间采用共享主存储器。SMP 机有对称性、单一地址空间、低通信延迟和一致的高速缓存等特点，具有高可靠性、可扩充性、易伸缩性。这一系统中任何处理器都可以访问任何存储单元及 I/O 设备；处理器之间通信代价很低，而并行度较高。 由于共享存储器中只要保存一个操作系统和数据库副本，既有利于动态负载平衡，又有利于保证数据的完整性和一致性。 在松散耦合 MIMD 系统中，每个处理单元都有一个独立的内存储器，各个处理单元之间通过设定的线路或网络通信，多计算机系统和集群系统都是松散耦合 MIMD 系统的例子。 集群系统是迄今为止开发出的另一种最为成功的并行机，它是一组互联的计算机系统。因此也是分布式系统的一种，集群操作系统也是分布式操作系统的一个品种。集群系统运行时构成统一的计算资源，给人以一台机器的感觉。集群系统的配置一般有两种方法，一是各个节点计算机自带磁盘，二是多个节点计算机共享 RAID 磁盘。 在集群系统中，每一台计算机都是一个完整的节点，离开集群后自己可以独立地工作，所以一个节点的失效并不意味着服务的失败，从而使集群系统具备很好的容错性。集群系统还具有很好的可伸缩性，可以用低成本的微机和以太网设备等产品构成。 寄存器 计算机系统的处理器包括一组寄存器，其个数根据机型（处理器型号）的不同而不同，它们构成了一级存储，虽然比主存储器容量要小的多，但是访问速度要快的多。这组寄存器所存储的信息与程序的执行有很大的关系，构成了处理器现场。 不同类型的处理器具有不同的寄存器组成。一般来说，这些寄存器可以分为以下几类： 通用寄存器。可由程序设计者指定许多功能，如存放操作数或用作寻址寄存器。 数据寄存器。用以存放操作数。它们作为内存数据的高速缓存，可以被系统程序和用户程序直接使用并进行计算。 地址寄存器。用于指明内存地址，如索引寄存器、段寄存器（基址/限长）、堆栈指针寄存器等。 I/O 地址寄存器。用于指定 I/O 设备 I/O 缓冲寄存器。用于处理器和 I/O 设备交换数据 控制寄存器。用于存放处理器的控制和状态信息，它至少应该包括程序计数器 PC 和指令寄存器 IR，中断寄存器以及用于存储器和 I/O 模块控制的寄存器。此外还有存放将被访问的存储单元地址的存储器地址寄存器，以及存放从存储器读出或欲写入的数据的存储器数据寄存器。 特权指令与非特权指令 计算机的基本功能是执行程序，而最终被执行的程序是存储在内存中的机器指令。处理器根据程序计数器（PC）内存中取一条指令到指令寄存器（IR）并执行它，PC 将自动地增长或改变为转移地址以指明下一条要执行的指令的入口地址。 每台计算机的机器指令的集合称指令系统，它反映了一台机器的功能和处理能力，可以分为以下五类： 数据处理类指令：用于执行算术和逻辑运算 转移类指令：如无条件转移、条件转移、计数转移等用于改变指令执行序列 数据传送类指令：用于在处理器的寄存器和寄存器、寄存器和存储器单元、存储器单元和存储器之间交换数据 移位与字符串指令，移位分算术、逻辑和循环移位。字符串处理有字符串的传送、比较、查询和转换。 I/O类指令：用于启动外围设备，让主存和外围设备之间交换数据 引入操作系统后，操作系统核心程序可以使用全部机器指令，但用户程序只能使用机器指令系统的一个子集。这是因为，用户程序执行一些有关资源管理的机器指令时很容易导致系统混乱，造成系统或用户信息的破坏。 因此，在多道程序设计环境中，从资源管理和控制程序执行的角度出发，必须把指令系统中的指令分作两类：特权指令和非特权指令。 所谓特权指令是指那些只能提供给操作系统的核心程序使用的指令，如启动输入 % 输出设备、设置时钟、控制中断屏蔽位、清内存、建立存储键，加载 PSW 等。只有操作系统才能执行全部指令（特权指令和非特权指令），如果一般用户执行特权指令，会导致非法执行而产生保护中断，转交给操作系统的“用户非法执行特权指令”的特殊处理程序处理。 处理器状态 那么，中央处理器怎么知道当前是操作系统还是一般用户在其上运行呢？这将依赖于处理器状态的标志。在执行不同程序时，根据执行程序对资源和机器指令的使用权限把处理器设置成不同状态。 处理器状态又称为处理器的运行模式，有些系统把处理器状态划分为核心状态、管理状态和用户状态，而大多数系统把处理器状态简单划分为管理状态（又称特权状态、系统模式、特态或管态）和用户状态（又称目标状态、用户模式、常态或目态）。 当处理器处于管理状态时，程序可以执行全部指令，访问所有资源，并具有改变处理器状态的能力；当处理器处于用户状态时，程序只能执行非特权指令。 Intel 奔腾处理器由四种状态，支持 4 个特权级别，0 级权限最高，3 级权限最低。 0 级为操作系统内核级。处理 I/O 、存储管理和其他关键操作。 1 级为系统调用处理程序级。用户程序可以通过调用这里的过程执行系统调用，但是只有一些特定的和受保护的过程可以被调用。 2 级为共享库过程级。它可以被很多正在运行的程序共享，用户程序可以调用这些过程，读取它们的数据，但是不能修改它们。 3 级为用户程序级。它受到的保护最少。 当然，各个操作系统在实现过程中可以根据具体策略有选择地使用硬件提供的保护级别，如运行在 奔腾 上的 windows 操作系统只使用了 0 级 和 3 级。 下面两类情况会导致从用户态向管理状态转换 程序请求操作系统服务，执行一条系统调用 程序运行时，产生了一个中断事件，运行程序被中断，让中断处理程序工作 这两类情况都是通过中断机构才发生的，可以说中断是目态到管态转换的惟一途径。当系统中断响应交换程序状态字时，这个处理中断事件的处理程序的程序状态字的处理器状态位标志一定为“管态”。怎样实现管态到目态的转换呢？每台计算机通常会提供一条特权指令称作加载程序状态字 LPSW (Load PSW)，用来实现操作系统向用户程序的转换。 程序状态字寄存器 操作系统通过引入程序状态字 PSW (Program Status Word) 来区别不同的处理器工作状态。 ，程序状态字用来指示处理器状态、控制指令的执行顺序并且保留和指示与运行程序有关的各种信息，其主要作用是方便地实现程序状态的保护和恢复。每个正在执行的程序都有一个与其执行相关的 PSW ，而每个处理器都设置一个程序状态字寄存器。 一个程序占有处理器执行，它的 PSW 将占有程序状态字寄存器。 一般来说，程序状态字寄存器包括以下几类内容： 程序基本状态。包括： 程序计数器：指明下一条执行的指令地址； 条件码：表示指令执行的结果状态； 处理器状态位：指明当前的处理器状态，如目态或管态、运行或等待。 中断码。保存程序执行时当前发生的中断事件。 中断屏蔽位。指明程序执行中发生中断事件时，是否响应出现的中断事件。 由于不同处理器中的控制寄存器组织方式不同，所以在大多数计算机的处理器现场中可能找不到一个称为程序状态字寄存器的具体寄存器，但总是有一组控制与状态寄存器实际上起到这一作用。 在 Intel 奔腾中，程序状态字由标志寄存器 EFLAGS 和指令指针寄存器 EIP 组成，均为 32 位。EFLAGS 的低 16 位称 FLAGS，可当作一个单元来处理。标志可划分为三组：状态标志、控制标志、系统标志。 状态标志：它使得一条指令的执行结果影响后面的指令。算术运算指令使用 OF","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:4:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断技术 现代计算机中都配置了硬件中断装置，中断机制是操作系统的重要组成部分之一。 每当用户程序执行系统调用以求获得系统的服务和帮助、或操作系统管理 I/O 设备和处理形形色色的内部和外部事件时，都需要通过中断机制进行处理。所以，也有人说操作系统是由 “中断驱动” 的。 中断是指程序执行过程中，当发生某个事件时，中止 CPU 上现行程序的运行，引出处理该事件的服务程序执行的过程。 在提供中断装置的计算机系统中，在每两条指令或某些特殊指令执行期间都检查是否有中断事件发生，若无则立即执行下一条或继续执行，否则响应该事件并转去处理中断事件。 中断这种处理突发事件的能力是由硬件和软件协作完成的。首先，由硬件的中断装置发现产生的中断事件，然后，中断装置中止现行程序的执行，引出处理该事件的程序来处理。 计算机系统不仅可以处理由于硬件或软件错误而产生的事件，而且可以处理某种预见要发生的事件。例如，外围设备工作结束时，也发出中断请求，向系统报告它已完成任务，系统根据具体情况做出相应处理。 引起中断的事件称为中断源。发现中断源并产生中断的硬件称中断装置。在不同的硬件结构中，通常有不同的中断源和不同的中断装置，但它们有一个共性，即当中断事件发生后，中断装置能改变处理器内操作执行的顺序，可见中断是现代操作系统实现并发性的基础之一。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:5:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断源分类 从中断事件的性质和激活的手段来说，可以分成强迫性中断事件和自愿性中断事件两大类。 强迫性中断事件不是正在运行的程序所期待的，而是由于随机发生的某种事故或外部请求信息所引起的。这类中断事件大致有以下几种： 机器故障中断事件。例如电源故障、主存储器出错等 程序性中断事件。例如定点溢出、除数为0、地址越界等。由于这类中断反映程序执行中发现的例外情况，所以又称异常 外部中断事件。例如时钟的定时中断、控制台发控制信息等 输入输出中断事件。例如设备出错、传输结束等 自愿性中断事件是正在运行的程序所期待的事件。这种事件是由于执行了一条访管指令而引起的，它表示正在运行的程序对操作系统有某种需求，一旦机器执行到一条访管指令时，便自愿停止现行程序的执行而转入访管中断处理程序处理。例如，要求操作系统协助启动外围设备工作。 两类中断事件的响应过程略有不同，详见图： 两类中断事件 还可以按照中断信号的来源，把中断分为外中断和内中断两类： 外中断。一般又称中断，是指来自处理器和主存储器之外的中断，包括电源故障中断、时钟中断、控制台中断、它机中断和 I/O 中断等。每个不同的中断具有不同的中断优先级，在处理高一级中断时，往往会屏蔽部分或全部低级中断。 内中断。是指来自处理器和主存内部的中断，一般又称异常，包括通路校验错、主存奇偶错、非法操作码、地址越界、页面失效、调试指令、访管中断、算术操作溢出等各种程序性中断。其中访管中断是由机器指令提供的特殊指令，该指令执行时将会引起内中断。异常是不能被屏蔽的，一旦出现应立即响应并加以处理。 中断和异常的区别如下： 中断：中断是由与现行指令无关的中断信号触发的，所以它是异步的，而且中断的发生与 CPU 处在用户模式或内核模式无关，通常在两条机器指令之间才可以响应中断，一般来说，中断处理程序提供的服务不是为当前进程所需要的，如时钟中断、硬盘读写服务请求中断 异常：异常则是由处理器正在执行现行指令而引起的。因而一条指令执行期间允许响应陷入。通常，异常处理程序提供的服务是为当前进程所用的。异常包括很多方面，有出错，也有陷入。出错和陷入的主要一点区别是：它们发生时保存的返回指令地址不同，出错保存指向触发异常的那条指令，而陷入保存指向触发异常的那条指令的下一条指令。因此，当从异常返回时，出错会重新执行那条指令，而陷入就不会重新执行那条指令。 上述的内中断与外中断（中断和异常）要通过硬件设施来产生中断请求，可以看作硬中断。与其相对应的不必由硬件发信号而能引发的一种中断称为软中断，软中断是利用硬件中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。它通常是由内核或进程对某个进程发出的中断信号，可以看作内核与进程或进程与进程之间用来模拟硬中断的一种信号通信方式。 软中断和硬中断两者的共同点是：当中断源产生中断请求或发出软中断信号后，CPU 或者接收进程在适当的时机自动进行中断处理或完成软中断信号所对应的功能。这里所说适当时机表示接收的硬中断会及时获得中断处理程序的处理，但接收软中断信号的进程不一定正好在接到此信号时占有处理器，而相应的软中断信号处理必需等到该接收进程获得处理器后才能进行，通常会有一定时间的延迟。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:0","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断装置 发现中断源并产生中断的硬件称中断装置，这些硬件包括中断逻辑线路和中断寄存器。 迄今为止，所有的计算机系统都采用硬件和软件（硬件中断装置和软件中断处理程序）结合的方法实现中断处理。 一般来说，硬件中断装置主要做以下三件事： 发现中断源，响应中断请求。当发现多个中断源时，它将根据规定的优先级，先后发出中断请求。 保护现场。将运行程序中断点在处理器中某些寄存器内的现场信息（又称运行程序的执行上下文）存放于内存储器。使得中断处理程序运行时，不会破坏被中断程序的有用信息，以便在中断处理结束后能够返回被中断程序继续运行。 启动处理中断事件的中断处理程序，处理器状态已从目态被切换到管态。 中断来源于正在执行的程序以及计算机系统的各个部件，甚至计算机的外部环境。当一个具体的中断事件发生时，计算机的硬件中断装置必须把它记录下来。中断寄存器是用来记录中断事件的寄存器，中断寄存器的内容称中断字，中断字的每一位对应一个中断事件。每当一条机器指令执行结束的时刻，中断控制部件扫描中断字，查看是否有中断事件发生，若是则处理器便响应这个中断请求。 当中断发生后，中断字的相应位会被置位。由于同一时刻可能有多个中断事件发生，中断装置将根据中断屏蔽要求和中断优先级选取一个，然后把中断寄存器的内容送入程序状态字寄存器的中断码字段，且把中断寄存器的相应位清“0”当处理中断事件的程序执行时就可以读出中断信息进行分析，从而知道发生了什么中断事件。 紧接着中断装置进行必要的保护现场工作。此时并不一定要将处理器中所有寄存器中的信息全部存于（写回）存储器中，但是，对程序状态字寄存器中的那些信息一定要保护起来。最后，将中断处理程序的程序状态字送入现行程序状态字寄存器，这就引出了相应的中断事件处理程序。 IBM中大型机中断响应过程 如果把被中断的程序的程序状态字称为旧程序状态字，而把中断处理程序的程序状态字称为新程序状态字的话，如何来实现新旧程序状态字的交换呢？通常，系统为每一种中断都开辟了主存的固定单元存放新的和旧的程序状态字。 下图是 IBM 中大型机中断响应过程，主存中开辟了专用的双字单元（用16进制标出），用于存放各类中断的旧的和新的 PSW（分别为旧的和新的外中断、访管中断、程序中断、机器故障中断和 I/O 中断），CPU 中还有硬件程序状态字寄存器保存运行程序的现行 PSW。 IBM PC 中断的响应过程 当响应中断时，由硬件执行 1 把中断码装配到现行 PSW 中，然后，执行 2 把现行 PSW 保存到中断类相应的旧 PSW 单元；同时，执行 3 把中断类相应的新 PSW 加载到现行 PSW ，这就引出了相应中断类的中断处理程序。中断事件处理结束后，如果执行 4 便可从断点返回继续执行被中断的程序。 在 IBM PC 机上，为了方便地找到中断处理程序，通常在计算机内存的低地址处开辟了一个称为中断向量表的区域。表中每一项称为一个中断向量，其中存放了一个中断处理程序的入口地址及相关信息，不同中断源需要用不同的中断处理程序处理，也就对应了不同的中断向量。 另外，采用堆栈方式保存被中断程序的状态信息，当发现中断源并响应中断时，中断装置将把现行 PSW 内容压进堆栈，接着再把指令指针 IP 和代码段基地址内容也压进堆栈，这就保存了原运行程序的状态。处理器根据硬件中断装置提供的中断向量号，获得被接受的中断请求的中断向量地址，再按照中断向量地址把中断处理程序的 PSW 送入现行程序状态字寄存器，加载新的程序状态字。从而，就引出了处理特定中断事件的中断处理程序。返回原程序时，只要把栈顶内容弹出送入现行 IP、CS和PSW中。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:1","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断处理程序 处理中断事件的程序称为中断处理程序。它的主要任务是处理中断事件和恢复正常操作。由于不同中断源对应不同中断处理程序，故快速找到中断处理程序的入口地址是一个关键问题。寻找入口地址可用如下办法：在主存储器(常在低地址区)设置一张向量地址表，存储单元的地址对应向量地址，存储单元的内容为入口地址。CPU 响应中断后，根据预先规定的次序找到相应向量地址，便可获得该中断事件处理程序的入口地址。 一个操作系统设计者将根据中断的不同类型和不同的应用环境，来确定不同的处理原则。 具体地讲，一个中断处理程序主要做以下四项工作： 保护未被硬件保护的一些必需的处理状态。例如，将通用寄存器的内容保存到主存储器，从而使中断处理程序在运行中可以使用通用寄存器 识别各个中断源，分析产生中断的原因。 处理发生的中断事件。中断处理程序将根据不同的中断源，进行各种处理操作。有简单的操作，如置一个特征标志；也有相当复杂的操作，如重新启动磁带机倒带并执行重读操作。 恢复正常操作。恢复正常操作一般有几种情况：恢复中断前的程序按断点执行；重新启动一个新的程序或者甚至重新启动操作系统。 ","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:2","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":"中断事件的具体处理方案 机器故障中断事件的处理 一般来说，这种事件是由硬件的故障产生的，排除这种故障必须进行人工干预。中断处理能做的工作一般是保护现场，防止故障蔓延，报告给操作员并提供故障信息以便维修和校正，以及对程序中所造成的破坏进行估价和恢复。下面列举一些硬件失效中断事件的处理办法。 电源故障的处理 当电源发生故障，例如断电时，硬设备能保证继续正常工作一段时间。操作系统利用这段时间可以做以下三项工作： 将处理器中有关寄存器内的信息经主存储器送到磁盘保存起来，以便在故障排除后恢复现场，继续工作。 停止外围设备工作。有些外围设备（例如磁带机）不能立即停止，中断处理程序将把这些正在交换信息又不能立即停止的设备记录下来。 停止处理器工作。一般可以让主机处于停机状态，此时，整个系统既不执行指令又不响应中断。 当故障排除后，操作员可以从一个约定点启动操作系统以恢复工作。恢复程序做的主要工作是： 恢复中断前的有关现场 启动被停止的外围设备继续工作 如果发生故障时有不能立即停止的外围设备正在工作，那么，涉及这些外围设备的程序将被停止执行而等待操作员的干预命令 完成上述各项工作后，系统将选择可以运行的程序继续运行 主存储器故障的处理 主存储器的奇偶校验或海明校验装置发现主存储器读写错误时，就产生这种中断事件。中断处理程序首先停止与出现的中断事件有关的程序的运行。然后向操作员报告出错单元的地址和错误的性质。 程序性中断事件的处理 处理程序性中断事件大体上有两种办法。 对于那些纯属程序错误而又难以克服的事件，例如非法使用特权指令，企图访问一个不允许其使用的主存储器单元等，操作系统只能将出错程序的名字、出错地点和错误性质报告给操作员并请求干预。 对于其他一些程序性中断，例如定点溢出、阶码下溢等，不同的用户往往有不同的处理要求。所以，操作系统可以将这种程序性中断事件转交给用户程序自行处理。 如果用户程序对发生的中断事件没有提出处理办法，那么操作系统将进行标准处理。 用户怎样来编制处理中断事件的程序呢？有些语言提供了称之为 on 语句的调试语句，它的形式如下： on \u003c条件\u003e \u003c中断续元入口\u003e 比如： // 每当发生定点溢出时，转向以 LA 为标号的语句 on fixed overflow go to LA; // 对于发生在不同地方的同一种程序性中断事件允许用户采用不同的处理方法。 // 例如，在执行了上述调试语句后又执行调试语句： on fixed overflow go to LB; // 就表示今后再发生溢出时将转向 LB 而不是转向 LA 去处理了 有了调试语句后，用户用程序设计语言编制程序时，也就可以编写处理程序性中断事件的程序了。编译程序为每个用户设置一张中断续元入口表，且在编译源程序产生目标程序时，把调试语句翻译成一段程序。其功能是：将中断续元入口地址送入中断续元入口表中对应该语句的中断条件的那一栏。中断续元入口表的形式如图: 中断续元入口 对应每一个用户处理的中断事件，表格中有一栏用以填写处理该中断事件的中断续元入口地址。如果用户没有给出处理其中断事件的中断续元时，相应栏的内容为0。当程序运行执行到调试语句时，就将中断续元的入口地址送入相应栏内。 显然，对于同一中断事件，当执行第二次对应该事件的调试语句时，就将第二次规定的中断续元入口地址填入表内相应栏中而冲去了第一次填写的内容。这就是上面所说的，利用对同一条件多次使用调试语句时，可以做到对发生于不同地点的同一种中断事件采用不同的处理方法。 当发生程序中断事件后，操作系统是怎样转交给用户程序去处理的呢？操作系统只要根据中断事件查看表中对应栏，如果对应栏为“0”它表示用户未定义该类中断续元，此时系统将按规定的标准办法进行处理。例如，将程序停止下来，向操作员报告出错位置和性质，或者置之不顾，就好像什么事也没有发生一样。如果对应栏不为“0”，则强迫用户程序转向中断续元去处理。 如果在中断续元的执行中又发生中断事件时，就不能这样简单地处理了。首先，中断续元的嵌套一般应规定重数，在上面的表格中规定嵌套重数为2。表格第一栏的第 0 字节记录了第一次进入中断续元的事件号；第 1 个字节记录了第二次（嵌套）进入中断续元的事件号。其次，中断续元的嵌套不能递归，例如，处理定点溢出的中断续元，在执行时不允许又发生定点溢出程序性中断事件。 下面按步骤小结一下中断续元的处理过程和原则： 编译程序编译到 on 语句时，生成填写相应中断续元入口表的目标代码段； 程序运行执行到 on 语句时，根据中断条件号，将中断续元入口填入相应栏，这是通过执行上述代码段来实现的； 执行同一中断条件号的 on 语句时，中断续元入口被填入同一栏，从而，用户可在他的程序的不同部分对同一中断条件采用不同的处理方法； 每当一个中断条件发生时，检查中断续元入口表相应栏，或转入中断续元处理，或进行操作系统标准处理； 程序性中断处理允许嵌套，应预先规定嵌套重数，但不允许递归。 外部中断事件的处理 时钟定时中断以及来自控制台的信息都属外部中断事件，它们的处理原则如下： 时钟中断事件的处理 时钟是操作系统进行调度工作的重要工具，如让分时进程作时间片轮转、让实时进程定时发出或接收控制信号、系统定时唤醒或阻塞一个进程、对用户进程进行记账。 时钟可以分成绝对时钟和间隔时钟（即闹钟）两种。利用计时器能确保操作系统必要时获得控制权，例如，陷入死循环的进程最终因时间片耗尽会被迫出让处理器。 系统设置一个绝对时钟寄存器，计算机的绝对时钟定时地（例如每 10 ms）把该寄存器的内容加 1。如果开始时这个寄存器的内容为 0，那么，只要操作员告诉系统开机时的年、月、日、时、分、秒，以后就可推算出当前的年、月、日、时、分、秒了。当绝对时钟寄存器记满溢出时，就产生一次绝对时钟中断，操作系统处理这个中断时，只要在主存的固定单元上加 1 就行了。这个固定单元记录了绝对时钟中断的次数，这样就可保证有足够的计时量。计算当前时间时，只要按绝对时钟中断的次数和绝对时钟寄存器的内容推算就可得到。 间隔时钟是定时将一个间隔时钟寄存器的内容减 1，当间隔时钟寄存器的内容为 0 时，就产生一个间隔时钟中断。所以，只要在间隔时钟寄存器中放一个预定的值，那么就可起到闹钟的作用，每当产生一个间隔时钟中断，就意味着预定的时间到了。操作系统经常利用间隔时钟作控制调度。 时钟硬件做的工作仅仅是按已知时间间隔产生中断，其余与时间有关的任务必须由软件来做，不同的操作系统有关时钟的任务不同，但一般包括以下内容： 维护绝对日期和时间 防止进程的运行时间超出其允许值，发现陷入死循环的进程 对使用 CPU 的用户进程记账 处理进程的间隔时钟（闹钟) 对系统的功能或部件提供监视定时器 在 Intel x86/奔腾 微机中，Linux利用 CMOS 中记录的时间作为系统启动时的基准时间，在系统运行时，利用时钟滴答来维护系统的时间。Linux 使用一个全局变量称 jiffies(瞬时)作为所有系统时间的测量基准，系统启动时，CMOS 中记录的时间转化为从 1970年1月1日0时0分0秒(UNIX纪元)算起的 jiffies 值(累积秒数)。操作系统中需要有定时服务的机制，以实现准时调度任务或处理与时间相关的工作，这些都是通过定时器机制来实现的。 Linux定时器机制 Linux 中存在两种类型的系统定时器，这两种定时器都具有对应的处理例程，必须在到达给定的系统时间时被进程调用，但实现方法有些不同。第一类是老的定时器机制，有一个 CA 个指针的数组定义的定时器。每个指针可指向一个 timer-struct 结构，而 timer-active 是活动定时器的掩码，数组元素是静态定义的，在系统初始化时入口被加到该数组中。第二类是新的定时器机制，突破了 32 个定时器的限制，使用一个 timer-list 数据结构的链表，按定时器到期时间的升序排列。两类定时器中 expires 给出该定时器被激活的时间，而 *fn() 指出定时器激活后的处理函数。 两类定时器都使用 jiffies 值作为到期比较时间。例如，某个定时器要在 2s 之后到期，则必须将 2s 转换成对应的 jiffies 值，加上当前的系统时间(也是以 jiffies 为单位)后，得到的便是该定时器到期的系统时间 expires。每次系统时钟滴答到来时，定时器 bottom half 处理过程被标记为活动状态，这样当调度程序下次运行时，定时器队列能获得处理。定时器 buttom half 处理过程要处理两种类型的系统定时器。对于老的系统定时器，检查 timer-active 中被置位的位掩码，以便确定活动的定时器。如果一个活动的定时器到期，便调用对应的定时器例程，timer-active 对应位被清除。对于新的系统定时器，检查链表中的 timer-list 数据结构。每个到期的定时器将被从链表中移出，对应的定时器例程被调用。新的定时器机制的优点是能传递参数 data 到定时器例程中。 有了上述定时器，Linux 就可以统计用户的记账信息，它记录进程的创建时间及进程在生命周期占用的 CPU 时间。每个时钟滴答到来时，核心都修改当前进程在内核态和用户态占用的时间，这些时间称为记账信息。对于不同的时间，Linux 运行了不同的间隔定时器，这些间隔定时器的类型有三种： real 这种间隔定时器按实际时间计时，不管进程处在何种模式下运行（包括进程被挂起时），计时总在进行，当定时到达时发送给进程一个 SIGALRM 信号 virtual 这种间隔定时器仅当进程在用户态下执行时才计时，当定时到达时发送","date":"2022-03-17","objectID":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/:6:3","tags":["system","操作系统原理"],"title":"操作系统教程","uri":"/2022/03/0001-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"},{"categories":["linux"],"content":"imx6ull emmc镜像制作 ","date":"2022-03-16","objectID":"/2022/03/0004-imx6ull%E7%83%A7%E5%86%99%E9%95%9C%E5%83%8F/:1:0","tags":["linux","imx6ull"],"title":"Imx6ull烧写镜像","uri":"/2022/03/0004-imx6ull%E7%83%A7%E5%86%99%E9%95%9C%E5%83%8F/"},{"categories":["linux"],"content":"什么是buildroot buildroot 是一个简单、高效、易用的工具，能够利用交叉编译生成嵌入式linux系统 ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:1:0","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"buildroot 项目 ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:2:0","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"拉取buildroot源码 https://github.com/imx6ull-pro/buildroot.git buildroot 配置编译选项 查询可用目标系统 make list-defconfigs 选定目标系统 make imx6ullevk_defconfig 打开配置菜单 make menuconfig # 或 make nconfig 查看帮助 make help ","date":"2022-03-15","objectID":"/2022/03/0002-buildroot/:2:1","tags":["linux","imx6ull","buildroot"],"title":"Buildroot","uri":"/2022/03/0002-buildroot/"},{"categories":["linux"],"content":"gvfs 介绍 gvfs 是 GNOME 用户空间虚拟文件系统的缩写，从 GLib 2.15.1 开始加入系统，主要是对 I/O 的一层抽象。gvfs 提供了一些模块，这些模块由使用 libgio 的 API 应用程序自动使用。也通过 fuse，允许不适用 gio 的应用程序可以访问 gvfs 文件系统。 访问虚拟文件系统的前提是挂载文件系统，gvfs 提供了一个守护进程——gvfsd来协调处理模块，每个模块都与 gvfsd 通过 gio 进行通信信。gvfs带有一些后端，这些后端实现了回收站、sftp、ftp、webdav、以及本地数据相关支持，都是作为 gvfs 功能实现的一部分。 gvfs 还包括用于 gio 实现卷监视器。 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:1:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfs守护进程说明 守护进程 功能 gvfsd 是gvfs主要守护程序。它通过org.gtk.vfs.Daemon名连接到dbus会话总线上，当gvfsd没有启动时候，可以通过gio客户端自动拉起gvfsd守护进程。gvfsd主要任务是充当模块的安装器和跟踪器。在需要的时候，它会产生新的后端，并跟踪它们的生命周期，维护已挂载的列表并创建与它们的直接连接。gvfsd还将启动gvfsd-fuse 并向其提供应在其中安装 fuse 文件系统的安装点 gvfsd-fuse gvfsd-fuse维护FUSE(用户空间的文件系统)挂载，以使gvfs后端可用于 POSIX 应用程序。fuse文件系统的挂载点由 [PATH] 参数提供。其主要由 gvfsd 启动 gvfsd-metadata gvfsd-metadata是一个守护进程，充当内部 gvfs 元数据存储的写入序列化程序。它是在 gio 客户端更改元数据时候自动启动。读取操作直接由客户端 gio 完成，并不需要运行守护程序 gvfs-goa-volume-monitor 支持 GNOME 在线账户 gvfs-gphoto2-volume-monitor 支持图片传输协议，如:gPhoto gvfs-mtp-volume-monitor 支持媒体传输协议 gvfs-udisks2-volume-monitor gvfs-udisks2-volume-monitor负责磁盘、介质、挂载和fstab桌面用户界面中显示的项目。特别的是gnome-shell以及使用 GLib API 的任何其它应用程序都在使用此过程中的信息。 请注意：不要把它与udisks软件包中的udisksd和udisksctl混淆 gvfs-afc-volume-monitor 苹果文件系统 gvfsd-afc 挂载IPhone/Ipod touch音量 gvfsd-afp 苹果文件协议卷 gvfsd-afp-browse 浏览apple归档协议卷 gvfsd-archive 挂载各种格式的归档文件 gvfsd-burn 提供刻录 CD 的位置 gvfsd-cdda 挂载音频 CD gvfsd-computer 提供计算机 computer:/// 支持 gvfsd-dav 挂载 DAV 文件系统 gvfsd-dnssd 浏览域名解析 gvfsd-ftp 挂载 FTP 文件系统 gvfsd-gphoto2 通过PTP挂载，这意味着gvfs通过libgphoto2通过 VFS 将相机上的照片显示给GNOME程序 gvfsd-http 通过 HTTP 挂载 gvfsd-localtest 测试后端 gvfsd-mtp 通过 mtp 挂载 gvfsd-network 提供 network:///支持 gvfsd-nfs 提供 nfs 协议支持 gvfsd-recent 提供最近访问支持 gvfsd-sftp 提供sftp支持 gvfsd-smb 提供samba支持 gvfsd-smb-browse 浏览windows共享文件系统的卷 gvfsd-trash 提供回收站支持 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:1:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd 代码模块功能梳理 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"gvfsd 依赖文件及库分析 # 源码 daemon/main.c daemon/mount.c # 依赖库 gvfsddaemon gvfsd 代码梳理 解析命令行，是否使用 fuse、是否debug、是否仅仅打印版本信息 … 创建gvfs daemon g_vfs_daemon_new (TRUE, \u003creplace\u003e) gvfs_get_socket_dir()创建文件夹 监听 daemon 的 shutdown 信号 session dbus总线上注册，名字为：org.gtk.vfs.Daemon 如果需要 fuse 支持则启动 gvfsd-fuse 进程 session 上 dbus 注册成功就会调用 gboolean mount_init() gvfsd 结束执行 mount_finalize() g_vfs_daemon_new (TRUE, \u003creplace\u003e) g_vfs_daemon_new () 声明与定义位于daemon/gvfsdaemon.[hc]文件里 创建线程: g_thread_pool_new() 初始化互斥锁: g_mutex_init() 挂载数量初始化0、jobs初始化NULL、registered_paths(hash)、client_connections(hash)、session dbus的conn g_dbus_auth_observer_new() allow-mechanism authorize-authenticated-peer gvfs_dbus_daemon_skeleton_new() handle-get-connection handle-cancel handle-list-monitor-implementations gvfs_dbus_mountable_skeleton_new() handle-mount gboolean mount_init () gboolean mount_init ()声明与定义在daemon/mount.[hc]文件里 read_mountable_config () 获取环境变量 GVFS_MOUNTABLE_EXTENSION(默认是.mount文件)、GVFS_MOUNTABLE_DIR 读取 GVFS_MOUNTABLE_DIR 文件名需要有 .mount 后缀，文件夹是：/usr/share/gvfs/mounts/ /sys/fs/cgroup/ 解析 xxx.mount并保存到链表 mountables 全局变量 创建管道 pipe(reload_pipes) (其中 reload_pipes 是全局的static int reload_pipes[2];) 监控管道，当管道有数据读入就会重新执行第一步流程read_mountable_config () 获取SESSION bus 的实例 conn = g_bus_get_sync(SESSION, NULL, NULL) mount_tracker = gvfs_dbus_mount_tracker_skeleton_new () 并分别监听信号(这些信号分别对应相应dbus功能) handle-register-fuse handle-register-mount handle-mount-location handle-lookup-mount handle-lookup-mount-by-fuse-path handle-list-mounts handle-list-mounts2 handle-list-mountable-info handle-list-mount-types handle-unregister-mount g_dbus_interface_skeleton_export(mount_tracker,conn,G_VFS_DBUS_MOUNTTRACKER_PATH,NULL) G_VFS_DBUS_MOUNTTRACKER_PATH 是 /org/gtk/vfs/mounttracker 通过d-feet查看，此dbus提供了一系列接口，主要功能包括：支持的挂载类型、挂载信息、挂载点、通过 fuse 挂载的位置；同时也提供了挂载和卸载信号 gvfs_dbus_mount_tracker_skeleton_new() 一系列dbus对应的操作及一些接口声明 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:2:2","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"udisks2 gvfs-udisks2-monitor 进程负责磁盘、media、挂载点和fstab在桌面环境挂载、访问。尤其是 gnome-shell 和文件管理器程序 (nautilus)以及其它使用 GLib 的 API 程序。 通常，只会显示可挂载文件系统的测盘或媒体，这些媒体在下边统称为 “设备”。 如果设备挂载点在 /media/、$HOME、/run/media/$USER 之外的文件夹，那么设备可能不会显示在用户界面。或者如果设备挂载点在 /media/、$HOME、/run/media/$USER 这些目录之下，但是挂载点是以 . 开头的，那么也不会显示。这需要使用使用挂载选项 x-gvfs-show 来强制显示，当然 x-gvfs-hide 也可以使挂载点隐藏。 设备的名称、图标、符号图标是根据某些特征选择的，比如：设备的文件系统标签、x-gvfs-name=\u003cvalue\u003e、x-gvfs-icon=\u003cvalue\u003e 和 x-gvfs-symbolic-icon=\u003cvalue\u003e 在 /etc/fstab 添加自动挂载点时候，建议用户使用 /dev/disk 层次结构中稳定的符号连接，而不是内核名称 sda、sdb 等 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:0","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"热插拔 通过 eSATA 或 USB 连接的设备在物理机器上是可热插拔的。当物理设备连接到机器上或从机器上移除时候 linux内核 会把通知事件发送到用户空间，系统接受到此类事件并根据其配置对它们进行响应 设备驱动加载后会在 devfs (/dev) 下生成对应的设备节点，如果设备连接后 systemd-udevd 会根据配置对 /dev/ 下的设备节点进行增加 如果是块设备，systemd-udevd 通知 udisksd 和 gvfsd 以及 gvfs-udisks2-volume-monitor ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:1","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"一些 fstab 例子 强制在用户界面隐藏设备 /dev/disk/by-id/ata-HITACHI_HTS723232A7A364_E3834563KRG2HN-part1 /home/davidz/Data auto defaults,x-gvfs-hide 0 0 强制在用户界面显示设备(显示名字为 ‘My Movies’) /dev/disk/by-uuid/4CAE8E5B5AF47502 /Movies auto defaults,x-gvfs-show,x-gvfs-name=My%20Movies 0 0 自定义设备图标 /dev/disk/by-uuid/4CAE8E5B5AF47502 /Movies auto defaults,x-gvfs-show,x-gvfs-name=My%20Movies,x-gvfs-icon=folder-videos,x-gvfs-symbolic-icon=folder-videos-symbolic 0 0 强制在用户空间显示 NFS 挂载点 10.200.0.210:/tank/media /mnt/Filer nfs4 default,users,noauto,x-gvfs-show 0 0 ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:2","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux"],"content":"一些udev例子 不自动挂载金士顿U盘 SUBSYSTEMS==\"usb\", ENV{ID_VENDOR}==\"*Kingston*\", ENV{ID_MODEL}==\"*DataTraveler*\", ENV{UDISKS_AUTO}=\"0\" 自动挂载某设备但是不要求admin权限 ENV{ID_SERIAL}==\"WDC_WD1002FAEX-00Y9A0_WD-WCAW30039835\", ENV{UDISKS_AUTO}=\"1\", ENV{UDISKS_SYSTEM}=\"0\" 给特殊设备特殊名字和图标 ENV{ID_MEDIA_PLAYER}==\"apple-ipod\", ENV{UDISKS_NAME}=\"David's iPod\", ENV{UDISKS_ICON_NAME}=\"multimedia-player-ipod\", ENV{UDISKS_SYMBOLIC_ICON_NAME}=\"multimedia-player-ipod-symbolic\" 确保此特殊设备不出现在用户界面 ENV{ID_SERIAL}==\"HITACHI_HTS723232A7A364_E3834563KRG2HN\", ENV{UDISKS_IGNORE}=\"1\" ","date":"2022-03-14","objectID":"/2022/03/0001-gvfs/:3:3","tags":["linux","gvfs"],"title":"gvfs","uri":"/2022/03/0001-gvfs/"},{"categories":["linux","qemu"],"content":"在Linux宿主机上挂载 qemu 虚拟盘 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:0","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"下载 qemu-nbd 工具 pacman -S qemu 或 apt-get install qemu-utils 或 yum install qemu-img ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:1","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"加载nbd模块并挂载 modprobe nbd max_part=8 qemu-nbd --connect=/dev/nbd0 \u003cxxx.qcow2\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:2","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"开始挂载nbd磁盘到文件系统 mount /dev/nbd0xx \u003c挂载点\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:3","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"卸载nbd qemu-nbd --disconnect /dev/nbd0 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:4","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"将vmware的vmdk虚拟盘转为qemu支持的qcow2虚拟盘 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:0","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"合并vmware虚拟磁盘 如果vmware下虚拟机的磁盘是分块的，比如:xxx-s001.vmdk、xxx-s002.vmdk… 需要先合并为一个vmdk文件 vmware-vdiskmanager.exe -r \u003c虚拟盘的路径\u003e -t 0 \u003c合并后盘的名字\u003e vmware-vdiskmanager.exe 在vmware安装路径下 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:1","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"vmdk转qcow2 在linux下执行(确保执行前安装有qemu环境和工具包) qemu-img convert -f vmdk -O qcow2 \u003cxxx.vmdk\u003e \u003cxxx.qcow2\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:2","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux"],"content":"ARM 简史 ARM公司既不生产芯片也不销售芯片，它只出售芯片技术授权。却做到了在手持设备市场上占有90%以上的份额。 软银在2016年耗资320亿美元拿下ARM，使得本来就大红大紫的ARM公司，再一次窜到了业界人士的面前。ARM这家不生产芯片却也能数钱数到手抽筋的公司到底有着怎样的发展史？ 1978 年诞生 ARM公司既不生产芯片也不销售芯片，它只出售芯片技术授权。却做到了在手持设备市场上占有90%以上的份额。 软银在2016年耗资320亿美元拿下ARM，使得本来就大红大紫的ARM公司，再一次窜到了业界人士的面前。ARM这家不生产芯片却也能数钱数到手抽筋的公司到底有着怎样的发展史？ CPU公司的全称：Cambridge Processor Unit，字面意思是“剑桥处理器单元”。 CPU公司的创始人：奥地利籍物理学博士Hermann Hauser和他的朋友，英国工程师Chris Curry。 不过，CPU公司成立之后，主要从事电子设备设计和制造的业务。他们接到的第一份订单，是制造赌博机的微控制器系统。这个微控制器系统被开发出来后，称之为Acorn System 1。 1979 年公司改名 1979年，这家公司给自己换了个名字——Acorn Computer Ltd。 Acorn是什么意思？橡子。 Acorn Computer Ltd公司的商标里面就有一个橡子。 关于Acorn，还有一个有趣的说法，就是因为他们想在电话黄页里排在Apple（苹果）公司的前面… 在Acorn System 1之后，他们又陆续开发了System 2、3、4，还有面向消费者的盒式计算机 —— Acorn Atom。 1981 年迎来BBC订单 到了1981年，公司迎来了一个难得的机遇 —— 英国广播公司BBC打算在整个英国播放一套提高电脑普及水平的节目，他们希望Acorn能生产一款与之配套的电脑。 这个计划非常宏大，英国政府也参与其中（购机费的一半将由政府资助），电脑一旦采购，将进入英国的每一间教室。 接下这个任务之后，Acorn就开始干了起来。 结果，很快他们就发现，自己产品的硬件设计并不能满足需求。当时，中央处理器的发展潮流，正在从8位变成16位。Acorn并没有合适的芯片可以用。 起初，他们打算使用美国国家半导体和摩托罗拉公司的16位芯片。但是，经过评估后，他们发现了两个缺陷： 芯片的执行速度有点慢，中断的响应时间太长。 售价太贵，一台500英镑的电脑，处理器芯片就占到100英镑。 他们打算去找当时如日中天的英特尔（Intel），希望对方提供一些80286处理器的设计资料和样品。但是，却遭到了拒绝。 备受打击的Acorn公司，一气之下决定自己干，自己造芯片。 当时，Acorn公司的研发人员从美国加州大学伯克利分校找到了一个关于新型处理器的研究——简化指令集，恰好可以满足他们的设计要求。 在此基础上，经过多年的艰苦奋斗，来自剑桥大学的计算机科学家Sophie Wilson和Steve Furber最终完成了微处理器的设计。 对于这块芯片，Acorn给它命名为Acorn RISC Machine。 嗯，这就是大名鼎鼎的“ARM”三个字母的由来。 Acorn是公司名称，Machine是机器，那RISC是什么意思呢？ RISC的全称是\"精简指令集计算机\"（reduced instruction set computer），它支持的指令比较简单，所以功耗小、价格便宜，特别适合移动设备。早期使用ARM芯片的典型设备，就是苹果公司的牛顿PDA。 这里解释一下，到底“简化指令集”有什么意义。 它是相对于“复杂指令集（CISC，complex instruction set computer）”的一个概念。 早期的处理器都是CISC架构（包括英特尔的处理器），随著时间推移，有越来越多的指令集加入。由于当时编译器的技术并不纯熟，程序都会直接以机器码或是组合语言写成，为了减少程序的设计时间，逐渐开发出单一指令，复杂操作的程序代码。设计师只需写下简单的指令，再交给CPU去执行。 但是后来有人发现，整个指令集中，只有约20％的指令常常会被使用到，大约占了整个程序的80％；剩余80％的指令，只占了整个程序的20％。（典型的二八原则） 于是，1979年美国加州大学伯克利分校的David Patterson教授提出了RISC的想法，主张硬件应该专心加速常用的指令，较为复杂的指令则利用常用的指令去组合。 1985年10月，英特尔发布了80386。在80386面前，ARM1就只有被吊打的份了。 intel 80386 32位，27.5万个晶体管，频率为12.5MHz，后提高到33MHz 让ARM直接在性能上和x86系列硬杠，显然是不现实的。ARM有意无意地选择了与Intel不同的设计路线——Intel持续迈向x86高效能设计，ARM则专注于低成本、低功耗的研发方向。 BBC在1981年就提出需求，如果等到1985年ARM1出来，那岂不是黄花菜都凉了？ 所以，在ARM1问世之前，Acorn其实已经提供了解决方案给BBC。 当时，Acorn的电脑，临时采用了MOS 6502处理器（由MOS科技研发的8位微处理器）。 MOS 6502处理器 1982 年推出 BBC Micro计算机 1982 年Acorn计算机公司推出了BBC Micro计算机，这是欧洲第一台畅销的个人计算机。 BBC Micro 1984 BBC Micro 被大量使用 到了 1984 年，大约80%的英国学校都配有这款电脑。Acorn公司彻底在大英帝国老百姓面前刷了一把存在感。 后来，ARM处理器被研发出来之后，用在了BBC Micro的后续型号中。 BBC Micro电脑里面的ARM芯片 1985 年推出 ARM1 芯片 1985 年Acorn与合作伙伴推出了ARM1芯片，以此作为其未来个人计算机的中枢。 在ARM1之后，Acorn陆续推出了好几个系列，例如ARM2，ARM3。 1990 年得到苹果公司投资 1990 年11月27日，Acorn公司正式改组为ARM计算机公司。苹果公司出资150万英镑，芯片厂商VLSI出资25万英镑，Acorn本身则以150万英镑的知识产权和12名工程师入股。 在成立后的那几年，ARM业绩平平，工程师们人心惶惶，害怕随时失业。 在这个情况下，ARM决定改变他们的产品策略——他们不再生产芯片，转而以授权的方式，将芯片设计方案转让给其他公司，即“Partnership”开放模式。 没想到正是这种模式，开创了属于ARM的全新时代。 ARM 32位嵌入式RISC(Reduced lnstruction Set Computer)处理器扩展到世界范围，占据了低功耗、低成本和高性能的嵌入式系统应用领域的领先地位。 ARM所采取的是IP（Intellectual Property，知识产权）授权的商业模式，收取一次性技术授权费用和版税提成。 具体来说，ARM有三种授权方式：处理器、POP以及架构授权。 处理器授权是指授权合作厂商使用ARM设计好的处理器，对方不能改变原有设计，但可以根据自己的需要调整产品的频率、功耗等。 POP（processor optimization pack，处理器优化包）授权是处理器授权的高级形式， ARM出售优化后的处理器给授权合作厂商，方便其在特定工艺下设计、生产出性能有保证的处理器。 架构授权是ARM会授权合作厂商使用自己的架构，方便其根据自己的需要来设计处理器（例如后来高通的Krait架构和苹果的Swift架构，就是在取得ARM的授权后设计完成的）。 所以，授权费和版税就成了ARM的主要收入来源。除此之外，就是软件工具和技术支持服务的收入。 对于半导体公司来说，授权费和版税到底有多少呢？一次性技术授权费用在100万-1000万美元之间，版税提成比例一般在1%-2%之间。 正是ARM的这种授权模式，极大地降低了自身的研发成本和研发风险。它以风险共担、利益共享的模式，形成了一个以ARM为核心的生态圈，使得低成本创新成为可能。 苹果公司投资ARM，是为了保证其Newton手持计算机的芯片供应，这个不切实际的设备以失败而告终。 注意：这里的ARM是公司名称，不是芯片名称。这个ARM的完全拼写也不一样，是Advanced RISC Machines。 前面的芯片名称：Acorn RISC Machine 现在的公司名称：Advanced RISC Machines 1998 年诺基亚基于ARM设计并畅销 1998 年诺基亚基于ARM设计的畅销帮助它成了全世界最大的手机生产商。 1991 年ARM将产品授权给英国GEC Plessey半导体公司 1993 年ARM将产品授权给Cirrus Logic和德州仪器（Texas Instruments，TI） 与德州仪器的合作，给ARM公司带来了重要的突破。而且，也给ARM公司树立了声誉，证实了授权模式的可行性。 此后，越来越多的公司参与到这种授权模式中，与ARM建立了合作关系。其中就包括三星、夏普等公司。 在此基础上，ARM坚定了授权模式的决心，并着手设计更多性价比高的产品。 1993年，苹果公司推出了一款新型掌上电脑产品——Newton。ARM公司开发的ARM6芯片被用于该产品之中。 Apple Newton Message Pad 现在被认为是PDA和智能手机的鼻祖 但是很遗憾，因为Newton技术过于超前，加上一些用户体验上的缺陷，所以未能被市场接受，后来以失败告终。 但ARM积累了经验，继续改良技术。没过多久，ARM迎来了自己的黄金机遇——","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:1:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"硬件相关概念 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"电平 在数字电路中，分为高电平和低电平，分别用1和0表示。一个数字电路的管脚，总是存在一个电平的，要么高要么低，或者说要么1要到0(其实还有一种，高阻) ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:1","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"总线 在嵌入式系统中一定会有一块处理器芯片，此外，还有其它的芯片作为外部设备（后面简称外设），这些芯片与处理器协作实现产品的功能。复杂的产品往往是由大量的芯片组成的。那么不可避免的是我们需要将所有的外设与处理器进行相连，最为简单的是将所有的外设都采用独立（注意是独立）的信号线连接至处理器，这样的好处是容易理解，但问题是：不可行。 因为处理器芯片需要引出太多的线了，从芯片的生产和产品的生产角度来看都不实际。加之，处理器（在此我们假设处理器是单核的，而不是多核的）处理事务在微观上是串行的，也就是说在某一时刻如果要对外设进行读写操作，那只可能是对大量外设中的一个进行，即多个外设不可能在微观上被处理器同时访问。需要注意的是，这里提出了微观这一概念，这是为了区别于宏观。 从宏观上来讲，一个处理器中可以有多个任务同时运行，但这些任务在微观上却是一个一个运行的（后面会用串行来描述这里所说的“一个一个”），多任务的串行运行实现是由操作系统扮演着重要的角色来实现的。回到我们的话题，即然将每个外设采用独立的信号线连到处理器不可行，且处理器在单一时间内只会对一个外设进行访问，那我们能不能采用共享的信号线将所有的芯片连在一起呢？这就是总线概念的由来。 通俗的说，如果我们周围有十个家庭，为了让这十个家庭每两个之间都能往来，我们并不需要为每两个家庭修一条单独（注意是单独）的路（如果这样，要修45条路），而是可以修一条大路，然后，每个家都与大路相连。 对于总线，我们往往说总线是处理器的，而其它的外设是挂在总线上的。那有一个问题，我们每一时间只能访问挂在总线上的一个外设，那如何区分这些外设呢？和我们的路一样，我们需要用地址来区分每一个家庭，在总线上，也是采用地址来进行区分的。这样，总线就根据其功能分为两类了。一类是地址总线，这一总线上的数据只会是从处理器向外设“流”，是单向的。 另一类则是数据总线，用来将数据从处理器传送到外设（从处理器的角度来说是写操作）或者是将数据从外设传送到处理器（从处理器的角度来说是读操作），显然，数据总线是双向的。也就是说，在我们的嵌入式系统中同时存在地址总线和数据总线将所有需要与处理器进行通讯的芯片连在一起的。 总线是有宽度的，正如我们的路分为“三车道”或是“四车道”，我们说32位处理器，是指其数据总线宽度是32位，也就是“有32辆车能同时跑”，显然，宽度越是宽我们的处理器速度就越是快，因为我们从外设芯片存取数据的速度会更快，这就是为什么我们的计算机向64位发展的原因。同样的，地址总线也是有宽度的，对于32位处理器其最大宽度也就是32位。 总线的概念有了，那接下来的一个问题是，即使是每一个外设都有一个地址，那这一地址记在哪里呢？是放在外设芯片上吗？如果这样的话，那就有一个问题，每一类外设的地址必须是不能重叠的，而当一个产品中需要两块一样的芯片的话，两块芯片的地址就无法区分了，看来这样操作存在问题。还有，如果这样的话每一个外设也得与（比如，32根）数据总线完全相连，并监听数据线以了解处理器是不是在“叫”自己，这样很是复杂。 此外，地址也有可能因为外设种类的增多而用光。总的来说地址不能存放在外设芯片，那如何让外设知道，此时它是被处理器招换从而需要进行读写访问的呢？答案就是芯片的片选（CS， chip select）信号，或者又叫使能（ENable）信号。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:2","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"片选(CS或EN) 片选信号对于外设芯片来讲，就是一个（也是一根）通知信号，告诉芯片“嘿，请开门，我要放些东西进来，或是拿些东西走”，这里的东西只能是数据，不可能是玉米棒什么的。那有个问题，这个信号源从哪里来呢？显然，只能从处理器来。那是不是也是像总线那样，每一个芯片都共用一根线连在一起呢？如果这样，可能处理器“一叫开门”所有的芯片都将“门”打开了。如果是处理器写数据，那可能所有的芯片都被写入同样的数据。 而取数据时，每个外设芯片都向外“扔”数据，这一定会造成数据总线冲突，因为有的芯片向总线上“扔”1，有的则“扔”0，这种情况下处理器一定会“发疯”的，因为它不知道应当得到1还是0。 既然这样，显然不能将所有的片选信号连在一起了，只能是各芯片的片选信号独立。前面提到了地址总线，我们是采用一根地址线连一个外设芯片呢？还是采用其它的方法。如果采用一根地址线连一个外设芯片，那可能最多只能挂接32个芯片了，这显然不行。其实，在现实中，是采用32位的数字来表示一个外设芯片的地址的，比如1可以表示芯片A，而6534可以表示另外一个芯片B， 等等。由此看来，理论上我们可以表示2的32次方（4294967296）个设备，之所以说理论上，是因为有的设备要占用大量的地址。即然这样，那还有一个问题，如果将32位的地址总线转换成芯片的一根片选信号呢？这需要引入译码（器）的概念。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:3","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"译码器 译码器将一个数据转换成一根信号线上的信号，比如3/8译码器，可以将一个位宽是3位的数据转换成8根（2的3次方）完全独立的信号线，当向数据侧写入二进制的011时，对应的是8根线的第3根，当输入二进制的111时，对应的是8根线中的最后一根。有了译码器，处理器的地址线就简化了，只要32根地址线加上外面的译码器，就可以访问大量的外设芯片了。外部设备的选择问题，我们已经解决了，现在还得回头看一看数据总线。 3/8译码器 在嵌入式系统中，所有芯片的数据总线可以理解成是直接相连的。之所以用了“可以理解”一词，是因为为了提高总线的负载能力，其中会加入总线驱动器。为了理解，我们看一看我们生活中的自来水，比如，在北京理论上可能所有的水管是连在一起的，但中间可能为了提高水压，存在很多小的水站用来增加供水压力，而不可能全北京所有的自来水自接来自一个水厂。 既然所有的数据总线是连在一起的，那就可能会有问题。当向外部设备写数据时，处理器先向地址总线输送目标外设的地址，地址译码器将其转换成一根信号的片选信号送到了目标外设，目标外设收到这一信号后，将“门”打开。接下来处理器将要传送到外设的数据往数据总线上一放，由于只有目标外设芯片打开了“门”，所以数据只会进入到目标外设，而其它的外设什么也不会收到。 很好！处理器向外写数据应当没有问题，我们接下来看一看读。读的话，由于数据是从外设输送到处理器的，尽管我们采用和写一样的方法打开目标外设的“门”，但此时，其它的外设也在数据总线上，它们有可能处于1也可能处于0，是不是会影响处理器读取目标外设的数据呢？结果当然不会，但我们得引入另一个概念：高阻态。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:4","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"高阻态 很显然，当处理器从目标外设读数据时，我们希望其它没有被选上的芯片的数据总线不会对目标外设所要传送的数据有影响，那怎么办呢？实际上，当芯片没有被选中时，其数据总线都处于高阻态。所谓的高阻态，我们可以理解成这一管脚在外设芯片内部是断开的，如此一来，显然不会对处理器从目标外设读取数据造成任何的影响了。 我们说当一个芯片没有被选中或是没有被使能时，其数据总线一定是处于高阻态的。前面用了“门”的开和关来打比方，那“门”是指什么呢？是指外设的数据总线，片选信号的作用就是控制将外设的数据总线与处理器的数据总线相连或是断开。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:5","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"驱动 总线上的数据是谁放上去的我们就说谁是那一时刻的驱动者。也就是说，当处理器向外设写数据时，它是在驱动数据总线的，而当处理器从目标外设读取数据时，目标外设是在驱动数据总线的。对于地址总线，因为只可能从处理器向目标外设写，所以地址总线永远是由处理器驱动的。当一个芯片没有被选中时，我们说它并不驱动数据总线。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:6","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"三态门 前面我们说到外设芯片的数据总线在没有被选中时其处于高阻态，当被选中时，其电平可能是高（1）或是低（0）。如此一来，我们说外设的数据总线其芯片管脚是属于三态门的，即存在高电平、低电平和高阻态，三个状态。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:7","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"电平特效 前面我们了解了什么是片选信号，也讲到了三态门，需要指出的是片选信号通常不是三态门，其只存在两个状态，即高电平或是低电平。前面我们也说了，片选信号是用来“开门”的，而片选信号又有高和低电平，那到底是高电平表示“开门”呢？还是低电平？对于这一问题，我们称如果一个电平对于一个片选信号表示“开门”那么它就是这一信号的有效电平。 比如，对于一个片选信号，如果低电平表示“开门”，那么我们说这个片选信号是低电平有效的。虽然，在这里我们用片选信号来解释电平的有效性，但是很多信号都存在有效性的问题，比如，后面我们将要谈的读信号和写信号都存在有效性问题。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:8","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"时序 在前面我们说到当处理器要向外设芯片写数据时，需要先将所需访问的外设的地址放在地址总线上，然后，由译码器将地址总线上的数据转换成片选信号，片选信号则使能目标外设芯片，接下来处理器写数据到数据总线上，从而完成一个写操作。显然，在处理器将数据写到数据总线之前地址线上的数据必须一直保留一段时间，否则的话译码器不能长时间的使片选信号有效。 当完成了数据的写操作后，处理器就不需要保证地址总线上的地址有效了。我们可以看出，这一系列的操作都有一定严格的时间顺序的，这称之为时序。时序描述了处理器与外部设备的交互信号 “规程”，大家只有按照这一“规程”来操作，才能保证处理器与外部设备之间能正常的通讯。 这好比，我们的道路上的红绿灯，如果我们行人和车辆不按照其指示来通行的话，就会出现事故。通常，采用时序图来描述芯片之间通讯的信号“规程”。 读时序图 读时序图 从图中我们可以看出ADDRESS是表示地址总线的，DQ是表示数据总线的,CE是片选信号，且是低电平有效，其宽度要保证在进行读操作时总是有效的。学会看时序图对于做嵌入式系统开发非常有帮助，因为我们不可避免的要与芯片打交道。在时序图中，通常会标识很多的时间需求信息。 在写启动代码时需要初始化各地址空间的片选地址寄存器和读写时序，时序的配置依据就是来自于外设芯片的时间需求，这是芯片手册很重要的一部分内容。当一个地址空间中存在多个外设芯片时，我们需要考虑到其中最慢的外设芯片的时间需求，否则的话有的芯片就不能正常工作。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:9","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"读信号 当处理器需要从外设芯片读取信号时，除了需要产生片选信号外，还需要告诉外设芯片这是一个读操作，而不是一个写操作，这是通过读信号来实现的。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:10","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"写信号 前面讲了读信号，我想对于写信号也就不难理解了，这个信号用于告诉外设芯片，这是一个向外设芯片写数据的操作。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:11","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"I/O端口 前面提到了外设（芯片）)，现在是对外设进行分类的时候了。大体上外设分为两类，一类是存储器外设，而另一类是非存储器外设，后者常被称之为I/O设备，这里的I/O是Input/Output的简写，即输入、输出。可见，I/O外设是一个非常宽泛的概念。对于存储器外设，其特点是，它所占用的空间是连续的一片。比如，SDRAM内存就是属于存储器外设，如果其容量是8M字节，那么其占用的地址空间也会是8M的。 与存储器外设所不同的是，I/O外设所点用的地址一般都很少。比如一个I/O外设可能存在多个控制寄存器，这些控制寄存器从处理器来看就是多个I/O端口（地址），向这个地址写数据就是向外设所对应的寄存器写数据，反之，也可以是读。 比如，一个串口芯片可能存在多个寄存器，一个用来查询芯片的状态，一个用来设置芯片的功能，另一个用来读取芯片从串口线所收到的数据，最后，还有一个用来向芯片写数据以向串口线上发送数据。对于这一串口芯片的寄存器，从处理器的角度来看，都是独立的I/O端口。 I/O端口存在读、写性问题，有的端口是只读的，有的端口是只写的，还有的端口是即可读也可写，其读写性是由外设芯片的寄存器所决定的，在芯片的数据手册中能找到。需要指出的是，有些存储器外设也存在I/O端口，以对其进行一定的控制。从I/O端口这一名字来看，对于处理器来说，就是对从外面读入数据或是向外面输出数据的一个接口总称。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:12","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"中断 中断从硬件的角度来看就是一个能产生高、低电平的一根信号线，但理解它需要从处理器的角度出发。我们说过了，处理器从微观上看，所做的工作是按顺序进行的，其对程序的处理只能是一条指令一条指令的执行。如果存在需要对外设芯片进行访问，而有可能从处理器发出读、写命令后，由于外设通常比处理器慢很多，所以外设芯片需要一些时间来准备好所需的数据。 在这种情况下，如果处理器一直等外设芯片的返回数据再执行后续的指令的话，将耗费宝贵的时间，这些时间完全可以用来做其它的工作。别忘了，从宏观上看来处理器常常是多任务的，任务是指操作系统所提供的调度单位。当一个任务因为等待外设芯片的数据而阻塞时，我们可以切换到另外的任务，从而提高处理效率。 这就有一个问题，当处理器去处理另一个任务时，如果外设芯片的数据好了的话，如果告诉处理器呢？对了！就是通过中断信号。中断信号的高、低电平可以用来表示是否有中断需要处理器注意以处理特定的事件（比如，外设数据准备好了的事件）。 由此看来，中断的引入能大大的提高处理器的运用效率。为了使用处理器上的中断，一开始我们需要初始化好处理器的中断控制器，比如安装好所需的中断服务程序或称之为ISR（Interrupt Service Routine），然后，打开中断屏蔽位。中断服务程序中需要做如下的操作： 从外设读入或向外设写数据。读还是写通常需要读取外设的中断状态寄存器来决定。 清除外设的中断信号。我们知道，中断信号是由外设芯片驱动的，为了告诉外设芯片，处理器已经处理完了所需做的工作，那么处理器需要通过一定的方式通知外设芯片。这种方式就是向外设芯片的寄存器中的某一位写入一个数据，比如，可能是写入1表示清中断，也可能是写入0表示清中断，这通常在外设的数据手册中能查到。 当外设收到了处理器的清中断请求后，其就会驱动中断线使其无效。比如，一个外设的中断线是当其为低电平表示有中断，将其从低电平变为高电平就是驱动为无效。 清除处理器的中断信号标识。处理器中往往也会保存外部中断信号是否发生过，当我们处理完了外设芯片的中断时，我们也需要清除处理器上的标识，从而为下一次中断做准备。需要注意的是，清外设的中断必须发生在请处理器中断标识之前！ 中断还存在一个触发方式问题。有两种触发方式 ，一种是电平触发，另一种是沿触发。电平触发是指电平的高低表示外设是否有中断，而沿触发则是能过中断线上的电平的升或降来表示的，显然，存在两种沿触发方式。 一种是中断线从低电平变为高电平，我们称之为上升沿触发，另一处是中断线从高电平转换为低电平，我们称之为下降沿触发。总的来说中断的触发方式有电平触发、上升沿触发和下降沿触发。电平触发方式中处理中中断设置很重要的一个步骤。 ROM ROM(Read Only Memory)和RAM(Random Access Memory)指的都是半导体存储器，ROM在系统停止供电的时候仍然可以保持数据，而RAM通常是在掉电之后就丢失数据，典型的RAM就是计算机的内存。 ROM有很多种，PROM是可编程的ROM，它和EPROM(可擦除可编程ROM)的区别是，PROM是一次性的，也就是软件灌入后，就无法修改了，这是早期的产品，现在已经不再使用，而EPROM是通过紫外光的照射擦出原先的程序的一种通用存储器。另外一种EEPROM是通过电子擦除，价格很高，写入时间很长，写入慢。 举个例子，手机软件一般放在EEPROM中，我们打电话，有些最后拨打的号码，暂时存在SRAM中，不是马上写入通话记录(通话记录保存在EEPROM中)，因为当时有很重要工作(通话)要做，如果写入，漫长的等待用户无法忍受。 RAM RAM有两大类，一种称为静态RAM(Static RAM/SRAM)，SRAM速度非常快，是目前读写最快的存储设备了，它也非常昂贵，所以只在要求很苛刻的地方使用，譬如CPU的一级缓冲，二级缓冲。 另一种称为动态RAM(Dynamic RAM/DRAM)，DRAM保留数据的时间很短，速度也比SRAM慢，不过它还是比任何的ROM都要快，但从价格上来说DRAM相比SRAM要便宜很多，计算机内存就是DRAM的。 DRAM DRAM分为很多种，常见的主要有FPRAM/FastPage、EDORAM、SDRAM、DDR RAM、RDRAM、SGRAM以及WRAM等，这里介绍其中的一种DDR RAM。 DDR RAM DDR RAM(Date-Rate RAM)也称作DDR SDRAM，这种改进型的RAM和SDRAM是基本一样的，不同之处在于它可以在一个时钟读写两次数据，这样就使得数据传输速度加倍了。 这是目前电脑中用得最多的内存，而且它有着成本优势，击败了Intel的另外一种内存标准-Rambus DRAM。在很多高端的显卡上，也配备了高速DDR RAM来提高带宽，这可以大幅度提高3D加速卡的像素渲染能力。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:13","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"内存原理解析 内存是用来存放当前正在使用的(即执行中)的数据和程序，我们平常所提到的计算机的内存指的是动态内存(即DRAM)，动态内存中所谓的“动态”，指的是当我们将数据写入DRAM后，经过一段时间，数据会丢失，因此需要一个额外设电路进行内存刷新操作。 具体的工作过程是这样的：一个DRAM的存储单元存储的是0还是1取决于电容是否有电荷，有电荷代表1，无电荷代表0。但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，这就是数据丢失的原因; 刷新操作定期对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电; 若电量小于1/2，则认为其代表0，并把电容放电，藉此来保持数据的连续性。 NAND Flash和NOR Flash的比较 常用的Flash类型有：NOR Flash和NAND Flash两种。NOR Flash由Intel公司在1988年发明，以替代当时在市场上占据主要地位的EPROM和EEPROM。NANDFlash由Toshiba公司在1989年发明。两者的主要差别如下表所示。 NOR Flash支持XIP，即代码可以直接在NOR Flash上执行，无需拷贝到内存中。这是由于NOR Flash的接口与RAM完全相同，可以随机访问任意地址的数据。在NOR Flash上进行读操作的效率非常高，但是擦除和写操作的效率很低；另外，NOR Flash的容量一般比较小。 NAND Flash进行擦除和写操作的效率更高，并且容量更大。一般而言，NOR Flash用于存储程序，NAND Flash用于存储数据。基于NAND Flash的设备通常也要搭配NOR Flash以存储程序。 Flash存储器件由擦除单元(也称为块)组成，当要写某个块时，需要确保这个块已经被擦除。NOR Flash的块大小范围为64KB～128KB；NAND Flash的块大小范围为8KB～64KB，擦/写一个NOR Flash块需4S，而擦/写一个NAND Flash块仅需2ms。 NOR Flash的块太大，不仅增加了擦写时间，对于给定的写操作，NOR Flash也需要更多的擦除操作——特别是小文件，比如一个文件只有1KB，但是为了保存它却需要擦除大小为64KB～128KB的NOR Flash块。 NOR Flash的接口与RAM完全相同，可以随意访问任意地址的数据。而NAND Flash的接口仅仅包含几个I/O引脚，需要串行地访问。NAND Flash一般以512字节为单位进行读写。这使得NOR Flash适合于运行程序，而NAND Flash更适合于存储数据。 容量相同的情况下，NAND Flash的体积更小，对于空间有严格要求的系统，NAND Flash可以节省更多空间。市场上NOR Flash的容量通常为1~4MB(也有32MB的NOR Flash)，NANDFlash的容量为8~512MB。容量的差别也使得NOR Flash多用于存储程序，NAND Flash多用于存储数据。 对于Flash存储器件的可靠性需要考虑3点：位反转、坏块和可擦除次数。所有Flash器件都遭遇位反转的问题：由于FLASH固有的电器特性，在读写数据过程中，偶然会产生一位或几位数据错误——这种概率很低，而NAND Flash出现的概率远大于NOR Flash。当位反转发生在关键的代码、数据上时，有可能导致系统崩溃。 当仅仅是报告位反转，重新读取即可；如果确实发生了位反转，则必须有相应的错误检测/恢复措施。在NAND Flash上发生位反转的概率更高，推荐使用EDC/ECC进行错误检测和恢复。 NAND Flash上面会有坏块随机分布，在使用前需要将坏块扫描出来，确保不再使用它们，否则会使产品含有严重的故障。NAND Flash每块的可擦除次数通常在100000次左右，是NOR Flash的10倍。另外，因为NAND Flash的块大小通常是NOR Flash的1/8，所以NAND Flash的寿命远远超过NOR Flash。 linux对NOR、NAND Flash的软件支持都很成熟。在NOR Flash上常用jffs2文件系统，而在NAND Flash上常用yaffs文件系统。在更底层，有MTD驱动程序实现对它们的读、写、擦除操作，它也实现了EDC/ECC校验。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:14","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"工具 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"万用表 万用表通常是用来查看电平的高低、电阻的大小等的，是常用且必不可少的工具之一。在嵌入式系统开发中，我们常用的是数字万用表。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:1","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"示波器 在嵌入式系统开发中，我们不可避免的要与外设芯片打交道。调试驱动程序时，除了需要完全看明白芯片的数据手册，且在软件高度的过程中，还需要看我们所期望的信号电平是否发生在芯片上。比如，我们在写驱动程序时，需要通过写I/O端口来对外设芯片进行操作，当写相应的I/O端口时，我们知道所对应芯片的片选信号应当有效，有时，我们需要验证是否按预期发生了，这就需要用到示波器。 一般的示波器是能同时观测两个信号线的信号状态的。示波器都提供一定的功能，比如设置信号扑捉的方式等等。示波器很重要的一个参数据是其采集频率，根据Nyquist采集定理，如果我们想用示波器查看频率是100M赫兹的信号，那么其采样频率必须至少是其两倍，即200M赫兹。有人可能会问：为什么不用万用表来看呢？因为万用表的采集频率很底，无法采集到很快的信号变化。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:2","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"逻辑分析仪 简单的说逻辑分析器就是具有很多信号通道的示波器。通过逻辑分析仪，我们可以看到地址总线和数据总线上的数据。逻辑分析仪都提供一定的编程能力，用于编程什么时候开始对总线上的数据进行采集。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:3","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"环境搭建目标 pc 可以通过 串口 连接到 开发板，并能查看输出日志 pc 可以通过 ssh 连接到 开发板。开发板默认登录用户名: root，无密码 在 pc 上配置好 arm 交叉编译工具链 准备好常用的源码: uboot源码、linux源码、buildroot源码 我使用 manjaro 作为开发环境；使用 imx6ull pro 作为运行/学习环境，开发板下载的工具里没有linux平台的，因此需要从下载资料的 ubuntu 虚拟机里提取。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发板展示 各标号硬件含义 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发板启动方式（上图表号16对应状态） boot sw1(lcd_data5) sw2(lcd_data11) sw3(boot_mode0) sw4(boot_mode1) emmc OFF OFF ON OFF sd ON ON ON OFF usb X X OFF ON 注意：当设为 USB 启动时候，不能插上SD卡、TF卡；上电之后才可以插卡。刚出厂的板子在 emmc 上烧写了系统，开发板启动方式需要设置为 emmc 启动。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"第一次启动开发板 设置开发板的打开方式为 emmc，打开电源开关 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"接串口 下载 linux 串口驱动程序 https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers 并编译之后在源码目录执行insmod ./xxx.ko，插入编译生成的内核模块(xxx.ko文件) 连接开发板电源线并打开开关，插拔 usb 线观察 /dev/ 下设备变化，发现插入 usb 后会多出 ttyUSB0 这一设备 执行 pacman -S minicom 下载 minicom 打开串口 minicom -D /dev/ttyUSB0 然后重启开发板(直接断点和上电)，后续就可以通过 minicom 看到串口日志了（需要开发板默认打开串口输出） ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"ssh 连接到开发板 给开发板联网并重启，在系统选项里设置网络(ip、子网掩码、网关)并用 PC ssh 连接上去 接上串口，用 minicom 来观察日志输出 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:4","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"搭建环境 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"下载开相关源码及工具 百度网盘下载,提取码:root ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"配置 arm gcc 交叉编译环境(使用imx6ull资料配置) 解压缩 ubuntu 的虚拟机文件（如果压缩文件是多个，需要都选中然后解压） 查看解压后的文件有几个 *.vmdk 文件，如果是多个则需要使用 vdiskmanager 合并为一个 使用 qemu-img 把 xxx.vmdk 文件转为 qemu 支持的 qcow2 文件 我的 linux 工作机用 qemu 而不是 vmware 挂载转换后的文件系统 使用mount挂载虚拟硬盘的家目录，大概是 /dev/nb0p4 挂载后可以通过 ls 命令看到book文件夹，这就是家目录，然后把文件 100ask_imx6ull-sdk 复制出来，在这个文件夹的ToolChain目录下有需要的arm编译链，具体目录是 100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot 配置环境变量，修改 ~/.bashrc 添加如下配置: export ARCH=arm export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- PATH=\u003carm交叉编译根目录\u003e/bin:${PATH} export PATH=$(echo ${PATH} | sed 's/:/\\n/g' | sort | uniq | tr -s '\\n' ':' | sed 's/:$//g') 配置好后重新打开终端或执行source ~/.bashrc 之后打开终端，运行 arm-buildroot-linux-gnueabihf-gcc -v，查看是否有如下信息输出(如果没有，重新执行这一步): Using built-in specs. COLLECT_GCC=/data/environment/gcc-arm/bin/arm-buildroot-linux-gnueabihf-gcc.br_real COLLECT_LTO_WRAPPER=/data/environment/gcc-arm/bin/../libexec/gcc/arm-buildroot-linux-gnueabihf/7.5.0/lto-wrapper Target: arm-buildroot-linux-gnueabihf Configured with: ./configure --prefix=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --sysconfdir=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/etc --enable-static --target=arm-buildroot-linux-gnueabihf --with-sysroot=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/arm-buildroot-linux-gnueabihf/sysroot --enable-__cxa_atexit --with-gnu-ld --disable-libssp --disable-multilib --disable-decimal-float --with-gmp=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-mpc=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-mpfr=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-pkgversion='Buildroot 2020.02-gee85cab' --with-bugurl=http://bugs.buildroot.net/ --disable-libquadmath --enable-tls --enable-plugins --enable-lto --enable-threads --with-isl=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host --with-abi=aapcs-linux --with-cpu=cortex-a7 --with-fpu=neon-vfpv4 --with-float=hard --with-mode=arm --enable-languages=c,c++,fortran --with-build-time-tools=/home/book/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/arm-buildroot-linux-gnueabihf/bin --enable-shared --enable-libgomp Thread model: posix gcc version 7.5.0 (Buildroot 2020.02-gee85cab) 上述2、3、4步相关教程可以查看qcow2虚拟分区挂载 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"配置arm gcc交叉编译环境(这个留备后续使用，不需要配置) arm 交叉编译工具下载地址: arm 交叉编译工具下载地址，或者复制到浏览器下载(这个包宿主机是x86，目标代码编译成arm的): https://armkeil.blob.core.windows.net/developer/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-arm-none-linux-gnueabihf.tar.xz 下载并解压之后放置指定目录并改名为 gcc-arm，比如: /data/envrionment/gcc-arm/ 配置环境变量，编辑 ~/.bashrc，在末尾加入如下代码: export ARCH=arm export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- PATH=\u003carm交叉编译根目录\u003e/bin:${PATH} export PATH=$(echo ${PATH} | sed 's/:/\\n/g' | sort | uniq | tr -s '\\n' ':' | sed 's/:$//g') 配置好后重新打开终端或执行source ~/.bashrc 之后打开终端，运行 arm-none-linux-gnueabihf-gcc -v，查看是否有如下信息输出(如果没有，重新执行这一步): Using built-in specs. COLLECT_GCC=arm-none-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER=/data/environment/gcc-arm/bin/../libexec/gcc/arm-none-linux-gnueabihf/11.2.1/lto-wrapper Target: arm-none-linux-gnueabihf Configured with: /data/jenkins/workspace/GNU-toolchain/arm-11/src/gcc/configure --target=arm-none-linux-gnueabihf --prefix= --with-sysroot=/arm-none-linux-gnueabihf/libc --with-build-sysroot=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/install//arm-none-linux-gnueabihf/libc --with-bugurl=https://bugs.linaro.org/ --enable-gnu-indirect-function --enable-shared --disable-libssp --disable-libmudflap --enable-checking=release --enable-languages=c,c++,fortran --with-gmp=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-mpfr=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-mpc=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-isl=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-arch=armv7-a --with-fpu=neon --with-float=hard --with-mode=thumb --with-arch=armv7-a --with-pkgversion='GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)' Thread model: posix Supported LTO compression algorithms: zlib gcc version 11.2.1 20220111 (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 这里需要注意的是，如果下载的 arm 编译工具链与开发板文件系统的编译工具链 gcc 不一致，则会导致在 pc 上用跨平台编译工具链编译出来的程序无法在 arm 开发板上运行。解决办法：1. 重新编译开发板根文件系统、内核并烧写；2. 使用官方提供的交叉编译工具链 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"安装 make 项目管理命令 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:4","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"cortexA7 烧写工具 imx6ull 官方烧写工具是 mfgtools 操作简单，一键烧写整个镜像\u003c用这个就可以\u003e nxp 提供的 uuu (Universal Update Utility) 又名 mfgtools 3.0 这块具体使用后续会有介绍 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:5","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"4. mkimage 工具 这一工具来源于 u-boot，用来给一个 bin 文件添加头部信息，芯片固件需要根据头部信息把 bin 文件放到内存中去执行 执行 pacman -S u-boot 命令后，再次执行 mkimage -h 查看是否正确安装: mkimage: invalid option -- 'h' Error: Invalid option Usage: mkimage -l image -l ==\u003e list image header information mkimage [-x] -A arch -O os -T type -C comp -a addr -e ep -n name -d data_file[:data_file...] image -A ==\u003e set architecture to 'arch' -O ==\u003e set operating system to 'os' -T ==\u003e set image type to 'type' -C ==\u003e set compression type 'comp' -a ==\u003e set load address to 'addr' (hex) -e ==\u003e set entry point to 'ep' (hex) -n ==\u003e set image name to 'name' -d ==\u003e use image data from 'datafile' -x ==\u003e set XIP (execute in place) mkimage [-D dtc_options] [-f fit-image.its|-f auto|-F] [-b \u003cdtb\u003e [-b \u003cdtb\u003e]] [-E] [-B size] [-i \u003cramdisk.cpio.gz\u003e] fit-image \u003cdtb\u003e file is used with -f auto, it may occur multiple times. -D =\u003e set all options for device tree compiler -f =\u003e input filename for FIT source -i =\u003e input filename for ramdisk file -E =\u003e place data outside of the FIT structure -B =\u003e align size in hex for FIT structure and header Signing / verified boot options: [-k keydir] [-K dtb] [ -c \u003ccomment\u003e] [-p addr] [-r] [-N engine] -k =\u003e set directory containing private keys -K =\u003e write public keys to this .dtb file -G =\u003e use this signing key (in lieu of -k) -c =\u003e add comment in signature node -F =\u003e re-sign existing FIT image -p =\u003e place external data at a static position -r =\u003e mark keys used as 'required' in dtb -N =\u003e openssl engine to use for signing mkimage -V ==\u003e print version information and exit Use '-T list' to see a list of available image types ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:6","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"最后来一个例子 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"在开发机上编写一个例子 #include \u003cstdio.h\u003e int main (int argc, char* argv[]) { printf (\"Hello World!\\n\"); return 0; } ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开发机上的Makefile CC = arm-buildroot-linux-gnueabihf-gcc CUR_DIR = $(shell pwd) SRC = $(strip $(subst $(CUR_DIR), ., $(wildcard $(CUR_DIR)/*.c))) TARGET = $(strip $(patsubst %.c, %.run, $(SRC))) all:${TARGET} %.run:%.c ${CC} -o $@ $\u003c clean: rm -f *.run rm -f *.o ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"编译 分别保存上述代码为 hello-world.c、makefile脚本为 Makefile，两个文件放在同级目录，执行 make 会在当前目录下生成 hello-world.run，使用 scp ./hello-world.run root@\u003c开发机ip\u003e:~ 把编译好的二进制文件传输到开发机，最后使用 ssh 登录到开发机上家目录执行 ./hello-world.run 即可看到输出结果。 至此，开发环境和开发板打通。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"01：001-010 当编译发现大量错误的时候，从第一个看起，一个一个的解决，不要急着去看下一个错误，往往后面的错误都是由于前面的错误引起的，第一个解决后很可能都解决了。比如我们可能就写错了一行代码，编译提示几百个错误，你只要把这一行纠正了，其他错误也就没了。 定时器是个好东西，学会好使用它，有时候用QTimer::singleShot单次定时器和QMetaObject::invokeMethod可以解决意想不到的问题。比如在窗体初始化的时候加载一个耗时的操作，很容易卡主界面的显示，要在加载完以后才会显示界面，这就导致了体验很卡不友好的感觉，此时你可以将耗时的加载（有时候这些加载又必须在主线程，比如用QStackWidget堆栈窗体加载一些子窗体），延时或者异步进行加载，这样就会在界面显示后去执行，而不是卡住主界面。 //异步执行load函数 QMetaObject::invokeMethod(this, \"load\", Qt::QueuedConnection); //延时10毫秒执行load函数 QTimer::singleShot(10, this, SLOT(load())); 默认QtCreator是单线程编译，可能设计之初考虑到尽量不过多占用系统资源，而现在的电脑都是多核心的，默认msvc编译器是多线程编译的不需要手动设置，而对于其他编译器，需要手动设置才行。 方法一：在每个项目的构建设置中（可以勾选一个 shadow build 的页面地方）的build步骤，make arguments增加一行 -j16 即可，此设置会保存在pro.user文件中，一旦删除就需要重新设置，不建议此方法； 方法二：在构建套件的环境中增加，工具-\u003e选项-\u003e构建套件(kits)-\u003e选中一个构建套件-\u003eenvironment-\u003e右侧change按钮-\u003e打开的输入框中填入 MAKEFLAGS=-j4 ， 这样就可以不用每次设置多线程编译，只要是应用该构件套件的项目都会加上这个编译参数； 注意：-j后面接的是电脑的核心数，写多了不会有效果，要自己看下电脑的参数，或者填个-j4就行，毕竟现在电脑4核心应该是最基本的； 大概从2019年开始的新版本的QtCreator默认已经会根据电脑的核心自动设置多线程编译，比如识别到你的电脑是16核心的就会默认设置-j16参数进行编译； 如果你想顺利用QtCreator部署安卓程序，首先你要在 Android Studio 里面配置成功，编译一个程序能够在手机上或者模拟器中跑起来，把坑全部趟平。 很多时候找到Qt对应封装的方法后，记得多看看该函数的重载，多个参数的，你会发现不一样的世界，有时候会恍然大悟，原来Qt已经帮我们封装好了，比如QString、QColor的重载参数极其丰富，很多你做梦都想要的功能就在里面。 可以在pro文件中写上版本号、程序图标、产品名称、版权所有、文件说明等信息（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件。对于早期的Qt4版本你可以手动写rc文件实现。 #程序版本 VERSION = 2025.10.01 #程序图标 RC_ICONS = main.ico #产品名称 QMAKE_TARGET_PRODUCT = quc #版权所有 QMAKE_TARGET_COPYRIGHT = feiyangqingyun #文件说明 QMAKE_TARGET_DESCRIPTION = QQ: 517216493 WX: feiyangqingyun 管理员运行程序，限定在MSVC编译器，在项目pro文件中增加如下代码。 QMAKE_LFLAGS += /MANIFESTUAC:\"level='requireAdministrator' uiAccess='false'\" #以管理员运行 QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,\"5.01\" #VS2013 在XP运行 运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上一行CONFIG += console，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，一般没法正常运行的程序都会打印一些提示信息缺啥之类的。 TEMPLATE = app MOC_DIR = temp/moc RCC_DIR = temp/rcc UI_DIR = temp/ui OBJECTS_DIR = temp/obj #就是下面这行用来设置运行文件附带调试输出窗口 CONFIG += console 绘制平铺背景QPainter::drawTiledPixmap，绘制圆角矩形QPainter::drawRoundedRect()，而不是QPainter::drawRoundRect()，这两个函数非常容易搞混。 指定控件移除旧的样式。 //移除原有样式 style()-\u003eunpolish(ui-\u003ebtn); //必须要有下面这行不然还是不会卸载 ui-\u003ebtn-\u003esetStyleSheet(\"\"); //重新设置新的该控件的样式。 style()-\u003epolish(ui-\u003ebtn); ","date":"0001-01-01","objectID":"/1/01/qt/:0:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"02：011-020 获取类的属性和方法 //拿到控件元对象 const QMetaObject *metaObject = widget-\u003emetaObject(); //所有属性的数量 int propertyCount = metaObject-\u003epropertyCount(); //propertyOffset是自定义的属性开始的位置 int propertyOffset = metaObject-\u003epropertyOffset(); //循环取出控件的自定义属性, int i = 0 表示所有属性 for (int i = propertyOffset; i \u003c propertyCount; ++i) { QMetaProperty metaProperty = metaObject-\u003eproperty(i); const char *name = metaProperty.name(); const char *type = metaProperty.typeName(); QVariant value = widget-\u003eproperty(name); qDebug() \u003c\u003c name \u003c\u003c type \u003c\u003c value; } //所有方法的数量 int methodCount = metaObject-\u003emethodCount(); //methodOffset是自定义的方法开始的位置 int methodOffset = metaObject-\u003emethodOffset(); //循环取出控件的自定义方法, int i = 0 表示所有方法 for (int i = methodOffset; i \u003c methodCount; ++i) { QMetaMethod metaMethod = metaObject-\u003emethod(i); const char *name = metaMethod.name(); const char *type = metaMethod.typeName(); qDebug() \u003c\u003c name \u003c\u003c type; } Qt内置图标封装在QStyle中，大概七十多个图标，可以直接拿来用。 SP_TitleBarMenuButton, SP_TitleBarMinButton, SP_TitleBarMaxButton, SP_TitleBarCloseButton, SP_MessageBoxInformation, SP_MessageBoxWarning, SP_MessageBoxCritical, SP_MessageBoxQuestion, ... //下面这样取出来使用就行 QPixmap pixmap = this-\u003estyle()-\u003estandardPixmap(QStyle::SP_TitleBarMenuButton); ui-\u003elabel-\u003esetPixmap(pixmap); 根据操作系统位数判断加载 win32 { contains(DEFINES, WIN64) { DESTDIR = $$PWD/../bin64 } else { DESTDIR = $$PWD/../bin32 } } Qt5增强了很多安全性验证，如果出现setGeometry: Unable to set geometry，请将该控件的可见移到加入布局之后。 可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可。 QPushButton *btn = new QPushButton; btn-\u003eresize(30, ui-\u003elineEdit-\u003eheight()); QHBoxLayout *layout = new QHBoxLayout(ui-\u003elineEdit); layout-\u003esetMargin(0); layout-\u003eaddStretch(); layout-\u003eaddWidget(btn); 对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果。 巧妙的使用 findChildren 可以查找该控件下的所有子控件。 findChild 为查找单个。 //查找指定类名objectName的控件 QList\u003cQWidget *\u003e widgets = fatherWidget.findChildren\u003cQWidget *\u003e(\"widgetname\"); //查找所有QPushButton QList\u003cQPushButton *\u003e allPButtons = fatherWidget.findChildren\u003cQPushButton *\u003e(); //查找一级子控件,不然会一直遍历所有子控件 QList\u003cQPushButton *\u003e childButtons = fatherWidget.findChildren\u003cQPushButton *\u003e(QString(), Qt::FindDirectChildrenOnly); 巧妙的使用inherits判断是否属于某种类。 QTimer *timer = new QTimer; // QTimer inherits QObject timer-\u003einherits(\"QTimer\"); // returns true timer-\u003einherits(\"QObject\"); // returns true timer-\u003einherits(\"QAbstractButton\"); // returns false 使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-\u003edynamicPropertyNames()列出所有弱属性名称，然后通过widget-\u003eproperty(“name”)取出对应的弱属性的值。 在开发时, 无论是出于维护的便捷性, 还是节省内存资源的考虑, 都应该有一个 qss 文件来存放所有的样式表, 而不应该将 setStyleSheet 写的到处都是。如果是初学阶段或者测试阶段可以直接UI上右键设置样式表，正式项目还是建议统一到一个qss样式表文件比较好，统一管理。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"03：021-030 如果出现Z-order assignment: is not a valid widget.错误提示，用记事本打开对应的ui文件，找到为空的地方，删除即可。 善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来。特别注意的是第二个参数是QVariant类型，这就不要太灵活了，意味着可以附带万能的数据比如结构体，这样就可以带一堆数据了，而不是一个数据。比如下拉框选择学号，对应元素可以附带该学生的姓名、班级、成绩等。很多人以为只能附带QString、int之类的数据，因为通常的用法也是那两种。 QStringList listVideoOpenInterval, listVideoOpenIntervalx; listVideoOpenInterval \u003c\u003c \"0.0 秒\" \u003c\u003c \"0.1 秒\" \u003c\u003c \"0.3 秒\" \u003c\u003c \"0.5 秒\" \u003c\u003c \"1.0 秒\" \u003c\u003c \"2.0 秒\"; listVideoOpenIntervalx \u003c\u003c \"0\" \u003c\u003c \"100\" \u003c\u003c \"300\" \u003c\u003c \"500\" \u003c\u003c \"1000\" \u003c\u003c \"2000\"; for (int i = 0; i \u003c listVideoOpenInterval.count(); ++i) { ui-\u003ecboxVideoOpenInterval-\u003eaddItem(listVideoOpenInterval.at(i), listVideoOpenIntervalx.at(i)); } //取出对应的值 int indexVideoOpenInterval = ui-\u003ecboxVideoOpenInterval-\u003ecurrentIndex(); indexVideoOpenInterval = ui-\u003ecboxVideoOpenInterval-\u003eitemData(indexVideoOpenInterval).toInt(); 如果用了webengine模块，发布程序的时候带上QtWebEngineProcess.exe、translations文件夹、resources文件夹，不然无法正常运行。 在MFC程序或者VB/C#等窗体程序中，每个控件都有一个句柄，而且用句柄工具移过去会自动识别，但是在Qt程序中默认Qt是一个窗体一个句柄，如果要让每个控件都拥有独立的句柄，在main函数中要做如下设置。 int main(int argc, char *argv[]) { QApplication a(argc, argv); a.setAttribute(Qt::AA_NativeWindows); } Qt编写的Android程序防止程序被关闭。 #if defined(Q_OS_ANDROID) QAndroidService a(argc, argv); return a.exec() #else QApplication a(argc, argv); return a.exec(); #endif 可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置， *::down-arrow{} *::menu-indicator{} *::up-arrow:disabled{} *::up-arrow:off{} 可以指定位置设置背景图片。 QMainWindow \u003e .QWidget { background-color: gainsboro; background-image: url(:/images/xxoo.png); background-position: top right; background-repeat: no-repeat } 嵌入式linux运行Qt程序 //Qt4写法 ./HelloQt -qws \u0026 //Qt5写法 xcb 可以改成 linuxfb eglfs vnc wayland 等,有哪个就用哪个挨个测试 ./HelloQt --platform xcb ./HelloQt --platform linuxfb ./HelloQt --platform wayland 如果发现QtCreator中的构建套件不正常了或者坏了（比如不能正确识别环境中的qmake或者编译器、打开项目不能正常生成影子构建目录），请找到两个目录（C:\\Users\\Administrator\\AppData\\Local\\QtProject、C:\\Users\\Administrator\\AppData\\Roaming\\QtProject）删除即可，删除后重新打开QtCreator进行构建套件的配置就行。 QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV Filters安装即可（k-lite或者LAV Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer，并未完整验证，报错提示 Your GStreamer installation is missing a plug-in，需要命令安装 sudo apt-get install ubuntu-restricted-extras）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:3","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"04：031-040 判断编译器类型、编译器版本、操作系统。 //GCC编译器 #ifdef __GNUC__ #if __GNUC__ \u003e= 3 // GCC3.0 以上 //MSVC编译器 #ifdef _MSC_VER #if _MSC_VER \u003e=1000 // VC++4.0 以上 #if _MSC_VER \u003e=1100 // VC++5.0 以上 #if _MSC_VER \u003e=1200 // VC++6.0 以上 #if _MSC_VER \u003e=1300 // VC2003 以上 #if _MSC_VER \u003e=1400 // VC2005 以上 #if _MSC_VER \u003e=1500 // VC2008 以上 #if _MSC_VER \u003e=1600 // VC2010 以上 #if _MSC_VER \u003e=1700 // VC2012 以上 #if _MSC_VER \u003e=1800 // VC2013 以上 #if _MSC_VER \u003e=1900 // VC2015 以上 //Visual Studio版本与MSVC版本号的对应关系 MSC 1.0 _MSC_VER == 100 MSC 2.0 _MSC_VER == 200 MSC 3.0 _MSC_VER == 300 MSC 4.0 _MSC_VER == 400 MSC 5.0 _MSC_VER == 500 MSC 6.0 _MSC_VER == 600 MSC 7.0 _MSC_VER == 700 MSVC++ 1.0 _MSC_VER == 800 MSVC++ 2.0 _MSC_VER == 900 MSVC++ 4.0 _MSC_VER == 1000 (Developer Studio 4.0) MSVC++ 4.2 _MSC_VER == 1020 (Developer Studio 4.2) MSVC++ 5.0 _MSC_VER == 1100 (Visual Studio 97 version 5.0) MSVC++ 6.0 _MSC_VER == 1200 (Visual Studio 6.0 version 6.0) MSVC++ 7.0 _MSC_VER == 1300 (Visual Studio .NET 2002 version 7.0) MSVC++ 7.1 _MSC_VER == 1310 (Visual Studio .NET 2003 version 7.1) MSVC++ 8.0 _MSC_VER == 1400 (Visual Studio 2005 version 8.0) MSVC++ 9.0 _MSC_VER == 1500 (Visual Studio 2008 version 9.0) MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010 version 10.0) MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012 version 11.0) MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013 version 12.0) MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015 version 14.0) MSVC++ 14.1 _MSC_VER == 1910 (Visual Studio 2017 version 15.0) MSVC++ 14.11 _MSC_VER == 1911 (Visual Studio 2017 version 15.3) MSVC++ 14.12 _MSC_VER == 1912 (Visual Studio 2017 version 15.5) MSVC++ 14.13 _MSC_VER == 1913 (Visual Studio 2017 version 15.6) MSVC++ 14.14 _MSC_VER == 1914 (Visual Studio 2017 version 15.7) MSVC++ 14.15 _MSC_VER == 1915 (Visual Studio 2017 version 15.8) MSVC++ 14.16 _MSC_VER == 1916 (Visual Studio 2017 version 15.9) MSVC++ 14.2 _MSC_VER == 1920 (Visual Studio 2019 Version 16.0) MSVC++ 14.21 _MSC_VER == 1921 (Visual Studio 2019 Version 16.1) MSVC++ 14.22 _MSC_VER == 1922 (Visual Studio 2019 Version 16.2) //Borland C++ #ifdef __BORLANDC__ //Cygwin #ifdef __CYGWIN__ #ifdef __CYGWIN32__ //mingw #ifdef __MINGW32__ //windows #ifdef _WIN32 //32bit #ifdef _WIN64 //64bit #ifdef _WINDOWS //图形界面程序 #ifdef _CONSOLE //控制台程序 //Windows（95/98/Me/NT/2000/XP/Vista）和Windows CE都定义了 #if (WINVER \u003e= 0x030a) // Windows 3.1以上 #if (WINVER \u003e= 0x0400) // Windows 95/NT4.0以上 #if (WINVER \u003e= 0x0410) // Windows 98以上 #if (WINVER \u003e= 0x0500) // Windows Me/2000以上 #if (WINVER \u003e= 0x0501) // Windows XP以上 #if (WINVER \u003e= 0x0600) // Windows Vista以上 //_WIN32_WINNT 内核版本 #if (_WIN32_WINNT \u003e= 0x0500) // Windows 2000以上 #if (_WIN32_WINNT \u003e= 0x0501) // Windows XP以上 #if (_WIN32_WINNT \u003e= 0x0600) // Windows Vista以上 在pro中判断Qt版本及构建套件位数 #打印版本信息 message(qt version: $$QT_VERSION) #判断当前qt版本号 QT_VERSION = $$[QT_VERSION] QT_VERSION = $$split(QT_VERSION, \".\") QT_VER_MAJ = $$member(QT_VERSION, 0) QT_VER_MIN = $$member(QT_VERSION, 1) #下面是表示 Qt5.5及以上版本 greaterThan(QT_VER_MAJ, 4) { greaterThan(QT_VER_MIN, 4) { #自己根据需要做一些处理 }} #QT_ARCH是Qt5新增的,在Qt4上没效果 #打印当前Qt构建套件的信息 message($$QT_ARCH) #表示arm平台构建套件 contains(QT_ARCH, arm) {} #表示32位的构建套件 contains(QT_ARCH, i386) {} #表示64位的构建套件 contains(QT_ARCH, x86_64) {} #其实Qt内置了主版本号和子版本号变量 #判断当前qt版本号 message($$QT_ARCH : $$QT_VERSION -\u003e $$QT_MAJOR_VERSION . $$QT_MINOR_VERSION) #下面的含义是如果版本 \u003c 4.8 lessThan(QT_MAJOR_VERSION, 5) { lessThan(QT_MINOR_VERSION, 8) { #这里放要做的处理 }} #下面的含义是如果版本 \u003c 5.12.0 REQ_QT_MAJOR = 5 REQ_QT_MINOR = 12 REQ_QT_PATCH = 0 lessThan(QT_MAJOR_VERSION, $$REQ_QT_MAJOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_MINOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_PATCH) { #这里放要做的处理 } #下面的含义是如果版本 \u003e= 5.5 greaterThan(QT_MAJOR_VERSION, 4) { greaterThan(QT_MINOR_VERSION, 4) { #这里放要做的处理 }} //代码中判断版本不要太简单 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) //这里放要做的处理 #endif //下面表示 \u003e= 5.0.0 #if QT_VERSION \u003e= 0x050000 ... #endif //下面表示 \u003c 5.12.10 #if QT_VERSION \u003c 0x050C0A ... #endif Qt最小化后恢复界面可能会出现假死冻结现象，加上代码 void showEvent(QShowEvent *e) { setAttribute(Qt::","date":"0001-01-01","objectID":"/1/01/qt/:0:4","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"05：041-050 如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库。 QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\"); db.setDatabaseName(\":memory:\"); 清空数据表并重置自增ID，sql = truncate table table_name。 QtChart模块从Qt5.7开始自带，最低编译要求Qt5.4。在安装的时候记得勾选，默认不勾选。使用该模块需要引入命名空间。 #include \u003cQChartView\u003e QT_CHARTS_USE_NAMESPACE class CustomChart : public QChartView QPushButton左对齐文字，需要设置样式表QPushButton{text-align:left;} QLabel有三种设置文本的方法，掌握好Qt的属性系统，举一反三，可以做出很多效果。 //常规办法 ui-\u003elabel-\u003esetText(\"hello\"); //取巧办法 ui-\u003elabel-\u003esetProperty(\"text\", \"hello\"); //属性大法 ui-\u003elabel-\u003esetStyleSheet(\"qproperty-text:hello;\"); 巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行。 QEventLoop loop; connect(reply, SIGNAL(finished()), \u0026loop, SLOT(quit())); loop.exec(); 多种预定义变量 #if (defined webkit) || (defined webengine)，去掉生成空的debug和release目录，在pro文件中加一行 CONFIG -= debug_and_release。 新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About Plugins。也可以设置代码检查级别，Tools》Options 》C++ 》Code Model。 QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据。 如果数据量很小，也可以采用如下方法： //主动加载所有数据,不然获取到的行数\u003c=256 while(model-\u003ecanFetchMore()) { model-\u003efetchMore(); } 如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，比如自由拉伸边框，可以使用 setWindowFlags(Qt::CustomizeWindowHint)，这样会保留一个系统白边框。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:5","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"06：051-060 在某些http post数据的时候，如果采用的是\u0026字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码。 QString content = \"测试中文\"; QString note = content.toUtf8().toPercentEncoding(); Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启。 CONFIG += resources_big Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一。 方法一：设置属性 this-\u003esetAttribute(Qt::WA_StyledBackground, true); 方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。 方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。 void Widget::paintEvent(QPaintEvent *) { QStyleOption option; option.initFrom(this); QPainter painter(this); style()-\u003edrawPrimitive(QStyle::PE_Widget, \u0026option, \u0026painter, this); } 有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的。 在使用QFile的过程中，不建议频繁的打开文件写入然后再关闭文件，比如间隔5ms输出日志，IO性能瓶颈很大，这种情况建议先打开文件不要关闭，等待合适的时机比如析构函数中或者日期变了需要重新变换日志文件的时候关闭文件。不然短时间内大量的打开关闭文件会很卡，文件越大越卡。 在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接。 int fd = tcpSocket-\u003esocketDescriptor(); int keepAlive = 1; //开启keepalive属性,缺省值:0(关闭) int keepIdle = 5; //如果在5秒内没有任何数据交互,则进行探测,缺省值:7200(s) int keepInterval = 2; //探测时发探测包的时间间隔为2秒,缺省值:75(s) int keepCount = 2; //探测重试的次数,全部超时则认定连接失效,缺省值:9(次) setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)\u0026keepAlive, sizeof(keepAlive)); setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, (void *)\u0026keepIdle, sizeof(keepIdle)); setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, (void *)\u0026keepInterval, sizeof(keepInterval)); setsockopt(fd, SOL_TCP, TCP_KEEPCNT, (void *)\u0026keepCount, sizeof(keepCount)); 如果程序打包好以后弹出提示 This application failed to start because it could not find or load the Qt platform plugin 一般都是因为platforms插件目录未打包或者打包错了的原因导致的。 非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的（后面发现我在刚学Qt的时候也发布了一些demo到网上也是tr包含中文的，当时就狠狠的打了自己一巴掌），tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理。 很多人Qt和Qt Creator傻傻分不清楚，经常问Qt什么版本结果发一个Qt Creator的版本过来，Qt Creator是使用Qt编写的集成开发环境IDE，和宇宙第一的Visual Studio一样，他可以是msvc编译器的（WIN对应的Qt集成安装环境中自带的Qt Cerator是msvc的），也可以是mingw编译的，还可以是gcc的。如果是自定义控件插件，需要集成到Qt Creator中，必须保证该插件的动态库文件（dll或者so等文件）对应的编译器和Qt版本以及位数和Qt Creator的版本完全一致才行，否则基本不大可能集成进去。特别注意的是Qt集成环境安装包中的Qt版本和Qt Creator版本未必完全一致，必须擦亮眼睛看清楚，有些是完全一致的。 超过两处相同处理的代码，建议单独写成函数。代码尽量规范精简，比如 if(a == 123) 要写成 if (123 == a)，值在前面，再比如 if (ok == true) 要写成 if (ok)，if (ok == false) 要写成 if (!ok)等。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:6","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"07：061-070 很多人问Qt嵌入式平台用哪个好，这里统一回答（当前时间节点2018年）：imx6+335x比较稳定，性能高就用RK3288 RK3399，便宜的话就用全志H3，玩一玩可以用树莓派香橙派。 对于大段的注释代码，建议用 #if 0 #endif 将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是 #if 0则只要把0改成1即可，开发效率提升很多。 Qt打包发布，有很多办法，Qt5以后提供了打包工具windeployqt（linux上为linuxdeployqt，mac上为macdeployqt）可以很方便的将应用程序打包，使用下来发现也不是万能的，有时候会多打包一些没有依赖的文件，有时候又会忘记打包一些插件尤其是用了qml的情况下，而且不能识别第三方库，比如程序依赖ffmpeg，则对应的库需要自行拷贝，终极大法就是将你的可执行文件复制到Qt安装目录下的bin目录，然后整个一起打包，挨个删除不大可能依赖的组件，直到删到正常运行为止。 Qt中的动画，底层用的是QElapsedTimer定时器来完成处理，比如产生一些指定规则算法的数据，然后对属性进行处理。 在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致。 QRect rect(-radius, -radius, radius * 2, radius * 2); //以下两种方法二选一,其实绘制360度的圆弧=绘制无背景的圆形 painter-\u003edrawArc(rect, 0, 360 * 16); painter-\u003edrawEllipse(rect); 不要把d指针看的很玄乎，其实就是在类的实现文件定义了一个私有类，用来存放局部变量，个人建议在做一些小项目时，没有太大必要引入这种机制，会降低代码可读性，增加复杂性，新手接受项目后会看的很懵逼。 很多人在绘制的时候，设置画笔以为就只可以设置个单调的颜色，其实QPen还可以设置brush，这样灵活性就提高不知道多少倍，比如设置QPen的brush以后，可以使用各种渐变，比如绘制渐变颜色的进度条和文字等，而不再是单调的一种颜色。 很多控件都带有viewport，比如QTextEdit/QTableWidget/QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport()设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-\u003eviewport()-\u003esetStyleSheet(“background-color:transparent;”);而不是scrollArea-\u003esetStyleSheet(“QScrollArea{background-color:transparent;}”); 有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置 setAttribute(Qt::WA_Hover, true); Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等。 QDateTime dateTime; QString dateTime_str = dateTime.currentDateTime().toString(\"yyyy-MM-dd hh:mm:ss\"); //从字符串转换为毫秒（需完整的年月日时分秒） datetime.fromString(\"2011-09-10 12:07:50:541\", \"yyyy-MM-dd hh:mm:ss:zzz\").toMSecsSinceEpoch(); //从字符串转换为秒（需完整的年月日时分秒） datetime.fromString(\"2011-09-10 12:07:50:541\", \"yyyy-MM-dd hh:mm:ss:zzz\").toTime_t(); //从毫秒转换到年月日时分秒 datetime.fromMSecsSinceEpoch(1315193829218).toString(\"yyyy-MM-dd hh:mm:ss:zzz\"); //从秒转换到年月日时分秒（若有zzz，则为000） datetime.fromTime_t(1315193829).toString(\"yyyy-MM-dd hh:mm:ss[:zzz]\"); ","date":"0001-01-01","objectID":"/1/01/qt/:0:7","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"08：071-080 在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用 at() 取值而不是 [] 操作符，在官方书籍《C++ GUI Qt 4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用 at() 与使用 [] 操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用 at() 函数而不用 [] 操作符，因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而 at() 函数则不被允许出现在一个赋值的左边。 如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息。 QDialog dialog; dialog.setWindowModality(Qt::WindowModal); dialog.exec(); 安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns); 在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制。 将 QApplication::style() 对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication::style()-\u003edrawControl 的第4个参数如果不设置，则绘制出来的控件不会应用样式表。 心中有坐标，万物皆painter，强烈建议在学习自定义控件绘制的时候，将qpainter.h头文件中的函数全部看一遍、试一遍、理解一遍，这里边包含了所有Qt内置的绘制的接口，对应的参数都试一遍，你会发现很多新大陆，会一定程度上激发你的绘制的兴趣，犹如神笔马良一般，策马崩腾遨游代码绘制的世界。 在使用setItemWidget或者setCellWidget的过程中，有时候会发现设置的控件没有居中显示而是默认的左对齐，而且不会自动拉伸填充，对于追求完美的程序员来说，这个可不大好看，有个终极通用办法就是，将这个控件放到一个widget的布局中，然后将widget添加到item中，这样就完美解决了，而且这样可以组合多个控件产生复杂的控件。 //实例化进度条控件 QProgressBar *progress = new QProgressBar; //增加widget+布局巧妙实现居中 QWidget *widget = new QWidget; QHBoxLayout *layout = new QHBoxLayout; layout-\u003esetSpacing(0); layout-\u003esetMargin(0); layout-\u003eaddWidget(progress); widget-\u003esetLayout(layout); ui-\u003etableWidget-\u003esetCellWidget(0, 0, widget); 很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色。 //根据背景色自动计算合适的前景色 double gray = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255; QColor textColor = gray \u003e 0.5 ? Qt::black : Qt::white; 对QTableView、QTableWidget、QTreeView、QTreeWidget禁用列拖动。 #if (QT_VERSION \u003c QT_VERSION_CHECK(5,0,0)) ui-\u003etableView-\u003ehorizontalHeader()-\u003esetResizeMode(0, QHeaderView::Fixed); ui-\u003etreeView-\u003eheader()-\u003esetResizeMode(0, QHeaderView::Fixed); #else ui-\u003etableView-\u003ehorizontalHeader()-\u003esetSectionResizeMode(0, QHeaderView::Fixed); ui-\u003etreeView-\u003eheader()-\u003esetSectionResizeMode(0, QHeaderView::Fixed); #endif 从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0 ","date":"0001-01-01","objectID":"/1/01/qt/:0:8","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"09：081-090 Qt中的QColor对颜色封装的很完美，支持各种转换，比如rgb、hsb、cmy、hsl，对应的是toRgb、toHsv、toCmyk、toHsl，还支持透明度设置，颜色值还能转成16进制格式显示。 QColor color(255, 0, 0, 100); qDebug() \u003c\u003c color.name() \u003c\u003c color.name(QColor::HexArgb); //输出 #ff0000 #64ff0000 QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法。 if (variant.typeName() == \"QColor\") { QColor color = variant.value\u003cQColor\u003e(); QFont font = variant.value\u003cQFont\u003e(); QString nodeValue = color.name(QColor::HexArgb); } Qt中的QString和const char *之间转换，最好用toStdString().c_str()而不是toLocal8Bit().constData()，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常。 Qt的信号槽机制非常牛逼，也是Qt的独特的核心功能之一，有时候我们在很多窗体中传递信号来实现更新或者处理，如果窗体层级比较多，比如窗体A的父类是窗体B，窗体B的父类是窗体C，窗体C有个子窗体D，如果窗体A一个信号要传递给窗体D，问题来了，必须先经过窗体B中转到窗体C再到窗体D才行，这样的话各种信号关联信号的connect会非常多而且管理起来比较乱，可以考虑增加一个全局的单例类AppEvent，公共的信号放这里，然后窗体A对应信号绑定到AppEvent，窗体D绑定AppEvent的信号到对应的槽函数即可，干净清爽整洁。 QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets.qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突。 Qt中有个全局的焦点切换信号focusChanged，可以用它做自定义的输入法。Qt4中默认会安装输入法上下文，比如在main函数打印a.inputContext会显示值，这个默认安装的输入法上下文，会拦截两个牛逼的信号QEvent::RequestSoftwareInputPanel和QEvent::CloseSoftwareInputPanel，以至于就算你安装了全局的事件过滤器依然识别不到这两个信号，你只需要在main函数执行a.setInputContext(0)即可，意思是安装输入法上下文为空。Qt5.7以后提供了内置的输入法，可以通过在main函数最前面加上 qputenv(“QT_IM_MODULE”, QByteArray(“qtvirtualkeyboard”)); 来启用。 在Qt5.10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-\u003etableView-\u003ehorizontalHeader()-\u003esetMinimumSectionSize(0); Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT += gui-private才能使用。 #include \"QtGui/private/qzipreader_p.h\" #include \"QtGui/private/qzipwriter_p.h\" QZipReader reader(dirPath); QString path(\"\"); //解压文件夹到当前目录 reader.extractAll(path); //文件夹名称 QZipReader::FileInfo fileInfo = reader.entryInfoAt(0); //解压文件 QFile file(filePath); file.open(QIODevice::WriteOnly); file.write(reader.fileData(QString::fromLocal8Bit(\"%1\").arg(filePath))); file.close(); reader.close(); QZipWriter *writer = new QZipWriter(dirPath); //添加文件夹 writer-\u003eaddDirectory(unCompress); //添加文件 QFile file(filePath); file.open(QIODevice::ReadOnly); writer-\u003eaddFile(data, file.readAll()); file.close(); writer-\u003eclose(); 理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理。 在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:9","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"10：091-100 数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题。 新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写。 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,0,0)) void incomingConnection(qintptr handle); #else void incomingConnection(int handle); #endif Qt支持所有的界面控件比如QPushButton、QLineEdit自动关联 on_控件名_信号(参数) 信号槽，比如按钮的单击信号 on_pushButton_clicked()，然后直接实现槽函数即可。 QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染。 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,4,0)) //下面两种方法都可以,Qt默认采用的是AA_UseDesktopOpenGL QCoreApplication::setAttribute(Qt::AA_UseOpenGLES); //QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL); #endif QApplication a(argc, argv); 另外一个方法解决 全屏+QWebEngineView控件一起会产生右键菜单无法弹出的bug,需要上移一个像素 QRect rect = qApp-\u003edesktop()-\u003egeometry(); rect.setY(-1); rect.setHeight(rect.height()); this-\u003esetGeometry(rect); QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值。 QStyle::sliderValueFromPosition(minimum(), maximum(), event-\u003ex(), width()); 用QFile读写文件的时候，推荐用QTextStream文件流的方式来读写文件，速度快很多，基本上会有30%的提升，文件越大性能区别越大。 //从文件加载英文属性与中文属性对照表 QFile file(\":/propertyname.txt\"); if (file.open(QFile::ReadOnly)) { //QTextStream方法读取速度至少快百分之30 #if 0 while(!file.atEnd()) { QString line = file.readLine(); appendName(line); } #else QTextStream in(\u0026file); while (!in.atEnd()) { QString line = in.readLine(); appendName(line); } #endif file.close(); } 用QFile.readAll()读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果。 void frmMain::initStyle() { //加载样式表 QString qss; //QFile file(\":/qss/psblack.css\"); //QFile file(\":/qss/flatwhite.css\"); QFile file(\":/qss/lightblue.css\"); if (file.open(QFile::ReadOnly)) { #if 1 //用QTextStream读取样式文件不用区分文件编码 带bom也行 QStringList list; QTextStream in(\u0026file); //in.setCodec(\"utf-8\"); while (!in.atEnd()) { QString line; in \u003e\u003e line; list \u003c\u003c line; } qss = list.join(\"\\n\"); #else //用readAll读取默认支持的是ANSI格式,如果不小心用creator打开编辑过了很可能打不开 qss = QLatin1String(file.readAll()); #endif QString paletteColor = qss.mid(20, 7); qApp-\u003esetPalette(QPalette(QColor(paletteColor))); qApp-\u003esetStyleSheet(qss); file.close(); } } QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可。 QString s1, s2; s1 = \"666.5567124\"; s2.setNum(888.5632123, 'f', 7); qDebug() \u003c\u003c qSetRealNumberPrecision(10) \u003c\u003c s1.toDouble() \u003c\u003c s2.toDouble(); 用QScriptValueIterator解析数据的时候，会发现总是会多一个节点内容，并且内容为空，如果需要跳过则增加一行代码。 while (it.hasNext()) { it.next(); if (it.flags() \u0026 QScriptValue::SkipInEnumeration) continue; qDebug() \u003c\u003c it.name(); } setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:10","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"11：101-110 如果需要在尺寸改变的时候不重绘窗体，则设置属性即可 this-\u003esetAttribute(Qt::WA_StaticContents, true); 这样可以避免对已经显示区域的重新绘制。 默认程序中获取焦点以后会有虚边框，如果看着觉得碍眼不舒服可以去掉，设置样式即可：setStyleSheet(\"*{outline:0px;}\"); Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget。 void QUIHelper::initTableView(QTableView *tableView, int rowHeight, bool headVisible, bool edit) { //奇数偶数行颜色交替 tableView-\u003esetAlternatingRowColors(false); //垂直表头是否可见 tableView-\u003everticalHeader()-\u003esetVisible(headVisible); //选中一行表头是否加粗 tableView-\u003ehorizontalHeader()-\u003esetHighlightSections(false); //最后一行拉伸填充 tableView-\u003ehorizontalHeader()-\u003esetStretchLastSection(true); //行标题最小宽度尺寸 tableView-\u003ehorizontalHeader()-\u003esetMinimumSectionSize(0); //行标题最大高度 tableView-\u003ehorizontalHeader()-\u003esetMaximumHeight(rowHeight); //默认行高 tableView-\u003everticalHeader()-\u003esetDefaultSectionSize(rowHeight); //选中时一行整体选中 tableView-\u003esetSelectionBehavior(QAbstractItemView::SelectRows); //只允许选择单个 tableView-\u003esetSelectionMode(QAbstractItemView::SingleSelection); //表头不可单击 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,0,0)) tableView-\u003ehorizontalHeader()-\u003esetSectionsClickable(false); #else tableView-\u003ehorizontalHeader()-\u003esetClickable(false); #endif //鼠标按下即进入编辑模式 if (edit) { tableView-\u003esetEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked); } else { tableView-\u003esetEditTriggers(QAbstractItemView::NoEditTriggers); } } 在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则。 TEMPLATE = subdirs #设置ordered参数以后会依次编译 projA projB projC CONFIG += ordered SUBDIRS += projA SUBDIRS += projB SUBDIRS += projC #还可以通过设置depends指定某个项目依赖 比如下面指定projB依赖projA projB.depends = projA projC.depends = projA projD.depends = projC MSVC编译器的选择说明 如果是32位的Qt则编译器选择x86开头的 如果是64位的Qt则编译器选择amd64开头的 具体是看安装的Qt构建套件版本以及目标运行平台的系统位数和架构 一般现在的电脑默认以64位的居多，选择amd64即可 如果用户需要兼容32位的系统则建议选择32位的Qt，这样即可在32位也可以在64位系统运行 诸葛大佬补充：x86/x64都是编译环境和运行环境相同，没有或。带下划线的就是交叉编译，前面是编译环境，后面是运行环境。 名称 说明 x86 32/64位系统上编译在32/64位系统上运行 x86_amd64 32/64位系统上编译在64位系统上运行 x86_arm 32/64位系统上编译在arm系统上运行 amd64 64位系统上编译在64位系统上运行 amd64_x86 64位系统上编译在32/64位系统上运行 amd64_arm 64位系统上编译在arm系统上运行 很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置。 QDialog dialog; dialog.setWindowModality(Qt::WindowModal); 很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源。 如果你没有使用wait***函数的话，大部分的界面卡都出在数据处理和展示中，比如传过来的是一张图片的数据，你需要将这些数据转成图片，这个肯定是耗时的； 还有就是就收到的数据曲线绘制出来，如果过于频繁或者间隔过短，肯定会给UI造成很大的压力的，最好的办法是解决如何不要频繁绘制UI比如合并数据一起绘制等； 如果是因为绘制UI造成的卡，那多线程也是没啥用的，因为UI只能在主线程； 串口和网络的数据收发默认都是异步的，由操作系统调度的，如果数据处理复杂而且数据量大，你要做的是将数据处理放到多线程中； 如果没有严格的数据同步需求，根本不需要调用wait***之类的函数来立即发送和接收数据，实际需求中大部分的应用场景其实异步收发数据就足够了； 有严格数据同步需求的场景还是放到多线程会好一些，不然你wait***就卡在那边了； 多线程是需要占用系统资源的，理论上来说，如果线程数量超过了CPU的核心数量，其实多线程调度可能花费的时间更多，各位在使用过程中要权衡利弊； 再次强调，不要指望Qt的网络通信支持高并发，最多到1000个能正常工作就万事大吉，一般建议500以内的连接数。有大量高并发的需求请用第三方库比如swoole等。 在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行。 //这种方式设置的无边框窗体在嵌入式设备上无法产生焦点 setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint); //需要在show以后主动激活窗体 w-\u003eshow(); w-\u003eactivateWindow(); QString的replace函数会改变原字符串，切记，他在返回替换后的新字符串的同时也会改变原字符串，我的乖乖！ QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:11","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"12：111-120 在不同的平台上文件路径的斜杠也是不一样的，比如linux系统一般都是 / 斜杠，而在windows上都是 \\ 两个反斜杠，Qt本身程序内部无论在win还是linux都支持 / 斜杠的路径，但是一些第三方库的话可能需要转换成对应系统的路径，这就需要用到斜杠转换，Qt当然内置类方法。 QString path = \"C:/temp/test.txt\"; path = QDir::toNativeSeparators(path); //输出 C:\\\\temp\\\\test.txt QString path = \"C:\\\\temp\\\\test.txt\"; path = QDir::toNativeSeparators(path); //输出 C:/temp/test.txt 巧用QMetaObject::invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, “fun”, Qt::QueuedConnection); 这种方式来就可以。 invokeMethod函数有很多重载参数，可以传入返回值和执行方法的参数等。 invokeMethod函数不仅支持槽函数还支持信号，而且这逼居然是线程安全的，可以在线程中放心使用，牛逼！ 测试下来发现只能执行signals或者slots标识的方法。 默认可以执行private(protected/public) slots下的函数，但是不能执行private(protected/public)下的函数。 毛总补充：前提必须是slots或者signals标注的函数，不是标注的函数不在元信息导致无法查找，执行之后会提示No such method。 2021-11-06补充：如果要执行private(protected/public)下的函数，需要函数前面加上 Q_INVOKABLE 关键字，今天又学到了，必须加鸡腿。 其实这样看下来，就是任何方法函数都能执行了，这就超越了private(protected/public)的权限限定了，相当于一个类的私有函数用了 Q_INVOKABLE 关键字修饰也可以被 invokeMethod 执行，哇咔咔。 //头文件声明信号和槽函数 signals: void sig_test(int type,double value); private slots: void slot_test(int type, double value); private: Q_INVOKABLE void fun_test(int type, double value); //构造函数关联信号槽 connect(this, SIGNAL(sig_test(int, double)), this, SLOT(slot_test(int, double))); //单击按钮触发信号和槽,这里是同时举例信号槽都可以 void MainWindow::on_pushButton_clicked() { QMetaObject::invokeMethod(this, \"sig_test\", Q_ARG(int, 66), Q_ARG(double, 66.66)); QMetaObject::invokeMethod(this, \"slot_test\", Q_ARG(int, 88), Q_ARG(double, 88.88)); QMetaObject::invokeMethod(this, \"fun_test\", Q_ARG(int, 99), Q_ARG(double, 99.99)); } //会打印 66 66.66、88 88.88 void MainWindow::slot_test(int type, double value) { qDebug() \u003c\u003c type \u003c\u003c value; } //会打印 99.99 void MainWindow::fun_test(int type, double value) { qDebug() \u003c\u003c type \u003c\u003c value; } Qt5中的信号是public的，可以在需要的地方直接emit即可，而在Qt4中信号是protected的，不能直接使用，需要定义一个public函数来emit。 Qt5.15版本开始官方不再提供安装包，只提供源码，可以自行编译或者在线安装，估计每次编译各种版本太麻烦，更多的是为了统计收集用户使用信息比如通过在线安装，后期可能会逐步加大商业化力度。 有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有 QT += 的方式添加的模块，可以用 contains来判断。 qtHaveModule(webenginewidgets) { message(\"当前Qt库有找到 webenginewidgets 模块\") } !qtHaveModule(webkit) { message(\"当前Qt库没有找到 webkit 模块\") } contains(QT, network) { message(\"当前项目已经引入 network 模块\") } !contains(QT, widgets) { message(\"当前项目没有引入 widgets 模块\") } c++11新引入了原始字符串格式，用户避免在字符串中加入转义字符\\，可以用于表示json字符串等场景。 QString s1 = R\"(test\\001.jpg)\"; s1.replace(\"\\\\\", \"#\"); qDebug()\u003c\u003c s1; //结果 test#001.jpg 安卓上打印信息建议使用 qInfo() 而不是 qDebug() ，qInfo()才有效果。 Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置 setTimerType(Qt::PreciseTimer)。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用 startTimer(interval, Qt::PreciseTimer); Qt::PreciseTimer 精确的定时器，尽量保持毫秒精度。 Qt::CoarseTimer 粗略的定时器，尽量保持精度在所需的时间间隔5%范围内。 Qt::VeryCoarseTimer 很粗略的定时器，只保留完整的第二精度。 精度再高，也依赖对应的操作系统中断，假设中断需要 5ms，则定时器精度不可能高于5毫秒。 QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用。 用QSettings设置注册表，如果不是管理员身份运行会打印 QSettings: failed to set subkey “xxx” (拒绝访问。)，你需要手动鼠标右键管理员身份运行就可以。 ","date":"0001-01-01","objectID":"/1/01/qt/:0:12","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"13：121-130 QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途。 限制输入只能输入IP地址。 限制输入范围，强烈推荐使用 QRegExpValidator 正则表达式来处理。 //正在表达式限制输入 QString str = \"\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b\"; ui-\u003elineEdit-\u003esetValidator(new QRegExpValidator(QRegExp(str))); //用于占位 ui-\u003elineEdit-\u003esetInputMask(\"000.000.000.000\"); #if 0 //下面代码设置浮点数范围限制失败 ui-\u003elineEdit-\u003esetValidator(new QDoubleValidator(20, 50, 1)); #else //下面代码设置浮点数范围限制成功 QDoubleValidator *validator = new QDoubleValidator(20, 50, 1); validator-\u003esetNotation(QDoubleValidator::StandardNotation); ui-\u003elineEdit-\u003esetValidator(validator); #endif //下面代码设置整数范围限制成功 ui-\u003elineEdit-\u003esetValidator(new QIntValidator(10, 120)); //其实上面的代码缺陷很多，只能限制只输入小数，无法设定数值范围，很操蛋 //需要来个万能的牛逼的 QRegExpValidator //限制浮点数输入范围为[-180,180] QRegExp regexp(\"^-?(180|1?[0-7]?\\\\d(\\\\.\\\\d+)?)$\"); //限制浮点数输入范围为[-90,90]并限定为小数位后4位 QRegExp regexp(\"^-?(90|[1-8]?\\\\d(\\\\.\\\\d{1,4})?)$\"); QRegExpValidator *validator = new QRegExpValidator(regexp, this); ui-\u003elineEdit-\u003esetValidator(validator); 在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5.14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串 rtmp://58.200.131.2:1935/livetv/cctv1，会显示成 rtmp://… ，而在旧版本的Qt中会显示成 rtmp://58.200.131… ，很多时候我们并不想看到烦人的省略号，可以设置取消。 //取消自动换行 tableView-\u003esetWordWrap(false); //超出文本不显示省略号 tableView-\u003esetTextElideMode(Qt::ElideNone); QVideoWidget播放视频，可能会遇到画面闪烁的情况，播放视频的窗体需要设置个属性。 QVideoWidget *videoWidget = new QVideoWidget; videoWidget-\u003esetAttribute(Qt::WA_OpaquePaintEvent); Qt bug成千上万，这个不用大惊小怪，也基本上遇不到，大部分都是特殊极端情况特定应用场景出现，甚至你会遇到有些是debug可以release报错，有些release可以debug却报错的情况，最神奇的还有先是debug报错，然后release正常，再返回去用debug又正常，需要用release激活一下！学习编程的路本来就是一条坑坑洼洼的路，不断填坑，尽量规避坑！很多时候很多看起来的坑其实是自己没有注意细节导致的。 Qt视图中默认排序是按照字符串的ASCII排序的，如果是IP地址的话会出现192.168.1.117排在192.168.1.2前面的情况，如果要规避这种情况，一种做法是取末尾的地址转成整型再比较大小，缺点是跨网段就歇菜了，又会出现192.168.2.65出现在192.168.1.70前面，终极大法是将IP地址转成整型再比较大小。 QString QUIHelper::ipv4IntToString(quint32 ip) { QString result = QString(\"%1.%2.%3.%4\").arg((ip \u003e\u003e 24) \u0026 0xFF).arg((ip \u003e\u003e 16) \u0026 0xFF).arg((ip \u003e\u003e 8) \u0026 0xFF).arg(ip \u0026 0xFF); return result; } quint32 QUIHelper::ipv4StringToInt(const QString \u0026ip) { int result = 0; if (isIP(ip)) { QStringList list = ip.split(\".\"); int ip0 = list.at(0).toInt(); int ip1 = list.at(1).toInt(); int ip2 = list.at(2).toInt(); int ip3 = list.at(3).toInt(); result = ip3 | ip2 \u003c\u003c 8 | ip1 \u003c\u003c 16 | ip0 \u003c\u003c 24; } return result; } 在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致。 Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出。 #禁用qdebug打印输出 DEFINES += QT_NO_DEBUG_OUTPUT 在使用 QT_NO_DEBUG_OUTPUT 关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实 QT_NO_DEBUG_OUTPUT 禁用的 qdebug 的输出，Qt还有其他几种打印信息比如 qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用 qInfo 来输出信息就好。特别注意：qFatal 打印完信息程序会自动结束。 qDebug() \u003c\u003c \"qDebug\"; qInfo() \u003c\u003c \"qInfo\"; qWarning() \u003c\u003c \"qWarning\"; qCritical() \u003c\u003c \"qCritical\"; qDebug(\"qDebug\"); qWarning(\"qWarning\"); qCritical(\"qCritical\"); Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去。 #禁用qdebug打印输出 DEFINES += QT_NO_DEBUG_OUTPUT #自定义define变量 可以在整个项目中使用 #pro文件可以这样判断 contains(DEFINES, videovlc) {} #代码文件可以这样判断 #ifdef videovlc DEFINES += videovlc1 videoffmpeg #关闭编译警告提示 眼不见为净 CONFIG += warn_off #指定编译生成的文件到temp目录 分门别类存储 MOC_DIR = temp/moc RCC_DIR = temp/rcc UI_DIR = temp/ui OBJECTS_DIR = temp/obj #指定编译生成的可执行文件到bin目录 DESTDIR = bin Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理。 //主窗体头文件 protected: bool nativeEvent(const QByteArray \u0026eventType, void *message, long *result); #ifdef Q_OS_WIN bool winEvent(MSG *message, long *result); #endif //主窗体实现函数 #ifdef Q_OS_WIN #include \"Windows.h\" #endif bool frmMain::nativeEvent(const QByteArray \u0026eventType, void *message, long *result) { if (eventType == \"windows_g","date":"0001-01-01","objectID":"/1/01/qt/:0:13","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"14：131-140 Qt新版本往往会带来一些头文件的更新，比如以前使用QPainter绘制，不需要额外包含QPainterPath头文件，而5.15版本开始就需要显示主动引入#include “qpainterpath.h\"才行。 Qt6.0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件 QT += core5compat 才能用， 具体说明在https://doc.qt.io/qt-6/qtcore5-index.html。 qDebug输出打印信息，默认会完整打印转义字符，例如：\\ \" \\t \\n” 等，所以当你发现你明明设置了转义字符以后打印确还是转义前的字符，这就懵逼了，其实这是qdebug为了方便调试将各种字符都打印输出。无可否认，很多时候，我们极其兴奋的享受着Qt带来的各种轮子各种便利，但是偶尔，稍不留意，这些便利可能也会坑你一把。要做的就是擦亮眼睛，时刻谨慎，一步一个脚印踏踏实实码代码。 QString s1 = R\"(\\:device0)\"; //TNND居然输出的是 \\\\:device0 qDebug() \u003c\u003c s1; //这次终于正确的输出 \\:device0 qDebug().noquote() \u003c\u003c s1; 很多人有疑问为何qss对浏览器控件中的网页样式没法控制，其实用屁股想想也知道，那玩意是html css去控制的，和Qt一毛钱关系也没有，根本管不着，如果想要对滚动条样式设置，可以在网页代码中设置样式就行。 \u003cstyle type=\"text/css\"\u003e ::-webkit-scrollbar{width:0.8em;} ::-webkit-scrollbar-track{background:rgb(241,241,241);} ::-webkit-scrollbar-thumb{background:rgb(188,188,188);} \u003c/style\u003e Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件。 //设置了编码以后配置文件内容为 Company=上海物联网技术研究中心 //没有设置编码则配置文件内容为 Company=\\xe4\\xb8\\x8a\\xe6\\xb5\\xb7\\xe7\\x89\\xa9\\xe8\\x81\\x94\\xe7\\xbd\\x91\\xe6\\x8a\\x80\\xe6\\x9c\\xaf\\xe7\\xa0\\x94\\xe7\\xa9\\xb6\\xe4\\xb8\\xad\\xe5\\xbf\\x83 void App::readConfig() { QSettings set(App::ConfigFile, QSettings::IniFormat); set.setIniCodec(\"utf-8\"); set.beginGroup(\"AppConfig1\"); App::Company = set.value(\"Company\", App::Company).toString(); set.endGroup(); } void App::writeConfig() { QSettings set(App::ConfigFile, QSettings::IniFormat); set.setIniCodec(\"utf-8\"); set.beginGroup(\"AppConfig1\"); set.setValue(\"Company\", App::Company); set.endGroup(); } 用Qt做安卓开发都会遇到权限的问题，早期的安卓版本可以直接通过 AndroidManifest.xml 配置文件来添加需要的权限，这样在安装app的时候就会提示该app需要哪些权限让用户同意，现在的安卓版本都改成了动态权限，需要在app运行的时候弹出提示让用户确认再有权限，Qt迎合了这种策略内置了动态申请权限的方法 QtAndroid::requestPermissionsSync。 //动态设置权限 bool checkPermission(const QString \u0026permission) { #ifdef Q_OS_ANDROID #if (QT_VERSION \u003e= QT_VERSION_CHECK(5, 10, 0)) QtAndroid::PermissionResult result = QtAndroid::checkPermission(permission); if (result == QtAndroid::PermissionResult::Denied) { QtAndroid::requestPermissionsSync(QStringList() \u003c\u003c permission); result = QtAndroid::checkPermission(permission); if (result == QtAndroid::PermissionResult::Denied) { return false; } } #endif #endif return true; } int main(int argc, char *argv[]) { QApplication a(argc, argv); //请求权限 checkPermission(\"android.permission.READ_EXTERNAL_STORAGE\"); checkPermission(\"android.permission.WRITE_EXTERNAL_STORAGE\"); return a.exec(); } Qt重载qDebug输出自定义的信息。 struct FunctionInfo { QString function; QString name; QString groupEnabled; QString action; QString group; friend QDebug operator \u003c\u003c (QDebug debug, const FunctionInfo \u0026functionInfo) { QString info = QString(\"功能: %1 名称: %2 启用: %3 方法: %4 分组: %5\") .arg(functionInfo.function).arg(functionInfo.name).arg(functionInfo.groupEnabled) .arg(functionInfo.action).arg(functionInfo.group); debug \u003c\u003c info; return debug; } }; 对高分屏不同缩放比例的自适应处理方法。 //方法1：在main函数的最前面加上下面这句 5.6版本才开始有这个函数 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,6,0)) QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling); //开启高缩放支持以后图片可能发虚还要开启下面这个属性 QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps); #endif //方法2：在可执行文件同目录下新建文件 qt.conf 填入下面内容 [Platforms] WindowsArguments = dpiawareness=0 //下面这行用来解决Qt高DPI下文字显示有锯齿的问题 WindowsArguments = fontengine=freetype //方法3：在main函数最前面设置Qt内部的环境变量 qputenv(\"QT_AUTO_SCREEN_SCALE_FACTOR\", \"1.5\"); //方法4：新版本的Qt比如Qt5.14修正了对高分屏的处理支持不是整数的缩放 qputenv(\"QT_ENABLE_HIGHDPI_SCALING\", \"1\"); QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough); //禁用缩放 //测试发现AA_Use96Dpi属性在Qt5.9以上版本完全正常，以下版本比如5.7有部分控件在175%缩放不正常比如QTextEdit，需要外层套个widget才行。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) QApplication::setAttribute(Qt::AA_Use96Dpi); #endif #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,14,0)) QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要","date":"0001-01-01","objectID":"/1/01/qt/:0:14","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"15：141-150 QImage支持xpm图标，查看Qt内置的QStyle风格的代码中可以发现大量的xpm图标定义，通过代码的形式来产生图标，哇咔咔好牛逼。 static const char * const imgData[] = { \"15 11 6 1\", \" c None\", \"+ c #979797\", \"@ c #C9C9C9\", \"$ c #C1C1C1\", \"b c None\", \"d c None\", \" $++++++++$ \", \"$+bbbbbbbb+$ \", \"+b $$ +$ \", \"+b $@ +$ \", \"+b +$\", \"+b d+\", \"+b d+$\", \"+b $$ d+$ \", \"+b $@ d+$ \", \"$+dddddddd+$ \", \" $++++++++$ \"}; //这样就能直接显示一个箭头的图形 QImage img(imgData); QLabel lab; lab.setPixmap(QPixmap::fromImage(img)); lab.show(); 在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文。 int main(int argc, char *argv[]) { //需要设置共享上下文不然停靠窗体从正常到浮动后QOpenGLWidget窗体会失效 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,4,0)) QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts); #endif QApplication a(argc, argv); ... } 关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99%以上的Qt版本的乱码问题。 第一步：代码文件选择用utf8编码带bom。 第二步：在有中文汉字的代码文件顶部加一行（一般是cpp文件） #pragma execution_character_set(“utf-8”) 可以考虑放在head.h中，然后需要的地方就引入head头文件就行，而不是这行代码写的到处都是；这行代码是为了告诉msvc编译器当前代码文件用utf8去编译。 第三步：main函数中加入设置编码的代码，以便兼容Qt4，如果没有Qt4的场景可以不用，从Qt5开始默认就是utf8编码。 void QUIHelper::setCode() { #if (QT_VERSION \u003c= QT_VERSION_CHECK(5,0,0)) #if _MSC_VER QTextCodec *codec = QTextCodec::codecForName(\"gbk\"); #else QTextCodec *codec = QTextCodec::codecForName(\"utf-8\"); #endif QTextCodec::setCodecForLocale(codec); QTextCodec::setCodecForCStrings(codec); QTextCodec::setCodecForTr(codec); #else QTextCodec *codec = QTextCodec::codecForName(\"utf-8\"); QTextCodec::setCodecForLocale(codec); #endif } 关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论。 Qt在二进制兼容这块，已经做了最大的努力，通过将各种代码细节隐藏，Q指针+D指针技巧，尽量保持了接口的统一； 是否兼容最主要考虑编译器的因素，毕竟任何Qt版本都是需要通过编译器编译成对应的二进制文件，由他说了算。如果两个Qt版本采用的编译器版本一样，极大概率可执行文件是兼容的，比如 Qt5.10+msvc2015 32 位 和 Qt5.11+msvc2015 32位 编译出来的可执行文件，都用Qt5.11的库是可行的； mingw编译器的Qt版本也是如此，就是因为Qt官方安装包集成的mingw编译器一直在更新（极少附近版本没有更新mingw编译器版本除外），比如5.7用的mingw53，5.12用的mingw73，5.15用的mingw81，因为带的Qt库也是这个编译器编译出来的，所以导致看起来全部不兼容； 如果想要完全兼容，还有一个注意要素，那就是对应代码使用的类的头文件接口是否变了，按道理原有的接口极少会变，一般都是新增加，或者大版本才会改变，比如Qt4-Qt5-Qt6这种肯定没法兼容的，接口和模块都变了； 大胆的猜测：如果Qt5.6到Qt5.15你全部用一种编译器比如mingw73或者msvc2015重新编译生成对应的Qt运行库，然后在此基础上开发程序，最后生成的可执行文件用Qt5.15的库是都可以的，这样就轻松跨越了多个版本兼容； 大胆的建议：在附近的几个版本统一编译器，比如5.6-5.12之间就统一用mingw53或者msvc2015,5.12-5.15统一用msvc2017，要尝鲜其他编译器的可以自行源码编译其他版本，这样最起码附近的一大段版本（大概2-3年的版本周期）默认就兼容了。 本人测试的是widget部分，qml未做测试，不清楚是否机制一样； 通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4.7到5.15任意版本，通过查看对应函数的源码可以看到内部会检查是否是 ‘file:///’ 开头，是的话则自动读取样式表文件进行设置，无需手动读取。 //以前都是下面的方法 QFile file(\":/qss/psblack.css\"); if (file.open(QFile::ReadOnly)) { QString qss = QLatin1String(file.readAll()); qApp-\u003esetStyleSheet(qss); file.close(); } //其实一行代码就行 qApp-\u003esetStyleSheet(\"file:///:/qss/psblack.css\"); //特别说明，只支持qApp-\u003esetStyleSheet 不支持其他比如widget-\u003esetStyleSheet Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板 QCalendarWidget 就是 QToolButton+QSpinBox+QTableView 等组成，妙用 findChildren 可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等。 //打印子类类名集合 void printObjectChild(const QObject *obj, int spaceCount) { qDebug() \u003c\u003c QString(\"%1%2 : %3\") .arg(\"\", spaceCount) .arg(obj-\u003emetaObject()-\u003eclassName()) .arg(obj-\u003eobjectName()); QObjectList childs = obj-\u003echildren(); foreach (QObject *child, childs) { printObjectChild(child, spaceCount + 2); } } //拿到对话框进行设置和美化 QFileDialog *fileDialog = new QFileDialog(this); fileDialog-\u003esetOption(QFileDialog::DontUseNativeDialog, true); QLabel *lookinLabel = fileDialog-\u003efindChild\u003cQLabel*\u003e(\"lookInLabel\"); lookinLabel-\u003esetText(QString::fromLocal8Bit(\"文件目录：\")); lookinLabel-\u003esetStyleSheet(\"color:red;\"); //设置日期框默认值为空 QLineEdit *edit = ui-\u003edateEdit-\u003efindChild\u003cQLineEdit *\u003e(\"qt_spinbox_lineedit\"); if (!edit-\u003etext().isEmpty()) { edit-\u003eclear(); } Qt内置了各种对话框，比如文件对话框-QFileDialog ，颜色对话框-QColorDialog ，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理。 QFileDialog *fileDialog = new QFileDialog(this); //不设置此属性根本查找不到任何子元素,因为默认采用的系统对话框 fileDialog-\u003esetOption(QFileDialog::DontUseNativeDialog, true); qDebug() \u003c\u003c fileDialog-\u003efindChildren\u003cQLabel *\u003e(); //打印","date":"0001-01-01","objectID":"/1/01/qt/:0:15","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"16：151-160 当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载。 //Qt中使用二进制资源文件方法如下 //将qrc编译为二进制文件rcc，在控制台执行下列命令 rcc -binary main.qrc -o main.rcc //在应用程序中注册资源，一般在main函数启动后就注册 QResource::registerResource(qApp-\u003eapplicationDirPath() + \"/main.rcc\"); 关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有。 //假设窗体中有子控件，默认字体12px，父类类型是QWidget，父类类名是Widget //下面几种方法只会设置主窗体的字体，子控件不会应用，需要按个调用setFont QFont font; font.setPixelSize(20); this-\u003esetFont(font); this-\u003esetStyleSheet(\"{font:26px;}\"); this-\u003esetStyleSheet(\"QWidget{font:26px;}\"); this-\u003esetStyleSheet(\"Widget{font:26px;}\"); //下面才是通过样式表设置整个控件+子控件的字体 this-\u003esetStyleSheet(\"font:26px;\"); this-\u003esetStyleSheet(\"*{font:26px;}\"); this-\u003esetStyleSheet(\"QWidget\u003e*{font:26px;}\"); this-\u003esetStyleSheet(\"Widget\u003e*{font:26px;}\"); //下面设置全局字体 qApp-\u003esetFont(font); Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format_ARGB32或者Format_RGBA8888。 //pixel 函数获取像素点的颜色 setPixel 函数设置像素点的颜色 此函数任意Qt版本都有 //pixelColor 函数获取像素点的颜色 setPixelColor 函数设置像素点的颜色 此函数Qt5.6以后才有 //pixel函数取出来的是QRgb格式需要用 qRed qGreen qBlue qAlpha 进行转换 QImage image(\"1.png\"); image = image.convertToFormat(QImage::Format_ARGB32); int width = image.width(); int height = image.height(); //遍历图像的每一个像素 for (int x = 0; x \u003c width; ++x) { for (int y = 0; y \u003c height; ++y) { QString name = image.pixelColor(x, y).name(); //将白色以外的颜色全部替换成红色 if (name != \"#ffffff\") { image.setPixelColor(x, y, Qt::red); } } } //保存文件 image.save(\"2.png\"); 在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论。 Qt天生内置了sqlite数据库，只需要发布的时候带上插件就行（可以看到插件动态库文件比其他几种都要大，那是因为直接将数据库的源码都编译进去了，而其他只编译了中间通信交互的插件源码），其他数据库要么还要带上动态库，要么还需要创建数据源； 速度上，绝对无与伦比的出类拔萃，同样的数据库结构（表结构、索引等完全一致），查询速度和批量更新速度、数据库事务等，速度都是其他几种的至少3倍以上，而且随着数据量的增大对比越发明显； 几千万的数据量完全没问题，而且速度和性能都还可以，不要以讹传讹网上部分菜鸡说的不支持百万以上的数据量，本人亲测亿级别，数据量建议千万级别以下，着重注意数据库表和索引的设计； 其他数据库还要注意版本的区别，ODBC数据源形式还容易出错和执行失败； sqlite数据库也有几个重大缺点：不支持加密，不支持网络访问，不支持部分数据库高级特性，不支持海量数据（亿级别以上），但是对于绝大部分Qt项目还是足够； 数据库支持友好度大致是 sqlite \u003e postgresql \u003e mysql \u003e odbc ; 以上都是在Qt环境中个人测试得出的结论，结果未必正确，作为参考即可，其他编程环境比如C#、JAVA请忽略，也许差别可能在中间通信的效率造成的； Qt5.10以后提供了新的类 QRandomGenerator QRandomGenerator64 管理随机数，使用更方便，尤其是取某个区间的随机数。 //早期处理办法 先初始化随机数种子然后取随机数 qsrand(QTime::currentTime().msec()); //取 0-10 之间的随机数 qrand() % 10; //取 0-1 之间的浮点数 qrand() / double(RAND_MAX); //新版处理办法 支持5.10以后的所有版本包括qt6 QRandomGenerator::global()-\u003ebounded(10); //生成一个0和10之间的整数 QRandomGenerator::global()-\u003ebounded(10.123); //生成一个0和10.123之间的浮点数 QRandomGenerator::global()-\u003ebounded(10, 15); //生成一个10和15之间的整数 //兼容qt4-qt6及以后所有版本的方法 就是用标准c++的随机数函数 srand(QTime::currentTime().msec()); rand() % 10; rand() / double(RAND_MAX); //通用公式 a是起始值,n是整数的范围 int value = a + rand() % n; //(min, max)的随机数 int value = min + 1 + (rand() % (max - min - 1)); //(min, max]的随机数 int value = min + 1 + (rand() % (max - min + 0)); //[min, max)的随机数 int value = min + 0 + (rand() % (max - min + 0)); //[min, max]的随机数 int value = min + 0 + (rand() % (max - min + 1)); //如果在线程中取随机数，线程启动的时间几乎一样，很可能出现取到的随机数一样的问题，就算设置随机数为当前时间啥的也没用，电脑太快很可能还是一样的时间，同一个毫秒。 //取巧办法就是在run函数之前最前面将当前线程的id作为种子设置。时间不可靠，线程的id才是唯一的。 //切记 void * 转换到数值必须用 long long，在32位是可以int但是在64位必须long，确保万一直接用quint64最大 srand((long long)currentThreadId()); qrand((long long)currentThreadId()); Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下。 void frmMain::on_btnMenu_Max_clicked() { ...... //最大化以后有个BUG,悬停样式没有取消掉,需要主动模拟鼠标动一下 QEvent event(QEvent::Leave); QApplication::sendEvent(ui-\u003ebtnMenu_Max, \u0026event); } 项目中启用c++11语法支持。 greaterThan(QT_MAJOR_VERSION, 4): CONFIG += c++11 lessThan(QT_MAJOR_VERSION, 5): QMAKE_CXXFLAGS += -std=c++11 Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多。 ui-\u003etextEdit-\u003esetUndoRedoEnabled(false); 其他几点常规小经验，本人在这几个地方摔跤过很多次。 有返回值的函数，一定要主动return返回值，有部分编译器在没有返回值的情况下也能正常编译通过，但是运行的时候会出问题，得不到想要的结果，因为没有return对应的值。 定义的局部变量，主动给定个初始值，是个必须养成的好习惯，不然编译器给的初始值很可能不是你想要的，比如int变量默认0，有时候随机变成一个很大的数值，bool变量的初始值不同编译器不同值，有些是true有些是false，主动给一个初始值更可靠。 某些函数参数很多，而且后期可能还会修改","date":"0001-01-01","objectID":"/1/01/qt/:0:16","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"17：161-170 经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条。 Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5.9以前需要拿到原有的窗体属性做运算，后面可以用新的方法。 //增加一个无边框属性 setWindowFlags(windowFlags() | Qt::FramelessWindowHint); //移除无边框属性 setWindowFlags(windowFlags() \u0026 ~Qt::FramelessWindowHint); //下面是5.9以后新增的方法 //增加一个无边框属性到窗体属性链表 setWindowFlag(Qt::FramelessWindowHint, true); //从窗体属性链表中移除无边框属性 setWindowFlag(Qt::FramelessWindowHint, false); 如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸。 setMinimumSize(0, 0); setMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX); Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-\u003emouseButtons()，全局的鼠标坐标可以用QCursor::pos()。 //在鼠标右键的地方弹出菜单，如果菜单是QMenu而不是QAction则只能通过下面的方式弹出 if (qApp-\u003emouseButtons() == Qt::RightButton) { videoMenu-\u003eexec(QCursor::pos()); } //全局剪切板 qApp-\u003eclipboard(); //顶层控件对象集合 qApp-\u003etopLevelWidgets() //当前焦点所在控件 qApp-\u003efocusWidget() //当前平台名称 qApp-\u003eplatformName() //调用系统蜂鸣器 qApp-\u003ebeep() //打印当前Qt版本信息 qApp-\u003eaboutQt() //设置全局的鼠标样式 qApp-\u003esetOverrideCursor() //不使用系统的标准颜色字体等 QGuiApplication::setDesktopSettingsAware(bool on); QApplication app(argc, argv); //更多的全局对象属性等可以查阅 qguiapplication.h 头文件，你会发现新大陆。 Qt对区分不同的编译器也做了非常细致的处理。 #pro文件可以这样判断 msvc { //要做的处理 } mingw { //要做的处理 } //代码中可以这样判断 #ifdef Q_CC_MINGW //mingw编译器 #elif Q_CC_MSVC //msvc编译器 #endif //判断编译器和编译器版本 #if defined Q_CC_MSVC \u0026\u0026 _MSC_VER \u003c 1300 #if defined(Q_CC_GNU) \u0026\u0026 (__GNUC__ \u003c 4) //代码中判断ARM平台 #ifdef QT_ARCH_ARM //多个条件判断 #if defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE) 有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用 blockSignals 方法。 //方法1：先 disconnect 掉信号，处理好以后再 connect 信号，缺点很明显，很傻，如果信号很多，每个型号都要这么来一次。 disconnect(ui-\u003ecbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int))); for (int i = 0; i \u003c= 100; i++) { ui-\u003ecbox-\u003eaddItem(QString::number(i)); } connect(ui-\u003ecbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int))); //方法2：先调用 blockSignals(true) 阻塞信号，处理号以后再调用 blockSignals(false) 恢复所有信号。 //如果需要指定某个信号进行断开那就只能用 disconnect 来处理。 ui-\u003ecbox-\u003eblockSignals(true); for (int i = 0; i \u003c= 100; i++) { ui-\u003ecbox-\u003eaddItem(QString::number(i)); } ui-\u003ecbox-\u003eblockSignals(false); 项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2。 //方法1：pro文件直接全部引入，而不是每个都添加一次，省心省力。 HEADERS += *.h SOURCES += *.cpp //方法2：分模块文件夹存放，不同模块用pri包含代码文件，比如界面可以放在ui文件夹，下面搞个ui.pri，然后pro项目文件只需要引入这个pri文件即可。 include($$PWD/ui/ui.pri) //还可以加上一句包含路径这样可以省去在使用代码的时候不用写文件夹 INCLUDEPATH += $$PWD/ui //加上上面这行，在使用头文件的时候可以直接 include \"form.h\"，没有加则需要 include \"ui/form.h\"。 在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农名工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的。 //tcp客户端 QTcpSocket *socket = new QTcpSocket(this); //断开所有连接和操作 socket-\u003eabort(); //绑定网卡和端口 socket-\u003ebind(QHostAddress(\"192.168.1.2\"), 6005); //连接服务器 socket-\u003econnectToHost(\"192.168.1.3\", 6000); //打印通信用的本地绑定地址和端口 qDebug() \u003c\u003c socket-\u003elocalAddress() \u003c\u003c socket-\u003elocalPort(); //打印通信服务器对方的地址和端口 qDebug() \u003c\u003c socket-\u003epeerAddress() \u003c\u003c socket-\u003epeerPort() \u003c\u003c socket-\u003epeerName(); //udp客户端 QUdpSocket *socket = new QUdpSocket(this); //绑定网卡和端口,没有绑定过才需要绑定 //采用端口是否一样来判断是为了方便可以直接动态绑定切换端口 if (socket-\u003elocalPort() != 6005) { socket-\u003eabort(); socket-\u003ebind(QHostAddress(\"192.168.1.2\"), 6005); } //指定地址和端口发送数据 socket-\u003ewriteDatagram(buffer, QHostAddress(\"192.168.1.3\"), 6000); //上面是Qt5可以使用bind，","date":"0001-01-01","objectID":"/1/01/qt/:0:17","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"18：171-180 在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen_s函数，比如fmod中也是这个情况。这个时候就需要转码处理。 QString fileName = \"c:/测试目录/1.txt\"; //如果应用程序main函数中没有设置编码则默认采用系统的编码，可以直接通过toLocal8Bit转成正确的数据 const char *name = fileName.toLocal8Bit().constData(); //如果设置过了下面两句则需要主动转码 QTextCodec *codec = QTextCodec::codecForName(\"utf-8\"); QTextCodec::setCodecForLocale(codec); QTextCodec *code = QTextCodec::codecForName(\"gbk\"); const char *name = code-\u003efromUnicode(fileName).constData(); //推荐方式2以防万一保证绝对的正确，哪怕是设置过主程序的编码 //切记一旦设置过QTextCodec::setCodecForLocale会影响toLocal8Bit //有时候可能还有下面这种情况 #ifdef Q_OS_WIN #if defined(_MSC_VER) \u0026\u0026 (_MSC_VER \u003e= 1400) QTextCodec *code = QTextCodec::codecForName(\"utf-8\"); #else QTextCodec *code = QTextCodec::codecForName(\"gbk\"); #endif const char *name = code-\u003efromUnicode(fileName).constData(); #else const char *name = fileName.toUtf8().constData(); #endif 在查阅和学习Qt源码的过程中，发现了一些趋势和改变。 数据类型这块尽量用Qt内部的数据类型，哪怕是重定义过的比如quint8其实unsigned char，qreal就是double，以前翻看源码的时候可能还有些是double，现在慢慢改成了qreal。 循环结构用 for(;;) 替代 while(1)，因为转成汇编指令后 for(;;) 只有一条指令而 while(1) 确有4条，指令少不占用寄存器而且不用跳转，理论上速度要更快。 其实Qt中就重定义了 forever 关键字表示 for(;;) ，我的乖乖，想的真周到。 自动c++11以及后续的标准都支持auto万能数据类型，发现Qt的源码中也慢慢的改成了auto，这样加快了编写代码的效率，不用自己去指定数据类型而是让编译器自己推导数据类型。而且其实也不影响编译器编译的速度，因为无论指定和没有指定数据类型，编译器都要推导右侧的数据类型进行判断。不过有个缺点就是影响了阅读代码的成本，很多时候需要自己去理解推导。 Qt中设置或者打开加载本地文件需要用到QUrl类，本地文件建议加上 file:/// 前缀。 QString url = \"file:///c:/1.html\"; //浏览器控件打开本地网页文件 webView-\u003esetUrl(QUrl(url)); //打开本地网页文件，下面两种方法都可以 QDesktopServices::openUrl(QUrl::fromLocalFile(url)); QDesktopServices::openUrl(QUrl(url, QUrl::TolerantMode)); 在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5.15开始内置了setTransferTimeout来设置超时时间，非常好用。 //局部的事件循环,不卡主界面 QEventLoop eventLoop; //设置超时 5.15开始自带了超时时间函数 默认30秒 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,15,0)) manager-\u003esetTransferTimeout(timeout); #else QTimer timer; connect(\u0026timer, SIGNAL(timeout()), \u0026eventLoop, SLOT(quit())); timer.setSingleShot(true); timer.start(timeout); #endif QNetworkReply *reply = manager-\u003eget(QNetworkRequest(QUrl(url))); connect(reply, SIGNAL(finished()), \u0026eventLoop, SLOT(quit())); eventLoop.exec(); if (reply-\u003ebytesAvailable() \u003e 0 \u0026\u0026 reply-\u003eerror() == QNetworkReply::NoError) { //读取所有数据保存成文件 QByteArray data = reply-\u003ereadAll(); QFile file(dirName + fileName); if (file.open(QFile::WriteOnly | QFile::Truncate)) { file.write(data); file.close(); } } Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick/qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。 //如果是控制台程序则下面的QApplication换成QCoreApplication //如果是quick/qml程序则下面的QApplication换成QGuiApplication int main(int argc, char *argv[]) { //可以用下面这行测试Qt自带的输入法 qtvirtualkeyboard qputenv(\"QT_IM_MODULE\", QByteArray(\"qtvirtualkeyboard\")); //设置不应用操作系统设置比如字体 QApplication::setDesktopSettingsAware(false); #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) //设置高分屏缩放舍入策略 QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif #if (QT_VERSION \u003e QT_VERSION_CHECK(5,6,0)) //设置启用高分屏缩放支持 //要注意开启后计算到的控件或界面宽度高度可能都不对,全部需要用缩放比例运算下 QApplication::setAttribute(Qt::AA_EnableHighDpiScaling); //设置启用高分屏图片支持 QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps); #endif #if (QT_VERSION \u003e QT_VERSION_CHECK(5,4,0)) //设置opengl模式 AA_UseDesktopOpenGL(默认) AA_UseOpenGLES AA_UseSoftwareOpenGL //在一些很旧的设备上或者对opengl支持很低的设备上需要使用AA_UseOpenGLES表示禁用硬件加速 //如果开启的是AA_UseOpenGLES则无法使用硬件加速比如ffmpeg的dxva2 //QApplication::setAttribute(Qt::AA_UseOpenGLES); //设置opengl共享上下文 QApplication::setAttribute(Qt::AA_ShareOpenGLContexts); #endif QApplication a(argc, argv); QWidget w; w.show(); return a.exec(); } QCamera中获取设备的配置参数比如支持的分辨率集合等，需要先调用load后才能正确获取，或者关联stateChanged信号中判断状态是否是ActiveState，然后再读取。 //方法1：调用load后获取 camera = new QCamera(this); //先需要载入才能获取到对应参数 camera-\u003eload(); //输出当前设备支持的分辨率 QList\u003cQSize\u003e sizes = camera-\u003esupportedViewfinderResolutions(); emit resolutions(sizes); //","date":"0001-01-01","objectID":"/1/01/qt/:0:18","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"19：181-190 Qt天生就是linux的，从linux开始发展起来的，所以不少Qt程序员经常的开发环境是linux，比如常用的ubuntu等系统，整理了一点常用的linux命令。 命令 功能 sudo -s 切换到管理员，如果是 sudo -i 切换后会改变当前目录。 apt install g++ 安装软件包（要管理员权限），另一个派系的是 yum install。 cd /home 进入home目录。 ls 罗列当前所在目录所有目录和文件。 ifconfig 查看网卡信息包括IP地址，windows上是 ipconfig。 tar -zxvf bin.tar.gz 解压文件到当前目录。 tar -jxvf bin.tar.xz 解压文件到当前目录。 tar -zxvf bin.tar.gz -C /home 解压文件到/home目录，记住是大写的C。 tar -zcvf bin.tar.gz bin 将bin目录压缩成tar.gz格式文件（压缩比一般）。 tar -jcvf bin.tar.xz bin 将bin目录压缩成tar.xz格式文件（压缩比高，推荐）。 tar -… j z 表示不同的压缩方法，x表示解压，c表示压缩。 gedit 1.txt 用记事本打开文本文件。 vim 1.txt 用vim打开文件，很多时候可以缩写用vi。 ./configure make -j4 make install 通用编译源码命令，第一步./configure执行配置脚本，第二步make -j4启用多线程编译，第三步make install安装编译好的文件。 ./configure -prefix /home/liu/Qt-5.9.3-static -static -sql-sqlite -qt-zlib -qt-xcb -qt-libpng -qt-libjpeg -fontconfig -system-freetype -iconv -nomake tests -nomake examples -skip qt3d -skip qtdoc Qt通用编译命令。 ./configure -static -release -fontconfig -system-freetype -qt-xcb -qt-sql-sqlite -qt-zlib -qt-libpng -qt-libjpeg -nomake tests -nomake examples -prefix /home/liu/qt/Qt5.6.3 Qt静态带中文。 ./configure -prefix /home/liu/Qt-5.9.3-static -static -release -nomake examples -nomake tests -skip qt3d 精简编译命令。 ./configure –prefix=host –enable-static –disable-shared –disable-doc ffmpeg编译命令。 Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等。 //Qt5开始提供了日志上下文信息输出，比如输出当前打印消息所在的代码文件、行号、函数名等。 //如果是release还需要在pro中加上 DEFINES += QT_MESSAGELOGCONTEXT 才能输出上下文，默认release关闭的。 //切记不要在日志钩子函数中再写qdebug之类的，那样就死循环了。 //日志重定向一般就三种处理 //1: 输出到日志文件比如txt文本文件。 //2: 存储到数据库，可以分类存储，以便相关人员查询分析。 //3: 重定向到网络，对方用小工具连接程序后，所有打印信息通过tcp发过去。 //日志重定向 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) void Log(QtMsgType type, const QMessageLogContext \u0026context, const QString \u0026msg) #else void Log(QtMsgType type, const char *msg) #endif { //加锁,防止多线程中qdebug太频繁导致崩溃 static QMutex mutex; QMutexLocker locker(\u0026mutex); QString content; //这里可以根据不同的类型加上不同的头部用于区分 switch (type) { case QtDebugMsg: content = QString(\"%1\").arg(msg); break; case QtWarningMsg: content = QString(\"%1\").arg(msg); break; case QtCriticalMsg: content = QString(\"%1\").arg(msg); break; case QtFatalMsg: content = QString(\"%1\").arg(msg); break; } //加上打印代码所在代码文件、行号、函数名 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) if (SaveLog::Instance()-\u003egetUseContext()) { int line = context.line; QString file = context.file; QString function = context.function; if (line \u003e 0) { content = QString(\"行号: %1 文件: %2 函数: %3\\n%4\").arg(line).arg(file).arg(function).arg(content); } } #endif //将内容传给函数进行处理 SaveLog::Instance()-\u003esave(content); } //安装日志钩子,输出调试信息到文件,便于调试 void SaveLog::start() { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) qInstallMessageHandler(Log); #else qInstallMsgHandler(Log); #endif } //卸载日志钩子 void SaveLog::stop() { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) qInstallMessageHandler(0); #else qInstallMsgHandler(0); #endif } 自从c++11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记。 代码格式：capture mutable -\u003ereturn-type {statement} [capture]：捕捉列表，捕捉列表总是出现在Lambda函数的开始处，实际上，[]是Lambda引出符，编译器根据该引出符判断接下来的代码是否是Lambda函数，捕捉列表能够捕捉上下文中的变量以供Lambda函数使用。 (parameters)：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以连同括号 () 一起省略。 mutable：mutable修饰符，默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。 -\u003ereturn-type：返回类型，用追踪返回类型形式声明函数的返回类型，我们可以在不需要返回值的时候也可以连同符号 -\u003e 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。 {statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。 捕捉列表有以下几种形式： [var]表示值传递方式捕捉变量var。 [=]表示值传递方式捕捉所有父作用域的变量（包括this）。 [\u0026var]表示引用传递捕捉变量var。 [\u0026]表示引用传递方式捕捉所有父作用域的变量（包括this）。 [this]表示值传递方式捕捉当前的this指针。 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-\u003esetupUi(this); //按钮单击不带参数 connect(ui-\u003epushButton, \u0026QPushButton::clicked, [] { qDebug() \u003c\u003c \"hello lambda\"; }); //按钮单击带参数 connect(ui-\u003epushButton, \u0026QPushButton::clicked, [] (bool isCheck) { qDebug() \u003c\u003c \"hello lambda\" \u003c\u003c isCheck; }); //自定义信号带参数 connect(this, \u0026MainWindow::sig_test, [] (int i, int j) { qDebug() \u003c\u003c \"hello lambda\" \u003c\u003c i ","date":"0001-01-01","objectID":"/1/01/qt/:0:19","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"20：191-200 关于QList队列的处理中，我们最常用的就是调用append函数添加item，往前插入item很多人第一印象就是调用insert(0,xxx)来插入，其实QList完全提供了往前追加item的函数prepend、push_front。 QStringList list; list \u003c\u003c \"aaa\" \u003c\u003c \"bbb\" \u003c\u003c \"ccc\"; //往后追加 等价于 append list.push_back(\"ddd\"); //往前追加 等价于 prepend list.push_front(\"xxx\"); //往后追加 list.append(\"ddd\"); //往前追加 list.prepend(\"xxx\"); //指定第一个位置插入 等价于 prepend list.insert(0, \"xxx\"); //输出 QList(\"xxx\", \"aaa\", \"bbb\", \"ccc\", \"ddd\") qDebug() \u003c\u003c list; Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型。 //qwindowdefs.h typedef QList\u003cQWidget *\u003e QWidgetList; typedef QList\u003cQWindow *\u003e QWindowList; typedef QHash\u003cWId, QWidget *\u003e QWidgetMapper; typedef QSet\u003cQWidget *\u003e QWidgetSet; //qmetatype.h typedef QList\u003cQVariant\u003e QVariantList; typedef QMap\u003cQString, QVariant\u003e QVariantMap; typedef QHash\u003cQString, QVariant\u003e QVariantHash; typedef QList\u003cQByteArray\u003e QByteArrayList; Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值。 Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5.6开始提供了 AA_EnableHighDpiScaling 的属性设置开启高分屏，到了5.14以后还可以指定缩放的策略 HighDpiScaleFactorRoundingPolicy 比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了 AA_EnableHighDpiScaling 属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放。 //永远不应用高分屏及缩放 int main(int argc, char *argv[]) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) QApplication::setAttribute(Qt::AA_Use96Dpi); #endif #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,14,0)) QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif QApplication a(argc, argv); .... return a.exec(); } //自动应用高分屏及缩放 //方法很多，综合对比下来还是采用配置文件指定缩放策略最适中。 //新建qt.conf文件放到可执行文件同一目录 [Platforms] WindowsArguments = dpiawareness=0 //有时候想让用户去选择何种策略，需要开启高分屏的之后只需要将qt.conf文件放到可执行文件同一目录即可，就算代码中设置了不应用高分屏及缩放，也无效，也是优先取qt.conf文件的策略。 关于QSS要注意的坑。 qss源自css，相当于css的一个子集，主要支持的是css2标准，很多网上的css3的标准的写法在qss这里是不生效的，所以不要大惊小怪。 qss也不是完全支持所有的css2，比如text-align官方文档就有说明，只支持 QPushButton and QProgressBar，务必看清楚。 有时候偷懒直接来一句 *{xxx}，你会发现大部分是应用了，也有小部分或者极个别没有应用，你可能需要在对应的窗体中 this-\u003esetStyleSheet() 来设置。 qss的执行是有优先级的，如果没有指定父对象，则对所有的应用，比如在窗体widget中 {color:#ff0000;} 这样会对widget以及widget的所有子对象应用该样式，这种问题各大群每周都有人问，你会发现各种奇奇怪怪的异样不正常，怎么办呢，你需要指定类名或者对象名，比如 #widget{color:#ff0000;} 这样就只会对widget对象应用该样式，另一种写法 QWidget#widget{color:#ff0000;}，只想对窗体本身而不是子控件按钮标签等 .QWidget{color:#ff0000;} ，具体详细规则参见官方说明。 qss整体来说还是可以的，解析速度性能在Qt5高版本后期比Qt4好很多，尤其是修复了不少qss中的解析绘制BUG。尽管有这样那样的BUG，怀着包容的心对待它。 qss官方学习地址1：http://47.100.39.100/qtwidgets/stylesheet-reference.html qss官方学习地址2：http://47.100.39.100/qtwidgets/stylesheet-examples.html 关于Qt延时的几种方法。 void QUIHelperCore::sleep(int msec) { if (msec \u003c= 0) { return; } #if 1 //非阻塞方式延时,现在很多人推荐的方法 QEventLoop loop; QTimer::singleShot(msec, \u0026loop, SLOT(quit())); loop.exec(); #else #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) //阻塞方式延时,如果在主线程会卡住主界面 QThread::msleep(msec); #else //非阻塞方式延时,不会卡住主界面,据说可能有问题 QTime endTime = QTime::currentTime().addMSecs(msec); while (QTime::currentTime() \u003c endTime) { QCoreApplication::processEvents(QEventLoop::AllEvents, 100); } #endif #endif } 随着国产化的兴起，各种国产系统和国产数据库等逐渐进入开发者的世界，罗列几个要点。 中标麒麟neokylin基于centos。 银河麒麟kylin早期版本比如V2基于freebsd，新版本V4、V10基于ubuntu。 优麒麟ubuntukylin就是ubuntu的汉化版本，加了点农历控件啥的。 deepin基于debian。 uos基于deepin或者说是deepin的商业分支。 ubuntu基于debian。 linux界主要分两种发行版本，debian（ubuntu、deepin、uos、银河麒麟kylin等）和redhat（fedora、centos、中标麒麟neokylin、中兴新支点newstart等），分别对应apt-get和yum安装命令。绝大部分的linux系统都基于或者衍生自这两种发行版本。 理论上基于同一种系统内核的，在其上编译的程序可以换到另外的系统运行，前提是编译器版本一致，比如都是gcc4.9，在ubuntu14.04 64位用gcc4.9编译的Qt程序，是能够在uos 64位上运行的。 高版本编译器的系统一般能够兼容低版本的，比如你用gcc4.9编译的程序是能够在gcc7.0上运行，反过来不行。 意味着如果你想尽可能兼容更多的系统，尽量用低版本的编译器编译你的程序，当然要你的程序代码语法支持，比如c++11就要从gcc4.7开始才支持，如果你的代码用了c++11则必须至少选择gcc4.7版本及以上。 用Qt编写linux程序为了发布后的可执行文件可以兼容各种linux系统，只要在这两种内核（debian、redhat）的系统上用低版本的编译器比如gcc4.7编译qt程序发布即可。 2022-01-27补充：根据Qt官方安装包，发现基于redhat的gcc4.9编译器发布的，通用各种linux系统（亲测ubuntu各个版本、fedora、centos、deepin、uos、银河麒麟kylin、中标麒","date":"0001-01-01","objectID":"/1/01/qt/:0:20","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"21：201-210 编译生成debug版本动态库，文件末尾自动加上d结尾。 CONFIG(debug, debug|release) { win32: TARGET = $$join(TARGET,,,d) mac: TARGET = $$join(TARGET,,,_debug) unix:!mac: TARGET = $$join(TARGET,,,d) } QtCreator中pro项目文件格式说明。 名称 说明 QT += core gui 添加本项目中需要的模块，影响后面代码文件include的时候自动弹出下拉选择，如果pro文件没有引入该模块则无法自动语法提示，一般打包发布的时候对应动态库文件比如 Qt5Core.dll。 TARGET = xxx 生成最后目标文件的名字，可以是可执行文件或者库文件。 TEMPLATE = app 项目程序的生成模式，默认是app表示生成可执行文件程序，如果是动态库项目就是 TEMPLATE = lib。 CONFIG += qaxcontainer 引入一些配置，在Qt4的时候还用来引入一些模块，其中有部分改成了QT += 方式引入，比如Qt5引入本地activex控件支持改成了QT += qaxcontainer。 DEFINES += xxx 项目中自定义的一些定义，可以在代码文件中识别，通常用来定义一些不同平台的处理，根据项目需要自己定义任何标识。 HEADERS += head.h 项目中用到的头文件，一般拓展名是.h，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。 SOURCES += main.cpp 项目中用到的实现文件，一般拓展名是.cpp，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。 FORMS += Form.ui 项目中用到的UI文件，一般拓展名是.ui，可以写在一行也可以分行写，分行要用 \\ 斜杠结束。 RESOURCES += main.qrc 项目中用到的资源文件，可以多个，写代码使用对应资源文件中的文件时候务必记得资源文件中的前缀。 LIBS += -L$$PWD/ -lavformat -lavcodec 项目中编译时候链接依赖的库，一般是 .lib .a .dylib 文件，可以写在一行，省略文件名的lib打头部分，也可以分多行绝对路径和全名称。 DESTDIR += $$PWD/bin 目标生成路径，$$PWD表示当前目录，一般建议生成的最终文件重定向到另外目录存放，好找，不然一堆临时文件在里面有时候文件太多好难找。 INCLUDEPATH += $$PWD/include 工程需要的头文件，指定整个目录，写代码的时候找到的话会自动下拉。 DEPENDPATH += 工程的依赖路径，用的比较少，一般涉及到引入链接库的时候可能需要。 include($$PWD/3rd.pri) 引入pri模块文件，pri最大的好处就是分目录管理文件，通用的轮子模块可以放到一个目录下，然后用pri统一管理，可以给多个项目公用。 官方详细地址https://doc.qt.io/qt-5/qmake-variable-reference.html 如果发现之前编译正常，突然之间再编译就一直死循环的样子，停留在一行提示并疯狂不停的打印，或者提示文件时间在未来，这说明你很可能改过开发环境的时间（比如测试某个授权文件失效），导致有修改过文件的保存时间在未来，你只需要将时间调整回来，将最后更新时间不正确的代码文件重新保存下就行。Qt的增量编译是根据文件的最后修改时间来判定的，最后的修改时间比上一次的修改时间还要新则认为该文件被修改过，需要重新编译该文件。 Qt的构建套件一般是在安装Qt开发环境的时候自动设置的，当然也可以手动设置，手动设置的时候千万要注意编译器和Qt库必须一致，否则该构建套件是有问题的，千万不能乱设置，尤其是对构建套件命名的时候最好标明qt版本和编译器版本，最好也要一致，不要说名称叫msvc而编译器选择的确是mingw，这样尽管能正常使用该构建套件，但是会造成一种误解，还以为该套件是msvc的，其实里面是mingw的。有个qter说他的qt坏了，死活编译失败，远程一看，尼玛，构建套件名称写的qt_msvc2019 编译器选择的msvc2015（他电脑只安装了vs2015），qt库选择的mingw！差点狂扇自己八个耳光，太离谱了！ 当你编译Qt程序发现编译通不过提示报错，而且报错提示在Qt的头文件的时候，不要去尝试着修改Qt头文件来编译通过，那样没用的，你使用的Qt的库是已经根据原始的头文件编译好的。如果报错提示在编译生成的临时的moc等文件，你也不要尝试去修改他，那个是临时文件，这次你改好了也许编译通过了，你重新编一下又覆盖了还是旧的错误。总之你要从源头（你的代码）找问题。 有时候需要对文本进行分散对齐显示，相当于无论文字多少，尽可能占满整个空间平摊占位宽度，但是在对支持对齐方式的控件比如QLabel调用 setAlignment(Qt::AlignJustify | Qt::AlignVCenter) 设置分散对齐会发现没有任何效果，这个时候就要考虑另外的方式比如通过控制字体的间距来实现分散对齐效果。 QString text = \"测试分散对齐内容\"; //计算当前文本在当前字体下占用的宽度 QFont font = ui-\u003elabel-\u003efont(); int textWidth = ui-\u003elabel-\u003efontMetrics().width(text); //显示文本的区域宽度=标签的宽度-两边的边距 int width = ui-\u003elabel-\u003ewidth() - 12; //需要-1相当于中间有几个间隔 int count = text.count() - 1; //计算每个间距多少 qreal space = qreal(width - textWidth) / count; //设置固定间距 font.setLetterSpacing(QFont::AbsoluteSpacing, space); ui-\u003elabel-\u003esetFont(font); ui-\u003elabel-\u003esetText(text); 随着需求的不断增加，程序不断变大，用到的动态库也越来越多，到了发布程序的时候你会发现和可执行文件同一目录下文件数量真多，此时可能会考虑如何将一些库文件分门别类的存放，这样方便管理。 Qt提供的设置动态库路径的方法setLibraryPaths是用来搜索插件动态库的，而不是程序直接依赖的动态库。 很多人以为这个可以设置Qt的库或者程序中依赖的第三方库的路径，其实想想也知道，因为程序依赖这个库，找不到的话根本跑不起来，程序跑不起来怎么应用执行这个代码呢？ Qt默认是可用通过setLibraryPaths的方式设置Qt插件的动态库目录位置，比如数据库插件sqldrivers，因为这些库文件是真正在Qt程序跑起来以后通过插件形式去加载的。 还可以通过qt.conf文件设置 Plugins=“config” 指定所有插件在可执行文件下的config目录下。 要想设置程序直接依赖的动态库在其他目录，找遍全宇宙也只有一个办法，那就是设置环境变量，除此别无他法。 至于如何设置环境变量方式很多，比如手动在电脑上设置，或者搞个批处理文件执行命令行，在程序安装的时候自动执行，或者程序打包目录下用户手动运行这个批处理。 大神补充：设置插件的目录还可以通过在main函数最前面写 qputenv(“PATH”, QString(\"%1;%2”).arg(qgetenv(“PATH”), pluginFileInfo.path()).toLocal8Bit()); 来实现。 网友补充：最终找插件的路径其实就是这个 QT_PLUGIN_PATH 环境变量。 进度条控件如果设置的垂直方向，就算你设置了文本可见，会发现根本看不到进度文本，经过多方百折不挠的试探，以及和酷码大佬深入的探讨，发现只要设置下border样式（border:1px solid #ff0000、border:none、border-style:solid、border-radius:0px 任意一种）就行，就可以把文本显示出来，这TM就不知道Qt为什么总是不统一规则，这个BUG通用于任何版本，这个可能是因为边框的solid样式冲突了导致无法继续绘制，确切的说这必须是BUG，这个锅Qt必须背。 我们在使用QFileDialog::getOpenFileName、QFileDialog::getExistingDirectory等方法时，有时候会发现首次打开很卡，尤其是在默认目录很多文件的时候，此时你可以考虑设置这些函数最末尾的参数为QFileDialog::DontUseNativeDialog，表示不采用本地系统对话框，这样的话会采用Qt的对话框，速度快很多，估计系统的对话框在打开的时候会做很多初始化加载处理。 QFileDialog::getOpenFileName(this, \"\", \"\", \"\", 0, QFileDialog::DontUseNativeDialog); QFileDialog::getExistingDirectory(this, \"\", \"\", QFileDialog::DontUseNativeDialog); 滑块控件QSlider，如果设置的垂直样式，其进度颜色和剩余颜色，刚好和横向样式的颜色相反的，不确定这个是否是Qt的BUG，Qt456都是这个现象。 QSlider::groove","date":"0001-01-01","objectID":"/1/01/qt/:0:21","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"22：211-220 QMainWindow 在对停靠窗体进行排列的时候，有些不常用的设置容易遗忘，建议将 QMainWindow 的头文件函数过一遍一目了然。详细介绍各种停靠参数文章参见 https://zhuanlan.zhihu.com/p/388544168。 //设置允许各种嵌套比如上下排列左右排列非常灵活 //此设置会和下面的 setDockOptions 中的参数覆盖所以要注意顺序 //this-\u003esetDockNestingEnabled(true); //设置停靠参数,不允许重叠,只允许拖动和嵌套 this-\u003esetDockOptions(AnimatedDocks | AllowNestedDocks); //将底部左侧作为左侧区域，底部右侧作为右侧区域，否则底部区域会填充拉伸 this-\u003esetCorner(Qt::BottomLeftCorner, Qt::LeftDockWidgetArea); this-\u003esetCorner(Qt::BottomRightCorner, Qt::RightDockWidgetArea); 当我们在对QModelIndex取数据的时候，常规的角色的数据（QVariant类型支持to的比如toString、toInt、toDouble等）可以很方便的取出来，特定的数据类型需要用的万能取值模板函数 T value() 取出来。 //显示文本 QString text = index.data(Qt::DisplayRole).toString(); //文本对齐 int align = index.data(Qt::TextAlignmentRole).toInt(); //文字字体 QFont font = index.data(Qt::FontRole).value\u003cQFont\u003e(); //前景色 QColor color = index.data(Qt::ForegroundRole).value\u003cQColor\u003e(); //背景色 QColor color = index.data(Qt::BackgroundRole).value\u003cQColor\u003e(); 很多人以为拖曳只要在dropEvent事件就可以了，其实不行的，没有效果的，需要先在dragEnterEvent事件中执行event-\u003eaccept()才行，不然根本没有效果，很多人尤其是初学者都挂在这里，我就是在这里摔了一跤，好疼！ void frmMain::dropEvent(QDropEvent *event) { QList\u003cQUrl\u003e urls = event-\u003emimeData()-\u003eurls(); } void frmMain::dragEnterEvent(QDragEnterEvent *event) { if(event-\u003emimeData()-\u003ehasFormat(\"application/x-qabstractitemmodeldatalist\")) { event-\u003esetDropAction(Qt::MoveAction); event-\u003eaccept(); } else { event-\u003eignore(); } } Qt5.6以后内置的是webengine浏览器内核，如果需要做web交互的话必须用到 qwebchannel.js 这个文件，此文件是Qt官方提供的，所以不建议去改动其中的源码，要注意的是，由于官方对webengine的支持在不断更新，所以官方提供的对应Qt版本的 qwebchannel.js 文件也不同，意味着你要用对应提供的版本的 qwebchannel.js 文件才ok，该文件默认在 C:\\Qt\\Qt5.12.11\\Examples\\Qt-5.12.11\\webchannel\\shared 目录下。经过几十个Qt版本的测试发现，用高版本的 qwebchannel.js 放到低版本运行不行，低版本放到高版本可以，为了万无一失还是建议直接用对应版本的。 对于QString去除空格，有多种场景，可能需要去除左侧、右侧、所有等位置的空格。 //字符串去空格 -1=移除左侧空格 0=移除所有空格 1=移除右侧空格 2=移除首尾空格 3=首尾清除中间留一个空格 QString QUIHelperData::trimmed(const QString \u0026text, int type) { QString temp = text; QString pattern; if (type == -1) { pattern = \"^ +\\\\s*\"; } else if (type == 0) { pattern = \"\\\\s\"; //temp.replace(\" \", \"\"); } else if (type == 1) { pattern = \"\\\\s* +$\"; } else if (type == 2) { temp = temp.trimmed(); } else if (type == 3) { temp = temp.simplified(); } //调用正则表达式移除空格 if (!pattern.isEmpty()) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) temp.remove(QRegularExpression(pattern)); #else temp.remove(QRegExp(pattern)); #endif } return temp; } //测试代码 QString text = \" a b c d \"; //结果：a b c d QUIHelper::trimmed(text, -1); //结果：abcd QUIHelper::trimmed(text, 0); //结果： a b c d QUIHelper::trimmed(text, 1); //结果：a b c d QUIHelper::trimmed(text, 2); //结果：a b c d QUIHelper::trimmed(text, 3); Qt的网络库支持udp广播搜索和组播搜索，其中组播搜索可以跨网段搜索，有时候你会发现失灵，此时你可以尝试把本地的虚拟机的网卡禁用试试，估计就好了。还有就是在本地开启了代理啥的，先关掉试试。近期在使用tcpsocket连接的时候，发现在Qt4和Qt5中正常的程序，到了Qt6中就不行了，报错提示 The proxy type is invalid for this operation ，原来是本地设置了代理导致的，可能在Qt6以前会默认跳过去不处理。 //也可以通过代码设置跳过代理 #include \u003cQNetworkProxy\u003e QNetworkProxyFactory::setUseSystemConfiguration(false); //下面这样每次设置也可以 tcpSocket-\u003esetProxy(QNetworkProxy::NoProxy); //查阅到文章 https://www.cnblogs.com/cppskill/p/11730452.html //从5.8开始socket默认代理类型是DefaultProxy而不是NoProxy，不知道出于什么考虑。 关于交叉编译，对于初学者来说是个极难跨过去的砍（一旦跨过去了以后遇到需要交叉编译的时候都是顺水推舟信手拈来），因为需要搭建交叉编译环境，好在现在厂家提供的板子基本上都是测试好的环境，尤其是提供的编译器，不用自己再去折腾，按照官方手册来基本上不会有啥的的问题。 在linux系统上编译ffmpeg和qt都是非常简单的事情，初学者也会，前提只要本地的gcc g++编译器正常。 任何编译器包括嵌入式编译器，为了确保环境正常，你可以先查看对应的编译器版本是否ok，g++ -v 或者执行编译器所在目录的绝对路径。 交叉编译器查看版本 /opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux-g++ -v 编译器位数和操作系统位数有关，一般32位的编译器要在32位的系统上做交叉编译，虽然32位也可以安装依赖在64位系统做交叉编译，但是个人不建议，可能会出问题。64位的编译器只能在64位的系统。 设置环境变量只是为了编译的时候让自动寻找编译器，其实也完全可以不用设置环境变量，使用绝对路径指定编译器位置即可。 在linux上编译，无论是ffmpeg还是qt还是其他，都是通用的步骤，第一步：./configure 第二步：make 第三步：make install 。 至于具体configure后面有哪些参数，参照对应源码包的手册就行，搜索也一大堆。当然你用默认的就不带任何参数一般也可以，自动采用默认参数进行编译。 交叉编译ffmpeg命令：./configure –prefix=host –enable-static –disable-shared –disable-doc –cross-prefix=/opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux- –arch=arm –target-os=linux 交叉编译qt前提：修改mkspecs/qws/linux-arm-g++下面的qmake.conf，如果没有设置环境变量则设置对应编译器的绝对路径，并将编译器的名字改成你需要的。 比如修改gcc编译器：QMAKE_CC = /opt/FriendlyARM/toolscha","date":"0001-01-01","objectID":"/1/01/qt/:0:22","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"二、升级到Qt6 ","date":"0001-01-01","objectID":"/1/01/qt/:1:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"00：直观总结 增加了很多轮子，同时原有模块拆分的也更细致，估计为了方便拓展个管理。 把一些过度封装的东西移除了（比如同样的功能有多个函数），保证了只有一个函数执行该功能。 把一些Qt5中兼容Qt4的方法废弃了，必须用Qt5中对应的新的函数。 跟随时代脚步，增加了不少新特性以满足日益增长的客户需求。 对某些模块和类型及处理进行了革命性的重写，运行效率提高不少。 有参数类型的变化，比如 long * 到 qintptr * 等，更加适应后续的拓展以及同时对32 64位不同系统的兼容。 源码中的double数据类型全部换成了qreal，和Qt内部数据类型高度一致和统一。 我测试的都是QWidget部分，quick部分没有测试，估计quick部分更新可能会更多。 强烈建议暂时不要用Qt6.0到Qt6.2之间的版本，一些模块还缺失，相对来说BUG也比较多，推荐6.2.2版本开始正式迁移。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"01：01-10 万能方法：安装5.15版本，定位到报错的函数，切换到源码头文件，可以看到对应提示字样 QT_DEPRECATED_X(“Use sizeInBytes”) 和新函数。按照这个提示类修改就没错，一些函数是从Qt5.7 5.9 5.10等版本新增加的，可能你的项目还用的Qt4的方法，但是Qt6以前都兼容这些旧方法，到了Qt6就彻底需要用新方法了。PS：如果本身就是Qt6新增的功能函数则此方法无效 Qt6对core这个核心类进行了拆分，多出来core5compat，因此你需要在pro增加对应的模块已经代码中引入对应的头文件。 //pro文件引入模块 greaterThan(QT_MAJOR_VERSION, 4): QT += widgets greaterThan(QT_MAJOR_VERSION, 5): QT += core5compat //代码中引入头文件 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) #include \u003cQtWidgets\u003e #endif #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) #include \u003cQtCore5Compat\u003e #endif 默认Qt6开启了高分屏支持，界面会变得很大，甚至字体发虚，很多人会不习惯，因为这种模式如果程序很多坐标计算没有采用devicePixelRatio进行运算的话，100%会出现奇奇怪怪的问题，因为坐标不准确了。要取消这种效果可以设置高分屏缩放因子。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif 原有的随机数函数提示用QRandomGenerator替代，为了兼容所有qt版本，改动最小的办法是直接用c++中的随机数，比如qsrand函数换成srand，qrand函数换成rand，查看过源代码，其实封装的就是c++中的随机数，很多类似的封装比如qSin封装的sin。 QColor的 light 改成 lighter ，dark 改成 darker，其实 lighter、darker 这两个方法以前一直有。 QFontMetricsF 中的 fm.width 换成 fm.horizontalAdvance ，从5.11开始用新函数。 QPalette调色板枚举值，Foreground = WindowText, Background = Window，其中 Foreground 和 Background 没有了，要用 WindowText 和 Window 替代，以前就有。类似的还有 setTextColor 改成了 setForeground 。 QWheelEvent的 delta() 改成 angleDelta().y()，pos() 改成 position() 。 svg模块拆分出来了svgwidgets，如果用到了该模块则需要在pro增加 QT += svgwidgets ，同理opengl模块拆分出来了openglwidgets。 qlayout中的 margin() 函数换成 contentsMargins().left()，查看源码得知以前的 margin() 返回的就是 contentsMargins().left()，在四个数值一样的时候，默认四个数值就是一样。类似的还有setMargin移除了，统统用setContentsMargins。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"02：11-20 之前 QChar c = 0xf105 全部要改成强制转换 QChar c = (QChar)0xf105，不再有隐式转换，不然编译报错提示error: conversion from ‘int’ to ‘QChar’ is ambiguous 。 qSort等一些函数用回c++的 std::sort 。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) std::sort(ipv4s.begin(), ipv4s.end()); #else qSort(ipv4s); #endif Qt::WA_NoBackground 改成 Qt::WA_OpaquePaintEvent 。 QMatrix 类废弃了没有了，换成 QTransform ，函数功能基本一致，QTransform 类在Qt4就一直有。 QTime 计时去掉了，需要改成 QElapsedTimer ，QElapsedTimer 类在Qt4就一直有。 QApplication::desktop()废弃了， 换成了 QApplication::primaryScreen()。 #if (QT_VERSION \u003e QT_VERSION_CHECK(5,0,0)) #include \"qscreen.h\" #define deskGeometry qApp-\u003eprimaryScreen()-\u003egeometry() #define deskGeometry2 qApp-\u003eprimaryScreen()-\u003eavailableGeometry() #else #include \"qdesktopwidget.h\" #define deskGeometry qApp-\u003edesktop()-\u003egeometry() #define deskGeometry2 qApp-\u003edesktop()-\u003eavailableGeometry() #endif 获取当前屏幕索引以及尺寸需要分别处理。 //获取当前屏幕索引 int QUIHelper::getScreenIndex() { //需要对多个屏幕进行处理 int screenIndex = 0; #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) int screenCount = qApp-\u003escreens().count(); #else int screenCount = qApp-\u003edesktop()-\u003escreenCount(); #endif if (screenCount \u003e 1) { //找到当前鼠标所在屏幕 QPoint pos = QCursor::pos(); for (int i = 0; i \u003c screenCount; ++i) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) if (qApp-\u003escreens().at(i)-\u003egeometry().contains(pos)) { #else if (qApp-\u003edesktop()-\u003escreenGeometry(i).contains(pos)) { #endif screenIndex = i; break; } } } return screenIndex; } //获取当前屏幕尺寸区域 QRect QUIHelper::getScreenRect(bool available) { QRect rect; int screenIndex = QUIHelper::getScreenIndex(); if (available) { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) rect = qApp-\u003escreens().at(screenIndex)-\u003eavailableGeometry(); #else rect = qApp-\u003edesktop()-\u003eavailableGeometry(screenIndex); #endif } else { #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) rect = qApp-\u003escreens().at(screenIndex)-\u003egeometry(); #else rect = qApp-\u003edesktop()-\u003escreenGeometry(screenIndex); #endif } return rect; } QRegExp类移到了core5compat模块，需要主动引入头文件 #include 。 //设置限制只能输入数字+小数位 QString pattern = \"^-?[0-9]+([.]{1}[0-9]+){0,1}$\"; //设置IP地址校验过滤 QString pattern = \"(2[0-5]{2}|2[0-4][0-9]|1?[0-9]{1,2})\"; //确切的说 QRegularExpression QRegularExpressionValidator 从5.0 5.1开始就有 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) QRegularExpression regExp(pattern); QRegularExpressionValidator *validator = new QRegularExpressionValidator(regExp, this); #else QRegExp regExp(pattern); QRegExpValidator *validator = new QRegExpValidator(regExp, this); #endif lineEdit-\u003esetValidator(validator); QWheelEvent构造参数和对应的计算方位函数变了。 //模拟鼠标滚轮 #if (QT_VERSION \u003c QT_VERSION_CHECK(6,0,0)) QWheelEvent wheelEvent(QPoint(0, 0), -scal, Qt::LeftButton, Qt::NoModifier); #else QWheelEvent wheelEvent(QPointF(0, 0), QPointF(0, 0), QPoint(0, 0), QPoint(0, -scal), Qt::LeftButton, Qt::NoModifier, Qt::ScrollBegin, false); #endif QApplication::sendEvent(widget, \u0026wheelEvent); //鼠标滚轮直接修改值 QWheelEvent *whellEvent = (QWheelEvent *)event; //滚动的角度,*8就是鼠标滚动的距离 #if (QT_VERSION \u003c QT_VERSION_CHECK(6,0,0)) int degrees = whellEvent-\u003edelta() / 8; #else int degrees = whellEvent-\u003eangleDelta().x() / 8; #endif //滚动的步数,*15就是鼠标滚动的角度 int steps = degrees / 15; qVariantValue 改成 qvariant_cast ，qVariantSetValue(v, value) 改成了 v.setValue(val)。相当于退回到最原始的方法，查看qVariantValue源码封装的就是qvariant_cast。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:3","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"03：21-30 QStyleOption的init改成了initFrom。 QVariant::Type 换成了 QMetaType::Type ，本身以前的 QVariant::Type 封装的就是 QMetaType::Type 。 QStyleOptionViewItemV2 V3 V4 之类的全部没有了，暂时可以用 QStyleOptionViewItem 替代。 QFont的 resolve 的一个重载函数换成了 resolveMask。 QSettings的 setIniCodec 方法移除了，默认就是utf8，不需要设置。 qcombobox 的 activated(QString) 和 currentIndexChanged(QString) 信号删除了，用int索引参数的那个，然后自己通过索引获取值。个人觉得这个没必要删除。 qtscript模块彻底没有了，尽管从Qt5时代的后期版本就提示为废弃模块，一致坚持到Qt6才正式废弃，各种json数据解析全部换成qjson类解析。 QByteArray 的 append indexOf lastIndexOf 等众多方法的QString参数重载函数废弃了，要直接传 QByteArray，就在原来参数基础上加上 .toUtf8() 。查看源码也看得到以前的QString参数也是转成.toUtf8()再去比较。 QDateTime的时间转换函数 toTime_t + setTime_t 名字改了，对应改成了 toSecsSinceEpoch + setSecsSinceEpoch ，这两个方法在Qt5.8时候新增加的。 QLabel的 pixmap 函数之前是指针 *pixmap() 现在换成了引用 pixmap()。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:4","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"04：31-40 QTableWidget的 sortByColumn 方法移除了默认升序的方法，必须要填入第二个参数表示升序还是降序。 qtnetwork模块中（TCP/UDP相关的socket）的错误信号error换成了errorOccurred，就改了个名字，注意websocket那块居然没统一改过来依然是叫error。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) connect(udpSocket, SIGNAL(errorOccurred(QAbstractSocket::SocketError)), this, SLOT(error())); connect(tcpSocket, SIGNAL(errorOccurred(QAbstractSocket::SocketError)), this, SLOT(error())); #else connect(udpSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error())); connect(tcpSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error())); #endif //特别注意websocket中依然还是用error connect(webSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error())); XmlPatterns模块木有了，全部用xml模块重新解析。 nativeEvent的参数类型变了。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) bool nativeEvent(const QByteArray \u0026eventType, void *message, qintptr *result); #else bool nativeEvent(const QByteArray \u0026eventType, void *message, long *result); #endif QButtonGroup的buttonClicked信号中int参数的函数全部改名字叫idClicked。 QButtonGroup *btnGroup = new QButtonGroup(this); #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) connect(btnGroup, SIGNAL(idClicked(int)), ui-\u003exstackWidget, SLOT(setCurrentIndex(int))); #else connect(btnGroup, SIGNAL(buttonClicked(int)), ui-\u003exstackWidget, SLOT(setCurrentIndex(int))); #endif QWebEngineSettings之前是QWebEngineSettings::defaultSettings();现在改成了QWebEngineProfile::defaultProfile()-\u003esettings();通过查看之前的源码得知QWebEngineSettings::defaultSettings();封装的就是QWebEngineProfile::defaultProfile()-\u003esettings();因为Qt6去除了N多过度封装的函数。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) QWebEngineSettings *webSetting = QWebEngineProfile::defaultProfile()-\u003esettings(); #else QWebEngineSettings *webSetting = QWebEngineSettings::defaultSettings(); #endif Qt6将enterEvent的参数QEvent改成了QEnterEvent也不打个招呼。这种改变编译也不会提示的。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(6,0,0)) void enterEvent(QEnterEvent *); #else void enterEvent(QEvent *); #endif //后面经过JasonWong大佬的指点，从父类重新实现的virtual修饰的函数，建议都加上override关键字。 //这样的话一旦父类的函数或者参数变了则会提示编译报错，而不是编译通过但是运行不正常会一脸懵逼茫然，从而把锅扣给Qt。 //下面是父类函数 virtual void enterEvent(QEvent *event); //子类建议加上override void enterEvent(QEvent *event) override; Qt6中多个类进行了合并，比如现在QVector就成了QList的别名，意味着这两个类是同一个类没有任何区别，可能Qt内部对两种的优点都集中在一起，并尽量重写算法或者其他处理规避缺点。同理QStringList现在也成了 QList 的别名，是同一个类，没有单独的类。 在Qt4时代默认QWidget构造函数父类是0，到了Qt5变成了Q_NULLPTR，到了Qt6居然用的是默认的c++标准中的nullptr而不是Qt自定义定义的Q_NULLPTR（同样的还有Q_DECL_OVERRIDE换成了用override等），可能是为了彻底抛弃历史包袱拥抱未来。 //下面依次是Qt4/5/6的写法 MainWindow(QWidget *parent = 0); MainWindow(QWidget *parent = Q_NULLPTR); MainWindow(QWidget *parent = nullptr); //查阅Qt源码查看Q_NULLPTR原来是根据编译器定义来选择 #ifdef Q_COMPILER_NULLPTR # define Q_NULLPTR nullptr #else # define Q_NULLPTR NULL #endif //Qt高版本兼容低版本写法比如Qt5/6都支持 *parent = 0 这种写法。 对于委托的进度条样式QStyleOptionProgressBar类的属性，在Qt4的时候不能设置横向还是垂直样式，默认横向样式，要设置orientation需要用另外的QStyleOptionProgressBarV2。从Qt5开始新增了orientation和bottomToTop属性设置。在Qt6的时候彻底移除了orientation属性，只有bottomToTop属性，而且默认进度是垂直的，很操蛋，理论上默认应该是横向的才对，绝大部分进度条场景都是横向的。这个时候怎么办呢，原来现在的处理逻辑改了，默认垂直的，如果要设置横向的直接设置 styleOption.state |= QStyle::State_Horizontal 这种方式设置才行，而Qt6以前默认方向是通过 orientation 值取得，这个State_Horizontal从Qt4就一直有，Qt6以后要主动设置下才是横向的就是。 ","date":"0001-01-01","objectID":"/1/01/qt/:1:5","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"05：41-50 Qt6.2版本开始增加了对多媒体模块的支持，但是在mingw编译器下还是有问题，直到6.2.2才修复这个问题，官网解释是因为mingw编译器版本不支持，到6.2.2采用了新的mingw900_64，这个编译器版本才支持。所以理论上推荐从6.2.2开始使用新的Qt6。 QTextStream中的setCodec方法改成了setEncoding，参数变了，功能更强大。 QTextStream stream(\u0026file); #if (QT_VERSION \u003c QT_VERSION_CHECK(6,0,0)) stream.setCodec(\"gbk\"); #else stream.setEncoding(QStringConverter::System); #endif QModelIndex的查找子节点child函数去掉了，但是查找父节点parent函数保留，查阅代码得知之前的child函数就是封装的model-\u003eindex(row, column, QModelIndex)函数。 //下面两个函数等价 如果要兼容Qt456则用下面这个方法 QModelIndex index = indexParent.child(i, 0); QModelIndex index = model-\u003eindex(i, 0, indexParent); //下面两个函数等价 如果要兼容Qt456则用下面这个方法 QModelIndex indexChild = index.child(i, 0); QModelIndex indexChild = model-\u003eindex(i, 0, index); 之前QPixmap类中的静态函数grabWindow和grabWidget彻底废弃了，改成了用QApplication::primaryScreen()-\u003egrabWindow，其实这个从Qt5开始就建议用这个。 #if (QT_VERSION \u003e= QT_VERSION_CHECK(5,0,0)) QPixmap pixmap = QApplication::primaryScreen()-\u003egrabWindow(widget-\u003ewinId()); #else QPixmap pixmap = QPixmap::grabWidget(widget-\u003ewinId()); #endif ","date":"0001-01-01","objectID":"/1/01/qt/:1:6","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"三、Qt安卓经验 ","date":"0001-01-01","objectID":"/1/01/qt/:2:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"01：01-05 pro中引入安卓拓展模块 QT += androidextras 。 pro中指定安卓打包目录 ANDROID_PACKAGE_SOURCE_DIR = $$PWD/android 指定引入安卓特定目录比如程序图标、变量、颜色、java代码文件、jar库文件等。 AndroidManifest.xml 每个程序唯一的一个全局配置文件，里面xml格式的数据，标明支持的安卓版本、图标位置、横屏竖屏、权限等。这个文件是最关键的，如果没有这个文件则Qt会默认生成一个。 android/res/drawable-hdpi drawable-xxxhdpi 等目录下存放的是应用程序图标。 android/res/layout 目录下存放的布局文件。 android/res/values/libs.xml 存储的一些变量值。 android/libs 目录下存放的jar库文件。 android/src 目录下存放的java代码文件，可以是根据包名建立的一层层子目录，也可以直接在src目录下。 其他目录自行搜索安卓目录规范。 后面的说明统一用的android目录举例，其实你可以改成任意目录，比如你的代码目录下是xxoo存放的安卓相关的打包文件，你就写成 ANDROID_PACKAGE_SOURCE_DIR = $$PWD/xxoo 。 java类名必须和文件名完全一致，区分大小写。 java类必须在android/src目录下不然不会打包到apk文件，可以是子目录比如 android/src/com/qt 。 Qt代码中的QAndroidJniObject指定传入的java包名，必须严格和java文件package完全一致，不然程序执行到此处会因为找不到而崩溃。 android/scr/MainActivity.java 顶部 没有 package 则代码中必须是 QAndroidJniObject javaClass(“MainActivity”); android/scr/MainActivity.java 顶部 package com.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com/qandroid/MainActivity”); android/scr/com/example/MainActivity.java 顶部 package com.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com/qandroid/MainActivity”); android/scr/com/example/MainActivity.java 顶部 package com.example.qandroid; 则代码中必须是 QAndroidJniObject javaClass(“com/qandroid/example/MainActivity”); 总之这个包名是和代码中的package后面一段吻合，而不是目录路径。为了统一管理方便查找文件，建议包名和目录路径一致。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"02：06-10 Qt只能干Qt内部类的事情，做一些简单的UI交互还是非常方便，如果涉及到底层操作，还是需要熟悉java会如虎添翼，一般的做法就是写好java文件调试好，提供静态方法给Qt调用，这样通过QAndroidJniObject这个万能胶水可以做到Qt程序调用java中的函数并拿到执行结果，也可以接收java中的函数。 pro中通过 OTHER_FILES += android/AndroidManifest.xml OTHER_FILES += android/src/JniMessenger.java 引入文件其实对整个程序的编译打包没有任何影响，就是为了方便在QtCreator中查看和编辑。 在Qt中与安卓的java文件交互都是用万能的QAndroidJniObject，可以执行java类中的普通函数、静态函数，可以传类对象jclass、类名className、方法methodName、参数，也可以拿到执行结果返回值。 (I)V括号中的是参数类型，括号后面的是返回值类型，void返回值对应V，由于String在java中不是数据类型而是类，所以要用Ljava/lang/String;表示，其他类作为参数也是这样处理。 调用实例方法：callMethod、callObjectMethod。 调用静态方法：callStaticMethod、callStaticObjectMethod。 不带Object的函数名用来执行无返回值或者常规返回值int、float等的方法。 如果返回值是String或者类则需要用带Object的函数名来执行，返回QAndroidJniObject类型再转换处理拿到结果，比如toString拿到字符串。 各种参数和返回值示例。 package org.qt; import org.qt.QtAndroidData; public class QtAndroidTest { //需要通过实例来调用 测试发现不论 private public 或者不写都可以调用 我擦 private void printText() { System.out.println(\"printText\"); } public static void printMsg() { System.out.println(\"printMsg\"); } public static void printValue(int value) { System.out.println(\"printValue:\" + value); } public static void setValue(float value1, double value2, char value3) { System.out.println(\"value1:\" + value1 + \" value2:\" + value2 + \" value3:\" + value3); } public static int getValue() { return 65536; } public static int getValue(int value) { return value + 1; } public static void setMsg(String message) { System.out.println(\"setMsg:\" + message); } public static String getMsg() { return \"hello from java\"; } public static void setText(int value1, float value2, boolean value3, String message) { System.out.println(\"value1:\" + value1 + \" value2:\" + value2 + \" value3:\" + value3 + \" message:\" + message); } public static String getText(int value1, float value2, boolean value3, String message) { //同时演示触发静态函数发给Qt QtAndroidData.receiveData(\"message\", \"你好啊 java\"); //下面两种办法都可以拼字符串 return \"value1:\" + value1 + \" value2:\" + value2 + \" value3:\" + value3 + \" message:\" + message; //return \"value1:\" + String.valueOf(value1) + \" value2:\" + String.valueOf(value2) + \" value3:\" + String.valueOf(value3) + \" message:\" + message; } } #include \"androidtest.h\" //java类对应的包名+类名 #define className \"org/qt/QtAndroidTest\" void AndroidTest::test() { jint a = 12; jint b = 4; //可以直接调用java内置类中的方法 jint max = QAndroidJniObject::callStaticMethod\u003cjint\u003e(\"java/lang/Math\", \"max\", \"(II)I\", a, b); //jclass javaMathClass = \"java/lang/Math\"; jdouble value = QAndroidJniObject::callStaticMethod\u003cjdouble\u003e(\"java/lang/Math\", \"random\"); qDebug() \u003c\u003c \"111\" \u003c\u003c max \u003c\u003c value; } void AndroidTest::printText() { QAndroidJniEnvironment env; jclass clazz = env.findClass(className); QAndroidJniObject obj(clazz); obj.callMethod\u003cvoid\u003e(\"printText\"); } void AndroidTest::printMsg() { #if 0 //查看源码得知不传入jclass类的函数中内部会自动根据类名查找jclass QAndroidJniEnvironment env; jclass clazz = env.findClass(className); QAndroidJniObject::callStaticMethod\u003cvoid\u003e(clazz, \"printMsg\"); #else //没有参数和返回值可以忽略第三个参数 QAndroidJniObject::callStaticMethod\u003cvoid\u003e(className, \"printMsg\"); //QAndroidJniObject::callStaticMethod\u003cvoid\u003e(classNameTest, \"printMsg\", \"()V\"); #endif } void AndroidTest::printValue(int value) { QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"printValue\", \"(I)I\", (jint)value); } void AndroidTest::setValue(float value1, double value2, char value3) { QAndroidJniObject::callStaticMethod\u003cvoid\u003e(className, \"setValue\", \"(FDC)V\", (jfloat)value1, (jdouble)value2, (jchar)value3); } int AndroidTest::getValue(int value) { //java类中有两个 getValue 函数 一个需要传参数 //jint result = QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"getValue\"); jint result = QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"getValue\", \"(I)I\", (jint)value); return result; } void AndroidTest::setMsg(const QString \u0026msg) { QAndroidJniObject jmsg = QAndroidJniObject::fromString(msg); QAndroidJniObject::callStaticMethod\u003cvoid\u003e(className, \"setMsg\", \"(Ljava/lang/String;)V\", jmsg.object\u003cjstring\u003e()); } QString AndroidTest::getMsg() { QAndroidJniObject result = QAndroidJniObject::callStaticObjectMe","date":"0001-01-01","objectID":"/1/01/qt/:2:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"03：11-15 安卓中一个界面窗体对应一个Activity，多个界面就有多个Activity，而在Qt安卓程序中，Qt这边只有一个Activity那就是QtActivity（包名全路径 org.qtproject.qt5.android.bindings.QtActivity），这个QtActivity是固定的写好的，整个Qt程序都是在这个QtActivity界面中。你打开AndroidManifest.xml文件可以看到对应节点有个name=org.qtproject.qt5.android.bindings.QtActivity，所以如果要让Qt程序能够更方便通畅的与对应的java类进行交互（需要上下文传递Activity的，比如震动，消息提示等），建议新建一个java类，继承自QtActivity即可，这样相当于默认Qt启动的就是你java类中定义的Activity，可以很好的控制和交互。 由于AndroidManifest.xml文件每个程序都可能不一样，为了做成通用的组件，这就要求可能不能带上AndroidManifest.xml文件，这样的话每个Qt安卓程序都启动默认内置的Activity，如果依赖Activity上下文的执行函数需要传入Qt的Activity才行，这里切记Qt的Activity包名是 Lorg/qtproject/qt5/android/bindings/QtActivity; 之前顺手想当然的写的 Landroid/app/Activity; 发现死活不行，原来是包名错了。 一个Qt安卓程序中可以有多个Java类，包括继承自Activity的类（这样的Activity可以通过QtAndroid::startActivity函数来调用），但是只能有一个通过AndroidManifest.xml文件指定的Activity，不指定会默认一个。如果java类中不需要拿到Qt的Activity进行处理的，可以不需要继承任何Activity，比如全部是运算的静态函数。 在java类中如果上面没有主动引入包名，则下面需要写全路径，引入了则不需要全路径可以直接用（包括枚举值都可以直接写，比如 VIBRATOR_SERVICE 这种枚举值引入了包名后不需要写android.content.Context.VIBRATOR_SERVICE），建议引入包名，比如上面写了 import org.qtproject.qt5.android.bindings.QtActivity; 则下面继承类可以直接写 public class QtAndroidActivity extends QtActivity，如果没有引入则需要写成 public class QtAndroidActivity extends org.qtproject.qt5.android.bindings.QtActivity 。 建议搭配 android studio 工具开发，因为在 android studio 中写代码都有自动语法提示，包名会提示自动引入，可以查看有那些函数方法等，还可以校验代码是否正确，而如果在QtCreator中手写有时候可能会写错，尤其是某个字母写错，当然这种错误是编译通不过的，会提示错误在哪行。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:3","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"04：16-20 用Qt做安卓开发最大难点两个，第一个就是传参数这些奇奇怪怪的字符（Ljava/lang/String;）啥意思，如何对应，这也不是Qt故意为难初学者啥的，因为这套定义机制是安卓系统底层要求的，系统层面定义的一套规范，其实这个在帮助文档中写的很清楚，都有数据类型对照表，用熟悉了几次就很简单了。第二个难点就是用java写对应的类，如果是会安卓开发的人来说那不要太简单，尤其是搜索那么方便一大堆，没有搞过安卓开发的人来说就需要学习下，这个没有捷径，只是希望Qt能够尽可能最大化的封装一些可以直接使用的类，比如后期版本就提供了权限申请的类 QtAndroid::requestPermissionsSync 之类的，用起来就非常的爽，不用自己写个java类调来调去的。 理论上来说按照Qt提供的万能大法类QAndroidJniObject，可以不用写java类也能执行各种处理，拿到安卓库中的属性和执行方法，就是写起来太绕太费劲，在java类中一行代码，这里起码三行，所以终极大法就是熟悉安卓开发，直接封装好java类进行调用。 测试发现GetStringUTFChars方法对应的数据字符串中不能带有temp字样，否则解析有问题，不知什么原因。 数据类型参数和返回值类型必须完全一致，否则执行会提示找不到对应的函数，有返回值一定要写上返回值。 jar文件对包名的命名没有要求，只要放在android/libs目录下即可，安卓底层是通过包名去查找，而不是通过文件名，你甚至可以将原来的包名重新改成也可以正常使用，比如classes.jar改成test.jar也能正常使用。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:4","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"05：21-25 关于权限设置，在早期的安卓版本，所有权限都写在全局配置文件AndroidManifest.xml中，这种叫安装时权限，就是安装的时候告诉安卓系统当前app需要哪些权限。大概从安卓6开始，部分权限需要动态申请，这种叫动态权限，这种申请到的权限也可以动态撤销，就是要求程序再次执行代码去向系统申请权限，比如拍照、存储读写等。也不是所有的权限都改成了动态申请，意味着兼容安卓6以上的系统你既要在AndroidManifest.xml中写上要求的权限，也要通过checkPermission申请你需要的权限。 android studio 新建并生产jar包步骤。 第一步：文件（File）-》新建（new）-》项目（new project）-》空白窗体（empty activity）。 第二步：刚才新建好的项目鼠标右键新建（new）-》模块（new module）-》安卓库（android library）。 说明：如果选择的不是安卓库（android library）而是java库（Java Library），则直接编译出来的就是jar文件，默认包名 com.example.lib.MyClass。推荐选择java库，编译后不用去一堆文件中找jar文件。 第三步：写好库名字，根据项目需要选择好最低sdk版本-》完成。 第四步：在刚才新建好的库项目mylibrary，依次找到子节点src/main/java/com.example.mylibrary上鼠标右键新建-》class类。切记是这个节点不是java节点或者其他节点。 第五步：写好你的类方法函数等。 package com.example.mylibrary; public class Test { public static int add(int a, int b) { return a + b; } } 第六步：选中库项目mylibrary，菜单执行编译（build）-》编译库（make module xxx）。 第七步：此时在mylibrary/build目录下有outputs目录和intermediates目录，其中outputs/aar目录下是生成的Android库项目的二进制归档文件，包含所有资源，class以及res资源文件全部包含。有时候我们仅仅需要jar文件，只包含了class文件与清单文件 ，不包含资源文件，如图片等所有res中的文件。需要到intermediates/aar_main_jar/debug目录下，可以看到classes.jar，将这个拷贝出来使用即可。当然你也可以对刚才的aar文件用解压缩软件解压出来也能看到classes.jar，是同一个文件。 其他：调用jar包非常简单，只需要将jar文件放在你的项目的libs目录下即可，对应的包名和函数一般jar包提供者会提供，没有提供的话，可以在android studio中新建空白项目，切换到project视图，找到libs目录，鼠标右键最下面作为包动态库添加到项目，导入包完成以后会自动在libs目录列出，双击刚刚导入的包然后就自动列出对应的类和函数。 Qt安卓使用jar包步骤。 第一步：将classes.jar放到android/libs目录下，为啥是这个目录？因为这是安卓的规则约定，这个目录就是放库文件，放在这个目录下的文件会自动打包编译到apk文件中。 第二步：调用jar文件之前，前提是你知道jar文件中的函数详细信息，这个一般jar提供者会提供好手册，如果代码没有混肴的话，你可以在android studio中双击打开查阅具体的函数。 第三步：如果jar文件中的函数简单，直接拿到结果不需要绕来绕去，可以直接写Qt类来调用；如果还是很复杂，建议再去新建java类处理完再交给Qt，当然也可以让jar的作者尽可能封装函数的时候就做好，尽量提供最简单的接口返回需要的数据。比如返回图片数据可以做成jar内部存储好图片，然后返回图片路径即可，不然有些数据转换也挺烦。 第四步：编写最终的调用函数。 int AndroidJar::add(int a, int b) { #ifdef Q_OS_ANDROID const char *className = \"com/example/mylibrary/Test\"; jint result = QAndroidJniObject::callStaticMethod\u003cjint\u003e(className, \"add\", \"(II)I\", (jint)a, (jint)b); return result; #endif } Qt6中对安卓支持部分做了大的改动，目前还不完善，如果是不涉及到与java交互的纯Qt项目，可以正常移植，涉及到的暂时不建议移植到Qt6，等所有类完善了再说。 移除了安卓插件androidextras，将其中部分功能类移到core模块中，不需要额外引入。 类名发生了变化，比如QAndroidJniObject改成了QJniObject、QAndroidJniEnvironment改成了QJniEnvironment，可能是为了统一移动开发平台类，弱化安卓的影响。 对应的安卓jdk要用jdk11而不是jdk1.8，Qt5.15两个都支持，建议就统一用jdk11。 对应封装的java类包名去掉了qt5标识，org.qtproject.qt5.android.bindings.QtActivity改成了org.qtproject.qt.android.bindings.QtActivity、org.qtproject.qt5.android.bindings.QtApplication改成了org.qtproject.qt.android.bindings.QtApplication。 对安卓最低sdk有要求，所以建议在配置AndroidManifest.xml文件的时候不要带上最低版本要求。 对AndroidManifest.xml文件内容有要求，之前Qt5安卓的不能在Qt6安卓下使用，具体内容参见示例下的文件。 对应示例demo在 C:\\Qt\\Examples\\Qt-6.3.0\\corelib\\platform 目录下，之前是 C:\\Qt\\Examples\\Qt-5.15.2\\androidextras ，目前就一个示例，可能因为其他类还没有移植好。 如果想要安卓全屏遮挡住顶部状态栏，可以在main函数中将show改成showFullScreen即可，当然也可以采用java的方式在onCreate函数中加一行 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); ","date":"0001-01-01","objectID":"/1/01/qt/:2:5","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"06：25-30 横竖屏切换的识别，在Qt中会同时反映到resizeEvent事件中，你可以在这个是尺寸变化后读取下当前屏幕是横屏还是竖屏，然后界面上做出调整，比如上下排列改成左右排列。 由于不同Qt版本对应的安卓配置文件 AndroidManifest.xml 内容格式不一样，高版本和低版本模板格式互不兼容，所以建议使用自己的Qt版本创建的 AndroidManifest.xml 文件，创建好以后如果使用的是自己重新定义的java文件的启动窗体则需要将 AndroidManifest.xml 文件中的 android:name=“org.qtproject.qt5.android.bindings.QtActivity” 换掉就行。 如果自己用android studio编译的jar文件放到Qt项目的libs目录下，导致编译通不过，提示 com.android.dx.cf.iface.ParseException: bad class file magic 之类的，那是因为jdk版本不一致导致的，你可能需要在android studio项目中找到模块编jdk版本设置的地方降低版本，比如你用的ndk是r14，则需要选择jdk1.6或者jdk1.7。一般来说高版本兼容低版本，因为ndk版本太低无法兼容jdk1.8。后面发现如果直接新建的是java库（Java Library）则不存在这个问题，如果选择的是安卓库（android library）就可能有这个问题。 安卓项目配置文件是固定的名字 AndroidManifest.xml ，改成其他名字就不认识，不要想当然改成其他名字导致无法正常识别。 AndroidManifest.xml文件中的package=“org.qtproject.example\"是包名，也是整个apk程序的内部唯一标识，如果多个apk这个包名一样，则会覆盖，所以一定要注意不同的程序记得把这个包名改成你自己的。这个包名也决定了java文件中需要使用资源文件时候的引入包名 import org.qtproject.example.R; 如果包名不一样则编译都通不过。 ","date":"0001-01-01","objectID":"/1/01/qt/:2:6","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"四、Qt设计模式 读《c++ Qt设计模式》书籍整理的一点经验。此书和官方的《C++ GUI Qt4编程》一起的。 通常而言，好的做法是在包含了Qt头文件之后再包含非Qt头文件，由于Qt（为编译器和预处理器）定义了许多符号，这使得避免名称冲突变得更容易，也更容易找到文件。 #include \"frminput2019.h\" #include \"ui_frminput2019.h\" #include \"qdatetime.h\" #include \"qdebug.h\" #include \"input2019.h\" #include \"inputnumber.h\" 一种好的编程实践是在代码中使用const实体而不是嵌入数字型常量（有时称他们为“幻数”）。如果以后需要修改他的值时，就可以获得这种灵活性。一般而言，将常量“孤立”出来，可提高程序的可维护性。 //不推荐写法 for (int i = 0; i \u003c 100; ++i) { ... } //推荐下面的写法 const int count = 100; for (int i = 0; i \u003c count; ++i) { ... } 内存管理使程序员获得了强大的能力，但是，“权力越大，责任越大”。 只要有可能，就应当使用列表而不是数组，比如应该使用 QList 代替 int [] ，在c++中数组被看成是“邪恶的”。 在利用Qt编写程序的过程中，因为Qt的父子所有权继承关系，很少会用到智能指针，因为需要调用delete的情况很少。任何时候只要我们需要调用delete，或者是需要将某个指针设定为0时，应该考虑使用一个智能指针。 实际上，我们不能完全确定使用多线程就一定能够真正改善程序的性能，例如，如果增加使用线程的数量，使他与系统可用的内核数量成正比，这样做或许还会降低程序的性能，因为所获得的收益会因线程竞争的剧增而消失殆尽。有时候，单线程中最有效的算法在多线程中却不一定有效。因此，如果真的是想改进程序的性能，理想的做法是，使用不同的实现方法，并与他们的性能进行比较后加以分类，当然测试对比的前提是使用完全相同的硬件和软件配置环境。 在源代码中关于文件路径，使用 / 会更方便一些，因为无论是在何种平台上，Qt都能理解他，不需要对他进行转换。但是，当我们想为用户显示路径时，最好还是根据应用程序所在平台的正确形式来显示他。 当我们有很多项数据需要处理时，比如成千上万或者更多，那么为每个处理都创建一个线程可能导致大量的开销，这样来依次处理数据或许更快些。一种解决办法就是创建少量的辅助线程，并让每个线程只处理一组数据。 ","date":"0001-01-01","objectID":"/1/01/qt/:3:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"五、Qt大佬专区 ","date":"0001-01-01","objectID":"/1/01/qt/:4:0","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"5.1 酷码大佬 微信：Kuma-NPC 关于Qt事件传递的一个说明： 通常写win32程序，鼠标消息应该是直接发给指定窗口句柄的，指定窗口没有处理就会转化成透传消息，交给父窗口处理。你在一个普通文字label上点击，父窗口也能收到鼠标事件。 Qt应该是所有消息都发给了顶层窗口，所以事件分发逻辑是自己处理，主窗口收到鼠标事件然后Qt自己分发给指定子控件，QEvent会有ignore或者accept表示自己处理了没有，例如鼠标点击事件，事件分发器发现没有被处理，数据重新计算然后分发给父窗口。这样父窗口收到的事件坐标就是基于自己窗口内的。用eventFilter就需要自己计算坐标。 再比如，当使用QDialog，放一个QLineEdit并设置焦点，按Esc时QDialog也会自动关闭，本质上就是因为QLineEdit并不处理Esc的按键事件，透传给了QDialog。 ","date":"0001-01-01","objectID":"/1/01/qt/:4:1","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"5.2 小豆君 无论你是学Qt，Java，Python或其它，都需要明白一个道理：摒弃掉你的好奇心，千万不要去追求第三方类或工具是怎么实现的，这往往会让你收效甚微，其实，你只需要熟练掌握它的接口，知道类的目的即可，不可犯面向过程的毛病，刨根问底。记住，你的目标是让其它工具为你服务，你要踩在巨人的肩膀上创造世界。 Qt真正的核心：元对象系统、属性系统、对象模型、对象树、信号槽。往死里啃这五大特性，在你的项目中，逐渐的设法加入这些特性，多多练习使用它们，长此以往你会收获意想不到的效果。 一边请教别人，一边多多重构，其实编码这条路虽然有人给你指路，但真正走下去的是你自己，当你真正走完时，你的编码水平一定会有非常大的提升。也许别人1000行的代码，在你这里几十行就搞定了，这也正事Qt的魅力。 在阅读Qt的帮助文档时，要静下心来，不要放过每一句，记住在文档中没有废话，尤其是每段的开头。 ","date":"0001-01-01","objectID":"/1/01/qt/:4:2","tags":null,"title":"","uri":"/1/01/qt/"},{"categories":null,"content":"六、其他经验 Qt界的中文乱码问题，版本众多导致的如何选择安装包问题，如何打包发布程序的问题，堪称Qt界的三座大山！ 在Qt的学习过程中，学会查看对应类的头文件是一个好习惯，如果在该类的头文件没有找到对应的函数，可以去他的父类中找找，实在不行还有爷爷类，肯定能找到的。通过头文件你会发现很多函数接口其实Qt已经帮我们封装好了，有空还可以阅读下他的实现代码。 Qt安装目录下的Examples目录下的例子，看完学完，月薪20K起步；Qt常用类的头文件的函数看完学完使用一遍并加以融会贯通，月薪30K起步。 Qt在开发阶段不支持中文目录（运行阶段可以，比如打包发布的程序放到中文目录运行是ok的），切记，这是无数人可能犯的错误，在安装Qt集成开发环境以及编译器的时候，务必记得目录必须英文，Qt项目源码也必须是英文目录，否则很可能不正常，建议尽量用默认的安装位置。 如果出现崩溃和段错误，80%都是因为要么越界，要么未初始化，死扣这两点，80%的问题解决了。 Qt一共有几百个版本，关于如何选择Qt版本的问题，我一般保留四个版本，为了兼容Qt4用4.8.7，最后的支持XP的版本5.7.0，最新的长期支持版本比如5.15，最高的新版本比如5.15.2。强烈不建议使用4.7以前和5.0到5.3之间的版本（Qt6.0到Qt6.2之间、不含6.2的版本也不建议，很多模块还没有集成），太多bug和坑，稳定性和兼容性相比于之后的版本相当差，能换就换，不能换睡服领导也要换。如果没有历史包袱建议用5.15.2，目前新推出的6.0版本也强烈不建议使用，官方还在整合当中，好多类和模块暂时没有整合，需要等到6.2.2版本再用。 Qt和msvc编译器常见搭配是Qt5.7+VS2013、Qt5.9+VS2015、Qt5.12+VS2017、Qt5.15+VS2019、Qt6.2+VS2019，按照这些搭配来，基本上常用的模块都会有，比如webengine模块，如果选用的Qt5.12+msvc2015，则很可能官方没有编译这个模块，只是编译了Qt5.12+msvc2017的，如果一定要用msvc2015不想换msvc2017则只能选择Qt5.9+msvc2015套件，或者自行源码重新编译（这个难度超大，初学者绕过）。 Qt默认有对应VS版本，在下载对应VS插件的时候心里要有个数，官方默认提供的是原配的插件，如果想要Qt4.8+VS2015的插件，需要自行编译。一般来说是Qt4.8原配VS2010，Qt5.6原配VS2013，Qt5.9原配VS2015，Qt5.12原配VS2017，Qt5.15原配VS2019，切记：原配最好。 用Qt做开发机器建议用win10，尤其是2021年以后新发布的Qt版本，比如Qt5.12.12、Qt5.15.2、Qt6.2.2等，因为很可能自带的QtCreator用的最新的版本，Qt6开始不再支持win7，或者由于其他的原因，对win7的支持不友好，会出现奇奇怪怪的问题等，所以又是没得选必须用win10。建议各位拥抱新时代的变化，这世上唯一不变的只有变化。 新版本Qt安装包安装的时候需要填写注册信息，如果不想填写，先禁用网卡，在运行安装包，可以直接跳过这一步进行安装。从Qt5.15开始不再提供离线安装包，意味着必须使用在线安装器安装Qt的后续版本，必须填写用户信息，没得选。 终极秘籍：如果遇到问题搜索Qt方面找不到答案，试着将关键字用JAVA C# android打头，你会发现别有一番天地，其他人其他语言其他领域很可能做过！ 如果Qt能从下面几个方面努力，相信会更有发展前景。 QWidget支持CSS3，具有诸多的牛逼的效果，目前支持的是CSS2。 QWidget支持GPU绘制，可选切换CPU或者GPU，提升绘制效率，利用现在强大的硬件。 Qml无缝支持js，可以利用现在各种js轮子，指数级提升qml的项目范围。 支持将程序转成web运行，比如转成cgi之类的程序，目前Qt for WebAssembly很鸡肋，功能极其有限，sql/network/本地访问等都不支持，首次加载速度超慢，大部分Qt类还不支持。 Qt自从4.7以后引入的QML。从此以后，Qt开发就分成了两种流派，一者使用原来的C++ 语言进行开发，另外一种使用QML语言进行开发。这下搞得嘞，经常吵吵不亦乐乎，在Qt界从此就有两大阵营产生激烈的纷争，那就是选用qml还是widget好，大量初学者也会问这个问题，有以下几点总结。 widget属于传统界面开发，和VB/VC/Delphi等拖曳控件开发类似，走CPU绘制，能最大化的兼容现有的硬件和过去的相对偏低性能的硬件。 qml属于新时代的产物，大概从2010年开始，和flutter/Electron等web开发框架及移动开发框架类似，为了适应各种移动端开发及动画流畅性触摸丝滑体验、充分利用和“榨干”现在的GPU性能，把CPU留出来给用户最大化发挥。 硬件性能越好，GPU越是强劲，qml的综合性能越是完爆widget，反之对比也是指数级的。除了极其省成本的嵌入式硬件领域或者国产CPU等，其他领域的硬件性能都是暴增。 widget主要集中在金融、军工、安防、航天、船舶、教育等领域，qml主要集中在汽车仪表、车机、直播等领域。 目前国内widget多于qml，国外可能偏向qml，这个不难看出，流行的移动端开发框架都是国外开发者居多。 可预见的十年内，这两者将长期并存，官方基本不再更新widget而是主推qml，意味着将来对qml的性能优化只增不减，未来趋势是qml。 没有编程经验的新手qml学习成本更低，而从VB/VC等传统软件开发转过来的从业者更适合学习widget。 有的时候不禁要问，既生widget何生qml，学习成本和选择又多了，其实这正是和这个世界的哲学一样：世界是简单的又是复杂的。为了适应各种需求和满足需要。 总之，无论qml还是widget，和找老婆一样，适合自己的就是最好的，自己擅长哪个就用哪个。 如果还不知道擅长哪个，有空就两个都学，学习过程中自己就会有切身感受和对比，能者多劳多多益善。能够顺利的最快的完成老板的任务给老板赚钱才是王道。 网友补充：如果你的软件最终是手指操作的多，就用qml，如果是鼠标操作的多，就选择widget。 写程序过程中发现问题，比如有些问题是极端特殊情况下出现，最好找到问题的根源，有时候肯定多多少少会怀疑是不是Qt本身的问题，怀疑是对的，但是99.9%的问题最终证实下来还是自己的代码写的不够好导致的，如果为了赶时间老板催的急，实在不行再用重启或者复位大法，比如搞个定时器、线程、网络通信啥的去检测程序是否正常，程序中某个模块或者功能是否正常，不正常就复位程序或者重启程序，在嵌入式上还可以更暴力一点就是系统重启和断电重启。 写程序过程中尤其要注意32位的库和64位的库互不兼容，比如32位的程序引用64位的库，64位的程序引用32位的库，都是编译通不过的，而在windows64位系统中是能够运行32位程序的，因为64位的系统提供了32位的运行环境，一般目录在Program Files(x86)，32位的程序在64位的环境中最终引用的还是32位的库。关于如何判断自己的Qt库是多少位，有个误区就是很多人要么看成了QtCreator的关于信息中列出的位数，要么以为自己是64位的系统就认为是64位的Qt，最终要在Qt构建套件中查看具体位数，大概从Qt5.14开始基本上很少提供32位的库，尤其是Qt6.0以后基本上默认就是只有64位的库了，这也是顺应时代潮流，毕竟不久的将来（个人预计2030年以前）基本上32位的系统占比不超过1%，放心大胆的用64位的库吧，抛弃烦人的32位以及XP系统。 关于程序中动态和静态的一点个人理解： 在Qt程序中，分动态库版本的Qt和静态库版本的Qt。 官方默认提供的二进制包就是动态库版本的Qt，如果自行编译则编译的时候对应参数 -shared。 静态库版本的Qt需要自行编译，编译的时候对应参数 -static，（理论上无论商业非商业使用Qt静态库需要收费，因为静态编译后都看不到Qt的相关库文件）。 使用动态库的Qt支持编译生成动态库和静态库（CONFIG += staticlib）的程序。 使用动态库的Qt程序支持动态库的引用（引用的时候 LIB += ，运行的时候需要动态库文件比如 .dll .so 文件支持）。 使用动态库的Qt程序支持静态库的引用（引用的时候 LIB += ，运行的时候无需库文件支持，可以理解为该文件已经和可执行文件合二为一，缺点是可执行文件体积变大）。 通过生成文件的个数和大小可以发现，静态库相当于把运行时需要的文件也一并合并到一个文件了，而动态库是拆分成两个文件，一个用于编译，一个用于运行。 上述动态库的规则也通用于静态库。 此规则应该是通用于其他语言框架。 很多人有个误区包括几年前的我，以为要用Qt编写静态库就必须用静态的Qt库，其实动态库的Qt也可以编写静态的库，只是该库不会生成动态库文件。 如果要将Qt程序编译成静态的可执行文件（单个文件无依赖），前提是所用的Qt库必须静态的。 后期的Qt版本，大致从5.15开始，就不在提供离线版本下载，需要自行通过在线安装器安装，由于默认服务器在国外，很多人反映下载的时候很慢，或者选择晚上的时候下载要快很多，为了解决这个烦人的问题，不至于时间都浪费在没有意义的等待上，有个极其简单的方法可以将速度提升几万倍，甚至冲坏你的硬盘。先下载 Fiddler5（尽量选择中文版本不然小白看不懂），双击打开程序后（可能win10自带的杀毒软件会报毒删除，","date":"0001-01-01","objectID":"/1/01/qt/:5:0","tags":null,"title":"","uri":"/1/01/qt/"}]