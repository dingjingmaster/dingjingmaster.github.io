[{"categories":["linux","qemu"],"content":"在Linux宿主机上挂载 qemu 虚拟盘 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:0","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"下载 qemu-nbd 工具 pacman -S qemu 或 apt-get install qemu-utils 或 yum install qemu-img ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:1","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"加载nbd模块并挂载 modprobe nbd max_part=8 qemu-nbd --connect=/dev/nbd0 \u003cxxx.qcow2\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:2","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"开始挂载nbd磁盘到文件系统 mount /dev/nbd0xx \u003c挂载点\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:3","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"卸载nbd qemu-nbd --disconnect /dev/nbd0 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:1:4","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"将vmware的vmdk虚拟盘转为qemu支持的qcow2虚拟盘 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:0","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"合并vmware虚拟磁盘 如果vmware下虚拟机的磁盘是分块的，比如:xxx-s001.vmdk、xxx-s002.vmdk… 需要先合并为一个vmdk文件 vmware-vdiskmanager.exe -r \u003c虚拟盘的路径\u003e -t 0 \u003c合并后盘的名字\u003e vmware-vdiskmanager.exe 在vmware安装路径下 ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:1","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux","qemu"],"content":"vmdk转qcow2 在linux下执行(确保执行前安装有qemu环境和工具包) qemu-img convert -f vmdk -O qcow2 \u003cxxx.vmdk\u003e \u003cxxx.qcow2\u003e ","date":"2022-03-10","objectID":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/:2:2","tags":["linux","qemu"],"title":"宿主机挂载qemu虚拟盘(qcow2)","uri":"/2022/03/0001-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BDqemu%E8%99%9A%E6%8B%9F%E7%9B%98qcow2/"},{"categories":["linux"],"content":"ARM 简史 ARM公司既不生产芯片也不销售芯片，它只出售芯片技术授权。却做到了在手持设备市场上占有90%以上的份额。 软银在2016年耗资320亿美元拿下ARM，使得本来就大红大紫的ARM公司，再一次窜到了业界人士的面前。ARM这家不生产芯片却也能数钱数到手抽筋的公司到底有着怎样的发展史？ 1978 年诞生 ARM公司既不生产芯片也不销售芯片，它只出售芯片技术授权。却做到了在手持设备市场上占有90%以上的份额。 软银在2016年耗资320亿美元拿下ARM，使得本来就大红大紫的ARM公司，再一次窜到了业界人士的面前。ARM这家不生产芯片却也能数钱数到手抽筋的公司到底有着怎样的发展史？ CPU公司的全称：Cambridge Processor Unit，字面意思是“剑桥处理器单元”。 CPU公司的创始人：奥地利籍物理学博士Hermann Hauser和他的朋友，英国工程师Chris Curry。 不过，CPU公司成立之后，主要从事电子设备设计和制造的业务。他们接到的第一份订单，是制造赌博机的微控制器系统。这个微控制器系统被开发出来后，称之为Acorn System 1。 1979 年公司改名 1979年，这家公司给自己换了个名字——Acorn Computer Ltd。 Acorn是什么意思？橡子。 Acorn Computer Ltd公司的商标里面就有一个橡子。 关于Acorn，还有一个有趣的说法，就是因为他们想在电话黄页里排在Apple（苹果）公司的前面… 在Acorn System 1之后，他们又陆续开发了System 2、3、4，还有面向消费者的盒式计算机 —— Acorn Atom。 1981 年迎来BBC订单 到了1981年，公司迎来了一个难得的机遇 —— 英国广播公司BBC打算在整个英国播放一套提高电脑普及水平的节目，他们希望Acorn能生产一款与之配套的电脑。 这个计划非常宏大，英国政府也参与其中（购机费的一半将由政府资助），电脑一旦采购，将进入英国的每一间教室。 接下这个任务之后，Acorn就开始干了起来。 结果，很快他们就发现，自己产品的硬件设计并不能满足需求。当时，中央处理器的发展潮流，正在从8位变成16位。Acorn并没有合适的芯片可以用。 起初，他们打算使用美国国家半导体和摩托罗拉公司的16位芯片。但是，经过评估后，他们发现了两个缺陷： 芯片的执行速度有点慢，中断的响应时间太长。 售价太贵，一台500英镑的电脑，处理器芯片就占到100英镑。 他们打算去找当时如日中天的英特尔（Intel），希望对方提供一些80286处理器的设计资料和样品。但是，却遭到了拒绝。 备受打击的Acorn公司，一气之下决定自己干，自己造芯片。 当时，Acorn公司的研发人员从美国加州大学伯克利分校找到了一个关于新型处理器的研究——简化指令集，恰好可以满足他们的设计要求。 在此基础上，经过多年的艰苦奋斗，来自剑桥大学的计算机科学家Sophie Wilson和Steve Furber最终完成了微处理器的设计。 对于这块芯片，Acorn给它命名为Acorn RISC Machine。 嗯，这就是大名鼎鼎的“ARM”三个字母的由来。 Acorn是公司名称，Machine是机器，那RISC是什么意思呢？ RISC的全称是\"精简指令集计算机\"（reduced instruction set computer），它支持的指令比较简单，所以功耗小、价格便宜，特别适合移动设备。早期使用ARM芯片的典型设备，就是苹果公司的牛顿PDA。 这里解释一下，到底“简化指令集”有什么意义。 它是相对于“复杂指令集（CISC，complex instruction set computer）”的一个概念。 早期的处理器都是CISC架构（包括英特尔的处理器），随著时间推移，有越来越多的指令集加入。由于当时编译器的技术并不纯熟，程序都会直接以机器码或是组合语言写成，为了减少程序的设计时间，逐渐开发出单一指令，复杂操作的程序代码。设计师只需写下简单的指令，再交给CPU去执行。 但是后来有人发现，整个指令集中，只有约20％的指令常常会被使用到，大约占了整个程序的80％；剩余80％的指令，只占了整个程序的20％。（典型的二八原则） 于是，1979年美国加州大学伯克利分校的David Patterson教授提出了RISC的想法，主张硬件应该专心加速常用的指令，较为复杂的指令则利用常用的指令去组合。 1985年10月，英特尔发布了80386。在80386面前，ARM1就只有被吊打的份了。 intel 80386 32位，27.5万个晶体管，频率为12.5MHz，后提高到33MHz 让ARM直接在性能上和x86系列硬杠，显然是不现实的。ARM有意无意地选择了与Intel不同的设计路线——Intel持续迈向x86高效能设计，ARM则专注于低成本、低功耗的研发方向。 BBC在1981年就提出需求，如果等到1985年ARM1出来，那岂不是黄花菜都凉了？ 所以，在ARM1问世之前，Acorn其实已经提供了解决方案给BBC。 当时，Acorn的电脑，临时采用了MOS 6502处理器（由MOS科技研发的8位微处理器）。 MOS 6502处理器 1982 年推出 BBC Micro计算机 1982 年Acorn计算机公司推出了BBC Micro计算机，这是欧洲第一台畅销的个人计算机。 BBC Micro 1984 BBC Micro 被大量使用 到了 1984 年，大约80%的英国学校都配有这款电脑。Acorn公司彻底在大英帝国老百姓面前刷了一把存在感。 后来，ARM处理器被研发出来之后，用在了BBC Micro的后续型号中。 BBC Micro电脑里面的ARM芯片 1985 年推出 ARM1 芯片 1985 年Acorn与合作伙伴推出了ARM1芯片，以此作为其未来个人计算机的中枢。 在ARM1之后，Acorn陆续推出了好几个系列，例如ARM2，ARM3。 1990 年得到苹果公司投资 1990 年11月27日，Acorn公司正式改组为ARM计算机公司。苹果公司出资150万英镑，芯片厂商VLSI出资25万英镑，Acorn本身则以150万英镑的知识产权和12名工程师入股。 在成立后的那几年，ARM业绩平平，工程师们人心惶惶，害怕随时失业。 在这个情况下，ARM决定改变他们的产品策略——他们不再生产芯片，转而以授权的方式，将芯片设计方案转让给其他公司，即“Partnership”开放模式。 没想到正是这种模式，开创了属于ARM的全新时代。 ARM 32位嵌入式RISC(Reduced lnstruction Set Computer)处理器扩展到世界范围，占据了低功耗、低成本和高性能的嵌入式系统应用领域的领先地位。 ARM所采取的是IP（Intellectual Property，知识产权）授权的商业模式，收取一次性技术授权费用和版税提成。 具体来说，ARM有三种授权方式：处理器、POP以及架构授权。 处理器授权是指授权合作厂商使用ARM设计好的处理器，对方不能改变原有设计，但可以根据自己的需要调整产品的频率、功耗等。 POP（processor optimization pack，处理器优化包）授权是处理器授权的高级形式， ARM出售优化后的处理器给授权合作厂商，方便其在特定工艺下设计、生产出性能有保证的处理器。 架构授权是ARM会授权合作厂商使用自己的架构，方便其根据自己的需要来设计处理器（例如后来高通的Krait架构和苹果的Swift架构，就是在取得ARM的授权后设计完成的）。 所以，授权费和版税就成了ARM的主要收入来源。除此之外，就是软件工具和技术支持服务的收入。 对于半导体公司来说，授权费和版税到底有多少呢？一次性技术授权费用在100万-1000万美元之间，版税提成比例一般在1%-2%之间。 正是ARM的这种授权模式，极大地降低了自身的研发成本和研发风险。它以风险共担、利益共享的模式，形成了一个以ARM为核心的生态圈，使得低成本创新成为可能。 苹果公司投资ARM，是为了保证其Newton手持计算机的芯片供应，这个不切实际的设备以失败而告终。 注意：这里的ARM是公司名称，不是芯片名称。这个ARM的完全拼写也不一样，是Advanced RISC Machines。 前面的芯片名称：Acorn RISC Machine 现在的公司名称：Advanced RISC Machines 1998 年诺基亚基于ARM设计并畅销 1998 年诺基亚基于ARM设计的畅销帮助它成了全世界最大的手机生产商。 1991 年ARM将产品授权给英国GEC Plessey半导体公司 1993 年ARM将产品授权给Cirrus Logic和德州仪器（Texas Instruments，TI） 与德州仪器的合作，给ARM公司带来了重要的突破。而且，也给ARM公司树立了声誉，证实了授权模式的可行性。 此后，越来越多的公司参与到这种授权模式中，与ARM建立了合作关系。其中就包括三星、夏普等公司。 在此基础上，ARM坚定了授权模式的决心，并着手设计更多性价比高的产品。 1993年，苹果公司推出了一款新型掌上电脑产品——Newton。ARM公司开发的ARM6芯片被用于该产品之中。 Apple Newton Message Pad 现在被认为是PDA和智能手机的鼻祖 但是很遗憾，因为Newton技术过于超前，加上一些用户体验上的缺陷，所以未能被市场接受，后来以失败告终。 但ARM积累了经验，继续改良技术。没过多久，ARM迎来了自己的黄金机遇——","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:1:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"硬件相关概念 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"电平 在数字电路中，分为高电平和低电平，分别用1和0表示。一个数字电路的管脚，总是存在一个电平的，要么高要么低，或者说要么1要到0(其实还有一种，高阻) ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:1","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"总线 在嵌入式系统中一定会有一块处理器芯片，此外，还有其它的芯片作为外部设备（后面简称外设），这些芯片与处理器协作实现产品的功能。复杂的产品往往是由大量的芯片组成的。那么不可避免的是我们需要将所有的外设与处理器进行相连，最为简单的是将所有的外设都采用独立（注意是独立）的信号线连接至处理器，这样的好处是容易理解，但问题是：不可行。 因为处理器芯片需要引出太多的线了，从芯片的生产和产品的生产角度来看都不实际。加之，处理器（在此我们假设处理器是单核的，而不是多核的）处理事务在微观上是串行的，也就是说在某一时刻如果要对外设进行读写操作，那只可能是对大量外设中的一个进行，即多个外设不可能在微观上被处理器同时访问。需要注意的是，这里提出了微观这一概念，这是为了区别于宏观。 从宏观上来讲，一个处理器中可以有多个任务同时运行，但这些任务在微观上却是一个一个运行的（后面会用串行来描述这里所说的“一个一个”），多任务的串行运行实现是由操作系统扮演着重要的角色来实现的。回到我们的话题，即然将每个外设采用独立的信号线连到处理器不可行，且处理器在单一时间内只会对一个外设进行访问，那我们能不能采用共享的信号线将所有的芯片连在一起呢？这就是总线概念的由来。 通俗的说，如果我们周围有十个家庭，为了让这十个家庭每两个之间都能往来，我们并不需要为每两个家庭修一条单独（注意是单独）的路（如果这样，要修45条路），而是可以修一条大路，然后，每个家都与大路相连。 对于总线，我们往往说总线是处理器的，而其它的外设是挂在总线上的。那有一个问题，我们每一时间只能访问挂在总线上的一个外设，那如何区分这些外设呢？和我们的路一样，我们需要用地址来区分每一个家庭，在总线上，也是采用地址来进行区分的。这样，总线就根据其功能分为两类了。一类是地址总线，这一总线上的数据只会是从处理器向外设“流”，是单向的。 另一类则是数据总线，用来将数据从处理器传送到外设（从处理器的角度来说是写操作）或者是将数据从外设传送到处理器（从处理器的角度来说是读操作），显然，数据总线是双向的。也就是说，在我们的嵌入式系统中同时存在地址总线和数据总线将所有需要与处理器进行通讯的芯片连在一起的。 总线是有宽度的，正如我们的路分为“三车道”或是“四车道”，我们说32位处理器，是指其数据总线宽度是32位，也就是“有32辆车能同时跑”，显然，宽度越是宽我们的处理器速度就越是快，因为我们从外设芯片存取数据的速度会更快，这就是为什么我们的计算机向64位发展的原因。同样的，地址总线也是有宽度的，对于32位处理器其最大宽度也就是32位。 总线的概念有了，那接下来的一个问题是，即使是每一个外设都有一个地址，那这一地址记在哪里呢？是放在外设芯片上吗？如果这样的话，那就有一个问题，每一类外设的地址必须是不能重叠的，而当一个产品中需要两块一样的芯片的话，两块芯片的地址就无法区分了，看来这样操作存在问题。还有，如果这样的话每一个外设也得与（比如，32根）数据总线完全相连，并监听数据线以了解处理器是不是在“叫”自己，这样很是复杂。 此外，地址也有可能因为外设种类的增多而用光。总的来说地址不能存放在外设芯片，那如何让外设知道，此时它是被处理器招换从而需要进行读写访问的呢？答案就是芯片的片选（CS， chip select）信号，或者又叫使能（ENable）信号。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:2","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"片选(CS或EN) 片选信号对于外设芯片来讲，就是一个（也是一根）通知信号，告诉芯片“嘿，请开门，我要放些东西进来，或是拿些东西走”，这里的东西只能是数据，不可能是玉米棒什么的。那有个问题，这个信号源从哪里来呢？显然，只能从处理器来。那是不是也是像总线那样，每一个芯片都共用一根线连在一起呢？如果这样，可能处理器“一叫开门”所有的芯片都将“门”打开了。如果是处理器写数据，那可能所有的芯片都被写入同样的数据。 而取数据时，每个外设芯片都向外“扔”数据，这一定会造成数据总线冲突，因为有的芯片向总线上“扔”1，有的则“扔”0，这种情况下处理器一定会“发疯”的，因为它不知道应当得到1还是0。 既然这样，显然不能将所有的片选信号连在一起了，只能是各芯片的片选信号独立。前面提到了地址总线，我们是采用一根地址线连一个外设芯片呢？还是采用其它的方法。如果采用一根地址线连一个外设芯片，那可能最多只能挂接32个芯片了，这显然不行。其实，在现实中，是采用32位的数字来表示一个外设芯片的地址的，比如1可以表示芯片A，而6534可以表示另外一个芯片B， 等等。由此看来，理论上我们可以表示2的32次方（4294967296）个设备，之所以说理论上，是因为有的设备要占用大量的地址。即然这样，那还有一个问题，如果将32位的地址总线转换成芯片的一根片选信号呢？这需要引入译码（器）的概念。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:3","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"译码器 译码器将一个数据转换成一根信号线上的信号，比如3/8译码器，可以将一个位宽是3位的数据转换成8根（2的3次方）完全独立的信号线，当向数据侧写入二进制的011时，对应的是8根线的第3根，当输入二进制的111时，对应的是8根线中的最后一根。有了译码器，处理器的地址线就简化了，只要32根地址线加上外面的译码器，就可以访问大量的外设芯片了。外部设备的选择问题，我们已经解决了，现在还得回头看一看数据总线。 3/8译码器 在嵌入式系统中，所有芯片的数据总线可以理解成是直接相连的。之所以用了“可以理解”一词，是因为为了提高总线的负载能力，其中会加入总线驱动器。为了理解，我们看一看我们生活中的自来水，比如，在北京理论上可能所有的水管是连在一起的，但中间可能为了提高水压，存在很多小的水站用来增加供水压力，而不可能全北京所有的自来水自接来自一个水厂。 既然所有的数据总线是连在一起的，那就可能会有问题。当向外部设备写数据时，处理器先向地址总线输送目标外设的地址，地址译码器将其转换成一根信号的片选信号送到了目标外设，目标外设收到这一信号后，将“门”打开。接下来处理器将要传送到外设的数据往数据总线上一放，由于只有目标外设芯片打开了“门”，所以数据只会进入到目标外设，而其它的外设什么也不会收到。 很好！处理器向外写数据应当没有问题，我们接下来看一看读。读的话，由于数据是从外设输送到处理器的，尽管我们采用和写一样的方法打开目标外设的“门”，但此时，其它的外设也在数据总线上，它们有可能处于1也可能处于0，是不是会影响处理器读取目标外设的数据呢？结果当然不会，但我们得引入另一个概念：高阻态。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:4","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"高阻态 很显然，当处理器从目标外设读数据时，我们希望其它没有被选上的芯片的数据总线不会对目标外设所要传送的数据有影响，那怎么办呢？实际上，当芯片没有被选中时，其数据总线都处于高阻态。所谓的高阻态，我们可以理解成这一管脚在外设芯片内部是断开的，如此一来，显然不会对处理器从目标外设读取数据造成任何的影响了。 我们说当一个芯片没有被选中或是没有被使能时，其数据总线一定是处于高阻态的。前面用了“门”的开和关来打比方，那“门”是指什么呢？是指外设的数据总线，片选信号的作用就是控制将外设的数据总线与处理器的数据总线相连或是断开。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:5","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"驱动 总线上的数据是谁放上去的我们就说谁是那一时刻的驱动者。也就是说，当处理器向外设写数据时，它是在驱动数据总线的，而当处理器从目标外设读取数据时，目标外设是在驱动数据总线的。对于地址总线，因为只可能从处理器向目标外设写，所以地址总线永远是由处理器驱动的。当一个芯片没有被选中时，我们说它并不驱动数据总线。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:6","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"三态门 前面我们说到外设芯片的数据总线在没有被选中时其处于高阻态，当被选中时，其电平可能是高（1）或是低（0）。如此一来，我们说外设的数据总线其芯片管脚是属于三态门的，即存在高电平、低电平和高阻态，三个状态。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:7","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"电平特效 前面我们了解了什么是片选信号，也讲到了三态门，需要指出的是片选信号通常不是三态门，其只存在两个状态，即高电平或是低电平。前面我们也说了，片选信号是用来“开门”的，而片选信号又有高和低电平，那到底是高电平表示“开门”呢？还是低电平？对于这一问题，我们称如果一个电平对于一个片选信号表示“开门”那么它就是这一信号的有效电平。 比如，对于一个片选信号，如果低电平表示“开门”，那么我们说这个片选信号是低电平有效的。虽然，在这里我们用片选信号来解释电平的有效性，但是很多信号都存在有效性的问题，比如，后面我们将要谈的读信号和写信号都存在有效性问题。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:8","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"时序 在前面我们说到当处理器要向外设芯片写数据时，需要先将所需访问的外设的地址放在地址总线上，然后，由译码器将地址总线上的数据转换成片选信号，片选信号则使能目标外设芯片，接下来处理器写数据到数据总线上，从而完成一个写操作。显然，在处理器将数据写到数据总线之前地址线上的数据必须一直保留一段时间，否则的话译码器不能长时间的使片选信号有效。 当完成了数据的写操作后，处理器就不需要保证地址总线上的地址有效了。我们可以看出，这一系列的操作都有一定严格的时间顺序的，这称之为时序。时序描述了处理器与外部设备的交互信号 “规程”，大家只有按照这一“规程”来操作，才能保证处理器与外部设备之间能正常的通讯。 这好比，我们的道路上的红绿灯，如果我们行人和车辆不按照其指示来通行的话，就会出现事故。通常，采用时序图来描述芯片之间通讯的信号“规程”。 读时序图 读时序图 从图中我们可以看出ADDRESS是表示地址总线的，DQ是表示数据总线的,CE是片选信号，且是低电平有效，其宽度要保证在进行读操作时总是有效的。学会看时序图对于做嵌入式系统开发非常有帮助，因为我们不可避免的要与芯片打交道。在时序图中，通常会标识很多的时间需求信息。 在写启动代码时需要初始化各地址空间的片选地址寄存器和读写时序，时序的配置依据就是来自于外设芯片的时间需求，这是芯片手册很重要的一部分内容。当一个地址空间中存在多个外设芯片时，我们需要考虑到其中最慢的外设芯片的时间需求，否则的话有的芯片就不能正常工作。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:9","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"读信号 当处理器需要从外设芯片读取信号时，除了需要产生片选信号外，还需要告诉外设芯片这是一个读操作，而不是一个写操作，这是通过读信号来实现的。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:10","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"写信号 前面讲了读信号，我想对于写信号也就不难理解了，这个信号用于告诉外设芯片，这是一个向外设芯片写数据的操作。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:11","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"I/O端口 前面提到了外设（芯片）)，现在是对外设进行分类的时候了。大体上外设分为两类，一类是存储器外设，而另一类是非存储器外设，后者常被称之为I/O设备，这里的I/O是Input/Output的简写，即输入、输出。可见，I/O外设是一个非常宽泛的概念。对于存储器外设，其特点是，它所占用的空间是连续的一片。比如，SDRAM内存就是属于存储器外设，如果其容量是8M字节，那么其占用的地址空间也会是8M的。 与存储器外设所不同的是，I/O外设所点用的地址一般都很少。比如一个I/O外设可能存在多个控制寄存器，这些控制寄存器从处理器来看就是多个I/O端口（地址），向这个地址写数据就是向外设所对应的寄存器写数据，反之，也可以是读。 比如，一个串口芯片可能存在多个寄存器，一个用来查询芯片的状态，一个用来设置芯片的功能，另一个用来读取芯片从串口线所收到的数据，最后，还有一个用来向芯片写数据以向串口线上发送数据。对于这一串口芯片的寄存器，从处理器的角度来看，都是独立的I/O端口。 I/O端口存在读、写性问题，有的端口是只读的，有的端口是只写的，还有的端口是即可读也可写，其读写性是由外设芯片的寄存器所决定的，在芯片的数据手册中能找到。需要指出的是，有些存储器外设也存在I/O端口，以对其进行一定的控制。从I/O端口这一名字来看，对于处理器来说，就是对从外面读入数据或是向外面输出数据的一个接口总称。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:12","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"中断 中断从硬件的角度来看就是一个能产生高、低电平的一根信号线，但理解它需要从处理器的角度出发。我们说过了，处理器从微观上看，所做的工作是按顺序进行的，其对程序的处理只能是一条指令一条指令的执行。如果存在需要对外设芯片进行访问，而有可能从处理器发出读、写命令后，由于外设通常比处理器慢很多，所以外设芯片需要一些时间来准备好所需的数据。 在这种情况下，如果处理器一直等外设芯片的返回数据再执行后续的指令的话，将耗费宝贵的时间，这些时间完全可以用来做其它的工作。别忘了，从宏观上看来处理器常常是多任务的，任务是指操作系统所提供的调度单位。当一个任务因为等待外设芯片的数据而阻塞时，我们可以切换到另外的任务，从而提高处理效率。 这就有一个问题，当处理器去处理另一个任务时，如果外设芯片的数据好了的话，如果告诉处理器呢？对了！就是通过中断信号。中断信号的高、低电平可以用来表示是否有中断需要处理器注意以处理特定的事件（比如，外设数据准备好了的事件）。 由此看来，中断的引入能大大的提高处理器的运用效率。为了使用处理器上的中断，一开始我们需要初始化好处理器的中断控制器，比如安装好所需的中断服务程序或称之为ISR（Interrupt Service Routine），然后，打开中断屏蔽位。中断服务程序中需要做如下的操作： 从外设读入或向外设写数据。读还是写通常需要读取外设的中断状态寄存器来决定。 清除外设的中断信号。我们知道，中断信号是由外设芯片驱动的，为了告诉外设芯片，处理器已经处理完了所需做的工作，那么处理器需要通过一定的方式通知外设芯片。这种方式就是向外设芯片的寄存器中的某一位写入一个数据，比如，可能是写入1表示清中断，也可能是写入0表示清中断，这通常在外设的数据手册中能查到。 当外设收到了处理器的清中断请求后，其就会驱动中断线使其无效。比如，一个外设的中断线是当其为低电平表示有中断，将其从低电平变为高电平就是驱动为无效。 清除处理器的中断信号标识。处理器中往往也会保存外部中断信号是否发生过，当我们处理完了外设芯片的中断时，我们也需要清除处理器上的标识，从而为下一次中断做准备。需要注意的是，清外设的中断必须发生在请处理器中断标识之前！ 中断还存在一个触发方式问题。有两种触发方式 ，一种是电平触发，另一种是沿触发。电平触发是指电平的高低表示外设是否有中断，而沿触发则是能过中断线上的电平的升或降来表示的，显然，存在两种沿触发方式。 一种是中断线从低电平变为高电平，我们称之为上升沿触发，另一处是中断线从高电平转换为低电平，我们称之为下降沿触发。总的来说中断的触发方式有电平触发、上升沿触发和下降沿触发。电平触发方式中处理中中断设置很重要的一个步骤。 ROM ROM(Read Only Memory)和RAM(Random Access Memory)指的都是半导体存储器，ROM在系统停止供电的时候仍然可以保持数据，而RAM通常是在掉电之后就丢失数据，典型的RAM就是计算机的内存。 ROM有很多种，PROM是可编程的ROM，它和EPROM(可擦除可编程ROM)的区别是，PROM是一次性的，也就是软件灌入后，就无法修改了，这是早期的产品，现在已经不再使用，而EPROM是通过紫外光的照射擦出原先的程序的一种通用存储器。另外一种EEPROM是通过电子擦除，价格很高，写入时间很长，写入慢。 举个例子，手机软件一般放在EEPROM中，我们打电话，有些最后拨打的号码，暂时存在SRAM中，不是马上写入通话记录(通话记录保存在EEPROM中)，因为当时有很重要工作(通话)要做，如果写入，漫长的等待用户无法忍受。 RAM RAM有两大类，一种称为静态RAM(Static RAM/SRAM)，SRAM速度非常快，是目前读写最快的存储设备了，它也非常昂贵，所以只在要求很苛刻的地方使用，譬如CPU的一级缓冲，二级缓冲。 另一种称为动态RAM(Dynamic RAM/DRAM)，DRAM保留数据的时间很短，速度也比SRAM慢，不过它还是比任何的ROM都要快，但从价格上来说DRAM相比SRAM要便宜很多，计算机内存就是DRAM的。 DRAM DRAM分为很多种，常见的主要有FPRAM/FastPage、EDORAM、SDRAM、DDR RAM、RDRAM、SGRAM以及WRAM等，这里介绍其中的一种DDR RAM。 DDR RAM DDR RAM(Date-Rate RAM)也称作DDR SDRAM，这种改进型的RAM和SDRAM是基本一样的，不同之处在于它可以在一个时钟读写两次数据，这样就使得数据传输速度加倍了。 这是目前电脑中用得最多的内存，而且它有着成本优势，击败了Intel的另外一种内存标准-Rambus DRAM。在很多高端的显卡上，也配备了高速DDR RAM来提高带宽，这可以大幅度提高3D加速卡的像素渲染能力。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:13","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"内存原理解析 内存是用来存放当前正在使用的(即执行中)的数据和程序，我们平常所提到的计算机的内存指的是动态内存(即DRAM)，动态内存中所谓的“动态”，指的是当我们将数据写入DRAM后，经过一段时间，数据会丢失，因此需要一个额外设电路进行内存刷新操作。 具体的工作过程是这样的：一个DRAM的存储单元存储的是0还是1取决于电容是否有电荷，有电荷代表1，无电荷代表0。但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，这就是数据丢失的原因; 刷新操作定期对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电; 若电量小于1/2，则认为其代表0，并把电容放电，藉此来保持数据的连续性。 NAND Flash和NOR Flash的比较 常用的Flash类型有：NOR Flash和NAND Flash两种。NOR Flash由Intel公司在1988年发明，以替代当时在市场上占据主要地位的EPROM和EEPROM。NANDFlash由Toshiba公司在1989年发明。两者的主要差别如下表所示。 NOR Flash支持XIP，即代码可以直接在NOR Flash上执行，无需拷贝到内存中。这是由于NOR Flash的接口与RAM完全相同，可以随机访问任意地址的数据。在NOR Flash上进行读操作的效率非常高，但是擦除和写操作的效率很低；另外，NOR Flash的容量一般比较小。 NAND Flash进行擦除和写操作的效率更高，并且容量更大。一般而言，NOR Flash用于存储程序，NAND Flash用于存储数据。基于NAND Flash的设备通常也要搭配NOR Flash以存储程序。 Flash存储器件由擦除单元(也称为块)组成，当要写某个块时，需要确保这个块已经被擦除。NOR Flash的块大小范围为64KB～128KB；NAND Flash的块大小范围为8KB～64KB，擦/写一个NOR Flash块需4S，而擦/写一个NAND Flash块仅需2ms。 NOR Flash的块太大，不仅增加了擦写时间，对于给定的写操作，NOR Flash也需要更多的擦除操作——特别是小文件，比如一个文件只有1KB，但是为了保存它却需要擦除大小为64KB～128KB的NOR Flash块。 NOR Flash的接口与RAM完全相同，可以随意访问任意地址的数据。而NAND Flash的接口仅仅包含几个I/O引脚，需要串行地访问。NAND Flash一般以512字节为单位进行读写。这使得NOR Flash适合于运行程序，而NAND Flash更适合于存储数据。 容量相同的情况下，NAND Flash的体积更小，对于空间有严格要求的系统，NAND Flash可以节省更多空间。市场上NOR Flash的容量通常为1~4MB(也有32MB的NOR Flash)，NANDFlash的容量为8~512MB。容量的差别也使得NOR Flash多用于存储程序，NAND Flash多用于存储数据。 对于Flash存储器件的可靠性需要考虑3点：位反转、坏块和可擦除次数。所有Flash器件都遭遇位反转的问题：由于FLASH固有的电器特性，在读写数据过程中，偶然会产生一位或几位数据错误——这种概率很低，而NAND Flash出现的概率远大于NOR Flash。当位反转发生在关键的代码、数据上时，有可能导致系统崩溃。 当仅仅是报告位反转，重新读取即可；如果确实发生了位反转，则必须有相应的错误检测/恢复措施。在NAND Flash上发生位反转的概率更高，推荐使用EDC/ECC进行错误检测和恢复。 NAND Flash上面会有坏块随机分布，在使用前需要将坏块扫描出来，确保不再使用它们，否则会使产品含有严重的故障。NAND Flash每块的可擦除次数通常在100000次左右，是NOR Flash的10倍。另外，因为NAND Flash的块大小通常是NOR Flash的1/8，所以NAND Flash的寿命远远超过NOR Flash。 linux对NOR、NAND Flash的软件支持都很成熟。在NOR Flash上常用jffs2文件系统，而在NAND Flash上常用yaffs文件系统。在更底层，有MTD驱动程序实现对它们的读、写、擦除操作，它也实现了EDC/ECC校验。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:2:14","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"工具 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:0","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"万用表 万用表通常是用来查看电平的高低、电阻的大小等的，是常用且必不可少的工具之一。在嵌入式系统开发中，我们常用的是数字万用表。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:1","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"示波器 在嵌入式系统开发中，我们不可避免的要与外设芯片打交道。调试驱动程序时，除了需要完全看明白芯片的数据手册，且在软件高度的过程中，还需要看我们所期望的信号电平是否发生在芯片上。比如，我们在写驱动程序时，需要通过写I/O端口来对外设芯片进行操作，当写相应的I/O端口时，我们知道所对应芯片的片选信号应当有效，有时，我们需要验证是否按预期发生了，这就需要用到示波器。 一般的示波器是能同时观测两个信号线的信号状态的。示波器都提供一定的功能，比如设置信号扑捉的方式等等。示波器很重要的一个参数据是其采集频率，根据Nyquist采集定理，如果我们想用示波器查看频率是100M赫兹的信号，那么其采样频率必须至少是其两倍，即200M赫兹。有人可能会问：为什么不用万用表来看呢？因为万用表的采集频率很底，无法采集到很快的信号变化。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:2","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"逻辑分析仪 简单的说逻辑分析器就是具有很多信号通道的示波器。通过逻辑分析仪，我们可以看到地址总线和数据总线上的数据。逻辑分析仪都提供一定的编程能力，用于编程什么时候开始对总线上的数据进行采集。 ","date":"2022-03-09","objectID":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/:3:3","tags":["linux","arm"],"title":"嵌入式相关概念","uri":"/2022/03/0003-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"},{"categories":["linux"],"content":"准备环境 工作机 linux 上要准备好 arm-gcc 编译工具链(如果没有则看imx6ull概念和环境搭建) 工作机 linux 上可以通过串口连接到 arm 开发板(如果没有则看imx6ull概念和环境搭建) 工作机 linux 上准备分别准备好 buildroot u-boot kernel 的源码 ","date":"2022-03-09","objectID":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:1:0","tags":["linux","imx6ull"],"title":"构建bootloader、内核和文件系统","uri":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["linux"],"content":"编译buildroot ","date":"2022-03-09","objectID":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:2:0","tags":["linux","imx6ull"],"title":"构建bootloader、内核和文件系统","uri":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["linux"],"content":"编译u-boot ","date":"2022-03-09","objectID":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:3:0","tags":["linux","imx6ull"],"title":"构建bootloader、内核和文件系统","uri":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["linux"],"content":"u-boot介绍 u-boot属于 bootloader 的一种实现。bootloader 是在操作系统运行之前运行的一段代码，用于引导操作系统。 ","date":"2022-03-09","objectID":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:3:1","tags":["linux","imx6ull"],"title":"构建bootloader、内核和文件系统","uri":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["linux"],"content":"u-boot编译 这次编译使用 imx6ull 资料里提供的 u-boot 源码 ","date":"2022-03-09","objectID":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:3:2","tags":["linux","imx6ull"],"title":"构建bootloader、内核和文件系统","uri":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["linux"],"content":"编译kernel 找到 imx-linux4.9.88 并执行命令 这里需要注意，imx6ull pro 处理器是 arm v7l 是 32 位系统 export ARCH=arm export CROSS_COMPILE=arm-none-linux-gnueabihf- make mrproper make 100ask_imx6ull_defconfig make zImage -j8 make dtbs ","date":"2022-03-09","objectID":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/:4:0","tags":["linux","imx6ull"],"title":"构建bootloader、内核和文件系统","uri":"/2022/03/0002-%E6%9E%84%E5%BB%BAbootloader%E5%86%85%E6%A0%B8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["linux"],"content":"环境搭建准备 pc 和 配置目标 通过串口可以用 PC 连接到 开发板，查看输出日志 通过ssh可以让 PC 连接到 开发板，并对开发板进行控制和数据交换 开发板默认登录用户名: root，无密码 linux 下烧写工具 pc 开发环境配置与准备 arm 交叉编译工具链环境 开发板引导程序源码 开发板linux内核源码 imx6ull 要使用的文件系统，比如：busybox、buildroot、yocto 我使用 manjaro 作为开发环境；使用 imx6ull pro 作为运行/学习环境，开发板下载的工具里没有linux平台的，因此需要从下载资料的 ubuntu 虚拟机里提取。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"1. 先展示开发板 各标号硬件含义 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"2. 开发板启动方式（上图表号16对应状态） boot sw1(lcd_data5) sw2(lcd_data11) sw3(boot_mode0) sw4(boot_mode1) emmc OFF OFF ON OFF sd ON ON ON OFF usb X X OFF ON 注意：当设为 USB 启动时候，不能插上SD卡、TF卡；上电之后才可以插卡。刚出厂的板子在 emmc 上烧写了系统，开发板启动方式需要设置为 emmc 启动。 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"3. 第一次启动开发板 设置开发板的打开方式为 emmc 下载 linux 串口驱动程序 https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers 并编译之后在源码目录执行insmod ./xxx.ko，插入编译生成的内核模块(xxx.ko文件) 连接开发板电源线并打开开关，插拔 usb 线观察 /dev/ 下设备变化，发现插入 usb 后会多出 ttyUSB0 这一设备 执行 pacman -S minicom 下载 minicom 打开串口 minicom -D /dev/ttyUSB0 然后重启开发板(直接断点和上电)，后续就可以通过 minicom 看到串口日志了（需要开发板默认打开串口输出） ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"4. 开发环境搭建 给开发板联网并重启，在系统选项里设置网络(ip、子网掩码、网关)并用 PC ssh 连接上去 接上串口，用 minicom 来观察日志输出 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:4","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"环境配置与工具下载 开发环境是在pc上配置，在pc上使用交叉编译将代码编译成可执行文件，然后使用 ssh 发送到开发板，再在开发板上运行 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"1. 配置 make 环境 使用包管理器安装 make 包: pacman -S make ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"2. 配置arm gcc交叉编译环境 arm 交叉编译工具下载地址: arm 交叉编译工具下载地址，或者复制到浏览器下载(这个包宿主机是x86，目标代码编译成arm的): https://armkeil.blob.core.windows.net/developer/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-arm-none-linux-gnueabihf.tar.xz 下载并解压之后放置指定目录并改名为 gcc-arm，比如: /data/envrionment/gcc-arm/ 配置环境变量，编辑 ~/.bashrc，在末尾加入如下代码: my_arm_home='/data/environment/gcc-arm' my_path=$PATH my_path=${my_arm_home}/bin:${my_path} export PATH=$(echo ${my_path} | sed 's/:/\\n/g' | sort | uniq | tr -s '\\n' ':' | sed 's/:$//g') 配置好后重新打开终端或执行source ~/.bashrc 之后打开终端，运行 arm-none-linux-gnueabihf-gcc -v，查看是否有如下信息输出(如果没有，重新执行这一步): Using built-in specs. COLLECT_GCC=arm-none-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER=/data/environment/gcc-arm/bin/../libexec/gcc/arm-none-linux-gnueabihf/11.2.1/lto-wrapper Target: arm-none-linux-gnueabihf Configured with: /data/jenkins/workspace/GNU-toolchain/arm-11/src/gcc/configure --target=arm-none-linux-gnueabihf --prefix= --with-sysroot=/arm-none-linux-gnueabihf/libc --with-build-sysroot=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/install//arm-none-linux-gnueabihf/libc --with-bugurl=https://bugs.linaro.org/ --enable-gnu-indirect-function --enable-shared --disable-libssp --disable-libmudflap --enable-checking=release --enable-languages=c,c++,fortran --with-gmp=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-mpfr=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-mpc=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-isl=/data/jenkins/workspace/GNU-toolchain/arm-11/build-arm-none-linux-gnueabihf/host-tools --with-arch=armv7-a --with-fpu=neon --with-float=hard --with-mode=thumb --with-arch=armv7-a --with-pkgversion='GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)' Thread model: posix Supported LTO compression algorithms: zlib gcc version 11.2.1 20220111 (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 这里需要注意的是，如果下载的 arm 编译工具链与开发板文件系统的编译工具链 gcc 不一致，则会导致在 pc 上用跨平台编译工具链编译出来的程序无法在 arm 开发板上运行。解决办法：1. 重新编译开发板根文件系统、内核并烧写；2. 使用官方提供的交叉编译工具链 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:2","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"2. 配置 arm gcc 交叉编译环境(使用imx6ull资料配置) 补充：上述配置的 交叉编译环境链可能并不能用，需要使用imx6ull资料里提供的 交叉编译链，具体操作如下 解压缩 ubuntu 的虚拟机文件（如果压缩文件是多个，需要都选中然后解压） 查看解压后的文件有几个 *.vmdk 文件，如果是多个则需要使用 vdiskmanager 合并为一个 使用 qemu-img 把 xxx.vmdk 文件转为 qemu 支持的 qcow2 文件 我的 linux 工作机用 qemu 而不是 vmware 挂载转换后的文件系统 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:3","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"3. cortexA7 烧写工具 imx6ull 目前在 windows 上有带界面的烧写工具。在 imx6ull 资料里的 ubuntu 虚拟机里也有相应的文件 打开 ubuntu 虚拟机，按文档取出烧写工具 ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:4","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"4. mkimage 工具 这一工具来源于 u-boot，用来给一个 bin 文件添加头部信息，芯片固件需要根据头部信息把 bin 文件放到内存中去执行 执行 pacman -S u-boot 命令后，再次执行 mkimage -h 查看是否正确安装: mkimage: invalid option -- 'h' Error: Invalid option Usage: mkimage -l image -l ==\u003e list image header information mkimage [-x] -A arch -O os -T type -C comp -a addr -e ep -n name -d data_file[:data_file...] image -A ==\u003e set architecture to 'arch' -O ==\u003e set operating system to 'os' -T ==\u003e set image type to 'type' -C ==\u003e set compression type 'comp' -a ==\u003e set load address to 'addr' (hex) -e ==\u003e set entry point to 'ep' (hex) -n ==\u003e set image name to 'name' -d ==\u003e use image data from 'datafile' -x ==\u003e set XIP (execute in place) mkimage [-D dtc_options] [-f fit-image.its|-f auto|-F] [-b \u003cdtb\u003e [-b \u003cdtb\u003e]] [-E] [-B size] [-i \u003cramdisk.cpio.gz\u003e] fit-image \u003cdtb\u003e file is used with -f auto, it may occur multiple times. -D =\u003e set all options for device tree compiler -f =\u003e input filename for FIT source -i =\u003e input filename for ramdisk file -E =\u003e place data outside of the FIT structure -B =\u003e align size in hex for FIT structure and header Signing / verified boot options: [-k keydir] [-K dtb] [ -c \u003ccomment\u003e] [-p addr] [-r] [-N engine] -k =\u003e set directory containing private keys -K =\u003e write public keys to this .dtb file -G =\u003e use this signing key (in lieu of -k) -c =\u003e add comment in signature node -F =\u003e re-sign existing FIT image -p =\u003e place external data at a static position -r =\u003e mark keys used as 'required' in dtb -N =\u003e openssl engine to use for signing mkimage -V ==\u003e print version information and exit Use '-T list' to see a list of available image types ","date":"2022-03-08","objectID":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:5","tags":["linux","imx6ull"],"title":"imx6ull pro 基础概念与环境搭建","uri":"/2022/03/0001-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]