# fpic与fpie


## fPIC/fpic

**-fPIC与-fpic都是在编译时加入的选项，用于生成位置无关的代码(Position-Independent-Code)，可以使得动态库可以被多个程序共享。**

这两个选项都是可以使代码在加载到内存时使用相对地址，所有对固定地址的访问都通过全局偏移表(global offset table，GOT)来实现。

-fPIC和-fpic最大的区别在于是否对GOT的大小有限制。

-fPIC对GOT表大小无限制，所以如果在不确定的情况下，使用-fPIC是更好的选择。

如果链接的可执行文件的GOT大小超过计算机特定的最大大小，则会从链接器收到错误消息，指示-fpic不起作用;在这种情况下，请使用-fPIC重新编译。

GOT大小根据操作系统的不同而大小不一样，SPARC上为8k，在AArch64上为28k，在m68k和RS / 6000上为32k。x86没有此限制。

如果不加-fPIC,则加载.so文件的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容,这就造成每个使用这个.so文件代码段的进程在内核里都会生成这个.so文件代码段的copy，每个copy都不一样,取决于 这个.so文件代码段和数据段内存映射的位置.

不加-fPIC编译出来的so文件,是要再加载时根据加载到的位置再次重定位的.(因为它里面的代码并不是位置无关代码)。如果被多个应用程序共同使用,那么它们必须每个程序维护一份so的代码副本了.(因为so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享)。

> 当设置编译参数是：fPIC 时候 __pic__ 和 __PIC__ 设置为2；
> <br/>
> 当设置编译参数是：fpic 时候 __pic__ 和 __PIC__ 设置为1；

> 什么情况下不用 fPIC
>   1. 该库可能时长更新
>   2. 该库需要非常高的效率(尤其有很多全局变量使用时候)
>   3. 该库并不大
>   4. 该库基本不需要多个应用程序共享


## fPIE/fpie

**-fPIE 与 -fpie 都是在编译时候加入的选项，用于生成位置无关的可执行文件。**

> -fpie and -fPIE both define the macros __pie__ and __PIE__. The macros have the value 1 for -fpie and 2 for -fPIE.


