<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>ldmappings 文件系统权限 - 九九</title><meta name="Description" content=""><meta property="og:title" content="ldmappings 文件系统权限" />
<meta property="og:description" content="ldmappings 大多数文件系统开发人员都遇到过idmapping。当从磁盘读取或写入权限、向用户空间报告所有权或用于权限检查时使用它们。本文的目标读者是想" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dingjingmaster.github.io/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/" /><meta property="og:image" content="https://dingjingmaster.github.io/img/logo.jpg"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-30T17:48:05+08:00" />
<meta property="article:modified_time" content="2022-05-30T17:48:05+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://dingjingmaster.github.io/img/logo.jpg"/>

<meta name="twitter:title" content="ldmappings 文件系统权限"/>
<meta name="twitter:description" content="ldmappings 大多数文件系统开发人员都遇到过idmapping。当从磁盘读取或写入权限、向用户空间报告所有权或用于权限检查时使用它们。本文的目标读者是想"/>
<meta name="application-name" content="九九">
<meta name="apple-mobile-web-app-title" content="九九"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://dingjingmaster.github.io/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/" /><link rel="prev" href="https://dingjingmaster.github.io/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/" /><link rel="next" href="https://dingjingmaster.github.io/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "ldmappings 文件系统权限",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/dingjingmaster.github.io\/2022\/05\/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90\/"
        },"image": ["https:\/\/dingjingmaster.github.io\/img\/logo.jpg"],"genre": "posts","keywords": "linux, kernel, filesystem, 文件系统","wordcount":  11798 ,
        "url": "https:\/\/dingjingmaster.github.io\/2022\/05\/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90\/","datePublished": "2022-05-30T17:48:05+08:00","dateModified": "2022-05-30T17:48:05+08:00","publisher": {
            "@type": "Organization",
            "name": "九九","logo": "https:\/\/dingjingmaster.github.io\/img\/logo.jpg"},"author": {
                "@type": "Person",
                "name": "ding jing"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="九九"><span class="header-title-pre"> </span>九九</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/timeline/"> 时间轴 </a><a class="menu-item" href="https://github.com/dingjingmaster" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="九九"><span class="header-title-pre"> </span>九九</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/timeline/" title="">时间轴</a><a class="menu-item" href="https://github.com/dingjingmaster" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">ldmappings 文件系统权限</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>ding jing</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/kernel/"><i class="far fa-folder fa-fw"></i>kernel</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-05-30">2022-05-30</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 11798 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 24 分钟&nbsp;<span id="/2022/05/0006-ldmappings-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/" class="leancloud_visitors" data-flag-title="ldmappings 文件系统权限">
                        <i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#ldmappings">ldmappings</a>
      <ul>
        <li><a href="#formal-notes">formal notes</a></li>
        <li><a href="#general-note">General note</a></li>
        <li><a href="#转换算法">转换算法</a>
          <ul>
            <li><a href="#交叉映射">交叉映射</a></li>
            <li><a href="#重新映射">重新映射</a></li>
          </ul>
        </li>
        <li><a href="#非法转换">非法转换</a></li>
      </ul>
    </li>
    <li><a href="#创建文件系统对象时的idmappings">创建文件系统对象时的Idmappings</a>
      <ul>
        <li><a href="#例1">例1</a></li>
        <li><a href="#例2">例2</a></li>
        <li><a href="#例3">例3</a></li>
        <li><a href="#例4">例4</a></li>
        <li><a href="#例5">例5</a></li>
      </ul>
    </li>
    <li><a href="#idmapped挂载上的idmappings">idmapped挂载上的Idmappings</a>
      <ul>
        <li><a href="#重新映射-helpers">重新映射 helpers</a></li>
        <li><a href="#例2-reconsider">例2 reconsider</a></li>
        <li><a href="#例3-reconsidered">例3 reconsidered</a></li>
        <li><a href="#例4-reconsidered">例4 reconsidered</a></li>
        <li><a href="#例5-reconsidered">例5 reconsidered</a></li>
      </ul>
    </li>
    <li><a href="#更改主目录的所有权">更改主目录的所有权</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="ldmappings">ldmappings</h2>
<p>大多数文件系统开发人员都遇到过<code>idmapping</code>。当从磁盘读取或写入权限、向用户空间报告所有权或用于权限检查时使用它们。本文的目标读者是想知道idmappings如何工作的文件系统开发人员。</p>
<h3 id="formal-notes">formal notes</h3>
<p><code>idmapping</code>本质上是将一个id范围转换为另一个或相同范围的id。在用户空间中广泛使用的idmappings表示法惯例是:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">u:k:r
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>u 表示上层idmapset u的第一个元素</li>
<li>k 表示下层idmapset k的第一个元素</li>
<li>r 参数表示idmapping的范围，即映射了多少个id。</li>
</ul>
<p>从现在开始，我们总是在id前加上u或k，以明确我们谈论的是上idmapset中的id还是下idmapset中的id。</p>
<p>为了看看实际情况，让我们看看下面的idmapping:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">u22:k10000:r3
</span></span></code></pre></td></tr></table>
</div>
</div><p>并写下它将生成的映射:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">u22 -&gt; k10000
</span></span><span class="line"><span class="cl">u23 -&gt; k10001
</span></span><span class="line"><span class="cl">u24 -&gt; k10002
</span></span></code></pre></td></tr></table>
</div>
</div><p>从数学的观点来看，<code>U</code> 和 <code>K</code> 是有序集，而idmapping是 <code>U</code> 到 <code>K</code> 的有序同构，所以 <code>U</code> 和 <code>K</code> 是有序同构的。事实上，<code>U</code> 和 <code>K</code> 总是一个给定系统中所有可用<code>id</code>集合的有序子集。</p>
<p>简单地从数学角度分析这个问题有助于我们突出一些属性，这些属性使我们更容易理解如何在<code>idmapping</code>之间进行转换。例如，我们知道逆<code>idmapping</code>也是一个有序同构:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">k10000 -&gt; u22
</span></span><span class="line"><span class="cl">k10001 -&gt; u23
</span></span><span class="line"><span class="cl">k10002 -&gt; u24
</span></span></code></pre></td></tr></table>
</div>
</div><p>考虑到我们处理的是有序同构，加上我们处理的是子集，我们可以相互嵌入<code>idmapping</code>，也就是说，我们可以在不同的<code>idmapping</code>之间进行合理的转换。例如，假设我们已经得到了三个<code>idmappings</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">1. u0:k10000:r10000
</span></span><span class="line"><span class="cl">2. u0:k20000:r10000
</span></span><span class="line"><span class="cl">3. u0:k30000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>以及第一次<code>idmapping</code>产生的<code>id k11000</code>，它将<code>上idmapset</code>中的<code>u1000</code>映射到<code>下idmapset</code>中的<code>k11000</code>。</p>
<p>因为我们处理的是有序同构子集，所以询问第二个或第三个<code>idmapping</code>中<code>id k11000</code>对应的是什么是有意义的。使用的简单算法是应用第一个<code>idmapping</code>的逆，将<code>k11000</code>映射到<code>u1000</code>。然后，我们可以使用第二个<code>idmapping</code>映射或第三个<code>idmapping</code>映射来映射<code>u1000</code>。第二个<code>idmapping</code>将<code>u1000</code>映射到<code>21000</code>。第三个<code>idmapping</code>将<code>u1000</code>映射到<code>u31000</code>。</p>
<p>如果我们给以下三个<code>idmappings</code>相同的任务:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">1. u0:k10000:r10000
</span></span><span class="line"><span class="cl">2. u0:k20000:r200
</span></span><span class="line"><span class="cl">3. u0:k30000:r300
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们将无法进行转换，因为这些集合不再是第一个<code>idmapping</code>的整个范围内的有序同构(然而，它们是第二个<code>idmapping</code>的整个范围内的有序同构。)第二个或第三个<code>idmapping</code>在上层<code>idmapset u</code>中都不包含<code>u1000</code>。这相当于没有id映射。我们可以简单地说<code>u1000</code>在第二个和第三个<code>idmapping</code>中是未映射的。内核将向用户空间报告未映射的id为<code>overflowuid</code> (<code>uid_t</code>)<code>-1</code>或<code>overflowgid</code> (<code>gid_t</code>)<code>-1</code>。</p>
<p>计算给定id映射到什么位置的算法非常简单。首先，我们需要验证范围是否可以包含目标id。为了简单起见，我们将跳过这一步。之后，如果我们想知道id映射到什么，我们可以做一些简单的计算:</p>
<ul>
<li>如果我们想要从左到右映射:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nl">u</span><span class="p">:</span><span class="nl">k</span><span class="p">:</span><span class="n">r</span>
</span></span><span class="line"><span class="cl"><span class="n">id</span> <span class="o">-</span> <span class="n">u</span> <span class="o">+</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果我们想要从右到左映射:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nl">u</span><span class="p">:</span><span class="nl">k</span><span class="p">:</span><span class="n">r</span>
</span></span><span class="line"><span class="cl"><span class="n">id</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="n">u</span> <span class="o">=</span> <span class="n">n</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了“从左到右”，我们还可以说“向下”，除了“从右到左”，我们还可以说“向上”。很明显，向下和向上的映射是相反的。</p>
<p>要查看上面的简单公式是否有效，请考虑以下两个idmappings:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">1. u0:k20000:r10000
</span></span><span class="line"><span class="cl">2. u500:k30000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>假设我们在第一个<code>idmapping</code>的<code>下idmapset</code>中给定<code>k21000</code>。我们想知道这是从第一个<code>idmapping</code>的<code>上层idmapset</code>中的哪个<code>id</code>映射过来的。我们在第一个<code>idmapping</code>中向上映射:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">id     - k      + <span class="nv">u</span>  <span class="o">=</span> n
</span></span><span class="line"><span class="cl">k21000 - k20000 + <span class="nv">u0</span> <span class="o">=</span> u1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在假设我们在第二个<code>idmapping</code>的<code>上层idmapset</code>中有一个<code>id u1100</code>，我们想知道这个id在第二个<code>idmapping</code>的<code>下层idmapset</code>中映射到什么。这意味着我们在第二个<code>idmapping</code>中向下映射:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">id    - u    + <span class="nv">k</span>      <span class="o">=</span> n
</span></span><span class="line"><span class="cl">u1100 - u500 + <span class="nv">k30000</span> <span class="o">=</span> k30600
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="general-note">General note</h3>
<p>在内核环境中，idmapping可以被解释为将一系列用户空间id映射到一系列内核id:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">userspace-id:kernel-id:range
</span></span></code></pre></td></tr></table>
</div>
</div><p>用户空间<code>id</code>总是<code>uid_t</code>或<code>gid_t</code>类型的<code>idmap</code>的上层<code>idmapset</code>中的一个元素，而内核<code>id</code>总是<code>kuid_t</code>或<code>kgid_t</code>类型的<code>idmapset</code>的下层<code>idmapset</code>中的一个元素。从现在开始，“用户空间id”将用于表示众所周知的<code>uid_t</code>和<code>gid_t</code>类型，而“内核id”将用于表示<code>kuid_t</code>和<code>kgid_t</code>。</p>
<p>内核主要关心内核id。它们在执行权限检查时使用，并存储在<code>inode</code>的<code>i_uid</code>和<code>i_gid</code>字段中。另一方面，用户空间id是一个由内核报告给用户空间的id，或者由用户空间传递给内核的id，或者从磁盘写入或读取的原始设备id。</p>
<p>注意，我们只关心内核存储<code>idmappings</code>的方式，而不关心用户空间如何指定它们。</p>
<p>在本文档的其余部分中，我们将在所有<code>用户空间id</code>前加上<code>u</code>，在所有<code>内核id</code>前加上<code>k</code>。<code>idmappings</code>范围将以<code>r</code>为前缀。因此，<code>idmapping</code>将被写成<code>u0:k10000:r10000</code>。</p>
<p>例如，id <code>u1000</code>是<code>idmapset上层</code>或以<code>u1000</code>开头的“userspace idmapset”中的id。它被映射到<code>k11000</code>，这是一个<code>内核id</code>，位于较低的idmapset或“内核idmapset”中，以<code>k10000</code>开头。</p>
<p><code>内核id</code>总是由一个<code>idmapping</code>创建的。这样的<code>id映射</code>与用户名称空间相关联。因为我们主要关心<code>idmappings</code>是如何工作的，所以我们不需要关心<code>idmappings</code>是如何创建的，也不需要关心在文件系统上下文之外如何使用它们。这最好留给用户名称空间来解释。</p>
<p>初始用户命名空间是特殊的。它总是有一个如下形式的idmapping:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">u0:k0:r4294967295
</span></span></code></pre></td></tr></table>
</div>
</div><p>它是在这个系统上所有可用id范围上的身份映射。</p>
<p>其他用户名称空间通常有非标识的id映射，例如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">u0:k10000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>当进程创建或想要更改文件的所有权时，或者当文件系统从磁盘读取文件的所有权时，根据与相关用户名称空间相关联的idmapping，用户空间id立即被转换为内核id。</p>
<p>例如，考虑由文件系统存储在磁盘上的文件被u1000所拥有:</p>
<ul>
<li>如果一个文件系统要挂载在初始用户名称空间中(就像大多数文件系统那样)，那么将使用初始<code>idmapping</code>。正如我们看到的，这是简单的身份映射。这意味着从磁盘读取的id <code>u1000</code>将被映射到id <code>k1000</code>。因此，<code>inode</code>的<code>i_uid</code>和<code>i_gid</code>字段将包含<code>k1000</code>。</li>
<li>如果要以<code>u0:k10000:r10000</code>的id映射挂载文件系统，那么从磁盘读取的<code>u1000</code>将被映射到<code>k11000</code>。所以一个<code>inode</code>的<code>i_uid</code>和<code>i_gid</code>将包含<code>k11000</code>。</li>
</ul>
<h3 id="转换算法">转换算法</h3>
<p>我们已经简要地看到，可以在不同的idmapping之间进行转换。现在我们将进一步了解它是如何工作的。</p>
<h4 id="交叉映射">交叉映射</h4>
<p>内核在很多地方都使用这种转换算法。例如，当通过<code>stat()</code>系统调用系列向用户空间报告文件的所有权时，使用它。</p>
<p>如果我们从一个<code>idmapping</code>中得到<code>k11000</code>我们可以把这个id映射到另一个<code>idmapping</code>中。为了使它工作，两个<code>idmapping</code>需要在它们的内核<code>idmapset</code>中包含相同的内核id。例如，考虑以下idmappings:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">1. u0:k10000:r10000
</span></span><span class="line"><span class="cl">2. u20000:k10000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们在第一个<code>idmapping</code>中将<code>u1000</code>映射到<code>k11000</code>。然后，我们可以使用第二个<code>idmapping</code>的内核<code>idmapset</code>将<code>k11000</code>转换为第二个<code>idmapping</code>中的用户空间id:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/* Map the kernel id up into a userspace id in the second idmapping. */
</span></span><span class="line"><span class="cl">from_kuid<span class="o">(</span>u20000:k10000:r10000, k11000<span class="o">)</span> <span class="o">=</span> u21000
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意，我们如何通过颠倒算法在第一个idmapping中返回内核id:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/* Map the userspace id down into a kernel id in the second idmapping. */
</span></span><span class="line"><span class="cl">make_kuid<span class="o">(</span>u20000:k10000:r10000, u21000<span class="o">)</span> <span class="o">=</span> k11000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/* Map the kernel id up into a userspace id in the first idmapping. */
</span></span><span class="line"><span class="cl">from_kuid<span class="o">(</span>u0:k10000:r10000, k11000<span class="o">)</span> <span class="o">=</span> u1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个算法允许我们回答这样一个问题:给定的内核id对应于给定的<code>idmapping</code>中的哪个用户空间id。为了能够回答这个问题，两个<code>idmapping</code>都需要在各自的内核<code>idmapset</code>中包含相同的内核id。</p>
<p>例如，当内核从磁盘读取一个原始用户空间id时，它会根据与文件系统相关联的idmapping将其映射到内核id。让我们假设文件系统的id映射为<code>u0:k20000:r10000</code>，它从磁盘读取<code>u1000</code>拥有的文件。这意味着<code>u1000</code>将映射到<code>k21000</code>, <code>k21000</code>将存储在<code>inode</code>的<code>i_uid</code>和<code>i_gid</code>字段中。</p>
<p>当用户空间中的某人调用<code>stat()</code>或相关函数来获取文件的所有权信息时，内核不能简单地根据文件系统的<code>idmapping</code>来映射id，因为如果调用者使用<code>idmapping</code>，这会给出错误的所有者。</p>
<p>因此，内核将把id映射回调用者的idmapping中。让我们假设调用者有一个稍微不寻常的idmapping <code>u3000:k20000:r10000</code>，那么<code>k21000</code>将映射回<code>u4000</code>。因此，用户会看到这个文件属于<code>u4000</code>。</p>
<h4 id="重新映射">重新映射</h4>
<p>通过两个<code>idmapping</code>的用户空间<code>idmapset</code>，可以将一个<code>内核id</code>从一个<code>idmapping</code>转换为另一个<code>idmapping</code>。这相当于<code>重新映射内核id</code>。</p>
<p>让我们来看一个例子。我们给出了以下两个<code>idmappings</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mf">1.</span> <span class="nl">u0</span><span class="p">:</span><span class="nl">k10000</span><span class="p">:</span><span class="n">r10000</span>
</span></span><span class="line"><span class="cl"><span class="mf">2.</span> <span class="nl">u0</span><span class="p">:</span><span class="nl">k20000</span><span class="p">:</span><span class="n">r10000</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们在第一个<code>idmapping</code>中得到<code>k11000</code>。为了将第一个<code>idmapping</code>中的<code>内核id</code>转换为第二个<code>idmapping</code>中的<code>内核id</code>，我们需要执行两个步骤:</p>
<ol>
<li>在第一个idmapping中将内核id映射到用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/* Map the kernel id up into a userspace id in the first idmapping. */
</span></span><span class="line"><span class="cl">from_kuid<span class="o">(</span>u0:k10000:r10000, k11000<span class="o">)</span> <span class="o">=</span> u1000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>在第二个idmapping中将用户空间id映射到内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/* Map the userspace id down into a kernel id in the second idmapping. */
</span></span><span class="line"><span class="cl">make_kuid<span class="o">(</span>u0:k20000:r10000, u1000<span class="o">)</span> <span class="o">=</span> k21000
</span></span></code></pre></td></tr></table>
</div>
</div><p>如您所见，我们在两个idmapping中都使用了用户空间idmapset来将一个idmapping中的内核id转换为另一个idmapping中的内核id。</p>
<p>这允许我们回答这样一个问题:我们需要使用哪个内核id才能在另一个idmapping中获得相同的用户空间id。为了回答这个问题，两个idmapping都需要在各自的用户空间idmapset中包含相同的用户空间id。</p>
<p>注意，在第一个idmapping中，我们可以通过颠倒算法轻松地返回内核id:</p>
<ol>
<li>在第二个idmapping中将内核id映射到用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/* Map the kernel id up into a userspace id in the second idmapping. */
</span></span><span class="line"><span class="cl">from_kuid<span class="o">(</span>u0:k20000:r10000, k21000<span class="o">)</span> <span class="o">=</span> u1000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>在第一个idmapping中将用户空间id映射到内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/* Map the userspace id down into a kernel id in the first idmapping. */
</span></span><span class="line"><span class="cl">make_kuid<span class="o">(</span>u0:k10000:r10000, u1000<span class="o">)</span> <span class="o">=</span> k11000
</span></span></code></pre></td></tr></table>
</div>
</div><p>观察这种转换的另一种方法是，如果两个idmapping都有相关的用户空间id映射，则将其视为一个idmapping的倒置和另一个idmapping的应用。在使用idmapped挂载时，这将会派上用场。</p>
<h3 id="非法转换">非法转换</h3>
<p>在一个idmapping的内核idmapset中使用一个id作为另一个或相同idmapping的用户空间idmapset中的id永远是无效的。内核idmapset总是表示内核id空间中的一个idmapset，而用户空间idmapset表示用户空间id。所以下面的翻译是被禁止的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/* Map the userspace id down into a kernel id in the first idmapping. */
</span></span><span class="line"><span class="cl">make_kuid(u0:k10000:r10000, u1000) = k11000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/* INVALID: Map the kernel id down into a kernel id in the second idmapping. */
</span></span><span class="line"><span class="cl">make_kuid(u10000:k20000:r10000, k110000) = k21000
</span></span><span class="line"><span class="cl">                                ~~~~~~~
</span></span></code></pre></td></tr></table>
</div>
</div><p>和同样是错误的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/* Map the kernel id up into a userspace id in the first idmapping. */
</span></span><span class="line"><span class="cl">from_kuid(u0:k10000:r10000, k11000) = u1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/* INVALID: Map the userspace id up into a userspace id in the second idmapping. */
</span></span><span class="line"><span class="cl">from_kuid(u20000:k0:r10000, u1000) = k21000
</span></span><span class="line"><span class="cl">                            ~~~~~
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="创建文件系统对象时的idmappings">创建文件系统对象时的Idmappings</h2>
<p>id向下映射或向上映射的概念在文件系统开发人员非常熟悉的两个内核函数中表达，我们已经在本文档中使用了它们:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/* Map the userspace id down into a kernel id. */
</span></span><span class="line"><span class="cl">make_kuid(idmapping, uid)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/* Map the kernel id up into a userspace id. */
</span></span><span class="line"><span class="cl">from_kuid(idmapping, kuid)
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们将简要介绍idmappings如何创建文件系统对象。为了简单起见，我们将只研究当VFS在调用文件系统本身之前已经完成路径查找时发生的情况。因此，我们关心的是调用<code>vfs_mkdir()</code>时会发生什么。我们还将假设创建文件系统对象的目录对每个人都是可读可写的。</p>
<p>当创建一个文件系统对象时，<code>调用者</code>将查看调用者的<code>文件系统id</code>。这些只是普通的<code>uid_t</code>和<code>gid_t</code>用户空间id，但它们在确定文件所有权时被专门使用，这就是为什么它们被称为“<em>文件系统id</em>”。它们通常与调用者的<code>uid</code>和<code>gid</code>相同，但也可以不同。我们将只假设它们总是相同的，以避免迷失在太多的细节中。</p>
<p>当调用者进入内核时，会发生两件事:</p>
<ol>
<li>在调用者的idmapping中将调用者的用户空间id向下映射到内核id。(准确地说，内核只会查看隐藏在当前任务凭证中的内核id，但对于我们的教育，我们将假设这个转换是及时发生的。)</li>
<li>验证调用者的内核id可以映射到文件系统idmapping中的用户空间id。</li>
</ol>
<p>第二步很重要，因为常规文件系统在写入磁盘时最终需要将内核id映射回用户空间id。因此，在第二步中，内核保证可以将有效的用户空间id写入磁盘。如果不能，内核将拒绝创建请求，甚至不冒远程文件系统损坏的风险。</p>
<p>精明的读者应该已经意识到这只是我们在上一节中提到的交叉映射算法的一个变种。首先，内核根据调用者的idmapping将调用者的用户空间id映射到内核id，然后根据文件系统的idmapping将内核id映射到内核id。</p>
<h3 id="例1">例1</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">caller id:            u1000
</span></span><span class="line"><span class="cl">caller idmapping:     u0:k0:r4294967295
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k0:r4294967295
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用者和文件系统都使用标识idmapping:</p>
<ol>
<li>在调用者的idmapping中将调用者的用户空间id映射到内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k0:r4294967295, u1000) = k1000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>验证调用者的内核id可以映射到文件系统idmapping中的用户空间id。
对于第二步，内核将调用<code>fsuidgid_has_mapping()</code>函数，最终归结为调用<code>from_kuid()</code>:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k0:r4294967295, k1000) = u1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>在本例中，两个idmappings是相同的，所以没有什么令人兴奋的事情发生。最终，放置在磁盘上的用户空间id将是u1000。</p>
<h3 id="例2">例2</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">caller id:            u1000
</span></span><span class="line"><span class="cl">caller idmapping:     u0:k10000:r10000
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k20000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>在调用者的idmapping中将调用者的用户空间id映射到内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k10000:r10000, u1000) = k11000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k20000:r10000, k11000) = u-1
</span></span></code></pre></td></tr></table>
</div>
</div><p>很明显，虽然调用者的用户空间id可以在调用者的idmapping中成功映射到内核id，但内核id不能根据文件系统的idmapping进行映射。因此，内核将拒绝这个创建请求。</p>
<p>请注意，虽然这个示例不太常见，但由于大多数文件系统不能使用非初始idmappings挂载，这是一个常见的问题，我们可以在下一个示例中看到。</p>
<h3 id="例3">例3</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">caller id:            u1000
</span></span><span class="line"><span class="cl">caller idmapping:     u0:k10000:r10000
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k0:r4294967295
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>在调用者的idmapping中将调用者的用户空间id映射到内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k10000:r10000, u1000) = k11000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k0:r4294967295, k11000) = u11000
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到，翻译总是成功的。文件系统最终放入磁盘的用户空间id将始终与调用者的idmapping中创建的内核id的值相同。这主要有两个后果。</p>
<p>首先，我们不能允许调用者最终使用另一个用户空间id写入磁盘。只有在使用调用者的或另一个idmapping挂载整个fileystem时才能这样做。但是该解决方案仅限于少数文件系统，而且不太灵活。但这是一个在容器化工作负载中非常重要的用例。</p>
<p>其次，调用者通常无法创建任何具有严格权限的文件或访问目录，因为在调用者的idmapping中，没有一个文件系统的内核id映射到有效的用户空间id</p>
<ol>
<li>在文件系统的idmapping中将原始用户空间id映射到内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k0:r4294967295, u1000) = k1000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>在调用者的idmapping中映射内核id到用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k10000:r10000, k1000) = u-1
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="例4">例4</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">file id:              u1000
</span></span><span class="line"><span class="cl">caller idmapping:     u0:k10000:r10000
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k0:r4294967295
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了向用户空间报告所有权，内核使用了上一节介绍的交叉映射算法:</p>
<ol>
<li>将磁盘上的用户空间id映射到文件系统idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k0:r4294967295, u1000) = k1000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>在调用者的idmapping中将内核id映射到用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k10000:r10000, k1000) = u-1
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这种情况下，交叉映射算法失败，因为文件系统idmapping中的内核id不能映射到调用者idmapping中的用户空间id。因此，内核将报告该文件的所有权为溢出。</p>
<h3 id="例5">例5</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">file id:              u1000
</span></span><span class="line"><span class="cl">caller idmapping:     u0:k10000:r10000
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k20000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了向用户空间报告所有权，内核使用了上一节介绍的交叉映射算法:</p>
<ol>
<li>将磁盘上的用户空间id映射到文件系统idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k20000:r10000, u1000) = k21000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>在调用者的idmapping中将内核id映射到用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k10000:r10000, k21000) = u-1
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这种情况下，交叉映射算法同样失败，因为文件系统idmapping中的内核id不能映射到调用者idmapping中的用户空间id。因此，内核将报告该文件的所有权为溢出。</p>
<p>注意，如果调用者使用初始idmapping，那么在最后两个示例中，事情将变得多么简单。对于使用初始idmapping安装的文件系统来说，这很简单。所以我们只考虑一个id映射为u0:k20000:r10000的文件系统:</p>
<ol>
<li>将磁盘上的用户空间id映射到文件系统idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k20000:r10000, u1000) = k21000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>在调用者的idmapping中将内核id映射到用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k0:r4294967295, k21000) = u21000
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="idmapped挂载上的idmappings">idmapped挂载上的Idmappings</h2>
<p>在上一节中我们看到的调用者的idmapping和文件系统的idmapping不兼容的例子会导致工作负载的各种问题。对于一个更复杂但常见的示例，考虑在主机上启动两个容器。为了完全防止这两个容器相互影响，管理员通常可以为这两个容器使用不同的不重叠的idmapping:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">container1 idmapping:  u0:k10000:r10000
</span></span><span class="line"><span class="cl">container2 idmapping:  u0:k20000:r10000
</span></span><span class="line"><span class="cl">filesystem idmapping:  u0:k30000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>管理员希望对以下文件集提供简单的读写访问:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">dir id:       u0
</span></span><span class="line"><span class="cl">dir/file1 id: u1000
</span></span><span class="line"><span class="cl">dir/file2 id: u2000
</span></span></code></pre></td></tr></table>
</div>
</div><p>到两个容器目前都不能。</p>
<p>当然，管理员可以选择通过chown()递归地更改所有权。例如，他们可以改变所有权，以便dir和它下面的所有文件可以从文件系统的交叉映射到容器的idmapping。让我们假设它们改变了所有权，以便与第一个容器的idmapping兼容:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">dir id:       u10000
</span></span><span class="line"><span class="cl">dir/file1 id: u11000
</span></span><span class="line"><span class="cl">dir/file2 id: u12000
</span></span></code></pre></td></tr></table>
</div>
</div><p>这仍然会使dir对第二个容器毫无用处。事实上，dir和它下面的所有文件将继续显示为第二个容器的溢出所有。</p>
<p>再来看看另一个越来越受欢迎的例子。一些服务管理器，比如systemd，实现了一个叫做“可移植主目录”的概念。用户可能希望在分配了不同登录用户空间id的不同机器上使用自己的主目录。大多数用户在家里的机器上将u1000作为登录id，并且他们主目录中的所有文件通常都属于u1000。在大学或工作单位，他们可能有另一个登录id，如u1125。这使得在他们的工作机器上与他们的主目录交互变得相当困难。</p>
<p>在这两种情况下，递归地改变所有权都有严重的影响。最明显的一个是所有权是全球性和永久性的变化。在主目录的情况下，所有权甚至需要在每次用户从他们的主目录切换到他们的工作机器时发生这种变化。对于非常大的文件集，这将变得越来越昂贵。</p>
<p>如果用户幸运的话，他们处理的文件系统是在用户名称空间内安装的。但是这也会全局地改变所有权，所有权的改变与文件系统挂载的生命周期有关，也就是超级块。更改所有权的惟一方法是完全卸载文件系统，然后在另一个用户名称空间中再次挂载它。这通常是不可能的，因为这意味着当前访问文件系统的所有用户都不能再访问了。这意味着dir仍然不能在具有不同idmapping的两个容器之间共享。但通常用户甚至没有这个选项，因为大多数文件系统在容器内是不可安装的。并且不要安装它们可能是可取的，因为它不需要文件系统处理恶意的文件系统映像。</p>
<p>但是上面提到的用例以及更多的情况都可以通过idmapped挂载来处理。它们允许在不同的坐骑上暴露同一套拥有不同所有权的dentry。这是通过通过mount_setattr()系统调用用用户名称空间标记挂载来实现的。然后使用与它相关联的idmapping从调用者的idmapping转换到文件系统的idmapping，然后使用我们前面介绍的重新映射算法进行反向转换。</p>
<p>Idmapped挂载使得以一种临时和本地化的方式改变所有权成为可能。所有权的变更仅限于一个特定的坐骑，并且与坐骑的生命周期相关。暴露文件系统的所有其他用户和位置都不受影响。</p>
<p>支持idmapped挂载的文件系统没有任何真正的理由来支持在用户名称空间内被挂载。可以在idmapped挂载下完全公开文件系统，以获得相同的效果。这样做的好处是，文件系统可以将超级块的创建留给初始用户名称空间中的特权用户。</p>
<p>但是，完全可以将idmapped挂载与用户名称空间内可挂载的文件系统结合起来。我们将在下面进一步讨论这个问题。</p>
<h3 id="重新映射-helpers">重新映射 helpers</h3>
<p>添加了Idmapping函数，在Idmapping之间进行转换。它们使用了我们前面介绍过的重新映射算法。我们来看看两个例子:</p>
<ul>
<li><code>i_uid_into_mnt()</code> 和 <code>i_gid_into_mnt()</code>
<code>i_*id_into_mnt()</code>函数将文件系统的内核id转换为挂载的idmapping中的内核id:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/* Map the filesystem&#39;s kernel id up into a userspace id in the filesystem&#39;s idmapping. */
</span></span><span class="line"><span class="cl">from_kuid(filesystem, kid) = uid
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/* Map the filesystem&#39;s userspace id down ito a kernel id in the mount&#39;s idmapping. */
</span></span><span class="line"><span class="cl">make_kuid(mount, uid) = kuid
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>mapped_fsuid()</code> 和 <code>mapped_fsgid()</code>
<code>mapped_fs*id()</code>函数将调用者的内核id转换为文件系统idmapping中的内核id。这个转换是通过使用挂载的idmapping重新映射调用者的内核id来实现的:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/* Map the caller&#39;s kernel id up into a userspace id in the mount&#39;s idmapping. */
</span></span><span class="line"><span class="cl">from_kuid(mount, kid) = uid
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/* Map the mount&#39;s userspace id down into a kernel id in the filesystem&#39;s idmapping. */
</span></span><span class="line"><span class="cl">make_kuid(filesystem, uid) = kuid
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意，这两个函数是相反的。考虑以下idmappings:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">caller idmapping:     u0:k10000:r10000
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k20000:r10000
</span></span><span class="line"><span class="cl">mount idmapping:      u0:k10000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>假设从磁盘读取属于<code>u1000</code>的文件。文件系统根据它的<code>idmapping</code>将这个id映射到<code>k21000</code>。这是存储在<code>inode</code>的<code>i_uid</code>和<code>i_gid</code>字段中的内容。</p>
<p>当调用者通过<code>stat()</code>查询这个文件的所有权时，内核通常会简单地使用交叉映射算法，并将文件系统的内核id映射到调用者的idmapping中的用户空间id。</p>
<p>但是当调用者访问idmapped挂载上的文件时，内核会首先调用<code>i_uid_into_mnt()</code>，从而将文件系统的内核id转换成挂载的idmapping中的内核id:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">i_uid_into_mnt(k21000):
</span></span><span class="line"><span class="cl">  /* Map the filesystem&#39;s kernel id up into a userspace id. */
</span></span><span class="line"><span class="cl">  from_kuid(u0:k20000:r10000, k21000) = u1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /* Map the filesystem&#39;s userspace id down ito a kernel id in the mount&#39;s idmapping. */
</span></span><span class="line"><span class="cl">  make_kuid(u0:k10000:r10000, u1000) = k11000
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，当内核向调用者报告所有者时，它将把挂载的idmapping中的内核id转换为调用者idmapping中的用户空间id:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k10000:r10000, k11000) = u1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以通过验证在创建新文件时发生了什么来测试这个算法是否真的有效。假设用户正在创建一个u1000的文件。</p>
<p>内核将其映射到调用者的idmapping中的k11000。通常，内核现在会应用交叉映射，验证k11000可以映射到文件系统idmapping中的用户空间id。由于k11000不能直接映射到文件系统的idmapping中，所以创建请求失败。</p>
<p>但是当调用者访问idmapped挂载上的文件时，内核会首先调用<code>mapped_fs*id()</code>，从而根据挂载的idmapping将调用者的内核id转换成一个内核id:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mapped_fsuid(k11000):
</span></span><span class="line"><span class="cl">   /* Map the caller&#39;s kernel id up into a userspace id in the mount&#39;s idmapping. */
</span></span><span class="line"><span class="cl">   from_kuid(u0:k10000:r10000, k11000) = u1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   /* Map the mount&#39;s userspace id down into a kernel id in the filesystem&#39;s idmapping. */
</span></span><span class="line"><span class="cl">   make_kuid(u0:k20000:r10000, u1000) = k21000
</span></span></code></pre></td></tr></table>
</div>
</div><p>当最后写入磁盘时，内核会将k21000映射到文件系统的idmapping中的用户空间id:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k20000:r10000, k21000) = u1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>正如我们所看到的，我们最终得到了一个可逆的，因此信息保持的算法。在idmapped挂载上从u1000创建的文件也会被报告为u1000所拥有，反之亦然。</p>
<p>现在，让我们在idmapped挂载上下文中简要地重新考虑前面失败的例子。</p>
<h3 id="例2-reconsider">例2 reconsider</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">caller id:            u1000
</span></span><span class="line"><span class="cl">caller idmapping:     u0:k10000:r10000
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k20000:r10000
</span></span><span class="line"><span class="cl">mount idmapping:      u0:k10000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>当调用者使用非初始idmapping时，通常的情况是将相同的idmapping附加到挂载上。现在我们执行三个步骤:</p>
<ol>
<li>在调用者的idmapping中将调用者的用户空间id映射到内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k10000:r10000, u1000) = k11000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>将调用者的内核id转换为文件系统idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mapped_fsuid(k11000):
</span></span><span class="line"><span class="cl">  /* Map the kernel id up into a userspace id in the mount&#39;s idmapping. */
</span></span><span class="line"><span class="cl">  from_kuid(u0:k10000:r10000, k11000) = u1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /* Map the userspace id down into a kernel id in the filesystem&#39;s idmapping. */
</span></span><span class="line"><span class="cl">  make_kuid(u0:k20000:r10000, u1000) = k21000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k20000:r10000, k21000) = u1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以磁盘上的所有权是u1000。</p>
<h3 id="例3-reconsidered">例3 reconsidered</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">caller id:            u1000
</span></span><span class="line"><span class="cl">caller idmapping:     u0:k10000:r10000
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k0:r4294967295
</span></span><span class="line"><span class="cl">mount idmapping:      u0:k10000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样的转换算法也适用于第三个例子。</p>
<ol>
<li>在调用者的idmapping中将调用者的用户空间id映射到内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k10000:r10000, u1000) = k11000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>将调用者的内核id转换为文件系统idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mapped_fsuid(k11000):
</span></span><span class="line"><span class="cl">   /* Map the kernel id up into a userspace id in the mount&#39;s idmapping. */
</span></span><span class="line"><span class="cl">   from_kuid(u0:k10000:r10000, k11000) = u1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   /* Map the userspace id down into a kernel id in the filesystem&#39;s idmapping. */
</span></span><span class="line"><span class="cl">   make_kuid(u0:k0:r4294967295, u1000) = k1000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k0:r4294967295, k21000) = u1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以磁盘上的所有权是u1000。</p>
<h3 id="例4-reconsidered">例4 reconsidered</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">file id:              u1000
</span></span><span class="line"><span class="cl">caller idmapping:     u0:k10000:r10000
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k0:r4294967295
</span></span><span class="line"><span class="cl">mount idmapping:      u0:k10000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了向用户空间报告所有权，内核现在使用我们前面介绍的转换算法执行三个步骤:</p>
<ol>
<li>将磁盘上的用户空间id映射到文件系统idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k0:r4294967295, u1000) = k1000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>将内核id转换为挂载的idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">i_uid_into_mnt(k1000):
</span></span><span class="line"><span class="cl">  /* Map the kernel id up into a userspace id in the filesystem&#39;s idmapping. */
</span></span><span class="line"><span class="cl">  from_kuid(u0:k0:r4294967295, k1000) = u1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /* Map the userspace id down into a kernel id in the mounts&#39;s idmapping. */
</span></span><span class="line"><span class="cl">  make_kuid(u0:k10000:r10000, u1000) = k11000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>在调用者的idmapping中将内核id映射到用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k10000:r10000, k11000) = u1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>之前，调用者的内核id不能在文件系统的idmapping中交叉映射。有了idmapped挂载之后，现在可以通过挂载的idmapping将它交叉映射到文件系统的idmapping中。现在将根据挂载的idmapping使用u1000创建文件。</p>
<h3 id="例5-reconsidered">例5 reconsidered</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">file id:              u1000
</span></span><span class="line"><span class="cl">caller idmapping:     u0:k10000:r10000
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k20000:r10000
</span></span><span class="line"><span class="cl">mount idmapping:      u0:k10000:r10000
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样，为了向用户空间报告所有权，内核现在使用我们前面介绍的转换算法执行三个步骤:</p>
<ol>
<li>将磁盘上的用户空间id映射到文件系统idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k20000:r10000, u1000) = k21000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>将内核id转换为挂载的idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">i_uid_into_mnt(k21000):
</span></span><span class="line"><span class="cl">  /* Map the kernel id up into a userspace id in the filesystem&#39;s idmapping. */
</span></span><span class="line"><span class="cl">  from_kuid(u0:k20000:r10000, k21000) = u1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /* Map the userspace id down into a kernel id in the mounts&#39;s idmapping. */
</span></span><span class="line"><span class="cl">  make_kuid(u0:k10000:r10000, u1000) = k11000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>在调用者的idmapping中将内核id映射到用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k10000:r10000, k11000) = u1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>以前，文件的内核id不能在文件系统的idmapping中交叉映射。有了idmapped挂载之后，现在可以通过挂载的idmapping将它交叉映射到文件系统的idmapping中。根据挂载的idmapping，该文件现在属于u1000。</p>
<h2 id="更改主目录的所有权">更改主目录的所有权</h2>
<p>我们在上面已经看到了当调用者、文件系统或两者都使用非初始idmapping时，如何使用idmapped挂载在idmapping之间进行转换。当调用者使用非初始idmapping时，存在各种各样的用例。这通常发生在容器化工作负载的上下文中。结果就像我们看到的那样，对于使用初始idmapping挂载的文件系统和使用非初始idmapping挂载的文件系统，对文件系统的访问无法工作，因为内核id不能在调用者的和文件系统的idmapping之间交叉映射。</p>
<p>正如我们在上面看到的，idmapped挂载提供了一种解决方案，它根据挂载的idmapping重新映射调用者或文件系统的idmapping。</p>
<p>除了容器化的工作负载之外，idmapped挂载还有一个优点:当调用者和文件系统都使用初始idmapping时，它们也可以工作，这意味着主机上的用户可以在每次挂载的基础上改变目录和文件的所有权。</p>
<p>考虑我们前面的示例，其中用户的主目录位于可移植存储上。在家里，他们的id是u1000，在他们的主目录中的所有文件都属于u1000，而在uni或work，他们的登录id是u1125。</p>
<p>带着他们的主目录会有问题。它们不能轻松地访问它们的文件，如果不应用宽松的权限或acl，它们可能无法写入磁盘，而且即使它们可以这样做，它们也将以u1000和u1125拥有的文件和目录混合而结束。</p>
<p>Idmapped挂载允许解决这个问题。用户可以在他们的工作计算机或家里的计算机上为他们的主目录创建idmapped挂载，这取决于他们希望最终在便携存储本身上拥有什么所有权。</p>
<p>假设他们希望磁盘上的所有文件都属于u1000。当用户在他们的工作岗位插入便携存储时，他们可以设置一个作业，该作业创建一个idmapped挂载，其中的idmapping最小值为u1000:k1125:r1。所以现在当他们创建一个文件时，内核执行以下步骤，我们已经从上面知道::</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">caller id:            u1125
</span></span><span class="line"><span class="cl">caller idmapping:     u0:k0:r4294967295
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k0:r4294967295
</span></span><span class="line"><span class="cl">mount idmapping:      u1000:k1125:r1
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>在调用者的idmapping中将调用者的用户空间id映射到内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k0:r4294967295, u1125) = k1125
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>将调用者的内核id转换为文件系统idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mapped_fsuid(k1125):
</span></span><span class="line"><span class="cl">  /* Map the kernel id up into a userspace id in the mount&#39;s idmapping. */
</span></span><span class="line"><span class="cl">  from_kuid(u1000:k1125:r1, k1125) = u1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /* Map the userspace id down into a kernel id in the filesystem&#39;s idmapping. */
</span></span><span class="line"><span class="cl">  make_kuid(u0:k0:r4294967295, u1000) = k1000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>验证调用者的内核id可以映射到文件系统的idmapping中的用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k0:r4294967295, k1000) = u1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此，最终将在磁盘上创建u1000文件。</p>
<p>现在让我们简单地看看id为u1125的调用者将在他们的工作计算机上看到什么所有权:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">file id:              u1000
</span></span><span class="line"><span class="cl">caller idmapping:     u0:k0:r4294967295
</span></span><span class="line"><span class="cl">filesystem idmapping: u0:k0:r4294967295
</span></span><span class="line"><span class="cl">mount idmapping:      u1000:k1125:r1
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>将磁盘上的用户空间id映射到文件系统idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">make_kuid(u0:k0:r4294967295, u1000) = k1000
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>将内核id转换为挂载的idmapping中的内核id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">i_uid_into_mnt(k1000):
</span></span><span class="line"><span class="cl">  /* Map the kernel id up into a userspace id in the filesystem&#39;s idmapping. */
</span></span><span class="line"><span class="cl">  from_kuid(u0:k0:r4294967295, k1000) = u1000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /* Map the userspace id down into a kernel id in the mounts&#39;s idmapping. */
</span></span><span class="line"><span class="cl">  make_kuid(u1000:k1125:r1, u1000) = k1125
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>在调用者的idmapping中将内核id映射到用户空间id:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from_kuid(u0:k0:r4294967295, k1125) = u1125
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此，最终将报告调用者文件属于u1125，在我们的示例中，u1125是调用者工作站上的用户空间id。</p>
<p>放置在磁盘上的原始用户空间id是u1000，因此当用户将他们的主目录返回到他们的主计算机时，他们使用初始idmapping分配了u1000，并使用初始idmapping挂载文件系统，他们将看到u1000拥有的所有文件。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-05-30</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux/">linux</a>,&nbsp;<a href="/tags/kernel/">kernel</a>,&nbsp;<a href="/tags/filesystem/">filesystem</a>,&nbsp;<a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/2022/05/0005-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81/" class="prev" rel="prev" title="自动挂载支持"><i class="fas fa-angle-left fa-fw"></i>自动挂载支持</a>
            <a href="/2022/05/0001-fetch%E4%B8%8Epull%E5%8C%BA%E5%88%AB/" class="next" rel="next" title="git fetch与pull区别">git fetch与pull区别<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2017 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">ding jing</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript" src="/lib/valine/Valine.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/algoliasearch/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/twemoji/twemoji.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":100},"comment":{"valine":{"appId":"oGOJ6TSiiaaOrhXD1bEYILk9-gzGzoHsz","appKey":"lbK71uSxpg4XmLmvm2h13JdJ","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-cn","pageSize":10,"placeholder":"你的评论 ...","recordIP":true,"serverURLs":"https://ogoj6tsi.lc-cn-n1-shared.com","visitor":true}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"PASDMWALPK","algoliaIndex":"index.zh-cn","algoliaSearchKey":"b42948e51daaa93df92381c8e2ac0f93","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":80,"type":"algolia"},"twemoji":true};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
