# Makefile


## 概述
在 Linux（unix）环境下使用 GNU 的 make 工具能够比较容易的构建一个属于你自己的工程，整个工程的编译只需要一个命令就可以完成编译、连接以至于最后的执行

Makefile 文件描述了整个工程的编译、连接等规则。其中包括：工程中的哪些源文件需要编译以及如何编译、需要创建那些库文件以及如何创建这些库文件、如何最后产生我们想要得可执行文件。

make 是一个命令工具，它解释 Makefile 中的指令（应该说是规则）。在 Makefile文件中描述了整个工程所有文件的编译顺序、编译规则。Makefile 有自己的书写格式、关键字、函数。像 C 语言有自己的格式、关键字和函数一样。而且在 Makefile 中可以使用系统 shell 所提供的任何命令来完成想要的工作。Makefile（在其它的系统上可能是另外的文件名）在绝大多数的 IDE 开发环境中都在使用，已经成为一种工程的编译方法。

### 基本概念
#### 编译
把高级语言书写的代码转换为机器可识别的机器指令。通常，一个高级语言的源文件都可对应一个目标文件。目标文件在Linux 中默认后缀为“.o”（如“foo.c”的目标文件为“foo.o”）。
#### 链接
将多.o 文件，或者.o 文件和库文件链接成为可被操作系统执行的可执行程序（Linux 环境下，可执行文件的格式为“ELF”格式）。链接器不检查函数所在的源文件，只检查所有.o 文件中的定义的符号。将.o 文件中使用的函数和其它.o 或者库文件中的相关符号进行合并，对所有文件中的符号进行重新安排（重定位），并链接系统相关文件（程序启动文件等）最终生成可执行程序。链接过程使用 GNU 的“ld”工具。
#### 静态库
静态库又称为文档文件（Archive File）。它是多个.o 文件的集合。Linux 中静态库文件的后缀为“.a”。静态库中的各个成员（.o 文件）没有特殊的存在格式，仅仅是一个.o 文件的集合。使用“ar”工具维护和管理静态库。
#### 共享库
共享库也是多个.o 文件的集合，但是这些.o 文件时有编译器按照一种特殊的方式生成（Linux 中，共享库文件格式通常为“ELF”格式。共享库已经具备了可执行条件）。模块中各个成员的地址（变量引用和函数调用）都是相对地址。使用此共享库的程序在运行时，共享库被动态加载到内存并和主程序在内存中进行连接。多个可执行程序可共享库文件的代码段（多个程序可以共享的使用库中的某一个模块，共享代码，不共享数据）。另外共享库的成员对象可被执行（由 libdl.so 提供支持）。

## GNU make介绍
make 在执行时，需要一个命名为 Makefile 的文件。这个文件告诉 make 以何种方式编译源代码和链接程序。

make 通过比较对应文件（规则的目标和依赖）的最后修改时间，来决定哪些文件需要更新、那些文件不需要更新。对需要更新的文件 make 就执行数据库中所记录的相应命令（在 make 读取 Makefile 以后会建立一个编译过程的描述数据库。此数据库中记录了所有各个文件之间的相互关系，以及它们的关系描述）来重建它，对于不需要重建的文件 make 什么也不做。

当使用 make 工具进行编译时，工程中以下几种文件在执行 make 时将会被编译（重新编译）：
1. 所有的源文件没有被编译过，则对各个 C 源文件进行编译并进行链接，生成最后的可执行程序；
2. 每一个在上次执行 make 之后修改过的 C 源代码文件在本次执行 make 时将会被重新编译；
3. 头文件在上一次执行 make 之后被修改。则所有包含此头文件的 C 源文件在本次执行 make 时将会被重新编译。

后两种情况是 make 只将修改过的 C 源文件重新编译生成.o 文件，对于没有修改的文件不进行任何工作。重新编译过程中，任何一个源文件的修改将产生新的对应的.o文件，新的.o 文件将和以前的已经存在、此次没有重新编译的.o 文件重新连接生成最后的可执行程序。

### Makefile 规则介绍
一个简单的 Makefile 描述规则组成：
```shell
<目标>:<依赖> ...
    <命令>
    ...
```
- `目标`：通常是最后需要生成的文件名或者为了实现这个目的而必需的中间过程文件名。可以是.o文件、也可以是最后的可执行程序的文件名等。另外，目标也可以是一个make执行的动作的名称，如目标“clean”，我们称这样的目标是“伪目标”。
- `依赖`：生成规则目标所需要的文件名列表。通常一个目标依赖于一个或者多个文件。
- `命令`：是规则所要执行的动作（任意的 shell 命令或者是可在shell 下执行的程序）。它限定了 make 执行这条规则时所需要的动作。

一个规则可以有多个命令行，每一条命令占一行。注意：每一个命令行必须以[Tab]字符开始，[Tab]字符告诉 make 此行是一个命令行。make 按照命令完成相应的动作。

命令就是在任何一个目标的依赖文件发生变化后重建目标的动作描述。一个目标可以没有依赖而只有动作（指定的命令）。比如 Makefile 中的目标“clean”

在 Makefile 中“规则”就是描述在什么情况下、如何重建规则的目标文件，通常规则中包括了目标的依赖关系（目标的依赖文件）和重建目标的命令。make 执行重建目标的命令，来创建或者重建规则的目标（此目标文件也可以是触发这个规则的上一个规则中的依赖文件）。规则包含了文件之间的依赖关系和更新此规则目标所需要的命令。

make 程序根据规则的依赖关系，决定是否执行规则所定义的命令的过程我们称之为`执行规则`。

书写makefile时，可以将一个较长行使用反斜线（\）来分解为多行，这样可以使我们的Makefile书写清晰、容易阅读理解。但需要注意：**反斜线之后不能有空格（这也是大家最容易犯的错误，错误比较隐蔽）**

### Makefile 如何工作
默认的情况下，make执行的是Makefile中的第一个规则，此规则的第一个目标称之为“最终目的”或者“终极目标”（就是一个Makefile最终需要更新或者创建的目标）

当在 shell 提示符下输入“make”命令以后。make 读取当前目录下的 Makefile 文件，并将 Makefile 文件中的第一个目标作为其执行的“终极目标”，开始处理第一个规则（终极目标所在的规则）。如果目标依赖一些 `.o` 文件，对这些.o 文件为目标的规则处理有下列三种情况：
1. 目标.o 文件不存在，使用其描述规则创建它；
2. 目标.o 文件存在，目标.o 文件所依赖的.c 源文件、.h 文件中的任何一个比目标.o文件“更新”（在上一次 make 之后被修改）。则根据规则重新编译生成它；
3. 目标.o 文件存在，目标.o 文件比它的任何一个依赖文件（的.c 源文件、.h 文件）“更新”（它的依赖文件在上一次 make 之后没有被修改），则什么也不做。
这些.o 文件所在的规则之所以会被执行，是因为这些.o 文件出现在“终极目标”的依赖列表中。

完成了对.o 文件的创建（第一次编译）或者更新之后，make 程序将处理终极目标所在的规则，分为以下三种情况：
1. 目标文件不存在，则执行规则以创建目标。
2. 目标文件存在，其依赖文件中有一个或者多个文件比它“更新”，则根据规则重新链接生成。
3. 目标文件存在，它比它的任何一个依赖文件都“更新”，则什么也不做。

### 指定变量
```shell
edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o
    cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o
```
针对一个 Makefile 规则，.o 文件列表出现了两次；第一次：作为目标“edit”的依赖文件列表出现，第二次：规则命令行中作为“cc”的参数列表。这样做所带来的问题是：如果我们需要为目标“edit”增加一个的依赖文件，我们就需要在两个地方添加（依赖文件列表和规则的命令中）。添加时可能在“edit”的依赖列表中加入了、但却忘记了给命令行中添加，或者相反。这就给后期的维护和修改带来了很多不方便，添加或修改时出现遗漏。

为了避免这个问题，在实际工作中大家都比较认同的方法是，使用一个变量“objects”、“OBJECTS”、“objs”、“OBJS”、“obj”或者“OBJ”来作为所有的.o 文件的列表的替代。在使用到这些文件列表的地方，使用此变量来代替。在上例的 Makefile 中我们可以添加这样一行：
```shell
objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o

edit : $(objects)
    cc -o edit $(objects)


clean :
    rm edit $(objects)
```
当我们需要为终极目标“edit”增加或者去掉一个.o 依赖文件时，只需要改变“objects”的定义（加入或者去掉若干个.o 文件）。这样做不但减少书写的工作量，而且可以减少修改而产生错误的可能。

### 自动推导规则

在使用make编译.c源文件时，编译.c源文件规则的命令可以不用明确给出。这是因为make本身存在一个默认的规则，能够自动完成对.c文件的编译并生成对应的.o文件。它执行命令“cc -c”来编译.c源文件。在Makefile中我们只需要给出需要重建的目标文件名（一个.o文件），make会自动为这个.o文件寻找合适的依赖文件（对应的.c文件。对应是指：文件名除后缀外，其余都相同的两个文件），而且使用正确的命令来重建这个目标文件。

这样，在书写 Makefile 时，我们就可以省略掉描述.c 文件和.o 依赖关系的规则，而只需要给出那些特定的规则描述（.o 目标所需要的.h 文件）。

### 另类风格的 makefile
上一节中我们提到过，Makefile 中，所有的.o 目标文件都可以使用隐含规则由 make 自动重建，我们可以根据这一点书写更加简洁的 Makefile。而且在这个 Makefile 中，我们是根据依赖而不是目标对规则进行分组。形成另外一种风格的 Makefile。实现如下：

```shell
#sample Makefile
objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o

edit : $(objects)
    cc -o edit $(objects)

$(objects) : defs.h

kbd.o command.o files.o : command.h

display.o insert.o search.o files.o : buffer.h
```
本例中，我们以三个头文件为出发点，对依赖于每一个头文件的目标进行合并。书写出一个多目标规则，规则中多个目标同时依赖于对应的头文件，而且同一个文件可能同时存在多个规则中。例子中头文件“defs.h”作为所有.o 文件的依赖文件。其它两个头文件作为规则所有目标文件（多个.o 文件）的依赖文件。

**这种风格的 Makefile 并不值得我们借鉴。**

问题在于：同时把多个目标文件的依赖放在同一个规则中进行描述（一个规则中含有多个目标文件），这样导致规则定义不明了，比较混乱。建议大家不要在 Makefile 中采用这种方式了书写。否则后期维护将会是一件非常痛苦的事情。

书写规则建议的方式是：单目标，多依赖。就是说尽量要做到一个规则中只存在一个目标文件，可有多个依赖文件。尽量避免使用多目标，单依赖的方式。这样书写的好处是后期维护会非常方便，而且这样做会使 Makefile 会更清晰、明了。

### 清楚工作目录过程文件
规则除了完成源代码编译之外，也可以完成其它任务。例如：前边提到的为了实现清除当前目录中编译过程中产生的临时文件（edit 和哪些.o 文件）的规则：
```shell
clean :
    rm edit $(objects)
```

在实际应用时，我们把这个规则写成如下稍微复杂一些的样子。以防止出现始料未及的情况。
```shell
.PHONY : clean

clean :
    -rm edit $(objects)
```

这两个实现有两点不同： 
1. 通过“.PHONY”特殊目标将“clean”目标声明为伪目标。避免当磁盘上存在一个名为“clean”文件时，目标“clean”所在规则的命令无法执行
2. 在命令行之前使用“-”，意思是忽略命令“rm”的执行错误。

> 实际使用时候， clean 这种目标不应该作为第一个规则(也就是终极目标)，因为 makefile 是用来构建项目的，并不是做清楚操作。clean目标的出现是为了方便执行 `make clean` 时候手动调用 clean 目标清空中间文件，保证项目干净。

## Makefile 总述
在一个完整的 Makefile 中，包含了 5 个东西：`显式规则`、`隐含规则`、`变量定义`、`指示符` 和 `注释`。
- 显式规则：它描述了在何种情况下如何更新一个或者多个被称为目标的文件（Makefile 的目标文件）。书写 Makefile 时需要明确地给出目标文件、目标的依赖文件列表以及更新目标文件所需要的命令（有些规则没有命令，这样的规则只是纯粹的描述了文件之间的依赖关系）。
- 隐含规则：它是make根据一类目标文件（典型的是根据文件名的后缀）而自动推导出来的规则。make根据目标文件的名，自动产生目标的依赖文件并使用默认的命令来对目标进行更新（建立一个规则）。
- 变量定义：使用一个字符或字符串代表一段文本串，当定义了一个变量以后，Makefile后续在需要使用此文本串的地方，通过引用这个变量来实现对文本串的使用。第一章的例子中，我们就定义了一个变量“objects”来表示一个.o文件列表。
- Makefile 指示符：指示符指明在 make 程序读取 makefile 文件过程中所要执行的一个动作。其中包括：
  - `包含`:读取给定文件名的文件，将其内容作为makefile文件的一部分。
  - `判断`:（通常是根据一个变量的得值）处理或者忽略Makefile中的某一特定部分。
  - `定义`:定义一个多行变量。
- 注释：Makefile 中“#”字符后的内容被作为是注释内容（和 shell 脚本一样）处理。如果此行的第一个非空字符为“#”，那么此行为注释行。注释行的结尾如果存在反斜线（\），那么下一行也被作为注释行。一般在书写 Makefile 时推荐将注释作为一个独立的行，而不要和 Makefile 的有效行放在一行中书写。当在 Makefile 中需要使用字符“#”时，可以使用反斜线加“#”（`\#`）来实现（对特殊字符“#”的转义），其表示将“#”作为一字符而不是注释的开始标志。

> Makefile 中第一个规则之后的所有以[Tab]字符开始的的行，make 程序都会将其交给系统 shell 程序去解释执行。因此，以[Tab]字符开始的注释行也会被交给 shell 来处理，此命令行是否需要被执行（shell 执行或者忽略）是由系统 shell 程序来判决的。

在使用指示符“define”定义一个多行的变量或者命令包时，其定义体（“define”和“endef”之间的内容）会被完整的展开到 Makefile 中引用此变量的地方（包含定义体中的注释行）；make 在引用此变量的地方对所有的定义体进行处理，决定是注释还是有效内容。Makefile 中变量的引用和 C 语言中的宏类似（但是其实质并不相同，后续将会详细讨论）。对一个变量引用的地方 make 所做的就是将这个变量根据定义进行基于文本的展开，展开变量的过程不涉及到任何变量的具体含义和功能分析。

### makefile 文件的命名
默认的情况下，make 会在工作目录（执行 make 的目录）下按照文件名顺序寻找 makefile 文件读取并执行，查找的文件名顺序为：“GNUmakefile”、“makefile”、“Makefile”。

通常应该使用“makefile”或者“Makefile”作为一个 makefile 的文件名（我们推荐使用“Makefile”，首字母大写而比较显著，一般在一个目录中和当前目录的一些重要 文 件 （ README,Chagelist 等 ） 靠 近 ， 在 寻 找 时 会 比 较 容 易 的 发 现 它 ）。 而“GNUmakefile”是我们不推荐使用的文件名，因为以此命名的文件只有“GNU make”才可以识别，而其他版本的 make 程序只会在工作目录下“makefile”和“Makefile”这两个文件。

如果make程序在工作目录下无法找到以上三个文件中的任何一个，它将不读取任何其他文件作为解析对象。但是根据make隐含规则的特性，我们可以通过命令行指定一个目标，如果当前目录下存在符合此目标的依赖文件，那么这个命令行所指定的目标将会被创建或者更新。

当 makefile 文件的命名不是这三个任何一个时，需要通过 make 的“-f”或者“--file”选项来指定 make 读取的 makefile 文件。给 make 指定 makefile 文件的格式为：“-fNAME”或者“—file=NAME”，它指定文件“NAME”作为执行 make 时读取的 makefile文件。也可以通过多个“-f”或者“--file”选项来指定多个需要读取的 makefile 文件，多个 makefile 文件将会被按照指定的顺序进行链接并被 make 解析执行。当通过“-f”或者“--file”指定 make 读取 makefile 的文件时，make 就不再自动查找这三个标准命名的 makefile 文件。

### 包含其它 makefile

Makefile 中包含其它文件所需要使用的关键字是“include”，和 c 语言对头文件的包含方式一致。“include”指示符告诉 make 暂停读取当前的 Makefile，而转去读取“include”指定的一个或者多个文件，完成以后再继续当前 Makefile 的读取。Makefile 中指示符“include”书写在独立的一行，其形式如下：
```shell
include 文件1  文件2
```
**FILENAMES 是 shell 所支持的文件名（可以使用通配符）**

指示符“include”所在的行可以一个或者多个空格（make程序在处理时将忽略这些空格）开始，切忌不能以[Tab]字符开始（如果一行以[Tab]字符开始make程序将此行作为一个命令行来处理）。指示符“include”和文件名之间、多个文件之间使用空格或者[Tab]键隔开。行尾的空白字符在处理时被忽略。使用指示符包含进来的Makefile中，如果存在变量或者函数的引用。它们将会在包含它们的Makefile中被展开

来看一个例子，存在三个.mk 文件 a.mk、b.mk、c.mk，“$(bar)”被扩展为“bish bash”。则：
```shell
include foo *.mk $(bar)
# 等价于
include foo a.mk b.mk c.mk bish bash
```

make 程序在处理指示符 include 时，将暂停对当前使用指示符“include”的 makefile 文件的读取，而转去依此读取由“include”指示符指定的文件列表。直到完成所有这些文件以后再回过头继续读取指示符“include”所在的 makefile文件。

通常指示符“include”用在以下场合：
1. 有多个不同的程序，由不同目录下的几个独立的Makefile来描述其重建规则。它们需要使用一组通用的变量定义(后续说明)或者模式规则(后续说明)。通用的做法是将这些共同使用的变量或者模式规则定义在一个文件中（没有具体的文件命名限制），在需要使用的Makefile中使用指示符“include”来包含此文件。
2. 当根据源文件自动产生依赖文件时；我们可以将自动产生的依赖关系保存在另外一个文件中，主Makefile使用指示符“include”包含这些文件。这样的做法比直接在主Makefile中追加依赖文件的方法要明智的多。其它版本的make已经使用这种方式来处理。

如果指示符“include”指定的文件不是以斜线开始（绝对路径，如/usr/src/Makefile...），而且当前目录下也不存在此文件；make将根据文件名试图在以下几个目录下查找：首先，查找使用命令行选项“-I”或者“--include-dir”指定的目录，如果找到指定的文件，则使用这个文件；否则继续依此搜索以下几个目录（如果其存在）：“/usr/gnu/include”、“/usr/local/include”和“/usr/include”。

当在这些目录下都没有找到“include”指定的文件时，make将会提示一个包含文件未找到的告警提示，但是不会立刻退出。而是继续处理Makefile的后续内容。当完成读取整个Makefile后，make将试图使用规则来创建通过指示符“include”指定的但未找到的文件，当不能创建它时（没有创建这个文件的规则），make将提示致命错误并退出。会输出类似如下错误提示：
```
Makefile:错误的行数：未找到文件名：提示信息（No such file or directory）
Make： *** No rule to make target ‘<filename>’. Stop
```

通常我们在 Makefile 中可使用“-include”来代替“include”，来忽略由于包含文件不存在或者无法创建时的错误提示（“-”的意思是告诉 make，忽略此操作的错误。make 继续执行）。像下边那样：
```
-include FILENAMES...
```

使用这种方式时，当所要包含的文件不存在时不会有错误提示、make 也不会退出；除此之外，和第一种方式效果相同。以下是这两种方式的比较：
- 使用“include FILENAMES...”，make 程序处理时，如果“FILENAMES”列表中的任何一个文件不能正常读取而且不存在一个创建此文件的规则时 make 程序将会提示错误并退出。
- 使用“-include FILENAMES...”的情况是，当所包含的文件不存在或者不存在一个规则去创建它，make 程序会继续执行，只有真正由于不能正确完成终极目标的重建时（某些必需的目标无法在当前已读取的 makefile 文件内容中找到正确的重建规则），才会提示致命错误并退出。

> 为了和其它的 make 程序进行兼容。也可以使用“sinclude”来代替“-include”

### 变量 `MAKEFILES`
如果在当前环境定义了一个“MAKEFILES”环境变量，make执行时首先将此变量的值作为需要读入的Makefile文件，多个文件之间使用空格分开。类似使用指示符
“include”包含其它Makefile文件一样，如果文件名非绝对路径而且当前目录也不存在此文件，make会在一些默认的目录去寻找，它和使用“include”的区别：
1. 环境变量指定的 makefile 文件中的“目标”不会被作为 make 执行的“终极目标”。就是说，这些文件中所定义规则的目标，make 不会将其作为“终极目标”来看待。
2. 环境变量所定义的文件列表，在执行 make 时，如果不能找到其中某一个文件（不存在或者无法创建）。make 不会提示错误，也不退出。就是说环境变量“MAKEFILES”定义的包含文件是否存在不会导致 make 错误（这是比较隐蔽的地方）。
3. make 在执行时，首先读取的是环境变量“MAKEFILES”所指定的文件列表，之后才是工作目录下的 makefile 文件，“include”所指定的文件是在 make 发现此关键字的时、暂停正在读取的文件而转去读取“include”所指定的文件。

变量“MAKEFILES”主要用在“make”的递归调用过程中的的通信。实际应用中很少设置此变量。因为一旦设置了此变量，在多级make 调用时；由于每一级make都会读取“MAKEFILES”变量所指定的文件，将导致执行出现混乱（这可能不是你想看到的执行结果）。不过，我们可以使用此环境变量来指定一个定义了通用“隐含规则”和变量的文件，比如设置默认搜索路径；通过这种方式设置的“隐含规则”和定义的变量可以被任何make进程使用（有点象C语言中的全局变量）。

> 不建议把 MAKEFILES 设置到全局环境变量里，推荐的做法实：在需要包含其它 makefile 文件时使用指示符“include”来实现。

### 变量 `MAKEFILE_LIST`
make 程序在读取多个 makefile 文件时，包括由环境变量“MAKEFILES”指定、命令行指、当前工作下的默认的以及使用指示符“include”指定包含的，在对这些文件进行解析执行之前 make 读取的文件名将会被自动依次追加到变量 “`MAKEFILE_LIST`” 的定义域中。

这样我们就可以通过测试此变量的最后一个字来获取当前 make 程序正在处理的makefile 文件名。具体地说就是在一个 makefile 文件中如果使用指示符“include”包含另外一个文件之后，变量“`MAKEFILE_LIST`”的最后一个字只可能是指示符“include”指定所要包含的那个文件的名字。一个 makefile 的内容如下：
```
name1 := $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
include inc.mk
name2 := $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))

all:
    @echo name1 = $(name1)
    @echo name2 = $(name2)
```
执行 make，则看到的将是如下的结果：
```
name1 = Makefile
name2 = inc.mk
```

### 其它特殊变量
GNU make支持一个特殊的变量，此变量不能通过任何途经给它赋值。它被展开为一个特定的值。这个重要的特殊的变量是“`.VARIABLES`”。它被展开以后是此引用点之前、makefile文件中所定义的所有全局变量列表。包括：空变量（未赋值的变量）和，但不包含目标指定的变量，目标指定变make的内嵌变量，量值在特定目标的上下文有效。

### makefile文件的重建
Makefile 可由其它文件生成，例如 RCS 或 SCCS 文件。如果 Makefile 由其它文件重建，那么在 make 在开始解析这个 Makefile 时需要重新读取更新后的 Makefile、而不是之前的 Makefile。make 的处理过程是这样的：

make 在读入所有 makefile 文件之后，首先将所读取的每个 makefile 作为一个目标，寻找更新它们的规则。如果存在一个更新某一个 makefile 文件明确规则或者隐含规则，就去更新对应的 makefile 文件。完成对所有的 makefile 文件的更新之后，如果之前所读取任何一个 makefile 文件被更新，那么 make 就清除本次执行的状态重新读取一遍所有的 makefile 文件（此过程中，同样在读取完成以后也会去试图更新所有的已经读取的 makefile 文件，但是一般这些文件不会再次被重建，因为它们在时间戳上已经是最新的）。读取完成以后再开始解析已经读取的 makefile 文件并开始执行必要的动作。

实际应用中，我们会明确给出makefile文件，而并不需要来由make自动重建它们。但是make在每一次执行时总会自动地试图重建那些已经存在的makefile文件，如果需要处于效率考虑，可以采用一些办法来避免make在执行过程时查找重建makefile的隐含规则。例如我们可以书写一个明确的规则，以makefile文件作为目标，规则的命令定义为空。

Makefile规则中，如果使用一个没有依赖只有命令行的双冒号规则去更新一个文件，那么每次执行make时，此规则的目标文件将会被无条件的更新（此规则定义的命令会被无条件执行）。如果这样一个规则的目标是makefile文件，那么执行make时，这个makefile文件（双冒号规则的目标）就会被无条件更新，而使得make的执行陷入到一个死循环（此makefile文件被不断的更新、重新读取、更新再重新读取的过程）。为了防止这种情况的发生，make在遇到一个目标是makefile文件的双冒号规则时，将忽略对这个规则的执行（其中包括了使用“MAKEFILES”指定、命令行选项指定、指示符“include”指定的需要make读取的所有makefile文件中定义的这一类双冒号规则）。

执行 make 时，如果没有使用“-f（--file）”选项指定一个文件，make 程序将读取缺省的文件。和使用“-f（--file）”选项不同，make 无法确定工作目录下是否存在缺省名称的 makefile 文件。如果缺省 makefile 文件不存在，但可以通过一个规则来创建它（此规则是隐含规则），则会自动创建缺省 makefile 文件，之后重新读取它并开始执行。

因此，如果在当前目录下不存在一个缺省的 makefile 文件，make 将会按照搜索makefile 文件的名称顺序去试图创建它，直到创建成功或者超越其缺省的命名顺序。需要明确的一点是：执行 make 时，如果不能成功地创建缺省的 makefile 文件，并不一定会导致错误。一个存在（缺省命名的或者可被创建的）的 makefile 文件并不是 make正确运行的前提。

当使用“-t（--touch）”选项来更新 Makefile 的目标文件（更新规则目标文件的时间戳）时，对于哪些是 makefile 文件的目标是无效的，这些目标文件（makefile 文件）的时间戳并不会被更新。就是说即使在执行 make 时使用了选项“-t”，那些目标是makefile 文件的规则同样也会被执行（重建这些 makefile 文件，而其它的规则不会被执行，make 只是简单的更新规则目标文件的时间戳）；类似还有选项“-q（—question）”和“-n（—just-print） ”，这主要是因为一个过时的 makefile 文件对其它目标的重建规则在当前看来可能是错误的。

正因为如此，执行命令“make –f mfile –n foo”首先会试图重建“mfile 文件”、并重新读取它，之后会打印出更新目标“foo”所要执行的命令（但不会真正的执行这些命令）。在这种情况时，如果不希望重建 makefile 文件。我们需要在执行 make 时，在命令行中将这个 makefile 文件作为一个最终目标，这样选项“–t”和其它的选项就对这个 makefile 文件目标有效，防止执行这个 makefile 作为目标的规则（如果是“-t”参数，则是简单的更新这个 makefile 文件的时间戳）。同样，命令“make –f mfile –n mfilefoo”会读取文件“mfile”，打印出重建文件“mfile”的命令、重建“foo”的命令而实际不执行任何命令。并且所打印的用于更新“foo”目标的命令是选项“-f”指定的、没有被重建的“mfile”文件中所定义的命令。

### 重载另一个 makefile
有些情况下，存在两个比较类似的 makefile 文件。其中一个（makefile-A）需要使用另外一个（makefile-B）中所定义的变量和规则。通常我们会想到在“makefile-A”中使用指示符“include”包含“mkaefile-B”来达到目的。

但使用这种方式，如果在两个 makefile 文件中存在相同目标，而在不同的文件中其描述规则使用不同的命令。这样，相同的目标文件就同时存在两个不同的规则命令，这是 makefile 所不允许的。遇到这种情况，使用指示符“include”显然是行不通的。

GNU make 提供另外一种途径来实现此目的。具体的做法如下：
  在需要包含的makefile文件（makefile-A）中，定义一个称之为“所有匹配模式”的规则，它用来述那些在“makefile-A”中没有给出明确创建规则的目标的重建规则。就是说，如果在当前makefile文件中不能找到重建一个目标的规则时，就使用“所有匹配模式”所在的规则来重建这个目标。

看一个例子，如果存在一个命名为“Makefile”的 makefile 文件，其中描述目标“foo”的规则和其他的一些规，我们也可以书写一个内容如下命名为“GNUmakefile”的文件。
```
#sample GNUmakefile
foo:
    frobnicate > foo

%: force
    @$(MAKE) -f Makefile $@

force: ;
```
执行命令“make foo”，make 将使用工作目录下命名为“GNUmakefile”的文件并执行目标“foo”所在的规则，创建目标“foo”的命令是：“frobnicate > foo”。

如果执行另外一个命令“make bar”，因为在“GUNmakefile”中没有此目标的更新规则。make 将使用“所有匹配模式”规则，执行命令“$(MAKE) -f Makefile bar”。如果文件“Makefile”中存在此目标更新规则的定义，那么这个规则会被执行。此过程同样适用于其它 “GNUmakefile”中没有给出的目标更新规则。此方式的灵活之处在于：如果在“Makefile”文件中存在同样一一个目标“foo”的重建规则，由于 make 执行时首先读取文件“GUNmakefile”并在其中能够找到目标“foo”的重建规则，所以 make就不会去执行这个“所有模式匹配规则”（上例中目标“%”所在的规则）。这样就避免了使用指示符“include”包含一个 makefile 文件时所带来的目标规则的重复定义问题。

此种方式，模式规则的模式只使用了单独的“%”（我们称他为“所有模式匹配规则”），它可以匹配任何一个目标；它的依赖是“force”，保证了即使目标文件已经存在也会执行这个规则（文件已存在时，需要根据它的依赖文件的修改情况决定是否需要重建这个目标文件）；“force”规则中使用空命令是为了防止 make 程序试图寻找一个规则去创建目标“force”时，又使用了模式规则“%: force”而陷入无限循环。

### make 如何解析 makefile
GUN make 的执行过程分为两个阶段:
1. 读取所有的 makefile 文件（包括“MAKIFILES”变量指定的、指示符“include”指定的、以及命令行选项“-f(--file)”指定的 makefile 文件），内建所有的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。
2. 根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新，并使用对应的规则来重建这些目标。

理解 make 执行过程的两个阶段是很重要的。它能帮助我们更深入的了解执行过程中变量以及函数是如何被展开的。

在 make 执行的第一阶段中如果变量和函数被展开，那么称此展开是“立即”的，此时所有的变量和函数被展开在需要构建的结构链表的对应规则中（此规则在建立链表是需要使用）。其他的展开称之为“延后”的。这些变量和函数不会被“立即”展开，而是直到后续某些规则须要使用时或者在 make 处理的第二阶段它们才会被展开。

#### 变量取值
变量定义解析的规则如下：
```
IMMEDIATE = DEFERRED
IMMEDIATE ?= DEFERRED
IMMEDIATE := IMMEDIATE
IMMEDIATE += DEFERRED or IMMEDIATE
define IMMEDIATE
DEFERRED
Endef
```
当变量使用追加符（+=）时，如果此前这个变量是一个简单变量（使用 :=定义的）则认为它是立即展开的，其它情况时都被认为是“延后”展开的变量。

#### 条件语句
所有使用到条件语句在产生分支的地方，make 程序会根据预设条件将正确地分支展开。就是说条件分支的展开是“立即”的。其中包括：“ifdef”、“ifeq”、“ifndef”和“ifneq”所确定的所有分支命令。

#### 规则的定义
所有的规则在 make 执行时，都按照如下的模式展开：
```
IMMEDIATE : IMMEDIATE ; DEFERRED
    DEFERRED
```
其中，规则中目标和依赖如果引用其他的变量，则被立即展开。而规则的命令行中的变量引用会被延后展开。此模板适合所有的规则，包括明确规则、模式规则、后缀规则、静态模式规则。

### 总结
make 的执行过程如下：
1. 依次读取变量“MAKEFILES”定义的 makefile 文件列表
2. 读取工作目录下的 makefile 文件（根据命名的查找顺序“GNUmakefile”，“makefile”，“Makefile”，首先找到那个就读取那个）
3. 依次读取工作目录 makefile 文件中使用指示符“include”包含的文件
4. 查找重建所有已读取的 makefile 文件的规则（如果存在一个目标是当前读取的某一个 makefile 文件，则执行此规则重建此 makefile 文件，完成以后从第一步开始重新执行）
5. 初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支
6. 根据“终极目标”以及其他目标的依赖关系建立依赖关系链表
7. 执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件）
8. 执行“终极目标”所在的规则

> 说明：
> <br/>执行一个规则的过程是这样的：
> <br/>对于一个存在的规则（明确规则和隐含规则）首先，make程序将比较目标文件和所有的依赖文件的时间戳。如果目标的时间戳比所有依赖文件的时间戳更新（依赖文件在上一次执行make之后没有被修改），那么什么也不做。否则（依赖文件中的某一个或者全部在上一次执行make后已经被修改过），规则所定义的重建目标的命令将会被执行。这就是make工作的基础，也是其执行规制所定义命令的依据。（后续讨论规则时将会对此详细地说明）

## Makefile 的规则
Makefile 中，规则描述了在何种情况下使用什么命令来重建一个特定的文件，此文件被称为规则“目标”（通常规则中的目标只有一个）。规则中出目标之外的罗列的其它文件称为“目标”的依赖，而规则的命令是用来更新或者创建此规则的目标。

除了 makefile 的“终极目标”所在的规则以外，其它规则的顺序在 makefile 文件中没有意义。“终极目标”就是当没有使用 make 命令行指定具体目标时，make 默认的更新的哪一个目标。

如果在 makefile 中第一个规则有多个目标的话，那么多个目标中的第一个将会被作为 make 的“终极目标”。有两种情况的例外：
1. 目标名以点号“.”开始的并且其后不存在斜线“/”（“./”被认为是当前目录；“../”被认为是上一级目录）;
2. 模式规则的目标。当这两种目标所在的规则是 Makefile 的第一个规则时，它们并不会被作为“终极目标”。

> “终极目标”是执行 make 的唯一目的，其所在的规则作为第一个被执行的规则。

### 规则语法
通常规则的语法格式如下：
```
TARGETS : PREREQUISITES
    COMMAND
    ...
```
或
```
TARGETS : PREREQUISITES ; COMMAND
    COMMAND
    ...
```
规则中“TARGETS”可以是空格分开的多个文件名，也可以是一个标签（例如：执行清空的“clean”）。“TARGETS”的文件名可以使用通配符，格式“A(M)”表示档案文件（Linux下的静态库.a文件）的成员“M”。通常规则只有一个目标文件（建议这么做），偶尔会在一个规则中需要多个目标。

书写规则是我们需要注意的几点：
1. 规则的命令部分有两种书写方式：
    a. 命令可以和目标：依赖描述放在同一行。命令在依赖文件列表后并使用分号（；）和依赖文件列表分开。
    b. 命令在目标：依赖的描述的下一行，作为独立的命令行。当作为独立的命令行时此行必须以[Tab]字符开始。
  在 Makefile 中，在第一个规则之后出现的所有以[Tab]字符开始的行都会被当作命令来处理。
2. Makefile 中符号“$”有特殊的含义（表示变量或者函数的引用），在规则中需要使用符号“$”的地方，需要书写两个连续的（“$$”）。
3. 前边已提到过，对于 Makefile 中一个较长的行，我们可以使用反斜线“\”将其书写到几个独立的物理行上。虽然 make 对 Makefile 文本行的最大长度是没有限制的，但还是建议这样做。不仅书写方便而且更有利于别人的阅读（这也是一个程序员修养的体现）。

一个规则告诉“make”两件事：
1. 目标在什么情况下已经过期； 
2. 如果需要重建目标时，如何去重建这个目标。

目标是否过期是由那些使用空格分割的规则的依赖文件所决定的。当目标文件不存在或者目标文件的最后修改时间比依赖文件中的任何一个晚时，目标就会被创建或者重建。就是说执行规则命令行的前提条件是以下两者之一：
1. 目标文件不存在； 
2. 目标文件存在，但是规则的依赖文件中存在一个依赖的最后修改时间比目标的最后修改时间晚。

规则的中心思想是：目标文件的内容是由依赖文件文件决定，依赖文件的任何一处改动，将导致目前已经存在的目标文件的内容过期。规则的命令为重建目标提供了方法。这些命令运行在系统 shell 之上。

### 依赖的类型
在 GNU make 的规则中可以使用两种不同类型的依赖：
1. 规则中使用的是常规依赖，这是书写 Makefile 规则时最常用的一种。
2. 另外一种在我们书写 Makefile 时不会经常使用，它比较特殊、称之为“order-only”依赖。

一个规则的常规依赖（通常是多个依赖文件）表明了两件事：首先，它决定了重建此规则目标所要执行规则（确切的说是执行命令）的顺序；表明在更新这个规则的目标（执行此规则的命令行）之前需要按照什么样的顺序、执行那些规则（命令）来重建这些依赖文件（对所有依赖文件的重建，使用明确或者隐含规则。就是说对于这样的规则：A:B C，那么在重建目标 A 之前，首先需要完成对它的依赖文件 B 和 C 的重建。重建 B 和 C 的过程就是执行 Makefile 中以文件 B 和 C 为目标的规则）。其次，它确定了一个依存关系；规则中如果依赖文件的任何一个比目标文件新，则认为规则的目标已经过期而需要重建目标文件。

通常，如果规则中依赖文件中的任何一个被更新，则规则的目标相应地也应该被更新。

在更新目标（目标文件已经存在）时只需要根据依赖文件中的部分来决定目标是否需要被重建，而不是在依赖文件的任何一个被修改后都重建目标。为了实现这一目的，相应的就需要对规则的依赖进行分类，一类是在这些依赖文件被更新后，需要更新规则的目标；另一类是更新这些依赖的，可不需要更新规则的目标。我们把第二类称为：“order-only”依赖。书写规则时，“order-only”依赖使用管道符号“|”开始，作为目标的一个依赖文件。规则依赖列表中管道符号“|”左边的是常规依赖，管道符号右边的就是“order-only”依赖。这样的规则书写格式如下：

```
TARGETS : NORMAL-PREREQUISITES | ORDER-ONLY-PREREQUISITES
```
这样的规则中常规依赖文件可以是空；同样也可以对一个目标进行多次追加依赖。需要注意：规则依赖文件列表中如果一个文件同时出现在常规列表和“order-only”列表中，那么此文件被作为常规依赖处理（因为常规依赖所实现的动作是“order-only”依赖所实现的动作的一个超集）。

“order-only”依赖的使用举例：
```
LIBS = libtest.a

foo : foo.c | $(LIBS)
    $(CC) $(CFLAGS) $< -o $@ $(LIBS)
```
make在执行这个规则时，如果目标文件“foo”已经存在。当“foo.c”被修改以后，目标“foo”将会被重建，但是当“libtest.a”被修改以后。将不执行规则的命令来重建目标“foo”。

> 就是说，规则中依赖文件$(LIBS)只有在目标文件不存在的情况下，才会参与规则的执行。当目标文件存在时此依赖不会参与规则的执行过程。

### 文件名使用通配符
Maekfile 中表示文件名时可使用通配符。可使用的通配符有：“\*”、“?”和“[…]”。在 Makefile 中通配符的用法和含义和 Linux（unix）的 Bourne shell 完全相同。例如，“\*.c”代表了当前工作目录下所有的以“.c”结尾的文件等。但是在 Makefile 中这些统配符并不是可以用在任何地方，Makefile 中统配符可以出现在以下两种场合：
1. 可以用在规则的目标、依赖中，make 在读取 Makefile 时会自动对其进行匹配处理(通配符展开)；
2. 可出现在规则的命令中，通配符的通配处理是在 shell 在执行此命令时完成的。除这两种情况之外的其它上下文中，不能直接使用通配符。而是需要通过函数“wildcard”来实现。

如果规则的一个文件名包含统配字符（“\*”、“.”等字符），在使用这样的文件时需要对文件名中的统配字符使用反斜线（\）进行转义处理。例如“foo\\\*bar”，在 Makefile中它表示了文件“foo\*bar”。Makefile 中对一些特殊字符的转移和 B-SHELL 以及 C 语言中的基本上相同。

另外需要注意：在 Linux（unix）中，以波浪线“~”开始的文件名有特殊含义。单独使用它或者其后跟一个斜线（~/），代表了当前用户的宿主目录（在 shell 下可以通过命令“echo ~(~\)”来查看）。

在一些系统中（像 MS-DOS 和 MS-Windows），用户没有各自的宿主目录，此情况下可通过设置环境变量“HOME”来模拟。

#### 通配符使用举例
通配符可被用在规则的命令中，它是在命令被执行时由 shell 进行处理。例如 Makefile 的清空过程文件规则：
```
clean:
    rm -f *.o
```

通配符也可以用在规则的依赖文件名中。看看下面这个例子。执行“make print”，执行的结果是打印当前工作目录下所有的在上一次打印以后被修改过的“.c”文件。
```
print: *.c
    lpr -p $?
    touch print
```

> 两点说明：
> <br/>1. 上述的规则中目标“print”时一个空目标文件。（当前目录下存在一个文件“print”，但我们不关心它的实际内容，此文件的作用只是记录最后一次执行此规则的时间）
> <br/>2. 自动环变量“$?”在这里表示依赖文件列表中被改变过的所有文件

变量定义中使用的通配符不会被统配处理（因此在变量定义中不能使用通配符，否则在某些情况下会出现非预期的结果）。在 Makefile 有这样一个变量定义：“objects = \*.o”。它表示变量“objects”的值是字符串“\*.o”（并不是期望的空格分开的.o 文件列表）。当需要变量“objects”代表所有.o 文件列表示，需要使用函数“wildcard”（objects = $(wildcar \*.o)）。

#### 通配符存在的缺陷
书写 Makefile 时，可能存在这种不正确的使用通配符的方法。这种看似正确的方式产生的结果可能产生非期望的结果。例如在你的Makefile 中，期望能够根据所有的.o 文件生成可执行文件“foo”。实现如下：
```
objects = *.o
foo : $(objects)
    cc -o foo $(CFLAGS) $(objects)
```
这里变量“objects”的值是一个字符串“\*.o”。在重建“foo”的规则中对变量“objects”进行展开，目标“foo”的依赖就是“\*.o”，即所有的.o 文件的列表。如果在工作目录下已经存在必需的.o 文件，那么这些.o 文件将成为目标的依赖文件，目标“foo”将根据规则被重建。

> 重建取决于当前目录下是否有 .o 文件

但是如果将工作目录下所有的.o 文件删除，重新执行 make 将会得到一个类似于“没有创建\*.o 文件的规则” 的错误提示。这当然不是我们所期望的结果（可能在出现这个错误时会令你感到万分迷惑！）。为了达到我们的初衷，在对变量进行定义的时需要使用一些高级的技巧，包括使用“wildcard”函数（变量定义为“objects=$(wildcard \*.o)”）和实现字符串的置换。

#### wildcard 函数
在规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数“wildcard”，它的用法是：$(wildcard PATTERN...) 。在 Makefile 中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。需要注意的是：这种情况下规则中通配符的展开和上一小节匹配通配符的区别。

一般我们可以使用“$(wildcard \*.c)”来获取工作目录下的所有的.c 文件列表。复杂一些用法；可以使用“$(patsubst %.c,%.o,$(wildcard \*.c))”，首先使用“wildcard”函数获取工作目录下的.c 文件列表；之后将列表中所有文件名的后缀.c 替换为.o。这样我们就可以得到在当前目录可生成的.o 文件列表。因此在一个目录下可以使用如下内容的 Makefile 来将工作目录下的所有的.c 文件进行编译并最后连接成为一个可执行文件：
```
#sample Makefile
objects := $(patsubst %.c,%.o,$(wildcard *.c))
foo : $(objects)
    cc -o foo $(objects)
```

### 目录搜寻
在一个较大的工程中，一般会将源代码和二进制文件（.o 文件和可执行文件）安排在不同的目录来进行区分管理。这种情况下，我们可以使用 make 提供的目录搜索依赖文件功能（在指定的若干个目录下自动搜索依赖文件）。在 Makefile 中，使用依赖文件的目录搜索功能。当工程的目录结构发生变化后，就可以做到不更改 Makefile 的规则，只更改依赖文件的搜索目录。

#### 一般目录搜索(变量VPATH)
GNU make 可以识别一个特殊变量“VPATH”。通过变量“VPATH”可以指定依赖文件的搜索路径，当规则的依赖文件在当前目录不存在时，make 会在此变量所指定的目录下去寻找这些依赖文件。通常我们都是用此变量来指定规则的依赖文件的搜索路径。其实“VPATH”变量所指定的是 Makefile 中所有文件的搜索路径，包括了规则的依赖文件和目标文件。

定义变量“VPATH”时，使用空格或者冒号（:）将多个需要搜索的目录分开。make搜索目录的顺序是按照变量“VPATH”定义中的目录顺序进行的（当前目录永远是第一搜索目录）。例如对变量的定义如下：
```
VPATH = src:../headers
```

这样我们就为所有规则的依赖指定了两个搜索目录，“src”和“../headers”。对于规则“foo:foo.c”如果“foo.c”存在于“src”目录下，此规则等价于“foo:src:/foo.c”。

通过“VPATH”变量指定的路径在 Makefile 中对所有文件有效。当需要为不同类型的文件指定不同的搜索目录时，需要使用另外一种方式。

#### 选择性搜索(关键字vpath)
使用 make 的“vpath”关键字（全小写的）。它不是一个变量，而是一个 make 的关键字，它所实现的功能和上一小节提到的“VPATH”变量很类似，但是它更为灵活。它可以为不同类型的文件（由文件名区分）指定不同的搜索目录。它的使用方法有三种：
1、`vpath PATTERN DIRECTORIES` 为所有符合模式“PATTERN”的文件指定搜索目录“DIRECTORIES”。多个目录使用空格或者冒号（：）分开。类似上一小节的“VPATH”变量。
2、`vpath PATTERN` 清除之前为符合模式“PATTERN”的文件设置的搜索路径。
3、`vpath` 清除所有已被设置的文件搜索路径。

vapth 使用方法中的“PATTERN”需要包含模式字符“%”。“%”意思是匹配一个或者多个字符，例如，“%.h”表示所有以“.h”结尾的文件。如果在“PATTERN”中没有包含模式字符“%”，那么它就是一个明确的文件名，这样就是给定了此文件的所在目录，我们很少使用这种方式来为单独的一个文件指定搜索路径。在“vpath”所指定的模式中我们可以使用反斜杠来对字符“%”进行引用（和其他的特使字符的引用一样）。

“PATTERN”表示了具有相同特征的一类文件，而“DIRECTORIES”则指定了搜索此类文件目录。当规则的依赖文件列表中的文件不能在当前目录下找到时，make程序将依次在“DIRECTORIES”所描述的目录下寻找此文件。例如：
```
vpath %.h ../headers
```
其含义是：Makefile 中出现的.h文件；如果不能在当前目录下找到，则到目录“../headers”下寻找。

> 注意：这里指定的路径仅限于在 Makefile 文件内容中出现的.h文件。 并不能指定源文件中包含的头文件所在的路径（在.c 源文件中所包含的头文件路径需要使用 gcc 的“-I”选项来指定，可参考 gcc 的 info 文档）。

在 Makefile 中如果存在连续的多个 vpath 语句使用了相同的“PATTERN”，make 就对这些 vpath 语句一个一个进行处理，搜索某种模式文件的目录将是所有的通过vpath 指定的符合此模式的多个目录，其搜索目录的顺序由 vpath 语句在 Makefile 出现的先后次序来决定。多个具有相同“PATTERN”的 vpath 语句之间相互独立。下边是两种方式下，所有的.c 文件的查找目录的顺序（不包含工作目录，对工作目录的搜索永远处于最优先地位）比较：
```
vpath %.c foo
vpath % blish
vpath %.c bar
```
表示对所有的.c 文件，make 依次查找目录：“foo”、blish”、“bar”。

```
vpath %.c foo：bar
vpath % blish
```
对于所有的.c 文件 make 将依次查找目录：“foo”、“bar”、“blish”





